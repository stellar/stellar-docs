---
title: "Transaction Envelope vs Operation Source Accounts"
sidebar_label: "Envelope vs Operation Sources"
description: "Learn how transaction envelope source accounts differ from operation source accounts in Stellar. Understand when and how to use different source accounts for operations within a single transaction."
sidebar_position: 15
---

import { CodeExample } from "@site/src/components/CodeExample";

:::note

This section covers non-smart contract transactions. For smart contract transactions, see [smart contract authorization](../../fundamentals/contract-development/authorization.mdx).

:::

In the Stellar protocol, a transaction is wrapped in an "envelope" that includes a set of operations, a sequence number, a base fee, and other metadata. Each transaction has a primary source account (the envelope source account) that is responsible for paying the transaction fee, providing the sequence number, and covering the account's minimum reserves. However, each individual operation within the transaction can specify its own source account, distinct from the envelope source.

If an operation doesn't specify an explicit source, it automatically inherits the envelope's source account. This allows flexibility in scenarios where multiple accounts need to execute actions in a single atomic transaction, such as batch payments or multisig configurations, without requiring separate transactions for each account.

## How it works

The primary purpose of this feature is to allow operations to execute "on behalf of" different accounts while the transaction as a whole is submitted under a single sequence number and fee. For example, a transaction could include a payment operation from account A and an account merge operation from account B, all wrapped under primary source C (which pays the fee). This is useful for optimizing costs and atomicity: if any operation fails, the entire transaction fails, preventing inconsistent states in the ledger.

### Key concepts

- **Envelope source account**: The account that pays the transaction fee and provides the sequence number
- **Operation source account**: The account that executes a specific operation within the transaction
- **Inheritance**: Operations without an explicit source inherit the envelope source account
- **Atomicity**: All operations in a transaction succeed or fail together

## Basic code examples

The following examples demonstrate basic applications using the Stellar SDK (`@stellar/stellar-sdk`). These show how to create transactions with operations from different sources. We assume you're on the testnet and have private keys for the involved accounts. Remember that to execute these, you need to load the accounts from Horizon or Soroban RPC and sign with the corresponding keys.

### Example 1: Payment from a different source account

This example shows how to create a transaction where the envelope source account pays the fee, but a payment operation executes from a different source account.

<CodeExample>

```javascript
const StellarSdk = require('@stellar/stellar-sdk');
const server = new StellarSdk.Server('https://horizon-testnet.stellar.org');

async function sendPaymentFromDifferentSource() {
  // Load the envelope source account (pays the fee)
  const envelopeAccount = await server.loadAccount('GAEJEMPLOMAIN');
  
  const transaction = new StellarSdk.TransactionBuilder(envelopeAccount, {
    fee: StellarSdk.BASE_FEE,
    networkPassphrase: StellarSdk.Networks.TESTNET
  })
  .addOperation(StellarSdk.Operation.payment({
    destination: 'GBDESTINO',
    asset: StellarSdk.Asset.native(),
    amount: '10',
    source: 'GBFUENTEDIFFERENTE' // Different source for this operation
  }))
  .setTimeout(30)
  .build();

  // Sign with both accounts' keys
  transaction.sign(StellarSdk.Keypair.fromSecret('SECRETO_MAIN'));
  transaction.sign(StellarSdk.Keypair.fromSecret('SECRETO_FUENTE_OP'));

  const result = await server.submitTransaction(transaction);
  console.log('Success:', result);
}

sendPaymentFromDifferentSource();
```

</CodeExample>

**Application**: Useful for custodial services where an administrative account pays transaction fees while user accounts execute the actual payments.

### Example 2: Multiple operations from different source accounts

This example demonstrates a transaction with operations from different source accounts, all coordinated by a single envelope source account.

<CodeExample>

```javascript
const StellarSdk = require('@stellar/stellar-sdk');
const server = new StellarSdk.Server('https://horizon-testnet.stellar.org');

async function multiSourceTransaction() {
  // Load the envelope source account (coordinates the transaction)
  const envelopeAccount = await server.loadAccount('GCMAIN');
  
  const transaction = new StellarSdk.TransactionBuilder(envelopeAccount, {
    fee: StellarSdk.BASE_FEE,
    networkPassphrase: StellarSdk.Networks.TESTNET
  })
  .addOperation(StellarSdk.Operation.changeTrust({
    asset: new StellarSdk.Asset('USD', 'GBISSUER'),
    limit: '1000',
    source: 'GBFUENTEA' // Source for changeTrust operation
  }))
  .addOperation(StellarSdk.Operation.accountMerge({
    destination: 'GBDESTINO',
    source: 'GBFUENTEB' // Source for accountMerge operation
  }))
  .setTimeout(30)
  .build();

  // Sign with all required source accounts
  transaction.sign(StellarSdk.Keypair.fromSecret('SECRETO_MAIN'));
  transaction.sign(StellarSdk.Keypair.fromSecret('SECRETO_A'));
  transaction.sign(StellarSdk.Keypair.fromSecret('SECRETO_B'));

  const result = await server.submitTransaction(transaction);
  console.log('Success:', result);
}

multiSourceTransaction();
```

</CodeExample>

**Application**: Useful for batch operations where multiple accounts need to perform different actions atomically, such as establishing trustlines and merging obsolete accounts in a single transaction.

### Example 3: Asset clawback from a different source account

This example shows how an asset issuer can perform a clawback operation from a different source account while an administrative account handles the transaction.

<CodeExample>

```javascript
const StellarSdk = require('@stellar/stellar-sdk');
const server = new StellarSdk.Server('https://horizon-testnet.stellar.org');

async function clawbackFromDifferentSource() {
  // Load the envelope source account (administrative account)
  const envelopeAccount = await server.loadAccount('GCMAIN');
  
  const transaction = new StellarSdk.TransactionBuilder(envelopeAccount, {
    fee: StellarSdk.BASE_FEE,
    networkPassphrase: StellarSdk.Networks.TESTNET
  })
  .addOperation(StellarSdk.Operation.clawback({
    asset: new StellarSdk.Asset('TOKEN', 'GBISSUER'),
    amount: '50',
    from: 'GBDESTINO',
    source: 'GBFUENTEDIFFERENTE' // Source for clawback operation
  }))
  .setTimeout(30)
  .build();

  // Sign with both accounts' keys
  transaction.sign(StellarSdk.Keypair.fromSecret('SECRETO_MAIN'));
  transaction.sign(StellarSdk.Keypair.fromSecret('SECRETO_FUENTE'));

  const result = await server.submitTransaction(transaction);
  console.log('Success:', result);
}

clawbackFromDifferentSource();
```

</CodeExample>

**Application**: Useful for asset issuers who need to reclaim tokens for regulatory compliance while keeping administrative and issuance keys separate for security.

## Signature implications and key custody

Signature implications are critical when using different sources for operations, as Stellar requires explicit authorization for each operation based on signature thresholds and weights. Each transaction must be signed on its complete envelope, but signatures must cover the requirements of all involved source accounts. In detail:

### Basic signature requirements

Every transaction requires at least one signature from the envelope source account to validate the sequence number and fee. If an operation has a different source, a signature from that source account must be included to authorize it specifically. 

Signatures are applied to the entire transaction envelope but verified per operation: for each operation, Stellar sums the weights of valid signatures associated with its source account and verifies if it reaches the configured threshold (low, medium, or high). If not, the operation fails, and due to atomicity, the entire transaction fails.

For example, a payment operation (medium threshold) from source B in a transaction with envelope source A requires that signatures from B reach their medium threshold, in addition to A's signature for the envelope.

### Extended multisig and thresholds

If a source account has multisig configuration (multiple keys with weights), additional signatures are needed to sum weights up to the threshold. Default thresholds are 0 (for trivial operations), but can be adjusted with `Set Options`. Examples:

- **Joint account**: High threshold=3 for signature changes, medium=1 for payments. If there are three signers with weight 1 each, a payment needs only one signature, but changing signers needs all three.
- **Corporate account**: Six employees with weight 1, threshold=3 for all operations. Requires at least three signatures for any action.

When using different source accounts, each source needs its independent signatures for its operations. Extra signatures (more than necessary) fail the transaction with error `TX_BAD_AUTH_EXTRA`, optimizing consensus.

### Alternative signature types and their implications

- **Pre-authorized**: An account can pre-authorize a particular transaction hash as a signer. Useful for escrow: pre-authorize two transactions with the same sequence number but different destinations; only one executes. Implication: Doesn't require online key at the time, but must be manually removed if unused.
- **Hash(x)**: Anyone knowing 'x' can sign. Useful for atomic cross-chain swaps, but once used, 'x' is publicly revealed, allowing unauthorized signatures unless combined with other signatures for threshold.
- These reduce dependency on live keys but increase risks if 'x' or hashes are compromised.

### Key custody implications

Custody becomes complicated with multiple sources, as you need secure access to private keys of all involved accounts.

- **Exposure risks**: Issuance keys (e.g., for assets) must be kept offline to prevent theft. In multisig, a compromised key with sufficient weight can authorize unwanted operations. Recommendation: Disable master key (weight=0) on sensitive accounts, relying only on additional signers, but this can permanently lock the account if signers are lost.
- **Multi-custodian management**: If accounts belong to different entities (e.g., users in an exchange), collect signatures separately: build the transaction, send partial envelope to each party to sign offline, then combine. This minimizes exposure but requires coordination (e.g., via SDK with iterative `tx.sign()`). Each additional signer increases minimum reserve by 0.5 XLM.
- **Operational security**: In setups like anchors, an additional key with low weight authorizes low-threshold operations (e.g., flags on trustlines), but not medium/high (e.g., payments). For enterprises, distributed custody (e.g., hardware wallets) avoids single points of failure. Always verify configurations: low ≤ medium ≤ high for consistency. If custody is lost, the account may become inaccessible, losing funds.

## Summary

This feature enables efficiency but demands rigorous custody: use offline wallets, multisig for redundancy, and regular threshold audits. The key is understanding that while operations can have different sources, all signatures are applied to the complete transaction envelope, and each operation's authorization is verified independently based on its source account's signature requirements.

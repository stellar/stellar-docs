---
sidebar_position: 40
title: Transaction Simulation
description: Simulate a contract interaction contained in a Stellar transaction.
---

## Footprint

As mentioned in the [persisting data](../../storage/persisting-data.mdx) section, a contract can only load or store `CONTRACT_DATA` entries that are declared in a _footprint_ associated with its invocation.

A footprint is a set of ledger keys, each marked as either read-only or read-write. Read-only keys are available to the transaction for reading; read-write keys are available for reading, writing, or both.

Any Soroban transaction submitted by a user has to be accompanied by this footprint. A single footprint encompasses _all_ the data read and written by _all_ contracts transitively invoked by the transaction: not just the initial contract that the transaction calls, but also all contracts it calls, and so on.

Since it can be difficult for a user to know which ledger entries a given contract call will attempt to read or write (especially entries that are caused by other contracts deep within a transaction), the host provides an auxiliary `simulateTransaction` mechanism that executes a transaction against a temporary, possibly out-of-date _snapshot_ of the ledger. The `simulateTransaction` mechanism is _not_ constrained to only read or write the contents of a footprint; rather it _records_ a footprint describing the transaction's execution, discards the execution's effects, and then returns the recorded footprint to its caller.

This simulation-provided footprint can then be used to accompany a "real" submission of the same transaction to the network for real execution. If the state of the ledger has changed too much between the time of the simulated and the real submission, the footprint may be too stale and no longer accurately identify the _keys_ the transaction needs to read and/or write, at which point the simulation must be retried to refresh the footprint.

In any event (whether successful or failing), the real transaction will execute atomically, deterministically, and with serializable consistency semantics. An inaccurate footprint simply causes deterministic transaction failure, not a stale-read anomaly. All effects of such a failed transaction are discarded, as they would be in the presence of any other error.

## Authorization

Please refer to the [authorization overview](../../security/authorization.mdx) and transaction authorization [section][auth-data] for general information on Soroban authorization: this section pertains specifically to how simulation works alongside authorization requirements.

Soroban's transaction [simulation mechanism][sim-tx] can be used to precompute the [`SorobanAuthorizedInvocation`][auth-invoke] trees that must be authorized by the `Address`es for all the `require_auth` checks to pass. It can be invoked in two different ways:

### Recording Mode

The Soroban host environment provides a simulation mode that records the entire context (address, contract ID, function, arguments, etc.) involved in calls to `require_auth`.

These records are added to a [`SorobanAuthorizedInvocation`][auth-invoke] tree and marked as successful. Then, after the invocation has finished, transaction simulation returns all of the recorded trees, as well as randomly-generated nonce values for the expected signatures.

Given this information from simulation, the client only needs to provide these trees and nonces to the `Address`es involved the invocation for signing, then build the final transaction by combining simulation output with the corresponding signatures.

Note that the "recording" auth mode _never_ emulates authorization failures. This is because failing authorization is always an "exceptional" situation (i.e., the `Address`es for which you don't anticipate successful authorization shouldn't be used in the first place). It is similar to how, for example, the [`simulateTransaction`][sim-tx] mechanism doesn't emulate failures caused by the incorrect footprint.

If you'd like to validate signatures, you should use [`simulateTransaction`][sim-tx] in authorization ["enforcement" mode](#enforcing-mode), which will verify the signatures before executing the transaction on-chain.

### Enforcing Mode

The recording auth mode is one option for [`simulateTransaction`][sim-tx]. However, when dealing with the custom account contracts, for example, it may be necessary to simulate the custom account's `__check_auth` code (which is simply _omitted_ in the recording auth mode), to get its ledger footprint.

This is called running simulation with "enforcing" auth mode. This is basically equivalent to running the transaction on-chain (with possibly a slightly stale ledger state); hence, it requires all the signatures to be valid.

From a developer's perspective, the difference between these is whether or not authorization entries are present in the [`InvokeHostFunction` operation](../../../../learn/fundamentals/transactions/list-of-operations.mdx#invoke-host-function) submitted to [`simulateTransaction`][sim-tx]. The [examples, below](#typescript-utilities), highlight this distinction in detail, but the short story is that passing `auth` to [`Operation.invokeContractFunction`](https://stellar.github.io/js-stellar-sdk/Operation.html#.invokeContractFunction) (which is a convenience wrapper on [`invokeHostFunction`](https://stellar.github.io/js-stellar-sdk/Operation.html#.invokeHostFunction)) will imply enforcement mode.

### SDK Usage

Below, we'll demonstrate the various ways in which you can invoke transaction simulation as well as highlight some utilities available in the [TypeScript SDK](https://stellar.github.io/js-stellar-sdk/) for authorization.

We'll cover three types of invocations:
* A simple invocation in which the source account of the transaction is the only signer for the invocation tree.
* An invocation in which two accounts need to sign the invocation tree.
* An invocation run in enforcement mode to confirm that signatures are correct.

#### Example 1: source account authorization.

In this variant, we will leverage the "source account"

<CodeExample>

```javascript
import {
  Operation,
  authorizeEntry,
  signAuthEntry,
} from "@stellar/stellar-sdk";
import { Server } from "@stellar/stellar-sdk/rpc";

async function main() {}

// Simulates, assembles, signs, sends, and waits for a simple contract invocation.
// "Simple" here meaning "just needs the source account to sign."
async function sendSimpleTransaction(tx, signer) {
  const preppedTx = await s.prepareTransaction(tx);
  preppedTx.sign(signer);
  const sentTx = await s.sendTransaction(preppedTx);
  return s.pollTransaction(sentTx.hash);
}

main().catch((e) => console.error(e));
```

</CodeExample>

#### Example 2: multi-party authentication.

#### Example 3: enforcement mode.


[auth-data]: stellar-transaction.mdx#authorization-data
[auth-invoke]: https://github.com/stellar/stellar-xdr/blob/v22.0/Stellar-transaction.x#L558
[sim-tx]: ../../../../data/rpc/api-reference/methods/simulateTransaction.mdx

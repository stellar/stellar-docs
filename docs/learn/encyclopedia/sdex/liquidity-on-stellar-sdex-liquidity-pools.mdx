---
title: "The SDEX and Automated Market Makers"
---

import { CodeExample } from "@site/src/components/CodeExample";
import YouTube from "@site/src/components/YouTube";

<YouTube ID="YFca255hXj8" />

The Stellar network acts as a decentralized distributed exchange that allows users to trade and convert assets with the [Manage Buy Offer](../../../data/horizon/api-reference/resources/operations/object/buy-offer.mdx) and [Manage Sell Offer](../../../data/horizon/api-reference/resources/operations/object/sell-offer.mdx) operations. The Stellar ledger stores both the balances held by user accounts and orders that user accounts make to trade assets. [Validators](https://stellarbeat.io) track exactly which price these orders will accept and the quantity avaliable to transact.

When you convert one currency to another in traditional financial markets, your trade happens because of limit orders. These orders specify how much someone will pay for a certain amount of any asset. Thus, when you need to convert your dollars to yen, e.g., their order to sell yen for dollars counteracts and "fulfills" your trade.

Financial markets thrive because of liquidity, a result of deep [order books](https://wikipedia.org/wiki/Order_book). It's so to speak, of In a global [payments system](https://stellar.org/blog/foundation-news/introducing-stellar), this liquidity can be thought of as the grease that makes transaction cogs turn. Stellar is one of the very few platforms that accounts for liquidity at scale with no centralized party.

:::note

This page specifically covers liquidity from the Stellar Decentralized Exchange and Automated Market Makers built into the Stellar protocol. It does not include information regarding smart contracts. Rather, it explains the network's native layer-1 atomic-swap core infrastructure.

:::

## Reading Prices

This section covers querying the live order book and accessing price data. By interacting with the SDEX's public [Horizon endpoints](../../../data/horizon/api-reference/resources/README.mdx), you can obtain real-time market data and make informed trading decisions. While Stellar provides transparent access to price information, external oracles can also be used when integrating with other systems or when off-chain data is required.

The Stellar network takes a crowdsourced approach to liquidity. Namely, the SDEX gives all users equal access to a global decentralized order book for any pair of assets on he network. Since launching with the genesis of the Stellar network in 2014, the SDEX has processed over 4.2 billion trades worth upwards of \$25 billion.

Users can trade assets across the Stellar network using [priced orders](../../fundamentals/transactions/list-of-operations.mdx#manage-sell-offer), [path payments](../transactions-specialized/path-payments.mdx), and [native AMMs](#liquidity-pools-amm). These features leverage both the SDEX order books and liquidity pools, introduced in Protocol 18. To learn about how the SDEX and liquidity pools work together to execute transactions, see our [Path Payments Encyclopedia Entry](../transactions-specialized/path-payments.mdx).

## Protocol

The Stellar protocol facilitates cross-border payments and asset transfers by leveraging the SDEX. The SDEX allows for the seamless exchange of assets, enabling token settlement across all the network's different currencies and general assets.

Trading Setups Info

<CodeExample>

```python
from stellar_sdk import Keypair, Server, TransactionBuilder, Network, Asset

server = Server("https://horizon-testnet.stellar.org")

# Account setup
privateKey = "SAXBT6KO6NJ6SJXHBO6EBC7I5ZB7DZFYNPQOLXZJOKQ2LSGY5FU7ZJZB"
publicKey = "GBRPYHIL2CI3R5N4A7WMBETDZQ24DXFQGNCJWHXPFRGFWZHJZZBDTWR2"

# Asset config
astroDollar = Asset("AstroDollar", "GDRM3MK6KMHSYIT4E2AG2S2LWTDBJNYXE4H72C7YTTRWOWX5ZBECFWO7")
astroPeso = Asset("AstroPeso", "GBHNGLLIE3KWGKCHIKMHJ5HVZHYIK7WTBE4QF5PLAKL4CJGSEU7HZIW5")

def newTxBuilder(publicKey):
  sourceAccount = server.load_account(publicKey)
  return TransactionBuilder(
    source_account = sourceAccount,
    network_passphrase = Network.TESTNET_NETWORK_PASSPHRASE,
    base_fee = server.fetch_base_fee()
  ).set_timeout(360)
```

```js
const {
  Keypair,
  Server,
  TransactionBuilder,
  Asset,
  Networks,
} = require("stellar-sdk");

const server = new Server("https://horizon-testnet.stellar.org");

// Account setup
const privateKey = "SAXBT6KO6NJ6SJXHBO6EBC7I5ZB7DZFYNPQOLXZJOKQ2LSGY5FU7ZJZB";
const publicKey = "GBRPYHIL2CI3R5N4A7WMBETDZQ24DXFQGNCJWHXPFRGFWZHJZZBDTWR2";

// Asset config
const astroDollar = new Asset(
  "AstroDollar",
  "GDRM3MK6KMHSYIT4E2AG2S2LWTDBJNYXE4H72C7YTTRWOWX5ZBECFWO7",
);
const astroPeso = new Asset(
  "AstroPeso",
  "GBHNGLLIE3KWGKCHIKMHJ5HVZHYIK7WTBE4QF5PLAKL4CJGSEU7HZIW5",
);

// pending newTxEnvelope(..)
```

```java
import org.stellar.sdk.*;
import org.stellar.sdk.responses.AccountResponse;
import org.stellar.sdk.responses.SubmitTransactionResponse;

public class Liquidity {
  static final Server server = new Server("https://horizon-testnet.stellar.org");

  // Account setup
  static String privateKey = "SAXBT6KO6NJ6SJXHBO6EBC7I5ZB7DZFYNPQOLXZJOKQ2LSGY5FU7ZJZB";
  static String publicKey = "GBRPYHIL2CI3R5N4A7WMBETDZQ24DXFQGNCJWHXPFRGFWZHJZZBDTWR2";

  // Asset config
  Asset astroDollar = new AssetTypeCreditAlphaNum4("AstroDollar", "GDRM3MK6KMHSYIT4E2AG2S2LWTDBJNYXE4H72C7YTTRWOWX5ZBECFWO7");
  Asset astroPeso = new AssetTypeCreditAlphaNum4("AstroPeso", "GBHNGLLIE3KWGKCHIKMHJ5HVZHYIK7WTBE4QF5PLAKL4CJGSEU7HZIW5");

  public static Transaction.Builder newTxBuilder(KeyPair source) {
    AccountResponse sourceAccount = server.accounts().account(source.getAccountId());
    return new Transaction.Builder(sourceAccount, Network.TESTNET)
        .setBaseFee(Transaction.MIN_BASE_FEE)
        .setTimeout(360);
  }
}
```

```go
package main

import (
  "fmt"
  "github.com/stellar/go/build"
  "github.com/stellar/go/clients/horizonclient"
  "github.com/stellar/go/keypair"
  "github.com/stellar/go/network"
  "github.com/stellar/go/protocols/horizon"
  "github.com/stellar/go/txnbuild"
)

var server = horizonclient.DefaultTestNetClient

func main() {
  // Account setup
  privateKey := "SAXBT6KO6NJ6SJXHBO6EBC7I5ZB7DZFYNPQOLXZJOKQ2LSGY5FU7ZJZB"
  publicKey := "GBRPYHIL2CI3R5N4A7WMBETDZQ24DXFQGNCJWHXPFRGFWZHJZZBDTWR2"

  // Asset config
  astroDollar := txnbuild.CreditAsset{
    Code:   "AstroDollar",
    Issuer: "GDRM3MK6KMHSYIT4E2AG2S2LWTDBJNYXE4H72C7YTTRWOWX5ZBECFWO7",
  }
  astroPeso := txnbuild.CreditAsset{
    Code:   "AstroPeso",
    Issuer: "GBHNGLLIE3KWGKCHIKMHJ5HVZHYIK7WTBE4QF5PLAKL4CJGSEU7HZIW5",
  }
}

func newTxBuilder(pubKey string) (*txnbuild.Transaction, error) {
	account := horizonclient.AccountRequest{AccountID: pubKey}
  check(err) // Confirm account & sequence number
	txEnvelopeParams := &txnbuild.TransactionParams{
		SourceAccount:        &account,
		BaseFee:              txnbuild.MinBaseFee,
		Timebounds:           txnbuild.NewTimeout(360),
		IncrementSequenceNum: true,
	}
	return txnbuild.NewTransaction(txEnvelopeParams)
}
```

</CodeExample>

<CodeExample>

```python
transaction = TransactionBuilder(
  source_account = account,
  network_passphrase = Network.TESTNET_NETWORK_PASSPHRASE,
  base_fee = 100
).append_manage_sell_offer_op(
  selling = astroPeso,
  buying = astroDollar,
  amount = "1000",
  price = "20.0" # 20 Pesos per Dollar
).set_timeout(360).build()

keypair = Keypair.from_secret(privateKey) transaction.sign(keypair)

response = server.submit_transaction(transaction)

print(f"Transaction successful: {response['successful']}")
print(f"Transaction hash: {response['hash']}")
print(f"Offer ID: {response['result_xdr']}")
```

```js
(async function () {
  // this is gross :'(
  const account = await server.loadAccount(publicKey);

  const transaction = new TransactionBuilder(account, {
    fee: 100,
    networkPassphrase: Networks.TESTNET,
  })
    .addOperation({
      type: "manageSellOffer",
      selling: astroPeso,
      buying: astroDollar,
      amount: "1000",
      price: "20.0", // 20 Pesos per Dollar
    })
    .setTimeout(360)
    .build();

  const keypair = Keypair.fromSecret(privateKey);
  transaction.sign(keypair);

  try {
    const response = await server.submitTransaction(transaction);
    console.log(`Transaction successful: ${response.successful}`);
    console.log(`Transaction hash: ${response.hash}`);
    console.log(`Offer ID: ${response.result_xdr}`);
  } catch (e) {
    console.error(e);
  }
});
```

```java

  AccountResponse account = server.accounts().account(publicKey);

  Transaction transaction = new TransactionBuilder(account, Network.TESTNET)
    .setBaseFee(Transaction.MIN_BASE_FEE)
    .addOperation(new ManageSellOfferOperation.Builder(
      astroPeso,
      astroDollar,
      "1000", // Sell 1000 Pesos
      "20.0" // 20 Pesos per Dollar
    ).build())
    .setTimeout(360)
    .build();

  KeyPair keypair = KeyPair.fromSecretSeed(privateKey);
  transaction.sign(keypair);

  SubmitTransactionResponse response = server.submitTransaction(transaction);
  System.out.println("Transaction successful: " + response.isSuccessful());
  System.out.println("Transaction hash: " + response.getHash());
  System.out.println("Offer ID: " + response.getExtras().getResultXdr());
}
```

```go
  request := horizonclient.AccountRequest{AccountID: publicKey}
  account, err := server.AccountDetail(request)
  check(err)

  transaction, err := txnbuild.NewTransaction(
    txnbuild.TransactionParams{
      SourceAccount:        &account,
      IncrementSequenceNum: true,
      BaseFee:              txnbuild.MinBaseFee,
      Operations: []txnbuild.Operation{
        &txnbuild.ManageSellOffer{
          Selling: astroPeso,
          Buying:  astroDollar,
          Amount:  "1000",
          Price:   "20.0", // 20 Pesos per Dollar
        },
      },
      Timebounds: txnbuild.NewTimebounds(0, 360),
    },
  )
  check(err)
  kp, err := keypair.ParseFull(privateKey)
  check(err)
  signedTx, err := transaction.Sign(network.TestNetworkPassphrase, kp)
  check(err)

  resp, err := server.SubmitTransaction(signedTx)
  check(err)
  fmt.Printf("Transaction successful: %v\n", resp.Successful)
  fmt.Printf("Transaction hash: %s\n", resp.Hash)
  fmt.Printf("Offer ID: %s\n", resp.ResultXdr)
}
```

</CodeExample>

The price returned is quoted based on the response `base` asset, which is `AstroDollar` in this example. That means the default value will show XLM/AstroDollar for an `amount` of XLM. However, you can use `price_r` from the [query response](../../../data/horizon/api-reference/retrieve-an-order-book.api.mdx) to invert into a `counter` asset or get an exact ratio. Now that we know the live market rate, we can update our offer to use a competative exchange price rather than a flat `20` pesos/dollar ratio.

Relevantly, this exmaple code querys the [Horizon instance](../../../data/horizon/README.mdx) of the [SDF](../../glossary.mdx#stellar-development-foundation-sdf)'s testnet. Howver, in production, you would replace this server with the validating entity ou mst trust. This is because you want to align your view of the network with the entrypoint which you send any order to.

Along those lines, it's also worth noting again the difference in functinal control levels regauding teh SDEX. While you can read and submit transactions through public Horizon interfaces, validators themselves form transactions sets and reach consenssus in accordance with the underlying protocol rules governing core SCP. This means that your trade to convery currencies always exectued in equal preference ot other pending orders as long as the Horizon entrypoint operator includes your [operation](../../../data/horizon/api-reference/resources/operations/object/sell-offer.mdx) in their [transaction set](../../fundamentals/stellar-consensus-protocol.mdx#nomination-protocol) per their [reputation](../../fundamentals/stellar-consensus-protocol.mdx#quorum-set).

:::note

If you'd like to keep your view of the order book up to date, you can [stream](../../data/horizon/api-reference/structure/streaming) the information.

:::

### Custody

On Stellar, users can maintain custody of their assets at all times. The network's design ensures that asset transfers and conversions can occur without the need for intermediaries to hold or control user funds. Path payments allow users to send one asset and have the recipient receive another, all while maintaining custody and security.

### Intermediaries

Stellar eliminates unnecessary intermediaries by enabling direct asset exchange between users. This reduces costs and increases efficiency in cross-border transactions.

While Stellar provides a decentralized infrastructure, it supports compliance with regulatory requirements. Issuers can enforce authorization and compliance controls on their assets as needed.

## Minting Functionality

In addition to trading existing assets, the SDEX lets issuers create new assets directly on the network. A sell offer from the issuer account will generate new assets by decree. This functionality enables the issuance of tokens representing fiat currencies, commodities, or any other assets in exchange for another user token.

## Authorization

Stellar supports flexible authorization mechanisms, allowing issuers to control the use of their assets. This includes options like requiring authorization before holding an asset and revoking authorization to prevent an account from holding or trading the asset further.

The trading behavior of an account trading asset A for B depends on the status of its trustines:

| Permissions | Response |
| --- | --- |
| Trustlines for A and B are fully authorized | No restrictions on transactions |
| Trustline for A is fully authorized but trustline for B is authorized to maintain liabilities | Offers for A and B are authorized to maintain liabilities |
| Trustline for B is fully authorized but trustline for A is authorized to maintain liabilities | Offers for A and B are authorized to maintain liabilities |
| Trustlines for A and B are authorized to maintain liabilities | Offers for A and B are authorized to maintain liabilities |
| Trustline for A is not authorized or doesn’t exist | New offer operation fails, existing offers cancelled at time of deathorization |
| Trustline for B is not authorized or doesn’t exist | New offer operation fails, existing offers cancelled at time of deathorization |

<CodeExample title="listing depth">

```python
Query Horizon and print the order book for AstroDollar/AstroPeso
```

```js
// at 311
```

```java

```

```go

```

</CodeExample>

## Liquidity

### Market Depth

The more orders available to transact against, the more currency you can convert at any time without moving the market. Stellar stores these open orders as `offer` [objects](https://developers.stellar.org/docs/data/horizon/api-reference/resources/offers/object) directly on chain. This transparency allows anyone to analyze the order book and understand the trading activity for any asset pair.

### Fill Prices

The network and by extension its [validators](https://stellarbeat.io) match orders based on the protocol rules of [Stellar Core](https://github.com/stellar/stellar-core/blob/fbb53d8ad42dcc12a046c9be949d654821a24d38/src/transactions/OfferExchange.cpp#L227-L550). Orders are filled at the same price or better than specified, ensuring fair execution. This means you receive the best possible price available in the market at that moment.

## Submitting Trades

Let's pretend you just got paid in Mexican Pesos, but you'd prefer to hold your savings in U.S. Dollars. After querying the [exchange rate](#reading-prices), we can send a new offer to the network, swapping Pesos for Dollars at our desired rate. By submitting a sell offer that matches the current market price, we can ensure our pesos are converted to dollars promptly.

<CodeExample>

```python
should be implemented already ###
```

</CodeExample>

## Source of Truth

Now that we know how to submit an order to the SDEX, let's walk through reading the current order book. This entails collecting all the buyers for a specific currency pair and comparing this demand to all the sellers of that pair. We'll stick with our pesos-dollars example and ignore potential [passive offers](#passive-order) for the time being.

<CodeExample>

```python
orderBook = server.orderbook(
  selling = astroPeso,
  buying = astroDollar
).call()

print("Bids:")
for bid in orderBook['bids']:
  print(f"Price: {bid['price']}, Amount: {bid['amount']}")

print("\nAsks:")
for ask in orderBook['asks']:
  print(f"Price: {ask['price']}, Amount: {ask['amount']}")
```

```js
const orderBook = await server.orderbook(astroPeso, astroDollar).call();

console.log("Bids:");
orderBook.bids.forEach((bid) => {
  console.log(`Price: ${bid.price}, Amount: ${bid.amount}`);
});

console.log("\nAsks:");
orderBook.asks.forEach((ask) => {
  console.log(`Price: ${ask.price}, Amount: ${ask.amount}`);
});
```

```java
import java.util.List;

public static void main(String[] args) throws Exception {
  OrderBookResponse orderBook = server.orderBook(astroPeso, astroDollar).execute();

  System.out.println("Bids:");
  List<OrderBookResponse.Row> bids = orderBook.getBids();
  for (OrderBookResponse.Row bid : bids) {
    System.out.println("Price: " + bid.getPrice() + ", Amount: " + bid.getAmount());
  }

  System.out.println("\nAsks:");
  List<OrderBookResponse.Row> asks = orderBook.getAsks();
  for (OrderBookResponse.Row ask : asks) {
    System.out.println("Price: " + ask.getPrice() + ", Amount: " + ask.getAmount());
  }
}
```

```go
func main() {
  orderBook, err := server.OrderBook(horizonclient.OrderBookRequest{
    Selling: astroPeso,
    Buying:  astroDollar,
  })
  check(err)

  fmt.Println("Bids:")
  for _, bid := range orderBook.Bids {
    fmt.Printf("Price: %s, Amount: %s\n", bid.Price, bid.Amount)
  }

  fmt.Println("\nAsks:")
  for _, ask := range orderBook.Asks {
    fmt.Printf("Price: %s, Amount: %s\n", ask.Price, ask.Amount)
  }
}
```

</CodeExample>

When performing this analysis on live [mainnet](https://developers.stellar.org/docs/run-api/horizon/tutorials/quickstart#using-the-public-network) data, you will likely see a combination of trading taking place on top of the SDEX. The first, most basic option, is when a new order crosses the price set by an outstanding order. The two instantly cross once the new order gets accepted, and the transaction generates a taker `contraID` rather than an `offerID` for the "buyer" of the existing liquidity.

The other two options are exchanges made using [path payments](https://developers.stellar.org/docs/encyclopedia/path-payments) or [liquidity pools](https://developers.stellar.org/docs/encyclopedia/liquidity-on-stellar). Both path payments and liquidity pools are constantly interacting with the SDEX. Indeed, every new path payment and liquidity pool operation can only happen because of existing order book offers or new user [swap requests](https://developers.stellar.org/docs/start/list-of-operations/#manage-sell-offer).

## Singel Exercution point

streamling also works for trading-history data, among other ledger updates. markets good xyz some industries,

Since all oreders for a currency pari fall into the same SDEX order book, you cna know that you're getting the best exchange rate between two explicit assets. Accordingly, you can analyze the past valuation of a currency by reading its exchanged trades feed. We'll continue our exmaple and set up a recent trading price query:

<CodeExample>

```python
response = server.trades().for_asset_pair(astroPeso, astroDollar).call()

for trade in response['_embedded']['records']:
    price = int(trade['price_r']['n']) / int(trade['price_r']['d'])
    print(f"Trade ID: {trade['id']}, Price: {price}, Amount: {trade['base_amount']}")

```

```js
(async function () {
  const response = await server
    .trades()
    .forAssetPair(astroPeso, astroDollar)
    .call();

  response.records.forEach((trade) => {
    const price = parseInt(trade.price_r.n) / parseInt(trade.price_r.d);
    console.log(
      `Trade ID: ${trade.id}, Price: ${price}, Amount: ${trade.base_amount}`,
    );
  });
})();
```

```java
public static void main(String[] args) throws Exception {
  Page<TradeResponse> trades = server.trades()
    .forAssetPair(astroPeso, astroDollar)
    .execute();

  for (TradeResponse trade : trades.getRecords()) {
    double price = (double) trade.getPrice().getN() / trade.getPrice().getD();
    System.out.println("Trade ID: " + trade.getId() + ", Price: " + price + ", Amount: " + trade.getBaseAmount());
  }
}

```

```go
func main() {
  trades, err := server.Trades(horizonclient.TradeRequest{
    BaseAsset:    astroPeso,
    CounterAsset: astroDollar,
  })
  check(err)

  for _, trade := range trades.Embedded.Records {
    price := float64(trade.PriceR.N) / float64(trade.PriceR.D)
    fmt.Printf("Trade ID: %s, Price: %f, Amount: %s\n", trade.ID, price, trade.BaseAmount)
  }
}
```

</CodeExample>

When performing this analysis on live [mainnet](SRC_HRED_DOCS_MAONTEST, TESTNET again I think) data, you will in all likelihood see a combination of trading activity taking place on top of the SDEX. The first, most basic option, occurs when a new order crosses the price set by an outstanding order. The two instantly match once the new order is accepted, and the transaction generates a taker `contraID` rather than an `offerID` for the “buyer” of the existing liquidity.

The other two options involve exchanges made using [path paymnets](SRC_PATHPATYMETS) or [liquidity pools](SRC_AMMS). Both path payments and liquidity pools are constantly interacting with the SDEX. Indeed, every new path payment and liquidity pool operation can only occur because of existing order book offers or new user swap requests.

## Commingling and Interoperability

The SDEX facilitates seamless interoperability between different assets by combining orders in a unified order book. This design ensures that liquidity is concentrated, reducing spreads and improving execution for all participants. The SDEX has processed 4.5 billion trades across a dynamic range of assets, demonstrating its robustness and efficiency in facilitating decentralized trading.

## Access

### Order books

An order book is a record of outstanding orders on a network, and each record sits between two assets (wheat and sheep, for example). The order book for this asset pair records every account wanting to sell wheat for sheep and every account wanting to sell sheep for wheat. In traditional finance, buying is expressed as a “bid” order, and selling is expressed as an “ask” order (ask orders are also called offers).

A couple of notes on order books on Stellar:

- The term “offers” usually refers specifically to ask orders. In Stellar, however, all orders are stored as selling&mdash;i.e., the system automatically converts bids to asks. Because of this, the terms “offer” and “order” are used interchangeably in the Stellar ecosystem.[^buys]
- Order books contain all orders that are acceptable to parties on either side to make a trade.
- Some assets will have a small or nonexistent order book between them. In these cases, Stellar facilitates path payments, which we’ll discuss later.

[^buys]: When you create a buy offer using the [`createBuyOffer`](../../../data/horizon/api-reference/resources/operations/object/buy-offer.mdx) operation, it is internally converted and stored as a sell offer.

To view an order book chart, see the [Order Book Wikipedia Page](https://en.wikipedia.org/wiki/Order_book). In addition, there are also plenty of video tutorials and articles out there that can help you understand how order books work in greater detail.

### Viewing Activity

#### Liquidity Pools

You can access the transactions, operations, and effects related to a liquidity pool if you want to track its activity. Let’s see how we can track the latest deposits in a pool (suppose `poolId` is defined as before):

<CodeExample>

```python
def watch_liquidity_pool_activity():
  for op in (
    server.operations()
    .for_liquidity_pool(liquidity_pool_id=pool_id)
    .cursor("now")
    .stream()
  ):
    if op["type"] == "liquidity_pool_deposit":
      print("Reserves deposited:")
      for r in op["reserves_deposited"]:
        print(f"  {r['amount']} of {r['asset']}")
      print(f"  for pool shares: {op['shares_received']}")
    # ...
```

```js
server
  .operations()
  .forLiquidityPool(poolId)
  .call()
  .then((ops) => {
    ops.records
      .filter((op) => op.type == "liquidity_pool_deposit")
      .forEach((op) => {
        console.log("Reserves deposited:");
        op.reserves_deposited.forEach((r) =>
          console.log(`    ${r.amount} of ${r.asset}`),
        );
        console.log("  for pool shares: ", op.shares_received);
      });
  });
```

```java

```

```go

```

</CodeExample>

### Order Execution

An account can create orders to buy or sell assets using the Manage Buy Offer, Manage Sell Offer, or Passive Order operations. The account must hold the asset it wants to exchange, and it must trust the issuer of the asset it is trying to buy.

Orders in Stellar behave like limit orders in traditional markets. When an account initiates an order, it is checked against the existing orderbook for that asset pair. If the submitted order is a marketable order (for a marketable buy limit order, the limit price is at or above the ask price; for a marketable sell limit order, the limit price is at or below the bid price), it is filled at the existing order price for the available quantity at that price. If the order is not marketable (i.e., does not cross an existing order), the order is saved on the orderbook until it is either consumed by another order, consumed by a path payment, or canceled by the account that created the order.

Each order constitutes a selling obligation for the selling asset and buying obligation for the buying asset. These obligations are stored in the account (for lumens) or trustline (for other assets) owned by the account creating the order. Any operation that would cause an account to be unable to satisfy its obligations (such as sending away too much balance) will fail. This guarantees that any order in the orderbook can be executed entirely.

Orders are executed on a price-time priority, meaning orders will be executed based first on price; for orders placed at the same price, the order that was entered earlier is given priority and is executed before the newer one.

#### Path Hops

When sending path payments, your transfer can hop between up to six order books or AMMs to find the best price. Validators perform this arithmatic automatically, allowing you to specify only the lowest total amount you will accept. At each step in the path, the network calculates the optimal source of liquidity to convert through given your destination asset.

Both the order book and AMMs coexist, providing multiple avenues for liquidity. Instead of having to choose whether to go through the order book or an AMM, the pathfinding algorithm automatically checks both sources of liquidity and executes new trades using whichever offers the better rate. It also exchanges with an AMM over an order book at each step if the entire conversation happens at a price equal to or better than limit offers.

#### Purchase Assets (Manage Buy Offer)

When creating a buy order in Stellar via the Manage Buy Offer operation, the price is specified as 1 unit of the base currency (the asset being bought), in terms of the quote asset (the asset that is being sold). For example, if you’re buying 100 XLM in exchange for 20 USD, you would specify the price as `{20, 100}`, which would be the equivalent of 5 XLM for 1 USD (or \$.20 per XLM).

#### Manage Sell Offer

When creating a sell order in Stellar via the Manage Sell Offer operation, the price is specified as 1 unit of base currency (the asset being sold), in terms of the quote asset (the asset that is being bought). For example, if you’re selling 100 XLM in exchange for 40 USD, you would specify the price as `{40, 100}`, which would be the equivalent of 2.5 XLM for 1 USD (or \$.40 per XLM).

#### Passive Order

Passive orders allow markets to have zero spread. If you want to exchange USD from anchor A for USD from anchor B at a 1:1 price, you can create two passive orders so the two orders don’t fill each other.

A passive order is an order that does not execute against a marketable counter order with the same price. It will only fill if the prices are not equal. For example, if the best order to buy BTC for XLM has a price of 100 XLM/BTC, and you make a passive offer to sell BTC at 100 XLM/BTC, your passive offer does not take that existing offer. If you instead make a passive offer to sell BTC at 99 XLM/BTC it would cross the existing offer and fill at 100 XLM/BTC.

An account can place a passive sell order via the Create Passive Sell Offer operation.

### Price and Operations

Each order in Stellar is quoted with an associated price and is represented as a ratio of the two assets in the order, one being the “quote asset” and the other being the “base asset”. This is to ensure there is no loss of precision when representing the price of the order (as opposed to storing the fraction as a floating-point number).

Prices are specified as a `{numerator, denominator}` pair with both components of the fraction represented as 32-bit signed integers. The numerator is considered the base asset, and the denominator is considered the quote asset. When expressing a price of “Asset A in terms of Asset B,” the amount of B is the denominator (and therefore the quote asset), and A is the numerator (and therefore the base asset). As a good rule of thumb, it’s generally correct to be thinking about the base asset that is being bought/sold (in terms of the quote asset).

The order price you set is independent of the fee you pay for submitting that order in a transaction. Fees are always paid in lumens, and you specify them as a separate parameter when submitting the order to the network. To learn more about transaction fees, see our [section on Fees](../../fundamentals/fees-resource-limits-metering.mdx).

## Automated Market Makers

Market makers are businesses that traditionally help establish liquidity on exchanges.[^liq] They are historically a party willing to buy or sell an asset at any time. They maintain an “inventory” of said asset (to sell) alongside a stockpile of cash (to buy).

A market maker hopes to get a buyer real soon when they purchase an asset, or a seller if they run out.[^risk] They profit off the difference between what they buy an asset at and what they can sell it for—called the “spread.” The more volatile an asset, the less competition there might be between buyers and sellers to narrow the spread.

In other words, it becomes more expensive to trade an asset the less liquid it becomes, as you will need to “cross the spread” more often to fill sizable orders in reasonable time. AMMs democratize the process of market-making by encoding the maximum spread into a pool of capital, creating liquidity. When users want to trade, their order can execute against the AMM in place of explicit SDEX order book offers, should no bids or asks exist inside the spread.

:::info

Liquidity refers to how easily and cost-effectively one asset can be converted to another. Market-making businesses accept the inherent risk that an asset will move in one direction or another before a closing trade can cancel out any positions (or lack thereof), and they expect that the “fees” they can extract from the spread will exceed any trade losses over time. These small costs accrue in Stellar's AMM pools, and gains become shared by users depositing their capital.

:::

### Authorization Setup

AMM's pool share trustlines cannot be authorized or de-authorized independently. Instead, the authorization of a pool share trustline is derived from the trustlines for the assets in the liquidity pool. This design is necessary because a liquidity pool may contain assets from two different issuers, and both issuers should have a say in whether the pool share trustline is authorized.

There are a few possibilities with regard to authorization. The behavior of the A-B pool share trustline is determined according to the following table:

| SCENARIO | BEHAVIOR |
| --- | --- |
| Trustlines for A and B are fully authorized | No restrictions on deposit and withdrawal |
| Trustline for A is fully authorized but trustline for B is authorized to maintain liabilities | Trustlines for A and B are authorized to maintain liabilities |
| Trustline for B is fully authorized but trustline for A is authorized to maintain liabilities | Trustlines for A and B are authorized to maintain liabilities |
| Trustlines for A and B are authorized to maintain liabilities | Trustlines for A and B are authorized to maintain liabilities |
| Trustline for A is not authorized or doesn’t exist | Pool share trustline does not exist |
| Trustline for B is not authorized or doesn’t exist | Pool share trustline does not exist |

If the issuer of A or B revokes authorization, then the account will automatically withdraw from every liquidity pool containing that asset and those pool share trustlines will be deleted. We say that these pool shares have been redeemed. For example, if the account participates in the A-B, A-C, and B-C liquidity pools and the issuer of A revokes authorization then the account will redeem from A-B and A-C but not B-C. For each redeemed pool share trustline, a Claimable Balance will be created for each asset contained in the pool if there is a balance being withdrawn and the redeemer is not the issuer of that asset. The claimant of the Claimable Balance will be the owner of the deleted pool share trustline, and the sponsor of the Claimable Balance will be the sponsor of the deleted pool share trustline. The BalanceID of each Claimable Balance is the SHA-256 hash of the `revokeID`.

### Operations

There are two operations that facilitate participation in a liquidity pool: `LiquidityPoolDeposit` and `LiquidityPoolWithdraw`. Use `LiquidityPoolDeposit` to start providing liquidity to the market. Use `LiquidityPoolWithdraw` to stop providing liquidity to the market.

However, users don’t need to participate in the pool to take advantage of what it’s offering: an easy way to exchange two assets. For that, just use `PathPaymentStrictReceive` or `PathPaymentStrictSend`. If your application is already using path payments, then you don’t need to change anything for users to take advantage of the prices available in liquidity pools.

### Deterministic Pricing

Instead of relying on the buy and sell orders of the SDEX, AMMs keep assets liquid 24/7 using pooled capital and a mathematical equation. AMMs hold two different assets in a liquidity pool, and the quantities of those assets (or reserves) are inputs for that equation (Asset A \* Asset B = k). If an AMM holds more of the reserve assets, the asset prices move less in response to a trade.

When you submit an..

<CodeExample>

```python
def getSpotPrice():
  resp = server.liquidity_pools().liquidity_pool(poolId).call()
  amountA = resp["reserves"][0]["amount"]
  amountB = resp["reserves"][1]["amount"]
  spotPrice = Decimal(amountA) / Decimal(amountB)
  print(f"Price: {amountA}/{amountB} = {spotPrice:.7f}") # Max network precision
```

```js
const BigNumber = require("bignumber.js");

async function getSpotPrice() {
  const pool = await server.liquidityPools().liquidityPoolId(poolId).call();
  const [a, b] = pool.reserves.map((r) => r.amount);
  const spotPrice = new BigNumber(a).div(b);
  console.log(`Price: ${a}/${b} = ${spotPrice.toFormat(7)}`);
}
```

```java
public static void getSpotPrice(String[] args) throws Exception {
  LiquidityPoolResponse poolInfo = server.liquidityPools().liquidityPool(poolId).execute();
  double reserveA = Double.parseDouble(poolInfo.getReserves().get(0).getAmount());
  double reserveB = Double.parseDouble(poolInfo.getReserves().get(1).getAmount());
  double spotPrice = reserveA / reserveB;
  System.out.printf("Price: %.7f/%7f = %.7f%n", reserveA, reserveB, spotPrice);
}
```

```go
func getSpotPrice(server *horizonclient.Client, poolID string) {
	poolRequest := horizonclient.LiquidityPoolRequest{LiquidityPoolID: poolID}
	pool, err := server.LiquidityPoolDetail(poolRequest)
	check(err)

	reserveA, err := strconv.ParseFloat(pool.Reserves[0].Amount, 64)
	check(err)
	reserveB, err := strconv.ParseFloat(pool.Reserves[1].Amount, 64)
	check(err)

	spotPrice := reserveA / reserveB
	fmt.Printf("Price: %.7f/%.7f = %.7f\n", reserveA, reserveB, spotPrice)
}
```

</CodeExample>

#### AMM Calculations

AMMs are willing to make some trades and unwilling to make others. For example, if 1 EUR = 1.17 USD, then the AMM might be willing to sell 1 EUR for 1.18 USD and unwilling to sell 1 EUR for 1.16 USD. To determine what trades are acceptable, the AMM enforces an invariant. There are many possible invariants, and Stellar enforces a constant product invariant and so is known as a constant product market maker. This means that AMMs on Stellar must never allow the product of the reserves to decrease.

For example, suppose the current reserves in the liquidity pool are 1000 EUR and 1170 USD which implies a product of 1,170,000. Selling 1 EUR for 1.18 USD would be acceptable because that would leave reserves of 999 EUR and 1171.18 USD, which implies a product of 1,170,008.82. But selling 1 EUR for 1.16 USD would not be acceptable because that would leave reserves of 999 EUR and 1171.16 USD, which implies a product of 1,169,988.84.

AMMs decide exchange rates based on the ratio of reserves in the liquidity pool. If this ratio is different than the true exchange rate, arbitrageurs will come in and trade with the AMM at a favorable price. This arbitrage trade moves the ratio of the reserves back toward the true exchange rate.

AMMs charge fees on every trade, which is a fixed percentage of the amount bought by the AMM. For example, if an automated market maker sells 100 EUR for 118 USD then the fee is charged on the USD. The fee is 0.30%. If you actually wanted to make this trade, you would need to pay about 118.355 USD for 100 EUR. The automated market maker factors the fees into the constant product invariant, so in reality, the product of the reserves grows after every trade.

### AMM Participation

A pool of deposits from accounts allows trades to execute against the predefined market making algorithm.

Any eligible participant can deposit assets into an AMM and receive pool shares representing their AMM ownership in return. If there are 150 total pool shares and one user owns 30, they are entitled to withdraw 20% of the liquidity pool asset at any time.

Pool shares are similar to other assets on Stellar, but they cannot be transferred yet. You can only increase the number of pool shares you hold by depositing into a liquidity pool with the `LiquidityPoolDespositOp` and decrease the number of pool shares you hold by withdrawing from a liquidity pool with `LiquidityPoolWithdrawOp`.

A pool share has two representations. The full representation is used with `ChangeTrustOp`, and the hashed representation is used in all other cases. When constructing the asset representation of a pool share, the assets must be in lexicographical order. For example, A-B is in the correct order but B-A is not. This results in a canonical representation of a pool share.

AMMs charge a fee on all trades and the participants in the liquidity pool receive a share of the fee proportional to their share of the assets in the liquidity pool. Participants collect these fees when they withdraw their assets from the pool. The [communitee agreed](https://groups.google.com/g/stellar-dev/c/Ofb2KXwzva0/m/kyYI8Es9AQAJ) on the current fixed rate of 0.30%, the fee used in UniswapV2. These charges are completely separate from the network fees.

### Trustlines

Users need to establish trustlines to three different assets to participate in a liquidity pool: both the reserve assets (unless one of them is XLM) and the pool share itself.

An account needs a trustline for every pool share it wants to own. It is not possible to deposit into a liquidity pool without a trustline for the corresponding pool share. Pool share trustlines differ from trustlines for other assets in a few ways:

1. A pool share trustline cannot be created unless the account already has trustlines that are authorized or authorized to maintain liabilities for the assets in the liquidity pool. See below for more information about how authorization impacts pool share trustlines.
2. A pool share trustline requires 2 base reserves instead of 1. For example, an account (2 base reserves) with a trustline for asset A (1 base reserve), a trustline for asset B (1 base reserve), and a trustline for the A-B pool share (2 base reserves) would have a reserve requirement of 6 base reserves.

## Example Preamble

Here we will cover basic AMM participation and querying.

For all of the following examples, we’ll be working with three funded Testnet accounts. If you’d like to follow along, generate some keypairs and fund them via the friendbot.

The following code sets up the accounts and defines some helper functions. These should be familiar if you’ve played around with other examples like clawbacks.[^revoking]

[^revoking]: Stellar handles compliance edge cases if an account has trustlines revoked for one or more of the assets in an AMM. Once this happens, the account is forced to redeem all AMM pool shares. Since they by definition are not authorized to hold at least of asset, it gets returned to them as an unconditional claimable balance, avaliable once the issuer authorizes the account again.

{/* TODO: Need to unify keypairs/kps diction */}

<CodeExample>

```python
from decimal import Decimal
from stellar_sdk import *

server = Server("https://horizon-testnet.stellar.org")

secrets = [
  "SBGCD73TK2PTW2DQNWUYZSTCTHHVJPL4GZF3GVZMCDL6GYETYNAYOADN",
  "SAAQFHI2FMSIC6OFPWZ3PDIIX3OF64RS3EB52VLYYZBX6GYB54TW3Q4U",
  "SCJWYFTBDMDPAABHVJZE3DRMBRTEH4AIC5YUM54QGW57NUBM2XX6433P",
]
keypairs = [Keypair.from_secret(secret = secrets) for secrets in secretsList]

# Returns the given asset pair in "protocol order"
def orderAsset(a, b):
  return [a, b] if LiquidityPoolAsset.is_valid_lexicographic_order(a, b) else [b, a]

# kp0 issues the assets
kp0 = keypairs[0]
assetA, assetB = orderAsset(
  Asset("A", kp0.public_key),
  Asset("B", kp0.public_key)
)

def distributeAssets(issuerKp, recipientKp, assets):
  builder = newTxBuilder(issuerKp.public_key)
  for asset in assets:
    builder.append_change_trust_op(
      asset = asset,
      source = recipientKp.public_key
    ).append_payment_op(
      destination = recipientKp.public_key,
      asset = asset,
      amount = "100000",
      source = issuerKp.public_key
    )

  tx = builder.build()
  tx.sign(issuerKp)
  tx.sign(recipientKp)
  return server.submit_transaction(tx)

def preamble():
  resp1 = distributeAssets(kp0, keypairs[1], [assetA, assetB])
  resp2 = distributeAssets(kp0, keypairs[2], [assetA, assetB])
  # ...
```

```js
const sdk = require("stellar-sdk");

let server = new sdk.Server("https://horizon-testnet.stellar.org");

const kps = [
  "SBGCD73TK2PTW2DQNWUYZSTCTHHVJPL4GZF3GVZMCDL6GYETYNAYOADN",
  "SAAQFHI2FMSIC6OFPWZ3PDIIX3OF64RS3EB52VLYYZBX6GYB54TW3Q4U",
  "SCJWYFTBDMDPAABHVJZE3DRMBRTEH4AIC5YUM54QGW57NUBM2XX6433P",
].map((s) => sdk.Keypair.fromSecret(s));

// Returns the given asset pair in "protocol order"
function orderAssets(A, B) {
  return sdk.Asset.compare(A, B) <= 0 ? [A, B] : [B, A];
}

// kp0 issues the assets
const kp0 = kps[0];
const [A, B] = orderAssets(
  new sdk.Asset("A", kp0.publicKey()),
  new sdk.Asset("B", kp0.publicKey()),
);

function newTxBuilder(source, signer, ...ops) {
  let tx = new sdk.TransactionBuilder(source, {
    fee: sdk.BASE_FEE,
    networkPassphrase: sdk.Networks.TESTNET,
  });
  ops.forEach((op) => tx.addOperation(op));
  tx = tx.setTimeout(360).build();
  tx.sign(signer);
  return tx;
}

// Establishes trustlines and funds `recipientKps` for all `assets`
function distributeAssets(issuerKp, recipientKps, ...assets) {
  return server.loadAccount(issuerKp.publicKey()).then((issuer) => {
    const ops = recipientKps
      .map((recipientKp) =>
        assets.map((asset) => [
          sdk.Operation.changeTrust({
            source: recipientKp.publicKey(),
            asset: asset,
          }),
          sdk.Operation.payment({
            source: issuerKp.publicKey(),
            destination: recipientKp.publicKey(),
            amount: "100000",
            asset: asset,
          }),
        ]),
      )
      .flat(2);

    let tx = newTxBuilder(issuer, issuerKp, ...ops);
    tx.sign(...recipientKps);
    return server.submitTransaction(tx);
  });
}

function preamble() {
  return distributeAssets(kp0, [kps[1], kps[2]], A, B);
}
```

```java
import java.util.ArrayList;
import java.util.List;

private static final String[] secrets = {
  "SBGCD73TK2PTW2DQNWUYZSTCTHHVJPL4GZF3GVZMCDL6GYETYNAYOADN",
  "SAAQFHI2FMSIC6OFPWZ3PDIIX3OF64RS3EB52VLYYZBX6GYB54TW3Q4U",
  "SCJWYFTBDMDPAABHVJZE3DRMBRTEH4AIC5YUM54QGW57NUBM2XX6433P"
};

private static final List<KeyPair> keypairs = new ArrayList<>();
static {
  for (String secret : secrets) {
    keypairs.add(KeyPair.fromSecretSeed(secret));
  }
}

// Establishes trustlines and funds `recipientKps` for all `assets`
public static void distributeAssets(KeyPair issuer, KeyPair recipient, Asset[] assets) throws Exception {
  Transaction.Builder builder = newTxBuilder(issuer);

  for (Asset asset : assets) {
    builder.addOperation(
        new ChangeTrustOperation.Builder(asset)
            .setSourceAccount(recipient.getAccountId())
            .build()
    );
    builder.addOperation(
        new PaymentOperation.Builder(
          recipient.getAccountId(),
          asset,
          "100000")
            .setSourceAccount(issuer.getAccountId())
            .build()
    );
  }

  Transaction transaction = builder.build();
  transaction.sign(issuer);
  transaction.sign(recipient);
  server.submitTransaction(transaction);
}

// Function to order assets in "protocol order"
public static Asset[] orderAssets(Asset assetA, Asset assetB) {
  return LiquidityPoolAsset.isValidLexicographicOrder(assetA, assetB) ?
      new Asset[]{assetA, assetB} :
      new Asset[]{assetB, assetA};
}

public static void preamble() throws Exception {
  KeyPair kp0 = keypairs.get(0);
  Asset[] assets = orderAssets(
      new AssetTypeCreditAlphaNum4("A", kp0.getAccountId()),
      new AssetTypeCreditAlphaNum4("B", kp0.getAccountId())
  );
  distributeAssets(kp0, keypairs.get(1), assets);
  distributeAssets(kp0, keypairs.get(2), assets);
}
```

```go
var secrets = []string{
	"SBGCD73TK2PTW2DQNWUYZSTCTHHVJPL4GZF3GVZMCDL6GYETYNAYOADN",
	"SAAQFHI2FMSIC6OFPWZ3PDIIX3OF64RS3EB52VLYYZBX6GYB54TW3Q4U",
	"SCJWYFTBDMDPAABHVJZE3DRMBRTEH4AIC5YUM54QGW57NUBM2XX6433P",
}

func distributeAssets(issuerKp, recipientKp *keypair.Full, assets []txnbuild.Asset) error {
	tx, err := newTxBuilder(issuerKp.Address())
	check(err)

	ops := []txnbuild.Operation{}
	for _, asset := range assets {
		ops = append(ops,
			&txnbuild.ChangeTrust{
				Line:  asset,
				SourceAccount: recipientKp.Address(),
			},
			&txnbuild.Payment{
				Destination: recipientKp.Address(),
				Asset:       asset,
				Amount:      "100000",
				SourceAccount: issuerKp.Address(),
			},
		)
	}

	tx.Params.Operations = ops
	tx, err := tx.BuildSignEncode(issuerKp, recipientKp)
	check(err)

	_, err = server.SubmitTransactionXDR(tx)
	return err
}

// Function to order assets in "protocol order"
func orderAssets(a, b txnbuild.Asset) (txnbuild.Asset, txnbuild.Asset) {
	if a.LessThan(b) {
		return a, b
	}
	return b, a
}

func preamble() {
	kp0 := keypair.MustParseFull(secrets[0])
	kp1 := keypair.MustParseFull(secrets[1])
	kp2 := keypair.MustParseFull(secrets[2])

	assetA, assetB := orderAssets(
		txnbuild.CreditAsset{"A", kp0.Address()},
		txnbuild.CreditAsset{"B", kp0.Address()},
	)

	err := distributeAssets(kp0, kp1, []txnbuild.Asset{assetA, assetB})
	check(err)
	err = distributeAssets(kp0, kp2, []txnbuild.Asset{assetA, assetB})
	check(err)
}
```

</CodeExample>

Here, we use `distributeAssets()` to establish trustlines and set up initial balances of two custom assets (`A` and `B`, issued by `kp0`) for two accounts (`kp2` and `kp3`). For someone to participate in the pool, they must establish trustlines to each of the asset issuers and to the pool share asset (explained below).

:::danger TODO

Case when buying asset an asset, amount aquired > existing trustline amount.

:::

Note the `orderAssets()` helper here. Operations related to liquidity pools refer to the asset pair arbitrarily as `A` and `B`; however, they must be “ordered” such that `A` < `B`. This ordering is defined by the protocol, but its details should not be relevant (if you’re curious, it’s essentially lexicographically ordered by asset type, code, then issuer). We can use the comparison methods built into the SDKs (like `Asset.compare`) to ensure we pass them in the right order and avoid errors.

#### Participant Creation

First, let's create an AMM for the asset pair defined in the preamble. This involves establishing a trustline to the pool itself:

<CodeExample>

```python
poolAsset = LiquidityPoolAsset(
  asset_a = assetA,
  asset_b = assetB
)

def establishPoolTrustline(source, poolAsset):
  tx = (
    newTxBuilder(source.public_key)
      .appendChangeTrustOp(asset = poolAsset)
      .build()
  )
  tx.sign(source)
  return server.submitTransaction(tx)
```

```js
const poolAsset = new sdk.LiquidityPoolAsset(A, B, sdk.LiquidityPoolFeeV18);

function establishPoolTrustline(account, keypair, poolAsset) {
  return server.submitTransaction(
    newTxBuilder(
      account,
      keypair,
      sdk.Operation.changeTrust({
        asset: poolAsset,
      }),
    ),
  );
}
```

```java
import org.stellar.sdk.responses.SubmitTransactionResponse;

public static SubmitTransactionResponse establishPoolTrustline(KeyPair source, LiquidityPoolAsset poolAsset) throws Exception {
  Transaction tx = newTxBuilder(source)
    .addOperation(
      new ChangeTrustOperation.Builder(poolAsset).build()
    )
    .build();

  tx.sign(source);
  return server.submitTransaction(tx);
}
```

```go
func establishPoolTrustline(source *keypair.Full, poolAsset txnbuild.LiquidityPoolAsset) {
  tx := newTxBuilder(source.Address())
  tx.Operations = []txnbuild.Operation{
    &txnbuild.ChangeTrust{
      Line: poolAsset,
    },
  }
  tx, err := txnbuild.NewTransaction(*tx)
  check(err)
  signedTx, err := tx.Sign(network.TestNetworkPassphrase, source)
  check(err)
  _, err = server.SubmitTransaction(signedTx)
  check(err)
}
```

</CodeExample>

This lets the participants hold pool shares, which means now they can perform AMM deposits and withdrawals.

#### Participant Deposits

To work with a liquidity pool, you need to know its ID beforehand. It’s a deterministic value, and only a single liquidity pool can exist for a particular asset pair, so you can calculate it locally from the pool parameters.

<CodeExample>

```python
poolId = poolAsset.liquidity_pool_id

def addLiquidity(source, maxReserveA, maxReserveB):
  exactPrice = maxReserveA / maxReserveB
  minPrice = exactPrice - (exactPrice * Decimal("0.1"))
  maxPrice = exactPrice + (exactPrice * Decimal("0.1"))

  transaction = (
    newTxBuilder(source.public_key)
      .append_liquidity_pool_deposit_op(
        liquidity_pool_id = poolId,
        max_amount_a = f"{maxReserveA:.7f}",
        max_amount_b = f"{maxReserveB:.7f}",
        min_price = f"{minPrice:.7f}",
        max_price = f"{maxPrice:.7f}",
      )
      .build()
  )

  transaction.sign(source)
  return server.submit_transaction(transaction)
```

```js
const poolId = sdk
  .getLiquidityPoolId(
    "constant_product",
    poolAsset.getLiquidityPoolParameters(),
  )
  .toString("hex");

function addLiquidity(source, signer, poolId, maxReserveA, maxReserveB) {
  const exactPrice = maxReserveA / maxReserveB;
  const minPrice = exactPrice - exactPrice * 0.1;
  const maxPrice = exactPrice + exactPrice * 0.1;

  return server.submitTransaction(
    newTxBuilder(
      source,
      signer,
      sdk.Operation.liquidityPoolDeposit({
        liquidityPoolId: poolId,
        maxAmountA: maxReserveA,
        maxAmountB: maxReserveB,
        minPrice: minPrice.toFixed(7),
        maxPrice: maxPrice.toFixed(7),
      }),
    ),
  );
}
```

```java
private static final String poolId = poolAsset.getLiquidityPoolId();

public static SubmitTransactionResponse addLiquidity(
  KeyPair source,
  String poolId,
  String maxReserveA,
  String maxReserveB
) throws Exception {
  double exactPrice = Double.parseDouble(maxReserveA) / Double.parseDouble(maxReserveB);
  double minPrice = exactPrice - exactPrice * 0.1;
  double maxPrice = exactPrice + exactPrice * 0.1;

  Transaction transaction = newTxBuilder(source)
    .addOperation(
      new LiquidityPoolDepositOperation.Builder(
        poolId,
        maxReserveA,
        maxReserveB,
        String.format("%.7f", minPrice),
        String.format("%.7f", maxPrice)
      ).build()
    )
    .build();

  transaction.sign(source);
  return server.submitTransaction(transaction);
}

```

```go
var poolId, _ = poolShareAsset.LiquidityPoolID()

func addLiquidity(source *keypair.Full, maxReserveA, maxReserveB float64) {
  exactPrice := maxReserveA / maxReserveB
  minPrice := exactPrice - exactPrice*0.1
  maxPrice := exactPrice + exactPrice*0.1

  tx := newTxBuilder(source.Address())
  tx.Operations = []txnbuild.Operation{
    &txnbuild.LiquidityPoolDeposit{
      LiquidityPoolID: poolId,
      MaxAmountA:      formatFloat(maxReserveA),
      MaxAmountB:      formatFloat(maxReserveB),
      MinPrice:        formatFloat(minPrice),
      MaxPrice:        formatFloat(maxPrice),
    },
  }

  tx, err := txnbuild.NewTransaction(*tx)
  check(err)
  signedTx, err := tx.Sign(network.TestNetworkPassphrase, source)
  check(err)
  _, err = server.SubmitTransaction(signedTx)
  check(err)
}

```

</CodeExample>

When depositing assets into a liquidity pool, you need to define your acceptable price bounds. In the above function, we allow for a ±10% margin of error from the “spot price”. This margin is by no means a recommendation and is chosen just for demonstration.

Notice that we also specify the maximum amount of each reserve we’re willing to deposit. This, alongside the minimum and maximum prices, helps define boundaries for the deposit, since there can always be a change in the exchange rate between submitting the operation and it getting accepted by the network.

#### Calculating Price

While the network automatically calulates the AMM price product, this does not show up in the order book itself per se. Rather, your order will execute strictly at the best avaliable limit offer or AMM rate. While limit orders specify volume, AMM prices actually vary in real time based on the pool size, which we can find:

<CodeExample>

```python

This proposal only introduces a constant product liquidity pool.
The invariant for such a liquidity pool is (X + x - Fx) (Y - y) >= XY

X and Y are the initial reserves of the liquidity pool
F is the fee charged by the liquidity pool
x is the amount received by the liquidity pool
y is the amount disbursed by the liquidity pool

import requests

def fetch_amm_pool_data(asset_1, asset_2):
    """
    Fetches AMM pool data from the Stellar Horizon API for a given asset pair.

    :param asset_1: The first asset (e.g., XLM).
    :param asset_2: The second asset (e.g., USD stablecoin).

    :return: Reserves of asset_1 and asset_2 in the AMM pool.
    """
    url = f"https://horizon.stellar.org/liquidity_pools?reserves={asset_1},{asset_2}"

    response = requests.get(url)
    if response.status_code != 200:
        raise Exception("Error fetching data from Horizon API")

    data = response.json()

    # Assuming we want the first AMM pool found
    pool_data = data['_embedded']['records'][0]

    # Extract reserves
    reserve_xlm = float(pool_data['reserves'][0]['amount'])  # XLM reserves
    reserve_usd = float(pool_data['reserves'][1]['amount'])  # USD reserves

    return reserve_xlm, reserve_usd

def amm_price_xlm_usd(reserve_xlm, reserve_usd, trade_usd, xlm_price_usd):
    """
    Calculate the price impact of a trade worth $100 of XLM using an AMM's constant product formula.

    :param reserve_xlm: Reserve of XLM in the pool.
    :param reserve_usd: Reserve of the other token (e.g., USD stablecoin) in the pool.
    :param trade_usd: The amount of USD equivalent to be traded.
    :param xlm_price_usd: Current price of XLM in USD (e.g., 0.12 for $0.12/XLM).

    :return: The price for the $100 trade in XLM.
    """
    # Convert the trade amount in USD to XLM based on the current market price
    dx = trade_usd / xlm_price_usd  # Amount of XLM to trade

    # Constant product invariant (x * y = k)
    k = reserve_xlm * reserve_usd

    # New XLM reserve after the trade
    new_reserve_xlm = reserve_xlm + dx

    # Calculate the new reserve of USD after the trade
    new_reserve_usd = k / new_reserve_xlm

    # Amount of USD received (dy)
    dy = reserve_usd - new_reserve_usd

    # Price of the trade in terms of USD received per XLM traded
    price = dy / dx

    return price

# Example: Fetch reserves and calculate price impact for $100 worth of XLM
if __name__ == "__main__":
    asset_1 = "XLM"  # Asset 1 (XLM)
    asset_2 = "USD"  # Asset 2 (USD stablecoin)

    # Fetch AMM pool reserves from Stellar Horizon API
    reserve_xlm, reserve_usd = fetch_amm_pool_data(asset_1, asset_2)

    # Define trade and market parameters
    trade_usd = 100       # Amount of USD equivalent to trade
    xlm_price_usd = 0.12  # Current price of XLM in USD

    # Calculate price impact for $100 worth of XLM
    price_impact = amm_price_xlm_usd(reserve_xlm, reserve_usd, trade_usd, xlm_price_usd)

    print(f"Reserves: {reserve_xlm} XLM, {reserve_usd} USD")
    print(f"Price for trading $100 worth of XLM is: {price_impact} USD per XLM")
```

```js

```

```java

```

```go

```

</CodeExample>

#### Participant Withdrawals

If you own shares of a particular pool, you can withdraw reserves from it. The operation structure mirrors the deposit closely:

<CodeExample>

```python
def removeLiquidity(source, poolId, sharesAmount):
  poolInfo = server.liquidity_pools().liquidity_pool(poolId).call()
  totalShares = Decimal(poolInfo["total_shares"])
  minReserveA = (
      sharesAmount
      / totalShares
      * Decimal(poolInfo["reserves"][0]["amount"])
      * Decimal("0.95") # 95% safety factor
  )
  minReserveB = (
      sharesAmount
      / totalShares
      * Decimal(poolInfo["reserves"][1]["amount"])
      * Decimal("0.95")
  )
  tx = (
      newTxBuilder(source.public_key)
      .appendLiquidityPoolWithdrawOp(
          liquidityPoolId=poolId,
          amount=f"{sharesAmount:.7f}",
          minAmountA=f"{minReserveA:.7f}",
          minAmountB=f"{minReserveB:.7f}",
      )
      .build()
  )
  tx.sign(source)
  return server.submit_transaction(tx)
```

```js
function removeLiquidity(source, signer, poolId, sharesAmount) {
  return server
    .liquidityPools()
    .liquidityPoolId(poolId)
    .call()
    .then((poolInfo) => {
      let totalShares = poolInfo.total_shares;
      let minReserveA =
        (sharesAmount / totalShares) * poolInfo.reserves[0].amount * 0.95; // 95% safety factor
      let minReserveB =
        (sharesAmount / totalShares) * poolInfo.reserves[1].amount * 0.95;

      return server.submitTransaction(
        newTxBuilder(
          source,
          signer,
          sdk.Operation.liquidityPoolWithdraw({
            liquidityPoolId: poolId,
            amount: sharesAmount,
            minAmountA: minReserveA.toFixed(7),
            minAmountB: minReserveB.toFixed(7),
          }),
        ),
      );
    });
}
```

```java
public Map<String, Object> removeLiquidity(KeyPair source, String poolId, String sharesAmount) throws Exception {
  Map<String, Object> poolInfo = server.liquidityPools()
    .liquidityPool(poolId)
    .call();

  double totalShares = Double.parseDouble(poolInfo.get("total_shares").toString());
  double reserveA = Double.parseDouble(((Map<String, String>) ((List<Object>) poolInfo.get("reserves")).get(0)).get("amount"));
  double reserveB = Double.parseDouble(((Map<String, String>) ((List<Object>) poolInfo.get("reserves")).get(1)).get("amount"));

  double minReserveA = (Double.parseDouble(sharesAmount) / totalShares) * reserveA * 0.95; // 95% safety factor
  double minReserveB = (Double.parseDouble(sharesAmount) / totalShares) * reserveB * 0.95;

  Transaction transaction = newTxBuilder(source)
    .addOperation(
      new LiquidityPoolWithdrawOperation.Builder(
        poolId,
        sharesAmount,
        String.format("%.7f", minReserveA),
        String.format("%.7f", minReserveB)
      ).build()
    )
    .build();

  transaction.sign(source);
  return server.submitTransaction(transaction);
}
```

```go
func removeLiquidity(source *keypair.Full, poolID string, sharesAmount float64) {
	poolRequest := horizonclient.LiquidityPoolRequest{LiquidityPoolID: poolID}
	poolInfo, err := client.LiquidityPoolDetail(poolRequest)
	check(err)

	totalShares, err := strconv.ParseFloat(poolInfo.TotalShares, 64)
	check(err)
	reserveA, err := strconv.ParseFloat(poolInfo.Reserves[0].Amount, 64)
	check(err)
	reserveB, err := strconv.ParseFloat(poolInfo.Reserves[1].Amount, 64)
	check(err)

	minReserveA := (sharesAmount / totalShares) * reserveA * 0.95 // 95% safety factor
	minReserveB := (sharesAmount / totalShares) * reserveB * 0.95

	tx := newTxBuilder(source.Address())
	tx.Operations = []txnbuild.Operation{
		&txnbuild.LiquidityPoolWithdraw{
			LiquidityPoolID: poolID,
			Amount:          formatFloat(sharesAmount),
			MinAmountA:      formatFloat(minReserveA),
			MinAmountB:      formatFloat(minReserveB),
		},
	}

	tx, err := tx.Build()
	check(err)
	signedTx, err := tx.Sign(txnbuild.NetworkTest, source)
	check(err)
	resp, err := client.SubmitTransaction(signedTx)
	check(err)
}
```

</CodeExample>

Notice here that we specify the minimum amount. Much like with a strict-receive path payment, we’re specifying that we’re not willing to receive less than this amount of each asset from the pool. This effectively defines a minimum withdrawal price.

#### Putting it all together

Finally, we can combine these pieces together to simulate some participation in a liquidity pool. We’ll have everyone deposit increasing amounts into the pool, then one participant withdraws their shares. Between each step, we’ll retrieve the spot price.

{/* TODO: Move get spo `getSpotPrice` to the above calcualtion example */}

<CodeExample>

```python
# Step 1: kp1 adds liquidity
establishPoolTrustline(kps[1], poolAsset)
addLiquidity(
  kps[1],
  poolId,
  Decimal(1000),
  Decimal(3000)
) # Divides into 1:3 ratio
getSpotPrice()

# Step 2: kp2 adds liquidity
establishPoolTrustline(kps[2], poolAsset)
addLiquidity(
  kps[2],
  poolId,
  Decimal(2000),
  Decimal(6000)
) # Larger deposit this time
getSpotPrice()

# Step 3: kp1 removes all liquidity
accountDetails = server.accounts().account_id(kps[1].public_key).call()
for bals in accountDetails["balances"]:
  if (
    bals["asset_type"] == "liquidity_pool_shares" and
    bals["liquidity_pool_id"] == poolId
  ):
    balance = Decimal(bals["balance"])
    break
if not balance:
  raise Exception("No liquidity pool shares found for kp1")
removeLiquidity(kps[1], poolId, balance)
getSpotPrice()
```

```js
async function main() {
  const accounts = await Promise.all(
    kps.map((kp) => server.loadAccount(kp.publicKey())),
  );

  for (let i = 1; i < kps.length; i++) {
    const acc = accounts[i];
    const kp = kps[i];
    baseAmount = i + 1; // Arbitrary deposit increasing amounts
    const depositA = (baseAmount * 1000).toString();
    const depositB = (baseAmount * 3000).toString(); // Scalars maintain a 1:3 ratio

    await establishPoolTrustline(acc, kp, poolAsset);
    await addLiquidity(acc, kp, poolId, depositA, depositB);
    await getSpotPrice();
  }

  // kp1 removes all liquidity
  const { balances } = await server
    .accounts()
    .accountId(kps[1].publicKey())
    .call();

  const balance = balances.find(
    (bal) =>
      bal.asset_type === "liquidity_pool_shares" &&
      bal.liquidity_pool_id === poolId,
  )?.balance;
  if (!balance) throw new Error("No liquidity pool shares found for kp1.");

  await removeLiquidity(accounts[1], kps[1], poolId, balance);
  await getSpotPrice();
}

preamble().then(main);
```

```java
public static void main(String[] args) throws Exception {
  List<AccountResponse> accounts = new ArrayList<>();
  for (KeyPair kp : kps) {
      accounts.add(server.accounts().account(kp.getAccountId()));
  }

  for (int i = 1; i < kps.size(); i++) {
    establishPoolTrustline(kps.get(i), poolAsset);
    double depositA = (i + 1) * 1000; // Incremental deposit scalar
    double depositB = (i + 1) * 3000; // And maintain 1:3 ratio
    addLiquidity(kps.get(i), poolId, depositA, depositB);
    getSpotPrice();
  }

  // kp1 removes all liquidity
  KeyPair kp1 = kps.get(1);
  double balance = kp1.getBalances().stream()
    .filter(
      balance ->
        "liquidity_pool_shares".equals(balance.getAssetType()) &&
        poolId.equals(balance.getLiquidityPoolId())
    )å
    .mapToDouble(balance -> Double.parseDouble(balance.getBalance()))
    .findFirst();
  if (!balance.isPresent()) {
    throw new Exception("No liquidity pool shares found for kp1");

  removeLiquidity(kp1, poolId, balance);
  getSpotPrice();
}
```

```go
func main() {
  kps := make([]*keypair.Full, len(secrets))
	for i, secret := range secrets {
		kps[i] = keypair.MustParseFull(secret)
	}

	// Simulate deposits from participants
	for i := 1; i < len(kps); i++ {
		kp := kps[i]
		// Arbitrary deposit increasing amounts
    depositA := float64(i+1) * 1000
		depositB := float64(i+1) * 3000 // Scalar maintains 1:3 ratio

    establishPoolTrustline(kp, poolID)
    addLiquidity(kp, poolID, depositA, depositB)
		getSpotPrice(poolID)
	}

	// kp1 removes all liquidity
	kp1 := kps[1]
	account, err := server.AccountDetail(
    horizonclient.AccountRequest{AccountID: kp1.Address()}
  )
	check(err)

	var balance float64
	for _, bal := range account.Balances {
		if bal.AssetType == "liquidity_pool_shares" &&
    bal.LiquidityPoolID == poolID {
			balance, err = strconv.ParseFloat(bal.Balance, 64)
			check(err)
			break
		}
	}
	if balance == 0 {
		log.Fatalf("No liquidity pool shares found for kp1.")
	}
	removeLiquidity(kp1, poolID, balance)
	getSpotPrice(poolID)
}
```

</CodeExample>

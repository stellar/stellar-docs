---
title: Confirmation Modal
sidebar_position: 22
---

Since the user's keypair is encrypted with a pincode and stored in their browser, we will occasionally need to prompt them for that pincode to sign a transaction or otherwise prove that they should be permitted to perform some action or view some data.

## User Experience

The user should be informed about any actions that may take place, especially when funds are on the line. To ensure this, we will overtly request their confirmation via pincode before anything is done. The application has no way of knowing a user's pincode, so it can't decrypt their keypair without their confirmation.

The modal window we've implemented facilitates this confirmation flow whenever we need it.

![confirmation modal](/assets/confirm-pincode.png)

## Code implementation

Our modal function uses the `svelte-simple-modal` package to give us a versatile starting point. If you need to, install it now.

```bash npm2yarn
npm install --save-dev svelte-simple-modal
```

### Wrapping the rest of our app in the modal

On the Svelte side of things, this modal component will be a "wrapper" around the rest of our application. This will allow us to trigger the modal from anywhere we need, and it should behave similarly no matter what.

```svelte title="/src/routes/+layout.svelte"
<script>
    import '../app.postcss'

    // We will use a `writable` Svelte store to trigger our modal
    // highlight-next-line
    import { writable } from 'svelte/store'

    // We have a custom close button for consistent styling, but this is NOT a requirement.
    // highlight-start
    import ModalCloseButton from '$lib/components/ModalCloseButton.svelte'
    import Modal from 'svelte-simple-modal'
    const modal = writable(null)
    // highlight-end
</script>

// highlight-next-line
<Modal show={$modal} closeButton={ModalCloseButton} classContent="rounded bg-base-100">
    <slot />
// highlight-next-line
</Modal>
```

Source: https://github.com/stellar/basic-payment-app/blob/main/src/routes/+layout.svelte

### Creating a reusable modal Svelte component

In order to avoid reinventing the wheel every time we need a modal, we will create a reusable component that can accomodate most of our needs. Then, when we need the confirmation modal, we can pass an object of props to customize the modal's behavior. The basic parts of this component look like this.

```svelte title="/src/lib/components/ConfirmationModal.svelte"
<script>
    import { copy } from 'svelte-copy'
    import { CopyIcon } from 'svelte-feather-icons'
    import { errorMessage } from '$lib/stores/alertsStore'
    import { walletStore } from '$lib/stores/walletStore'
    import { Networks, TransactionBuilder } from 'stellar-sdk'

    // A Svelte "context" is used to control when to `open` and `close` a given
    // modal from within other components
    import { getContext } from 'svelte'
    const { close } = getContext('simple-modal')

    export let title = 'Transaction Preview'
    export let body =
        'Please confirm the transaction below in order to sign and submit it to the network.'
    export let confirmButton = 'Confirm'
    export let rejectButton = 'Reject'
    export let hasPincodeForm = true
    export let transactionXDR = ''
    export let transactionNetwork = ''
    export let firstPincode = ''

    let isWaiting = false
    let pincode = ''
    $: transaction = transactionXDR
        ? TransactionBuilder.fromXDR(transactionXDR, transactionNetwork || Networks.TESTNET)
        : null
</script>

<div class="prose p-3">
    <h1>{title}</h1>
    <p>{body}</p>

    {#if transaction}
        <!-- General, transaction-level information -->
        <h2>Transaction Details</h2>
        <p>Network: <code>{transaction.networkPassphrase}</code></p>
        <p>Source: <code>{transaction.source}</code></p>
        <p>Sequence Number: <code>{transaction.sequence}</code></p>
        <p>Fee: <code>{transaction.fee}</code></p>
        {#if 'memo' in transaction}
            <p>
                Memo ({transaction.memo.type}):
                <code
                    >{transaction.memo.type === 'text'
                        ? transaction.memo?.value?.toString('utf-8')
                        : transaction.memo.type === 'hash'
                        ? transaction.memo?.value?.toString('base64')
                        : transaction.memo.value}</code
                >
            </p>
        {/if}

        <!-- Specifics about the operation(s) present in the transaction -->
        <h2>Operations</h2>
        <ol start="0">
            {#each transaction.operations as operation, i}
                <li>Operation {i}</li>
                <ul>
                    {#each Object.entries(operation) as [key, value]}
                        <li>{key}: <code>{value}</code></li>
                    {/each}
                </ul>
            {/each}
        </ol>

        <!-- The transaction in XDR format, just because it's helpful to have sometimes -->
        <h2>Transaction XDR</h2>
        <p>
            Below, the entire (unsigned) transaction is displayed in XDR format. You can confirm the
            deatils of it by checking the "View XDR" page of the <a
                href="https://laboratory.stellar.org/#xdr-viewer?type=TransactionEnvelope&network=test"
                target="_blank"
                rel="noopener, noreferrer">Stellar Laboratory</a
            >.
        </p>
        <div class="relative">
            <pre class="whitespace-normal break-words">{transactionXDR}</pre>
            <button
                class="btn-ghost btn-square btn-sm btn absolute bottom-1 right-1"
                use:copy={transactionXDR}
            >
                <CopyIcon size="16" />
            </button>
        </div>
    {/if}

    <!-- Display the pincode form: the input element, and the "confirm" and "reject" buttons -->
    {#if hasPincodeForm}
        <form>
            <div class="form-control">
                <label class="label" for="pincode">
                    <span class="label-text">Confirm Pincode</span>
                </label>
                <input
                    type="password"
                    id="pincode"
                    class="input-bordered input"
                    bind:value={pincode}
                />
            </div>
            <div class="my-6 flex justify-end gap-3">
                <button
                    on:click|preventDefault={_onConfirm}
                    class="btn-success btn"
                    disabled={isWaiting}
                >
                    {#if isWaiting}<span class="loading loading-spinner loading-sm" />{/if}
                    {confirmButton}
                </button>
                <button
                    on:click|preventDefault={_onReject}
                    class="btn-error btn"
                    disabled={isWaiting}
                >
                    {rejectButton}
                </button>
            </div>
        </form>
    {/if}
</div>
```

Source: https://github.com/stellar/basic-payment-app/blob/main/src/lib/components/ConfirmationModal.svelte

### Trigger the modal component at signup

We can now use this modal component when it is time to confirm something from the user. As an example, here is how the modal is triggered when someone is signing up.

```svelte title="/src/routes/signup/+page.svelte"
<script>
    import { Keypair } from 'stellar-sdk'
    import TruncatedKey from '$lib/components/TruncatedKey.svelte'
    import ConfirmationModal from '$lib/components/ConfirmationModal.svelte'
    import { goto } from '$app/navigation'
    import { walletStore } from '$lib/stores/walletStore'
    import { fundWithFriendbot } from '$lib/stellar/horizonQueries'

    // The `open` Svelte context is used to open the confirmation modal
    import { getContext } from 'svelte'
    const { open } = getContext('simple-modal')

    // Define some component variables that will be used throughout the page
    let keypair = Keypair.random()
    $: publicKey = keypair.publicKey()
    $: secretKey = keypair.secret()
    let showSecret = false
    let pincode = ''

    // This function is run when the user submits the form containing the public
    // key and their pincode. We pass an object of props that corresponds to the
    // series of `export let` declarations made in our modal component.
    const signup = () => {
        open(ConfirmationModal, {
            firstPincode: pincode,
            title: 'Confirm Pincode',
            body: 'Please re-type your 6-digit pincode to encrypt the secret key.',
            rejectButton: 'Cancel',
        })
    }
</script>

<div class="hero min-h-screen bg-base-200">
    <div class="hero-content flex-col gap-7 lg:flex-row-reverse">
        <div class="text-center lg:text-left">
            <h1 class="text-5xl font-bold">Signup now!</h1>
            <p class="py-6">
                Please provide a 6-digit pincode to sign up. This pincode will be used to encrypt
                the secret key for your Stellar address, before it is stored in your browser's local
                storage. Your secret key to this address will be stored on your device. You will be
                the only one to ever have custody over this key.
            </p>
        </div>
        <div class="flex-col">
            <div class="card w-full max-w-sm flex-shrink-0 bg-base-100 shadow-2xl">
                <div class="card-body">
                    <form on:submit|preventDefault={signup}>
                        <div class="form-control my-1">
                            <label for="publicKey" class="label">
                                <span class="label-text">Public Key</span>
                            </label>
                            <div class="input-bordered input flex">
                                <TruncatedKey keyText={publicKey} />
                            </div>
                            <label for="publicKey" class="label">
                                <button
                                    on:click={() => (keypair = Keypair.random())}
                                    class="link-hover label-text-alt link"
                                >
                                    Generate new address?
                                </button>
                            </label>
                        </div>
                        <div class="form-control">
                            <label class="label cursor-pointer pb-0">
                                <span class="label-text">Show secret key?</span>
                                <input
                                    id="showSecret"
                                    name="showSecret"
                                    type="checkbox"
                                    class="toggle-accent toggle"
                                    bind:checked={showSecret}
                                />
                            </label>
                        </div>
                        {#if showSecret}
                            <div class="form-control mb-1">
                                <label for="secretKey" class="label">
                                    <span class="label-text">Secret Key</span>
                                </label>
                                <div class="input-bordered input flex">
                                    <TruncatedKey keyText={secretKey} />
                                </div>
                            </div>
                        {/if}
                        <div class="form-control my-1">
                            <label for="pincode" class="label">
                                <span class="label-text">Pincode</span>
                            </label>
                            <input
                                id="pincode"
                                name="pincode"
                                type="password"
                                class="input-bordered input"
                                minlength="6"
                                maxlength="6"
                                required
                                bind:value={pincode}
                            />
                        </div>
                        <div class="form-control mt-6">
                            <button type="submit" class="btn-primary btn">Signup</button>
                        </div>
                        <div class="form-control my-1">
                            <div class="label">
                                <a class="link-hover label-text-alt link" href="/login">
                                    Existing users, login here.
                                </a>
                            </div>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
</div>
```

### Customizing confirmation/rejection behavior

Now, as those components have been written here, they don't actually _do_ anything when the user inputs their pincode, or clicks on a button. Let's change that!

Since the confirmation behavior will need to vary depending on the circumstances (i.e., different actions for signup, transaction submission, etc.), we've got a way to pass that as a prop when we open the modal window.

First, in our modal component, we declare a dummy function to act as a prop, as well as an "internal" function that will call the prop function during the course of execution.

```svelte title="/src/lib/components/ConfirmationModal.svelte"
<script>
    // ...

    // `onConfirm` is a prop function that will be overridden from the component
    // that launches the modal
    export let onConfirm = async () => {}
    // `_onConfirm` is actually run when the user clicks the modal's "confirm"
    // button, and calls (in-turn) the supplied `onConfirm` function
    const _onConfirm = async () => {
        isWaiting = true
        try {
            // We make sure the user has supplied the correct pincode
            await walletStore.confirmPincode({
                pincode: pincode,
                firstPincode: firstPincode,
                signup: firstPincode ? true : false,
            })

            // We call the `onConfirm` function that was given to the modal by
            // the outside component.
            await onConfirm(pincode)

            // Now we can close this modal window
            close()
        } catch (err) {
            // If there was an error, we set our `errorMessage` alert
            errorMessage.set(err.body.message)
        }
        isWaiting = false
    }

    // Just like above, `onReject` is a prop function that will be overridden
    // from the component that launches the modal
    export let onReject = () => {}
    // Just like above, `_onReject` is actually run when the user clicks the
    // modal's "reject" button, and calls (if provided) the supplied `onReject`
    // function
    const _onReject = () => {
        // We call the `onReject` function that was given to the modal by the
        // outside component.
        onReject()
        close()
    }
</script>

<div class="prose p-3">
    <!-- ... -->
</div>
```

Now that our modal component is setup to make use of a prop function for confirmation and/or rejection, we can declare what those functions should do inside the page that spawns the modal.

```svelte title="/src/routes/signup/+page.svelte"
<script>
    // ...

    // highlight-start
    const onConfirm = async (pincode) => {
        // Register the encrypted keypair in the user's browser
        await walletStore.register({
            publicKey: publicKey,
            secretKey: secretKey,
            pincode: pincode,
        })

        // Fund the account with a request to Friendbot
        await fundWithFriendbot(publicKey)

        // If the registration was successful, redirect to the dashboard
        if ($walletStore.publicKey) {
            goto('/dashboard')
        }
    }
    // highlight-end

    const signup = () => {
        open(ConfirmationModal, {
            firstPincode: pincode,
            title: 'Confirm Pincode',
            body: 'Please re-type your 6-digit pincode to encrypt the secret key.',
            rejectButton: 'Cancel',
            // highlight-next-line
            onConfirm: onConfirm,
        })
    }
</script>

<div class="hero min-h-screen bg-base-200">
    <!-- ... -->
</div>
```

As you can see, we didn't actually need a customized `onReject` function, so we didn't pass one. No harm, no foul!

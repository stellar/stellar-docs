---
title: Hosted Deposit and Withdrawal
sidebar_position: 50
---

import { CodeExample } from "@site/src/components/CodeExample";

[Sep-24] standard defines the standard way for anchors and wallets to interact on behalf of users. Wallets use this standard to facilitate exchanges between on-chain assets (such as stablecoins) and off-chain assets (such as fiat, or other networks assets, e.g. BTC).

During the flow wallet makes several requests to the anchor, and finally receives an interactive URL to open in iframe. This URL is used by the user to provide an input (such as KYC) directly to the Anchor. Finally, wallet can fetch transaction information using query endpoints.

## Get Anchor Information

Let's start with getting instance of `Interactive` class, responsible for all SEP-24 interaction:

<CodeExample>

```kotlin
val sep24 = anchor.interactive()
```

</CodeExample>

First, let's get the information about Anchor's support for [SEP-24]. This request doesn't require authentication, and will return generic info, such as supported currencies, and features supported by the anchor. You can get full list of returned fields in the [SEP-24 specification](https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0024.md#info)

<CodeExample>

```kt
suspend fun getAnchorServices(): AnchorServiceInfo {
  return sep24.getServicesInfo()
}
```

</CodeExample>

## Interactive flows

Before getting started, make sure you have connected to the anchor and got an authentication token, as described in [Stellar Authentication] wallet guide. We will use `token` object in the examples below as [SEP-10] authentication token, obtained earlier.

To initiate an operation, we need to know an asset. You may want to hard-code it, or get it dynamically from the Anchor's info file, like shown above (for USDC):

<CodeExample>

```kt
val asset = info.currencies.first { it.code == "USDC" }.assetId
```

</CodeExample>

:::info

[//]: # "TODO: link to establish trustline guide"

Before starting with deposit flow, make sure that user account has established a trustline for the asset you are working with.

:::

### Basic flow

Let's start with a basic deposit:

<CodeExample>

```kt
val deposit = sep24.deposit(asset, token)
```

</CodeExample>

As the result, you will get an [interactive response](https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0024.md#deposit-and-withdraw-shared-responses) from the anchor.

Getting a URL that you should open in an iframe and deposit transaction id for future reference is as simple as:

<CodeExample>

```kt
val url = deposit.url
val id = deposit.id
```

</CodeExample>

Similarly to deposit, basic withdrawal flow has the same method signature and repose type:

<CodeExample>

```kt
val withdrawal = sep24.withdraw(asset, token)
val url = withdrawal.url
val id = withdrawal.id
```

</CodeExample>

### Providing KYC Info

To improve user experience, [SEP-24] standard supports passing user KYC to the anchor via [SEP-9]. In turn, anchor will pre-fill this information in the interactive popup.

:::info

While [SEP-9] supports passing binary data, current version of SDK doesn't offer such functionality.

:::

:::note

At the time, accepted [SEP-9] is not strictly typed yet. Improved typing will be offered in future versions.

:::

<CodeExample>

```kt
val sep9 = mapOf("email_address" to "mail@example.com")

val deposit = sep24.deposit(asset, token, sep9)
```

</CodeExample>

### Changing Stellar Transfer Account

By default, Stellar transfer will be sent to the authenticated account (with memo) that initiated a deposit.

While in most cases it's acceptable, some wallets may split their accounts. To do so, pass additional account (and optionally a memo):

<CodeExample>

```kt
suspend fun depositDifferentAccount(): InteractiveFlowResponse {
  val recipientAccount = "G..."
  val memo = "my memo" to MemoType.TEXT
  return anchor
    .interactive()
    .deposit(asset, token, destinationAccount = recipientAccount, destinationMemo = memo)
}
```

</CodeExample>

Similarly, for withdrawal, origin account of the Stellar transaction could be changed:

<CodeExample>

```kt
val originAccount = "G..."
val withdrawal = sep24.withdraw(asset, token, withdrawalAccount = originAccount)
```

</CodeExample>

## Getting Transaction Info

On the typical flow, wallet would get transaction data to notify user about status updates. This is done via [SEP-24] `GET /transaction` and `GET /transactions` endpoint.

Alternatively, some anchors support webhooks for notifications. Note, that this feature is not widely adopted yet.

### Tracking Transaction

Let's look into how to use wallet SDK to track transaction status change. We will use `Watcher` class for this purpose. First, let's initialize watcher and start tracking a transaction.

<CodeExample>

```kt
val watcher = sep24.watcher()
val result = watcher.watchOneTransaction(token, "transaction id")
```

</CodeExample>

Alternatively, we can track multiple transactions for the same asset

<CodeExample>

```kt
val watcher = sep24.watcher()
val result = watcher.watchAsset(getAuthToken(), asset)
```

</CodeExample>

Next, let's get the channel provided by `WatcherResult` to receive events.

<CodeExample>

```kt
do {
  val event = result.channel.receive()
  when (event) {
    is StatusChange ->
      println("Status changed to ${event.status}. Transaction: ${event.transaction}")
    is ExceptionHandlerExit -> println("Exception handler exited the job")
    is ChannelClosed -> println("Channel closed. Job is done")
  }
} while (event !is ChannelClosed)
```

</CodeExample>

This code example will consume all events coming from channel, until it's closed. There are 3 types of events:

- `StatusChange`: indicates that transaction status has changed.
- `ExceptionHandlerExit`: indicates that exception handler exited the processing loop. With default retry handler it happens when retries are exhausted.
- `ChannelClosed`: indicates that channel is closed and no more events will be emitted. This event will always fire. If `ExceptionHandlerExit` happened, channel will close right after. Otherwise, (under normal circumstances) it will stop when all transactions reached terminal statuses.

:::info

Events are stored in the channel until they are received, and calling `receive()` method will block the channel until a message is received. You can read more about how channel works in the [channel documentation](https://kotlinlang.org/docs/coroutines-and-channels.html#channels).

:::

### Fetching Transaction

While `Watcher` class offers powerful tracking capabilities, sometimes it's required to just fetch transaction (or transactions) once. `Anchor` class allows to fetch transaction by id, Stellar transaction id, or external transaction id:

<CodeExample>

```kt
val transaction = sep24.getTransactionBy(token, id = "transaction id")
```

</CodeExample>

It's also possible to fetch transaction by the asset

<CodeExample>

```kt
val transactions = sep24.getTransactionsForAsset(asset, token)
```

</CodeExample>

[sep-9]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-000p.md
[sep-10]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0010.md
[sep-24]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0024.md
[stellar authentication]: ./sep10.mdx

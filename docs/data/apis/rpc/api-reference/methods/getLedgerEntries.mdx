---
hide_title: true
description: Returns ledger entries
---

import { CodeExample } from "@site/src/components/CodeExample";
import { RpcMethod } from "@site/src/components/RpcMethod";
import rpcSpec from "@site/static/stellar-rpc.openrpc.json";

<RpcMethod
  method={rpcSpec.methods.filter((meth) => meth.name === "getLedgerEntries")[0]}
/>

# Building ledger keys

The Stellar ledger is, on some level, essentially a key-value store. The keys are instances of [`LedgerKey`](https://github.com/stellar/stellar-xdr/blob/v23.0/Stellar-ledger-entries.x#L588) and the values are instances of [`LedgerEntry`](https://github.com/stellar/stellar-xdr/blob/v23.0/Stellar-ledger-entries.x#L548). An interesting product of the store's internal design is that the key is a _subset_ of the entry: we'll see more of this later.

The `getLedgerEntries` method returns the "values" (or "entries") for a given set of "keys". Ledger keys come in a lot of forms, and we'll go over the commonly used ones on this page alongside tutorials on how to build and use them.

## Types of `LedgerKey` Entries

The source of truth should always be the XDR defined in the protocol. `LedgerKey`s are a union type defined in [Stellar-ledger-entries.x](https://github.com/stellar/stellar-xdr/blob/v22.0/Stellar-ledger-entries.x#L600). There are 10 different forms a ledger key can take:

1. **Account:** holistically defines a Stellar account, including its balance, signers, etc. (see [Accounts](../../../../../learn/fundamentals/stellar-data-structures/accounts.mdx))
2. **Trustline:** defines a balance line to a non-native asset issued on the network (see [`changeTrustOp`](../../../../../learn/fundamentals/transactions/list-of-operations.mdx#change-trust))
3. **Offer:** defines an offer made on the SDEX orderbook (see [Liquidity on Stellar](../../../../../learn/encyclopedia/sdex/liquidity-on-stellar-sdex-liquidity-pools.mdx#orderbook))
4. **Account Data:** defines key-value data entries attached to an account (see [`manageDataOp`](../../../../../learn/fundamentals/transactions/list-of-operation.mdxs#manage-data))
5. **Claimable Balance:** defines a balance that may or may not actively be claimable (see [Claimable Balances](../../../../../learn/encyclopedia/transactions-specialized/claimable-balances.mdx))
6. **Liquidity Pool:** defines the configuration of a native constant liquidity pool between two assets (see [Liquidity on Stellar](../../../../../learn/encyclopedia/sdex/liquidity-on-stellar-sdex-liquidity-pools.mdx#amms))
7. **Contract Data:** defines a piece of data being stored in a contract under a key
8. **Contract Code:** defines the Wasm bytecode of a contract
9. **Config Setting:** defines the currently active network configuration
10. **TTL:** defines the time-to-live of an associated contract data or code entry

We're going to focus on a subset of these for maximum value, but once you understand how to build and parse some keys and entries, you can extrapolate to all of them.

### Accounts

To fetch an account, all you need is its public key:

<CodeExample>

```typescript
import { Keypair, xdr } from "@stellar/stellar-sdk";

const publicKey = "GALAXYVOIDAOPZTDLHILAJQKCVVFMD4IKLXLSZV5YHO7VY74IWZILUTO";
const accountLedgerKey = xdr.LedgerKey.ledgerKeyAccount(
  new xdr.LedgerKeyAccount({
    accountId: Keypair.fromPublicKey(publicKey).xdrAccountId(),
  }),
);
console.log(accountLedgerKey.toXDR("base64"));
```

</CodeExample>

This will give you the full account details.

<CodeExample>

```typescript
const accountEntryData = (
  await s.getLedgerEntries(accountLedgerKey)
).entries[0].account();
```

</CodeExample>

If you just want to take a look at the structure, you can pass the raw base64 value we logged above to the [Laboratory](https://lab.stellar.org/endpoints/rpc/get-ledger-entries?$=network$id=testnet&label=Testnet&horizonUrl=https:////horizon-testnet.stellar.org&rpcUrl=https:////soroban-testnet.stellar.org&passphrase=Test%20SDF%20Network%20/;%20September%202015;&endpoints$params$xdrFormat=json;;) (or via `curl` if you pass `"xdrFormat": "json"` as an additional parameter to `getLedgerEntries`) and see all of the possible fields. You can also dig into them in code, of course:

<CodeExample>

```typescript
console.log(
  `Account ${publicKey} has ${accountEntryData
    .balance()
    .toString()} stroops of XLM and is on sequence number ${accountEntryData
    .seqNum()
    .toString()}`,
);
```

</CodeExample>

### Trustlines

A trustline is a balance entry for any non-native asset like AstroDollars. To fetch one, you need the trustline owner (a public key like for [Accounts](#accounts)) and the asset in question:

<CodeExample>

```typescript
const trustlineLedgerKey = xdr.LedgerKey.ledgerKeyTrustLine(
  new xdr.LedgerKeyTrustLine({
    accountId: Keypair.fromPublicKey(publicKey).xdrAccountId(),
    asset: new Asset(
      "USDC",
      "GA5ZSEJYB37JRC5AVCIA5MOP4RHTM335X2KGX3IHOJAPP5RE34K4KZVN",
    ).toTrustLineXDRObject(),
  }),
);
```

</CodeExample>

Much like an [account](#accounts), the resulting entry has a balance, but it also has a limit and flags to control how much of that asset can be held. The asset, however, can be either an issued asset or a liquidity pool:

<CodeExample>

```typescript
let asset: string;
let rawAsset = trustlineEntryData.asset();

switch (rawAsset.switch().value) {
  case AssetType.assetTypeCreditAlphanum4().value:
    asset = Asset.fromOperation(
      xdr.Asset.assetTypeCreditAlphanum4(rawAsset.alphaNum4()),
    ).toString();
    break;

  case AssetType.assetTypeCreditAlphanum12().value:
    asset = Asset.fromOperation(
      xdr.Asset.assetTypeCreditAlphanum12(rawAsset.alphaNum12()),
    ).toString();
    break;

  case AssetType.assetTypePoolShare().value:
    asset = rawAsset.liquidityPoolId().toXDR("hex");
    break;
}

console.log(
  `Account ${publicKey} has ${trustlineEntryData
    .balance()
    .toString()} stroops of ${asset} with a limit of ${trustlineEntryData
    .balance()
    .toString()}`,
);
```

</CodeExample>

### Offers

An offer represents a live order on the DEX. Each offer is identified by its `offerID`. To construct a `LedgerKey` for an offer, you only need the offer ID:

<CodeExample>

```typescript
const offerLedgerKey = xdr.LedgerKey.ledgerKeyOffer(
  new xdr.LedgerKeyOffer({
    offerID: 123456789n,
  }),
);
console.log(offerLedgerKey.toXDR("base64"));
```

</CodeExample>

Once you have the ledger entry, you can extract its fields:

<CodeExample>

```typescript
const offerEntryData = (
  await s.getLedgerEntries(offerLedgerKey)
).entries[0].offer();

console.log(`Offer ID: ${offerEntryData.offerId().toString()}`);
console.log(`Seller: ${offerEntryData.sellerId().accountId()}`);
console.log(`Amount: ${offerEntryData.amount().toString()}`); // of selling
console.log(
  `Price: ${offerEntryData.price().n().toString()} / ${offerEntryData.price().d().toString()}`,
);
```

</CodeExample>

You can then decode the selling and buying assets the same way you do for Trustlines, by inspecting `offerEntryData.selling()` and `offerEntryData.buying()` using the standard `xdr.Asset` parsing logic.

### Claimable Balances

A claimable balance represents assets that have been locked under certain claim conditions. Each claimable balance is identified by its `balanceId`, which is a 32-byte hash.

To construct a `LedgerKey` for a claimable balance, you need the `balanceId` as a `Buffer` or `Uint8Array`:

<CodeExample>

```typescript
const balanceIdHex =
  "407a334017a508fb2bf41952c74f977b46147ed70b175717f8bacc0ca3f2cc5b";
const balanceIdBytes = Buffer.from(balanceIdHex, "hex");

const claimableBalanceLedgerKey = xdr.LedgerKey.ledgerKeyClaimableBalance(
  new xdr.LedgerKeyClaimableBalance({
    balanceID: xdr.ClaimableBalanceID.claimableBalanceIdTypeV0(balanceIdBytes),
  }),
);
console.log(claimableBalanceLedgerKey.toXDR("base64"));
```

</CodeExample>

Once you have the ledger entry, you can extract its fields:

<CodeExample>

```typescript
const claimableBalanceEntryData = (
  await s.getLedgerEntries(claimableBalanceLedgerKey)
).entries[0].claimableBalance();

console.log(`Amount: ${claimableBalanceEntryData.amount().toString()} stroops`);

const asset = claimableBalanceEntryData.asset();
// Decode asset similar to as in trustlines

const claimants = claimableBalanceEntryData.claimants();

if (claimableBalanceEntryData.ext().switch().value === 1) {
  const flags = claimableBalanceEntryData.ext().v1().flags();
  const clawbackEnabled =
    (flags &
      xdr.ClaimableBalanceFlags.claimableBalanceClawbackEnabledFlag()) !==
    0;
  console.log(`Clawback Enabled: ${clawbackEnabled}`);
}
```

</CodeExample>

#### Claimants and Predicates

Claimable balances contain one or more claimants, each with a claim predicate. You can iterate through them as follows:

<CodeExample>

```typescript
for (let i = 0; i < claimants.length; i++) {
  const claimant = claimants[i].v0();
  const destination = claimant.destination().accountId();
  console.log(`Claimant ${i + 1}: ${destination}`);

  const predicate = claimant.predicate();
  const predicateType = predicate.switch().value;

  switch (predicateType) {
    case xdr.ClaimPredicateType.claimPredicateUnconditional().value:
      console.log("Predicate: Unconditional");
      break;
    case xdr.ClaimPredicateType.claimPredicateBeforeAbsoluteTime().value:
      console.log(`Predicate: Before Absolute Time = ${predicate.absBefore().toString()}`);
      break;
    case xdr.ClaimPredicateType.claimPredicateBeforeRelativeTime().value:
      console.log(`Predicate: Before Relative Time = ${predicate.relBefore().toString()} seconds`);
      break;
    default:
      console.log("Predicate: Complex predicate type (AND/OR/NOT)");
      break;
}
```

</CodeExample>

#### Flags

If the claimable balance has flags set (not `v0`), you can read them like this:

<CodeExample>

```typescript
switch (claimableBalanceEntryData.ext().switch().value) {
  case 0: // No flags
    break;
  case 1:
    const flags = claimableBalanceEntryData.ext().v1().flags();
    const clawbackEnabled = (flags & 1) !== 0; // claw = 0x1
    console.log(`Clawback Enabled: ${clawbackEnabled}`);
    break;
}
```

</CodeExample>

### Liquidity Pools

A liquidity pool represents an Automated Market Maker holding two assets. Each liquidity pool is identified by its `liquidityPoolID`, which is a 32-byte hash.

To construct a `LedgerKey` for an AMM, you need the liquidity-pool ID as a `Buffer` or `Uint8Array`. Core deterministicly stores this as a 64-char hex string.

<CodeExample>

```typescript
const liquidityPoolIdHex =
  "82f857462d5304e1ad7d5308fb6d90ff3e70ad8fb07b81d04b12d2cc867fc735";
const liquidityPoolIdBytes = Buffer.from(liquidityPoolIdHex, "hex");

const liquidityPoolLedgerKey = xdr.LedgerKey.ledgerKeyLiquidityPool(
  new xdr.LedgerKeyLiquidityPool({
    liquidityPoolID: liquidityPoolIdBytes,
  }),
);
console.log(liquidityPoolLedgerKey.toXDR("base64"));
```

</CodeExample>

Once you have the ledger entry, you can extract its fields:

<CodeExample>

```typescript
const liquidityPoolEntryData = (
  await s.getLedgerEntries(liquidityPoolLedgerKey)
).entries[0].liquidityPool();

console.log(
  `Total Pool Shares: ${liquidityPoolEntryData.totalPoolShares().toString()}`,
);
console.log(
  `Total Trustlines: ${liquidityPoolEntryData.poolSharesTrustLineCount().toString()}`,
);

const AMM = liquidityPoolEntryData.body();
switch (AMM.switch().value) {
  case xdr.LiquidityPoolType.liquidityPoolConstantProduct().value: {
    const params = AMM.constantProduct().params();
    const fee = params.fee(); // basis points
    const assetA = params.assetA();
    const assetB = params.assetB();
    console.log(`Constant-Product Between: ${assetA} and ${assetB}`);
    break;
  }
}
```

</CodeExample>

### Offers

An offer represents a live order on the DEX. Each offer is identified by its `offerID`. To construct a `LedgerKey` for an offer, you only need the offer ID:

<CodeExample>

```typescript
const offerLedgerKey = xdr.LedgerKey.ledgerKeyOffer(
  new xdr.LedgerKeyOffer({
    offerID: 123456789n,
  }),
);
console.log(offerLedgerKey.toXDR("base64"));
```

</CodeExample>

Once you have the ledger entry, you can extract its fields:

<CodeExample>

```typescript
const offerEntryData = (
  await s.getLedgerEntries(offerLedgerKey)
).entries[0].offer();

console.log(`Offer ID: ${offerEntryData.offerId().toString()}`);
console.log(`Seller: ${offerEntryData.sellerId().accountId()}`);
console.log(`Amount: ${offerEntryData.amount().toString()}`); // of selling
console.log(
  `Price: ${offerEntryData.price().n().toString()} / ${offerEntryData.price().d().toString()}`,
);
```

</CodeExample>

You can then decode the selling and buying assets the same way you do for Trustlines, by inspecting `offerEntryData.selling()` and `offerEntryData.buying()` using the standard `xdr.Asset` parsing logic.

### Claimable Balances

A claimable balance represents assets that have been locked under certain claim conditions. Each claimable balance is identified by its `balanceId`, which is a 32-byte hash.

To construct a `LedgerKey` for a claimable balance, you need the `balanceId` as a `Buffer` or `Uint8Array`:

<CodeExample>

```typescript
const balanceIdHex =
  "407a334017a508fb2bf41952c74f977b46147ed70b175717f8bacc0ca3f2cc5b";
const balanceIdBytes = Buffer.from(balanceIdHex, "hex");

const claimableBalanceLedgerKey = xdr.LedgerKey.ledgerKeyClaimableBalance(
  new xdr.LedgerKeyClaimableBalance({
    balanceID: xdr.ClaimableBalanceID.claimableBalanceIdTypeV0(balanceIdBytes),
  }),
);
console.log(claimableBalanceLedgerKey.toXDR("base64"));
```

</CodeExample>

Once you have the ledger entry, you can extract its fields:

<CodeExample>

```typescript
const claimableBalanceEntryData = (
  await s.getLedgerEntries(claimableBalanceLedgerKey)
).entries[0].claimableBalance();

console.log(`Amount: ${claimableBalanceEntryData.amount().toString()} stroops`);

const asset = claimableBalanceEntryData.asset();
// Decode asset similar to as in trustlines

const claimants = claimableBalanceEntryData.claimants();

if (claimableBalanceEntryData.ext().switch().value === 1) {
  const flags = claimableBalanceEntryData.ext().v1().flags();
  const clawbackEnabled =
    (flags &
      xdr.ClaimableBalanceFlags.claimableBalanceClawbackEnabledFlag()) !==
    0;
  console.log(`Clawback Enabled: ${clawbackEnabled}`);
}
```

</CodeExample>

#### Claimants and Predicates

Claimable balances contain one or more claimants, each with a claim predicate. You can iterate through them as follows:

<CodeExample>

```typescript
for (let i = 0; i < claimants.length; i++) {
  const claimant = claimants[i].v0();
  const destination = claimant.destination().accountId();
  console.log(`Claimant ${i + 1}: ${destination}`);

  const predicate = claimant.predicate();
  const predicateType = predicate.switch().value;

  switch (predicateType) {
    case xdr.ClaimPredicateType.claimPredicateUnconditional().value:
      console.log("Predicate: Unconditional");
      break;
    case xdr.ClaimPredicateType.claimPredicateBeforeAbsoluteTime().value:
      console.log(`Predicate: Before Absolute Time = ${predicate.absBefore().toString()}`);
      break;
    case xdr.ClaimPredicateType.claimPredicateBeforeRelativeTime().value:
      console.log(`Predicate: Before Relative Time = ${predicate.relBefore().toString()} seconds`);
      break;
    default:
      console.log("Predicate: Complex predicate type (AND/OR/NOT)");
      break;
}
```

</CodeExample>

#### Flags

If the claimable balance has flags set (not `v0`), you can read them like this:

<CodeExample>

```typescript
switch (claimableBalanceEntryData.ext().switch().value) {
  case 0: // No flags
    break;
  case 1:
    const flags = claimableBalanceEntryData.ext().v1().flags();
    const clawbackEnabled = (flags & 1) !== 0; // claw = 0x1
    console.log(`Clawback Enabled: ${clawbackEnabled}`);
    break;
}
```

</CodeExample>

### Liquidity Pools

A liquidity pool represents an Automated Market Maker holding two assets. Each liquidity pool is identified by its `liquidityPoolID`, which is a 32-byte hash.

To construct a `LedgerKey` for an AMM, you need the liquidity-pool ID as a `Buffer` or `Uint8Array`. Core deterministicly stores this as a 64-char hex string.

<CodeExample>

```typescript
const liquidityPoolIdHex =
  "82f857462d5304e1ad7d5308fb6d90ff3e70ad8fb07b81d04b12d2cc867fc735";
const liquidityPoolIdBytes = Buffer.from(liquidityPoolIdHex, "hex");

const liquidityPoolLedgerKey = xdr.LedgerKey.ledgerKeyLiquidityPool(
  new xdr.LedgerKeyLiquidityPool({
    liquidityPoolID: liquidityPoolIdBytes,
  }),
);
console.log(liquidityPoolLedgerKey.toXDR("base64"));
```

</CodeExample>

Once you have the ledger entry, you can extract its fields:

<CodeExample>

```typescript
const liquidityPoolEntryData = (
  await s.getLedgerEntries(liquidityPoolLedgerKey)
).entries[0].liquidityPool();

console.log(
  `Total Pool Shares: ${liquidityPoolEntryData.totalPoolShares().toString()}`,
);
console.log(
  `Total Trustlines: ${liquidityPoolEntryData.poolSharesTrustLineCount().toString()}`,
);

const AMM = liquidityPoolEntryData.body();
switch (AMM.switch().value) {
  case xdr.LiquidityPoolType.liquidityPoolConstantProduct().value: {
    const params = AMM.constantProduct().params();
    const fee = params.fee(); // basis points
    const assetA = params.assetA();
    const assetB = params.assetB();
    console.log(`Constant-Product Between: ${assetA} and ${assetB}`);
    break;
  }
}
```

</CodeExample>

### Offers

An offer represents a live order on the DEX. Each offer is identified by its `offerID`. To construct a `LedgerKey` for an offer, you only need the offer ID:

<CodeExample>

```typescript
const offerLedgerKey = xdr.LedgerKey.ledgerKeyOffer(
  new xdr.LedgerKeyOffer({
    offerID: 123456789n,
  }),
);
console.log(offerLedgerKey.toXDR("base64"));
```

</CodeExample>

Once you have the ledger entry, you can extract its fields:

<CodeExample>

```typescript
const offerEntryData = (
  await s.getLedgerEntries(offerLedgerKey)
).entries[0].offer();

console.log(`Offer ID: ${offerEntryData.offerId().toString()}`);
console.log(`Seller: ${offerEntryData.sellerId().accountId()}`);
console.log(`Amount: ${offerEntryData.amount().toString()}`); // of selling
console.log(
  `Price: ${offerEntryData.price().n().toString()} / ${offerEntryData.price().d().toString()}`,
);
```

</CodeExample>

You can then decode the selling and buying assets the same way you do for Trustlines, by inspecting `offerEntryData.selling()` and `offerEntryData.buying()` using the standard `xdr.Asset` parsing logic.

### Claimable Balances

A claimable balance represents assets that have been locked under certain claim conditions. Each claimable balance is identified by its `balanceId`, which is a 32-byte hash.

To construct a `LedgerKey` for a claimable balance, you need the `balanceId` as a `Buffer` or `Uint8Array`:

<CodeExample>

```typescript
const balanceIdHex =
  "407a334017a508fb2bf41952c74f977b46147ed70b175717f8bacc0ca3f2cc5b";
const balanceIdBytes = Buffer.from(balanceIdHex, "hex");

const claimableBalanceLedgerKey = xdr.LedgerKey.ledgerKeyClaimableBalance(
  new xdr.LedgerKeyClaimableBalance({
    balanceID: xdr.ClaimableBalanceID.claimableBalanceIdTypeV0(balanceIdBytes),
  }),
);
console.log(claimableBalanceLedgerKey.toXDR("base64"));
```

</CodeExample>

Once you have the ledger entry, you can extract its fields:

<CodeExample>

```typescript
const claimableBalanceEntryData = (
  await s.getLedgerEntries(claimableBalanceLedgerKey)
).entries[0].claimableBalance();

console.log(`Amount: ${claimableBalanceEntryData.amount().toString()} stroops`);

const asset = claimableBalanceEntryData.asset();
// Decode asset similar to as in trustlines

const claimants = claimableBalanceEntryData.claimants();

if (claimableBalanceEntryData.ext().switch().value === 1) {
  const flags = claimableBalanceEntryData.ext().v1().flags();
  const clawbackEnabled =
    (flags &
      xdr.ClaimableBalanceFlags.claimableBalanceClawbackEnabledFlag()) !==
    0;
  console.log(`Clawback Enabled: ${clawbackEnabled}`);
}
```

</CodeExample>

#### Claimants and Predicates

Claimable balances contain one or more claimants, each with a claim predicate. You can iterate through them as follows:

<CodeExample>

```typescript
for (let i = 0; i < claimants.length; i++) {
  const claimant = claimants[i].v0();
  const destination = claimant.destination().accountId();
  console.log(`Claimant ${i + 1}: ${destination}`);

  const predicate = claimant.predicate();
  const predicateType = predicate.switch().value;

  switch (predicateType) {
    case xdr.ClaimPredicateType.claimPredicateUnconditional().value:
      console.log("Predicate: Unconditional");
      break;
    case xdr.ClaimPredicateType.claimPredicateBeforeAbsoluteTime().value:
      console.log(`Predicate: Before Absolute Time = ${predicate.absBefore().toString()}`);
      break;
    case xdr.ClaimPredicateType.claimPredicateBeforeRelativeTime().value:
      console.log(`Predicate: Before Relative Time = ${predicate.relBefore().toString()} seconds`);
      break;
    default:
      console.log("Predicate: Complex predicate type (AND/OR/NOT)");
      break;
}
```

</CodeExample>

#### Flags

If the claimable balance has flags set (not `v0`), you can read them like this:

<CodeExample>

```typescript
switch (claimableBalanceEntryData.ext().switch().value) {
  case 0: // No flags
    break;
  case 1:
    const flags = claimableBalanceEntryData.ext().v1().flags();
    const clawbackEnabled = (flags & 1) !== 0; // claw = 0x1
    console.log(`Clawback Enabled: ${clawbackEnabled}`);
    break;
}
```

</CodeExample>

### Liquidity Pools

A liquidity pool represents an Automated Market Maker holding two assets. Each liquidity pool is identified by its `liquidityPoolID`, which is a 32-byte hash.

To construct a `LedgerKey` for an AMM, you need the liquidity-pool ID as a `Buffer` or `Uint8Array`. Core deterministicly stores this as a 64-char hex string.

<CodeExample>

```typescript
const liquidityPoolIdHex =
  "82f857462d5304e1ad7d5308fb6d90ff3e70ad8fb07b81d04b12d2cc867fc735";
const liquidityPoolIdBytes = Buffer.from(liquidityPoolIdHex, "hex");

const liquidityPoolLedgerKey = xdr.LedgerKey.ledgerKeyLiquidityPool(
  new xdr.LedgerKeyLiquidityPool({
    liquidityPoolID: liquidityPoolIdBytes,
  }),
);
console.log(liquidityPoolLedgerKey.toXDR("base64"));
```

</CodeExample>

Once you have the ledger entry, you can extract its fields:

<CodeExample>

```typescript
const liquidityPoolEntryData = (
  await s.getLedgerEntries(liquidityPoolLedgerKey)
).entries[0].liquidityPool();

console.log(
  `Total Pool Shares: ${liquidityPoolEntryData.totalPoolShares().toString()}`,
);
console.log(
  `Total Trustlines: ${liquidityPoolEntryData.poolSharesTrustLineCount().toString()}`,
);

const AMM = liquidityPoolEntryData.body();
switch (AMM.switch().value) {
  case xdr.LiquidityPoolType.liquidityPoolConstantProduct().value: {
    const params = AMM.constantProduct().params();
    const fee = params.fee(); // basis points
    const assetA = params.assetA();
    const assetB = params.assetB();
    console.log(`Constant-Product Between: ${assetA} and ${assetB}`);
    break;
  }
}
```

</CodeExample>

### Contract Data

Suppose we've deployed the [`increment` example contract] and want to find out what value is stored in the `COUNTER` ledger key. To build the key:

<CodeExample>

```python
from stellar_sdk import xdr, scval, Address

def get_ledger_key_symbol(contract_id: str, symbol_text: str) -> str:
    ledger_key = xdr.LedgerKey(
        type=xdr.LedgerEntryType.CONTRACT_DATA,
        contract_data=xdr.LedgerKeyContractData(
            contract=Address(contract_id).to_xdr_sc_address(),
            key=scval.to_symbol(symbol_text),
            durability=xdr.ContractDataDurability.PERSISTENT
        ),
    )
    return ledger_key.to_xdr()

print(
    get_ledger_key_symbol(
        "CCPYZFKEAXHHS5VVW5J45TOU7S2EODJ7TZNJIA5LKDVL3PESCES6FNCI",
        "COUNTER"
    )
)
```

```typescript
import { xdr, Address } from "@stellar/stellar-sdk";

const getLedgerKeySymbol = (
  contractId: string,
  symbolText: string,
): xdr.LedgerKey => {
  return xdr.LedgerKey.contractData(
    new xdr.LedgerKeyContractData({
      contract: new Address(contractId).toScAddress(),
      key: xdr.ScVal.scvSymbol(symbolText),
      // The increment contract stores its state in persistent storage,
      // but other contracts may use temporary storage
      // (xdr.ContractDataDurability.temporary()).
      durability: xdr.ContractDataDurability.persistent(),
    }),
  );
};

const ledgerKey = getLedgerKeySymbol(
  "CCPYZFKEAXHHS5VVW5J45TOU7S2EODJ7TZNJIA5LKDVL3PESCES6FNCI",
  "COUNTER",
);
```

</CodeExample>

### Contract Wasm Code

To understand this, we need a handle on how smart contract deployment works:

- When you deploy a contract, first the code is "installed" (i.e. uploaded onto the blockchain), creating a `LedgerEntry` with the Wasm byte-code that can be uniquely identified by its hash (that is, the hash of the uploaded code itself).
- Then, when a contract _instance_ is "instantiated," we create a `LedgerEntry` with a reference to that code's hash. This means many contracts can point to the same Wasm code.

Thus, fetching the contract code is a two-step process:

1. First, we look up the contract itself, to see which code hash it is referencing.
2. Then, we can look up the raw Wasm byte-code using that hash.

#### 1. Find the ledger key for the contract instance

<CodeExample>

```python
from stellar_sdk import xdr, Address

def get_ledger_key_contract_code(contract_id: str) -> xdr.LedgerKey:
  return xdr.LedgerKey(
    type=xdr.LedgerEntryType.CONTRACT_DATA,
    contract_data=xdr.LedgerKeyContractData(
      contract=Address(contract_id).to_xdr_sc_address(),
      key=xdr.SCVal(xdr.SCValType.SCV_LEDGER_KEY_CONTRACT_INSTANCE),
      durability=xdr.ContractDataDurability.PERSISTENT
    )
  )

print(get_ledger_key_contract_code(
  "CCPYZFKEAXHHS5VVW5J45TOU7S2EODJ7TZNJIA5LKDVL3PESCES6FNCI"
))
```

```typescript
import { Contract } from "@stellar/stellar-sdk";

function getLedgerKeyContractCode(contractId): xdr.LedgerKey {
  return new Contract(contractId).getFootprint();
}

console.log(
  getLedgerKeyContractCode(
    "CCPYZFKEAXHHS5VVW5J45TOU7S2EODJ7TZNJIA5LKDVL3PESCES6FNCI",
  ),
);
```

</CodeExample>

Once we have the ledger entry (via `getLedgerEntries`, see [below](#actually-fetching-the-ledger-entry-data)), we can extract the Wasm hash:

#### 2. Request the `ContractCode` using the retrieved `LedgerKey`

Now take the `xdr` field from the previous response's `result` object, and create a `LedgerKey` from the hash contained inside.

<CodeExample>

```python
from stellar_sdk import xdr

def get_ledger_key_wasm_id(
  # received from getLedgerEntries and decoded
  contract_data: xdr.ContractDataEntry
) -> xdr.LedgerKey:
  # First, we dig the wasm_id hash out of the xdr we received from RPC
  wasm_hash = contract_data.val.instance.executable.wasm_hash

  # Now, we can create the `LedgerKey` as we've done in previous examples
  ledger_key = xdr.LedgerKey(
    type=xdr.LedgerEntryType.CONTRACT_CODE,
    contract_code=xdr.LedgerKeyContractCode(
      hash=wasm_hash
    ),
  )
  return ledger_key
```

```typescript
import { xdr } from "@stellar/stellar-sdk";

function getLedgerKeyWasmId(
  contractData: xdr.ContractDataEntry,
): xdr.LedgerKey {
  const wasmHash = contractData.val().instance().executable().wasmHash();

  return xdr.LedgerKey.contractCode(
    new xdr.LedgerKeyContractCode({
      hash: wasmHash,
    }),
  );
}
```

</CodeExample>

Now, finally we have a `LedgerKey` that correspond to the Wasm byte-code that has been deployed under the `contractId` we started out with so very long ago. This `LedgerKey` can be used in a final request to `getLedgerEntries`. In that response we will get a `LedgerEntryData` corresponding to a `ContractCodeEntry` which will contain the actual, deployed, real-life contract byte-code:

<CodeExample>

```typescript
const theHashData: xdr.ContractDataEntry = await getLedgerEntries(
  getLedgerKeyContractCode("C..."),
).entries[0].contractData();

const theCode: Buffer = await getLedgerEntries(getLedgerKeyWasmId(theHashData))
  .entries[0].contractCode()
  .code();
```

</CodeExample>

## Actually fetching the ledger entry data

Once we've learned to _build_ and _parse_ these (which we've done above at length), the process for actually fetching them is always identical. If you know the type of key you fetched, you apply the accessor method accordingly once you've received them from the `getLedgerEntries` method:

<CodeExample>

```typescript
const s = new Server("https://soroban-testnet.stellar.org");

// assume key1 is an account, key2 is a trustline, and key3 is contract data
const response = await s.getLedgerEntries(key1, key2, key3);

const account = response.entries[0].account();
const contractData = response.entries[2].contractData();
const contractCode = response.entries[1].contractCode();
```

</CodeExample>

Now, finally we have a `LedgerKey` that correspond to the Wasm byte-code that has been deployed under the `ContractId` we started out with so very long ago. This `LedgerKey` can be used in a final request to the Stellar-RPC endpoint.

```json
{
  "jsonrpc": "2.0",
  "id": 12345,
  "method": "getLedgerEntries",
  "params": {
    "keys": [
      "AAAAB+QzbW3JDhlUbDVW/C+1/5SIQDstqORuhpCyl73O1vH6",
      "AAAABgAAAAGfjJVEBc55drW3U87N1Py0Rw0/nlqUA6tQ6r28khEl4gAAABQAAAAB"
      "AAAABgAAAAAAAAABn4yVRAXOeXa1t1POzdT8tEcNP55alAOrUOq9vJIRJeIAAAAUAAAAAQAAABMAAAAA5DNtbckOGVRsNVb8L7X/lIhAOy2o5G6GkLKXvc7W8foAAAAA"
    ]
  }
}
```

Then you can inspect them accordingly. Each of the above entries follows the XDR for that `LedgerEntryData` structure precisely. For example, the `AccountEntry` is in [`Stellar-ledger-entries.x#L191`](https://github.com/stellar/stellar-xdr/blob/v22.0/Stellar-ledger-entries.x#L191) and you can use `.seqNum()` to access its current sequence number, as we've shown. In JavaScript, you can see the appropriate methods in the [type definition](https://github.com/stellar/js-stellar-base/blob/6930a70d7fbde675514b5933baff605d97453ba7/types/curr.d.ts#L3034).

## Viewing and understanding XDR

If you don't want to parse the XDR out programmatically, you can also leverage both the [Stellar CLI](../../../../../tools/cli/stellar-cli.mdx) and the [Stellar Lab](https://lab.stellar.org/xdr/view) to get a human-readable view of ledger keys and entries. For example,

```bash
echo 'AAAAAAAAAAAL76GC5jcgEGfLG9+nptaB9m+R44oweeN3EcqhstdzhQ==' | stellar xdr decode --type LedgerKey --output json-formatted
{
  "account": {
    "account_id": "GAF67IMC4Y3SAEDHZMN57J5G22A7M34R4OFDA6PDO4I4VINS25ZYLBZZ"
  }
}
```

[`increment` example contract]: ../../../../../build/smart-contracts/getting-started/storing-data
["View XDR" page of the Stellar Lab]: https://lab.stellar.org/xdr/view?$=network$id=testnet&label=Testnet&horizonUrl=https:////horizon-testnet.stellar.org&rpcUrl=https:////soroban-testnet.stellar.org&passphrase=Test%20SDF%20Network%20/;%20September%202015;;

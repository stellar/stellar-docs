---
title: Securing Web-Based Projects
sidebar_position: 30
---

Any application managing cryptocurrency is a frequent target of malicious actors and needs to follow security best practices. The below checklist offers guidance on the most common vulnerabilities. However, even if you follow every piece of advice, security is not guaranteed. Web security and malicious actors are constantly evolving, so it’s good to maintain a healthy amount of paranoia.

## SSL/TLS

Ensure that TLS is enabled. Redirect HTTP to HTTPS where necessary to ensure that Man in the Middle (MITM) attacks can’t occur and sensitive data is securely transferred between the client and browser. Enable TLS and get an SSL certificate for free at [LetsEncrypt](https://letsencrypt.org/getting-started/).

If you don’t have SSL/TLS enabled, stop everything and do this first.

## Content security policy (CSP) headers

CSP headers tell the browser where it can download static resources from. For example, if you use astralwallet.io, and it requests a JavaScript file from myevilsite.com, your browser will block it unless it was whitelisted with CSP headers. You can read about how to implement CSP headers [here](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP).

Most web frameworks have a configuration file or extensions to specify your CSP policy, and the headers are auto-generated for you. For example, see [Helmet](https://www.npmjs.com/package/helmet) for Node.js. This would have prevented the [Blackwallet Hack](https://www.ccn.com/yet-another-crypto-wallet-hack-causes-users-lose-400000/).

## HTTP strict-transport-security headers

This is an HTTP header that tells the browser that all future connections to a particular site should use HTTPS. To implement this, add the [header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security) to your website. Some web frameworks (like [Django](https://docs.djangoproject.com/en/2.0/topics/security/#ssl-https)) have this built-in. This would have prevented the [MyEtherWallet DNS Hack](https://bitcoinmagazine.com/articles/popular-ether-wallet-mew-hijacked-dns-attack/).

## Storing sensitive data

Ideally, you don’t have to store much sensitive data. If you must, be sure to tread carefully. There are many strategies to store sensitive data:

- Ensure sensitive data is encrypted using a proven cipher like AES-256 and stored separately from application data. Always pick up Authenticated Encryption with Associated Data (AEAD) mode.
- Any communication between the application server and secret server should be in a private network and/or authenticated via HMAC. Your cipher strategy will change based on whether you will be sending the ciphertext over the wire multiple times.
- Back up any encryption keys you may use offline and store them only in-memory in your app.
- Consult a good cryptographer and read up on best practices. Look into the documentation of your favorite web framework.
- Rolling your own crypto is a bad idea. Always use tried and tested libraries such as [Networking and Cryptography Library (NaCI)](<https://en.wikipedia.org/wiki/NaCl_(software)>).

## Implement security logging and monitoring

Attackers often need to spend time exploring your website for unexpected or overlooked behavior. Examining logs defensively can help you catch onto what they’re trying to achieve. You can at least block their IP or automate blocking based on suspicious behavior.

It’s also worth setting up an error reporting (like [Sentry](https://sentry.io/welcome/)). Often, people trigger strange bugs when trying to hack things.

## Authentication weaknesses

You must build your authentication securely if you have logins for users. The best way to do this is to use something off the shelf. Both [Ruby on Rails](https://guides.rubyonrails.org/security.html#authentication) and [Django](https://docs.djangoproject.com/en/5.2/topics/auth) have robust, built-in authentication schemes.

Many JSON web token (JWT) implementations are poorly done, so ensure the library you use is audited.

Hash passwords with a time-tested scheme are good. And Balloon Hashing is also worth looking into.

We strongly prefer 2FA and require U2F or [TOTP](https://tools.ietf.org/html/rfc6238) 2FA for sensitive actions. 2FA is important as email accounts are usually not very secure. Having a second factor of authentication ensures that users who accidentally stay logged on or have their password guessed are still protected.

Finally, require strong passwords. Common and short passwords can be brute-forced. Dropbox has a great [open-source tool](https://dropbox.tech/security/zxcvbn-realistic-password-strength-estimation) that gauges password strength fairly quickly, making it usable for user interactions.

## Denial of service (DOS) attacks

DOS attacks are usually accomplished by overloading your web servers with traffic. To mitigate this risk, rate limit traffic from IPs and browser fingerprints. Sometimes people will use proxies to bypass IP rate-limiting. In the end, malicious actors can always find ways to spoof their identity, so the surest way to block DOS attacks is to implement proof of work checks in your client or use a managed service like [Cloudflare Distributed denial-of-service (DDoS) protection](https://www.cloudflare.com/ddos/).

## Block unused ports

Attackers will often scan your ports to see if you were negligent and left any open. Services like Heroku do this for you. [Read about how to enable this on AWS](https://docs.aws.amazon.com/config/latest/developerguide/restricted-common-ports.html).

## Phishing and social engineering

Phishing attacks will thwart any well-formed security infrastructure. Have clear policies published on your website and articulate them to users when they sign up (you will never ask for their password, etc.). Sign messages to your users and prompt users to check the website's domain they are on.

## Scan your website and libraries for vulnerabilities

Use web application scanning tools like to scan your third-party client libraries for vulnerabilities. Make sure to keep your third-party libraries up to date. Often, upgrades are triggered by security exploits.

Web application security tools fall under the following categories. 

* **Static Application Security Testing (SAST):** Scanners analyze the application's source code, byte code, or binary code without executing the program to find security flaws. [Snyk Code](https://snyk.io/product/snyk-code) and [Semgrep](https://semgrep.dev/solutions/static-application-security-testing) are popular examples of SAST tools. 

* **Dynamic Application Security Testing (DAST):** These tools test the application while it's running, probing it from the outside to find vulnerabilities during operation. [Burp Suite](https://portswigger.net/burp) and [Zed Attack Proxy (ZAP)](https://www.zaproxy.org) are popular examples of DAST tools. 

* **Interactive Application Security Testing (IAST):** This method combines aspects of both SAST and DAST by using agents inside the running application to identify vulnerabilities in real time, often providing more context and accuracy than SAST or DAST alone. [Seeker](https://www.blackduck.com/interactive-application-security-testing.html) and [Invicti](https://www.invicti.com/learn/interactive-application-security-testing-iast) are popular examples of IAST tools. 

* **Software Composition Analysis (SCA):** SCA tools identify vulnerabilities and risks within the third-party and open-source components used in a project. [Veracode](https://www.veracode.com/products/software-composition-analysis) and [Checkmarx](https://checkmarx.com/cxsca-open-source-scanning) offer popular SCA tools. 

You can also use [Mozilla Observatory](https://developer.mozilla.org/en-US/observatory) to check your HTTP security.


## Cross-Site Request Forgery Protection (CSRF), SQL injections

Most modern web and mobile frameworks handle both CSRF protection and SQL injections. Ensure CSRF protection is enabled and that you are using a database ORM instead of running raw SQL based on user input. For example, see what [Ruby on Rails documentation](http://guides.rubyonrails.org/security.html#sql-injection) says about SQL injections.

## Additional Resources

- [OWASP Top Ten](https://owasp.org/www-project-top-ten/): A list of the most critical security risks to web applications.
- [OWASP Top Ten Proactive Controls](https://top10proactive.owasp.org/): A list of security controls that developers can implement to mitigate the risks identified in the OWASP Top Ten.
- [OWASP Cheat Sheet Series](https://cheatsheetseries.owasp.org/): A collection of concise good practice guides for application developers and architects.
- [OWASP Application Security Verification Standard](https://owasp.org/www-project-application-security-verification-standard/): A standard for testing the security of web applications.

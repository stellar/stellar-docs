---
title: Extend a deployed contract's Wasm code TTL
hide_table_of_contents: true
description: Use Stellar CLI to extend contract's Wasm bytecode TTL, with or without local binary.
---


# Guide: Extending a Deployed Contract's Wasm Code TTL

This guide provides a step-by-step approach to extending the Time-to-Live (TTL) of a deployed WebAssembly (Wasm) contract. This includes writing the extension logic, deploying the updated contract, and verifying the changes.

## Prerequisites

1. **Development Environment**:
   - Install Rust and `wasm-pack` for building Wasm contracts.
   - Install necessary blockchain development tools (e.g., Substrate, Polkadot, etc.).
   - Set up a local node or have access to a testnet for deploying and testing the contract.

2. **Tools**:
   - `cargo`: Rust's package manager.
   - `wasm-pack`: Tool for building and publishing Wasm packages.
   - Blockchain-specific CLI tools for deployment and interaction.

## Step-by-Step Guide

### 1. Define the Contract Structure

First, create a new Rust project for your Wasm contract if you don’t have one:

```sh
cargo new my_contract
cd my_contract
```

Add the required dependencies in `Cargo.toml`:

```toml
[dependencies]
# Add dependencies like ink!, substrate, etc., as required
```

### 2. Implement the Contract Logic

In this section, we'll implement the logic for our contract, including the functionality to extend the TTL.

#### Code Walkthrough

Here's an example of how the contract might look:

```rust
#![cfg_attr(not(feature = "std"), no_std)]

use ink_lang as ink;

#[ink::contract]
mod my_contract {
    #[ink(storage)]
    pub struct MyContract {
        ttl: u64,
        code: Vec<u8>,
        owner: AccountId,
    }

    impl MyContract {
        #[ink(constructor)]
        pub fn new(initial_ttl: u64) -> Self {
            let caller = Self::env().caller();
            Self {
                ttl: initial_ttl,
                code: Vec::new(),
                owner: caller,
            }
        }

        #[ink(message)]
        pub fn extend_ttl(&mut self, extra_time: u64) -> Result<(), &'static str> {
            let caller = self.env().caller();
            if caller != self.owner {
                return Err("Only the owner can extend the TTL");
            }
            self.ttl += extra_time;
            Ok(())
        }

        #[ink(message)]
        pub fn get_ttl(&self) -> u64 {
            self.ttl
        }

        #[ink(message)]
        pub fn update_code(&mut self, new_code: Vec<u8>) -> Result<(), &'static str> {
            let caller = self.env().caller();
            if caller != self.owner {
                return Err("Only the owner can update the code");
            }
            self.code = new_code;
            Ok(())
        }
    }
}
```

#### Explanation

1. **Contract Definition**: The `MyContract` struct defines the state of the contract, including `ttl` (Time-to-Live), `code` (Wasm code), and `owner` (the account that deployed the contract).

2. **Constructor**: The `new` function is the constructor, initializing the contract with an initial TTL and setting the caller as the owner.

3. **Extend TTL**: The `extend_ttl` function allows the owner to extend the contract's TTL by a specified amount of time. It checks if the caller is the owner before proceeding.

4. **Get TTL**: The `get_ttl` function returns the current TTL of the contract.

5. **Update Code**: The `update_code` function allows the owner to update the Wasm code. It checks if the caller is the owner before updating the code.

### 3. Build the Contract

Next, build the contract to generate the Wasm binary:

```sh
cargo +nightly contract build
```

### 4. Deploy the Contract

Deploy the contract to the blockchain. This process depends on the specific blockchain you are using. Here’s a generic example:

```sh
# Use the CLI tool provided by your blockchain framework
substrate-contract deploy --wasm target/wasm32-unknown-unknown/release/my_contract.wasm --constructor "new" --args <initial_ttl>
```

### 5. Interact with the Contract

Use the CLI or UI tools provided by the blockchain to interact with your deployed contract. For instance, you can extend the TTL and update the code:

```sh
# Extend the TTL
substrate-contract call --contract <contract_address> --message "extend_ttl" --args <extra_time>

# Update the code
substrate-contract call --contract <contract_address> --message "update_code" --args <new_code>
```

### 6. Verify the Changes

Verify that the TTL has been extended and the code has been updated correctly by calling the respective getter functions:

```sh
# Get the current TTL
substrate-contract call --contract <contract_address> --message "get_ttl"
```

## Conclusion

By following this guide, you can extend the TTL of a deployed Wasm contract and update its code. Ensure you thoroughly test the contract on a testnet before deploying it to a mainnet. Adjust the contract logic and deployment steps according to the specific blockchain platform you are using.



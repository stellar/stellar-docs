---
title: "Muxed accounts and pooled accounts"
description: Use muxed accounts to differentiate between individual accounts in a pooled account.
sidebar_position: 60
---

import { CodeExample } from "@site/src/components/CodeExample";

When building an application or service on Stellar, one of the first things you have to decide is how to handle user accounts.

You can create a Stellar account for each user, but most custodial services, including cryptocurrency exchanges, choose to use a single pooled Stellar account to handle transactions on behalf of their users. In these cases, the muxed account feature can map transactions to individual accounts via an internal customer database.

:::note

Historically, many services used memos to distinguish users, e.g., “send to this G-address with this memo.” In the long term, muxed accounts are preferable: they reduce user error, make UX more consistent, and integrate cleanly with SDKs and smart contracts. However, not all wallets, exchanges, and anchors support muxed accounts yet, so you may want to support both memos and muxed accounts during a transition period.

:::

## Pooled accounts

A pooled account allows a single Stellar account ID to be shared across many users. Services that use pooled accounts track customers in a separate, internal database and use muxed accounts to map incoming and outgoing payments to the corresponding internal customer.

The benefits of a pooled account are:

- Lower costs – no base reserve is required per end user.
- Simpler key management – you only manage one account keypair (or a small set of custodian keys).

The trade-off is that you assume responsibility for:

- Tracking all individual customer balances.
- Handling errors, atomicity, and refunds in your own systems.
- Detecting and preventing misuse or fraud at the application layer.

## Muxed accounts

Muxed accounts (“multiplexed accounts”) are embedded into the protocol for convenience and standardization. They distinguish individual logical accounts that all exist under a single, traditional Stellar account. A muxed account combines a familiar `GABC…` account address with a 64-bit integer ID.

- Virtual only: muxed accounts themselves do not exist on the ledger; only the shared underlying `GABC…` account does.
- Spec: muxed accounts are defined in [CAP-0027: First-class multiplexed accounts](https://stellar.org/protocol/cap-27) and their string representation in [SEP-23: Strkeys](https://stellar.org/protocol/sep-23).

It is safe for all wallets and services to implement sending to muxed accounts. If you wish to receive deposits to muxed accounts, remember that not every wallet or exchange supports them yet, so you may need to support both memos and M-addresses during migration.

### Why exchanges and custodians use muxed accounts

Most exchanges historically used the **pooled account + memo** model: all users deposit and withdraw from a single `G...` address, and the service tracks individual balances off-chain. A memo (often a numeric ID) tells the exchange which internal user to credit.

This model works, but has well-known problems:

- Users forget to include the memo.
- Users reuse another user’s memo or type it incorrectly.
- Support teams must manually reconcile “missing memo” deposits.

Muxed accounts solve this by embedding a distinct numeric ID directly into the address:

- Each user gets a unique M-address (muxed account) that still resolves to the same pooled `G...` address.
- Payments to a user’s M-address deterministically map to a single internal customer row.
- No memo is required, so deposits and withdrawals become memo-less and less error-prone.

Benefits for exchanges and custodians:

- Greatly reduces user error, missed memos, and support tickets.
- Provides a standardized interface for wallets, custodians, and smart contract flows.
- Cleanly extends to smart contract token transfers as multiplexing becomes standard in contracts.

### Address format

Muxed accounts have their own address format that starts with an `M` prefix. For example, from a traditional Stellar account address:

```text
GA7QYNF7SOWQ3GLR2BGMZEHXAVIRZA4KVWLTJJFC7MGXUA74P7UJVSGZ
```

you can derive multiple muxed accounts with different IDs:

- `MA7QYNF7SOWQ3GLR2BGMZEHXAVIRZA4KVWLTJJFC7MGXUA74P7UJUAAAAAAAAAAAACJUQ` has ID 0
- `MA7QYNF7SOWQ3GLR2BGMZEHXAVIRZA4KVWLTJJFC7MGXUA74P7UJUAAAAAAAAAABUTGI4` has ID 420

Some useful properties:

- M-addresses are longer than G-addresses (69 characters vs. 56).
- You can always parse a muxed address to recover:
  - the underlying `G...` address, and
  - the 64-bit integer ID.
- M-addresses are a client-side representation:
  - All operations ultimately act on the underlying `G...` account.
  - Authorization and signing always use the base account; muxed accounts don’t have their own secret keys.

Both example M-addresses above act on the same underlying `GA7Q…` account when used with supported operations.

### Supported operations

Not all operations accept muxed accounts, but they can be used for:

- The source account of any operation or transaction.
- The fee source of a fee-bump transaction.
- The destination of the three payment operations:
  - `Payment`
  - `PathPaymentStrictSend`
  - `PathPaymentStrictReceive`
- The destination of an `AccountMerge`.
- The target (`from` field) of a `Clawback` operation.

In practice, for exchanges and custodial services this covers:

- User deposits into a pooled account (M → G).
- User withdrawals from the pooled account (G or M → external G or M).
- Internal transfers between customers on the same pooled account (M → M).
- Clawing back assets from a muxed customer balance (where the asset is clawback-enabled).

There is no validation on the ID at the protocol level. As far as the Stellar network is concerned, all supported operations behave exactly as if you had not used a muxed account; the ID is for your off-chain bookkeeping.

### Migrating from memos to muxed accounts

Memos are still widely supported and will continue to exist at the protocol level for classic transactions, but exchanges are strongly encouraged to migrate toward muxed accounts, especially for new integrations and for smart contract-based token flows where multiplexing is first-class.

A practical migration strategy:

1. Accept both memos and M-addresses for deposits

- Allow incoming deposits to:
  - your existing `G...` deposit address with a memo or
  - a user-specific `M...` address.
- Map both to the same internal customer record.

2. Support withdrawals to `G...` and `M...`

- When a user withdraws, allow:
  - a raw `G...` address (optionally with a memo for legacy recipients), or
  - a muxed `M...` address where no memo is needed.
- Many wallets and platforms now display or require M-addresses for custodial flows.

3. Update validation code

- If you currently validate addresses as “must start with `G`”, update that logic to support both `G` and `M` strkeys.
- All actively maintained Stellar SDKs (JavaScript, Go, Python, Java, Elixir, etc.) support muxed accounts out of the box, including utilities to decode/encode between `G` and `M` forms.

4. Phase down memo usage

- Continue supporting memos only for external platforms that have not yet implemented muxed accounts.
- Encourage power users and institutional clients to switch to M-addresses to reduce support friction.

### SDK integrations

All official SDKs expose helpers for creating, parsing, and using muxed accounts. Here are a couple of minimal examples.

#### JavaScript SDK:

```js
import * as sdk from "@stellar/stellar-sdk";

const server = new sdk.rpc.Server("https://soroban-testnet.stellar.org");
const custodianGAddress = "GA..."; // pooled account

// Load the underlying account once so we have its sequence number
const custodianAccount = await server.getAccount(custodianGAddress);

// Create a muxed account for customer ID "12345"
const customerId = "12345"; // stringified uint64
const muxed = new sdk.MuxedAccount(custodianAccount, customerId);

console.log(muxed.accountId()); // prints an M-address like "MA7QY..."
```

Parsing an existing muxed address:

```js
const mAddress = muxed.accountId();

// You need the base account's current sequence number to parse it
const sequenceNum = custodianAccount.sequenceNumber();
const parsed = sdk.MuxedAccount.fromAddress(mAddress, sequenceNum);

console.log(parsed.baseAccount().accountId()); // underlying G-address
console.log(parsed.id()); // "12345"
```

The same `MuxedAccount` object can be passed anywhere an account source or destination is expected when building transactions with `TransactionBuilder`.

#### Elixir SDK:

```elixir
# pooled G-address
g_address = "GA..."

# create a muxed account for internal ID 12345
m_address = StellarSdk.Account.create_muxed(g_address, 12345)

# build an Account struct from an M- or G-address
account = StellarSdk.Account.new(m_address)
```

The Elixir SDK takes care of encoding/decoding the ID portion as you build operations and transactions.

### Payments workflow for exchanges

When combining pooled accounts with muxed accounts, the typical exchange workflow looks like this:

#### Receiving deposits

- Generate a unique M-address per user (or per sub-account).
- Display this M-address to the user in your UI.
- When a deposit arrives:
  - The on-chain balance increases for the pooled `G...` account.
  - Your off-chain system decodes the muxed ID and credits the correct customer balance.

No memo is required, and you can use the same pooled account for many customers and assets.

#### Sending withdrawals

- Allow users to withdraw to either:
  - a regular `G...` address (optionally with a memo if the recipient is using the legacy model), or
  - a muxed `M...` address.
- If the destination is muxed, your system:
  - parses the ID,
  - uses the underlying `G...` address as the destination in the transaction,
  - and records the muxed ID in your internal ledger or events.

#### Tracking balances and activity

- Always load and display on-chain balances using the base `G...` account.
- When listing transactions internally, map:
  - any source or destination M-address back to the associated internal customer record, and/or
  - log the muxed ID in your own events or analytics pipeline.

#### Common patterns

- Standard payment (G → G): Deposit from an external wallet to your exchange’s pooled account (legacy pattern).

- Muxed-to-unmuxed (M → G): Withdrawal from a specific exchange customer to an external wallet, without any memo.

- Muxed-to-muxed (M → M): Internal transfer between two exchange customers that share the same pooled account. On-chain, this looks like the account sending funds to itself; only fees change. You may want to recognize and aggregate such transfers to avoid unnecessary on-chain churn.

### Muxed accounts in smart contracts

Stellar extends multiplexing into the smart contract world so that token transfers and contract calls can carry the same “virtual account” semantics that exchanges use today.

Key points:

- The Rust `soroban-sdk` exposes a `MuxedAddress` type:
  - It represents either a regular `Address` or a multiplexed address (`Address + u64 id`).
  - The `address()` method returns the underlying `Address` used for authorization and storage.
  - The `id()` method returns the optional muxed ID, which is typically used only in events so indexers and off-chain systems can distinguish virtual sub-accounts.

- `MuxedAddress` is interface-compatible with `Address`:
  - If a contract accepts `MuxedAddress`, callers can still pass a plain `Address` without breaking.
  - This lets contracts upgrade from `Address` to `MuxedAddress` without disrupting existing clients.
- Only regular Stellar accounts can be multiplexed; multiplexed contract addresses do not exist.
- Client SDKs (such as the JavaScript `Address` class) understand muxed forms:
  - `new Address("M...")` can represent a muxed account as a contract argument.
  - Under the hood, SDKs convert M-addresses into appropriate XDR types (`ScAddress`, etc.) when invoking contracts.

Typical smart contract use cases:

| Contract Function | Muxed Support | SDK Usage Example                 |
| ----------------- | ------------- | --------------------------------- |
| Payment/Transfer  | Yes           | Pass M-address as destination     |
| Path Payment      | Yes           | Use M-address for route endpoints |
| Account Merge     | Yes           | Merge to M-address for refunds    |
| Asset Clawback    | Yes           | Set M-address as clawback target  |

For most contracts you can continue to use `Address` everywhere. Reach for `MuxedAddress` only when you specifically need to model virtual users under a pooled account (for example, exchange token deposits and withdrawals).

Read more about muxed accounts as they relate to smart contracts in GitHub: [CAP-0067: Unified Asset Events](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0067.md#multiplexing-support).

## Examples

The following examples demonstrate how muxed accounts work in practice, showing three common payment scenarios:

1. A standard account-to-account payment (G → G)
2. A muxed-to-unmuxed payment (M → G)
3. A muxed-to-muxed payment between two customers of the same pooled account (M → M)

:::note

The examples here are described conceptually; the actual JavaScript implementation on the docs site uses Stellar RPC and`@stellar/stellar-sdk` to construct and submit real transactions. You can keep the existing code sample and simply update the surrounding explanation with the concepts from this page.

:::

### Example 1 – Basic payment (G → G)

This example establishes baseline behavior with a standard payment between two regular Stellar accounts. Both accounts exist directly on the ledger, demonstrating traditional Stellar payment flow without muxed account abstractions. The custodian account balance decreases by the payment amount plus transaction fees; the recipient increases by the payment amount.

### Example 2 – Muxed to unmuxed payment (M → G)

This example demonstrates a payment from a muxed account (representing a custodial customer) to a regular Stellar account:

- The underlying pooled custodian account is the actual source on chain.
- The transaction includes the muxed source so your off-chain system knows which user initiated it.
- The transaction is signed with the custodian keys, since muxed accounts have no secret keys.
- The custodian balance decreases by the payment amount plus fees.

### Example 3 – Muxed to muxed payment (M → M)

When two muxed accounts share the same underlying pooled account:

- On-chain, the account is effectively sending assets to itself.
- The net asset balance doesn’t change (the debit and credit cancel out).
- You still pay transaction fees, since the payment is recorded on the ledger.

In practice, these “internal transfers” are often better handled purely off-chain, or batched, to avoid unnecessary fees and ledger noise.

## FAQs

**1. Are M-addresses backwards compatible?**

Yes. An M-address is just another strkey encoding of the same underlying `G...` account plus a 64-bit ID. Services that don’t yet understand muxed accounts can still operate on the underlying `G...` account; they just won’t make use of the ID. During migration, exchanges should support both:

- incoming deposits to `G...` + memo, and
- incoming deposits to `M...` (muxed) addresses.

**2. Do customers have secret keys for muxed accounts?**

No. The secret key belongs to the underlying `G...` account. Muxed accounts are purely virtual views over that on-chain account.

For custodial exchanges, this matches the usual model: the exchange signs transactions on behalf of users; users control their balances via the exchange’s application, not on-chain keys.

**3. How do I troubleshoot errors or unsupported muxed accounts?**

If you encounter errors like “destination is invalid” or `op_malformed` when using an `M...` destination, it usually means muxed accounts aren’t fully supported somewhere in your stack.

Try the following:

- Upgrade your tooling: Make sure you’re on a recent version of your Stellar SDKs and Horizon/RPC client. In some SDKs, muxed accounts were initially hidden behind a feature flag; newer versions enable them by default.

- Check for muxing feature flags / options: If your SDK mentions “enable muxing” (for example, the JavaScript SDK’s

```text
“destination is invalid; did you forget to enable muxing?”
message), enable that option or upgrade to a version where it’s no longer required.
```

- Validate both `G...` and `M...` prefixes: Ensure your own validation logic allows both regular (`G...`) and muxed (`M...`) addresses instead of rejecting anything that doesn’t start with `G`.

Decode when necessary: If a remote service doesn’t support muxed accounts, decode the `M...` address into its base `G...` address and, if they require it, include the muxed ID as a memo or internal reference instead.

**4. How do smart contracts interact with muxed accounts?**

For Stellar smart contracts, you generally work with the `Address` type, and optionally `MuxedAddress` in Rust (`soroban-sdk`) or the `Address` helper in the JavaScript SDK:

- Callers can pass either `G...` or `M...` addresses into contract functions.
- The contract can expose `Address` or `MuxedAddress` parameters; SDKs will handle conversions from strkeys to the on-chain representation.
- The muxed ID is usually surfaced in events for off-chain systems, not stored directly in contract state.

This allows you to build smart contracts that integrate cleanly with pooled account exchanges, while keeping the on-chain logic simple and consistent.

**5. How do I handle platforms that don’t support muxed accounts?**

There are two common scenarios when muxed account support is missing.

1. You pay a muxed address, but the recipient doesn’t support muxed accounts

In general, you should avoid sending payments to muxed addresses on platforms that don’t support them, since they won’t be able to provide or interpret `M...` destinations correctly.

If this does happen anyway:

- With an out-of-date SDK, parsing the muxed destination might fail and you’ll see a helpful error (for example,

```text
“destination is invalid; did you forget to enable muxing?”).
Upgrade your SDK.
```

- With an up-to-date SDK, the `M...` address will parse successfully. What happens next is up to your application logic.
- On the network, the operation itself will still succeed: the destination’s underlying `G...` account receives the funds, even if the muxed ID is ignored by the recipient.

2. You want to pay a muxed address, but your platform doesn’t support them

In this case, you should not try to use a muxed address at all:

- Your platform or SDK will likely fail to construct the operation, or reject the address format.
- Instead, fall back to the legacy pattern:
  - use the regular `G...` address, and
  - include an appropriate memo or other reference so the recipient can route the payment internally.

**6. What do I do if I receive a transaction with muxed addresses and a memo ID?**

In an ideal world, this situation would never happen. You can determine whether or not the underlying IDs are equal; if they aren’t, this is a malformed transaction and we recommend not submitting it to the network.

**7. What happens if I pass a muxed address to an incompatible operation?**

Only certain operations allow muxed accounts, as described above. Passing a muxed address to an incompatible parameter with an up-to-date SDK should result in a compilation or runtime error at the time of use.

For example, when using the JavaScript SDK incorrectly:

<CodeExample>

```js
const mAddress =
  "MA7QYNF7SOWQ3GLR2BGMZEHXAVIRZA4KVWLTJJFC7MGXUA74P7UJUAAAAAAAAAABUTGI4";
transactionBuilder.addOperation(
  Operation.setTrustLineFlags({
    trustor: mAddress, // wrong!
    asset: someAsset,
    flags: { clawbackEnabled: false },
  }),
);
```

</CodeExample>

The runtime result would be:

“Error: invalid version byte. expected 48, got 96”

This error message indicates that the `trustor` failed to parse as a Stellar account ID (`G...`). In other words, your code will fail and the invalid operation will never reach the network.

**8. How do I validate Stellar addresses?**

You should use the validation methods provided by your SDK or carefully adhere to [SEP-23](https://stellar.org/protocol/sep-23). For example, the JavaScript SDK provides the following methods for validating Stellar addresses:

```ts
namespace StrKey {
  function isValidEd25519PublicKey(publicKey: string): boolean;
  function isValidMed25519PublicKey(publicKey: string): boolean;
}
```

There are also abstractions for constructing and managing both muxed and regular accounts; consult your SDK documentation for details.

## Code Implementation

_The following code demonstrates all three examples using Stellar RPC. You can run all examples sequentially with `runAllMuxedExamples()` or execute individual examples using their respective functions._

<CodeExample>

```js
import * as sdk from "@stellar/stellar-sdk";

const server = new sdk.rpc.Server("https://soroban-testnet.stellar.org");

const custodian = sdk.Keypair.random();
const outsider = sdk.Keypair.random();

let custodianAcc, outsiderAcc, customers;

// Setup function to fund accounts and create muxed customers
async function preamble() {
  console.log("=== FUNDING ACCOUNTS WITH XLM ===");
  await Promise.all([
    server.requestAirdrop(custodian.publicKey()),
    server.requestAirdrop(outsider.publicKey()),
  ]);
  console.log("All accounts funded with XLM via airdrop");

  [custodianAcc, outsiderAcc] = await Promise.all([
    server.getAccount(custodian.publicKey()),
    server.getAccount(outsider.publicKey()),
  ]);

  customers = ["1", "22", "333", "4444"].map(
    (id) => new sdk.MuxedAccount(custodianAcc, id),
  );

  console.log("\n=== ACCOUNT SETUP ===");
  console.log("Custodian:\n       ", custodian.publicKey());
  console.log("Outsider:\n       ", outsider.publicKey());
  console.log("Customers:");
  customers.forEach((customer) => {
    console.log(
      " " + customer.id().padStart(4, " ") + ":",
      customer.accountId(),
    );
  });
}

// Example 1: Basic payment between two G accounts
async function runUnmuxedExample() {
  console.log("=== BASIC PAYMENT EXAMPLE (G → G) ===");

  console.log("=== INITIAL BALANCES ===");
  await showBalance(custodianAcc);
  await showBalance(outsiderAcc);

  await makePayment(
    custodianAcc,
    outsiderAcc,
    "Basic Payment from G to G address",
  );

  console.log("\n=== FINAL BALANCES ===");
  const finalCustodianAcc = await server.getAccount(custodian.publicKey());
  const finalOutsiderAcc = await server.getAccount(outsider.publicKey());
  await showBalance(finalCustodianAcc);
  await showBalance(finalOutsiderAcc);

  console.log("\n=== BASIC PAYMENT EXAMPLE COMPLETED ===");
}

// Example 2: Payment from M account to G account
async function runMuxedToUnmuxedExample() {
  console.log("=== MUXED TO UNMUXED PAYMENT EXAMPLE (M → G) ===");

  console.log("=== INITIAL BALANCES ===");
  await showBalance(custodianAcc);
  await showBalance(outsiderAcc);
  const src = customers[0];
  console.log(
    `Sending 10 XLM from Customer ${src.id()} to ${formatAccount(
      outsiderAcc.accountId(),
    )}.`,
  );

  await makePayment(src, outsiderAcc, "Payment from M to G address");

  console.log("\n=== FINAL BALANCES ===");
  const finalCustodianAcc = await server.getAccount(custodian.publicKey());
  const finalOutsiderAcc = await server.getAccount(outsider.publicKey());
  await showBalance(finalCustodianAcc);
  await showBalance(finalOutsiderAcc);

  console.log("\n=== MUXED TO UNMUXED EXAMPLE COMPLETED ===");
}

// Example 3: Payment between two M accounts
async function runMuxedToMuxedExample() {
  console.log("=== MUXED TO MUXED PAYMENT EXAMPLE (M → M) ===");

  console.log("=== INITIAL BALANCES ===");
  await showBalance(custodianAcc);

  const src = customers[1]; // Customer 22
  const dest = customers[2]; // Customer 333

  console.log(
    `Sending 10 XLM from Customer ${src.id()} to Customer ${dest.id()}.`,
  );

  await makePayment(src, dest, "Payment from M to M address");

  console.log("\n=== FINAL BALANCES ===");
  const finalCustodianAcc = await server.getAccount(custodian.publicKey());
  await showBalance(finalCustodianAcc);

  console.log("\n=== MUXED TO MUXED EXAMPLE COMPLETED ===");
}

// Main function that runs preamble once and then all three examples
async function runAllMuxedExamples() {
  try {
    // Run setup/funding only once
    await preamble();

    // Show initial state
    console.log("=== OVERALL INITIAL BALANCES ===");
    await showBalance(custodianAcc);
    await showBalance(outsiderAcc);
    console.log("\n" + "=".repeat(60) + "\n");

    // Run all three examples sequentially
    await runUnmuxedExample();
    console.log("\n" + "=".repeat(60) + "\n");

    await runMuxedToUnmuxedExample();
    console.log("\n" + "=".repeat(60) + "\n");

    await runMuxedToMuxedExample();

    console.log("\n=== ALL MUXED ACCOUNT EXAMPLES COMPLETED ===");
  } catch (error) {
    console.error("Error in examples:", error.message);
  }
}

// Helper function to format account ID with label
function formatAccount(accountId) {
  const shortId = accountId.substring(0, 8);
  if (accountId === custodian.publicKey()) {
    return `${shortId} (Custodian)`;
  } else if (accountId === outsider.publicKey()) {
    return `${shortId} (Outsider)`;
  }

  // Check if it's a muxed account by finding the matching customer
  const matchingCustomer = customers?.find(
    (customer) => customer.accountId() === accountId,
  );
  if (matchingCustomer) {
    return `${accountId.substring(0, 8)}...${accountId.slice(
      -6,
    )} (Customer ${matchingCustomer.id()})`;
  }
  return shortId;
}

function scaleAsset(x) {
  return Number(x) / 10000000; // Preserves decimal precision
}

// Helper function to get XLM balance using RPC
function getXLMBalance(accountId) {
  return server
    .getAccountEntry(accountId)
    .then((accountEntry) => {
      return scaleAsset(accountEntry.balance().toBigInt()).toFixed(7);
    })
    .catch(() => "0");
}

// Helper function to submit transaction and poll for completion using RPC
function submitAndPollTransaction(transaction, description = "Transaction") {
  return server.sendTransaction(transaction).then((submitResponse) => {
    if (submitResponse.status !== "PENDING") {
      throw new Error(
        `Transaction submission failed: ${submitResponse.status}`,
      );
    }

    console.log(`${description} submitted: ${submitResponse.hash}`);

    return server.pollTransaction(submitResponse.hash).then((finalResponse) => {
      if (finalResponse.status === "SUCCESS") {
        console.log(`${description} completed successfully`);
        return {
          hash: submitResponse.hash,
          status: finalResponse.status,
          resultXdr: finalResponse.resultXdr,
        };
      } else {
        throw new Error(`${description} failed: ${finalResponse.status}`);
      }
    });
  });
}

function buildTx(source, signer, ops) {
  var tx = new sdk.TransactionBuilder(source, {
    fee: sdk.BASE_FEE,
    networkPassphrase: sdk.Networks.TESTNET,
  });

  ops.forEach((op) => tx.addOperation(op));
  tx = tx.setTimeout(30).build();
  tx.sign(signer);
  return tx;
}

// Helper function to load account, handling muxed accounts
function loadAccount(account) {
  if (sdk.StrKey.isValidMed25519PublicKey(account.accountId())) {
    return loadAccount(account.baseAccount());
  } else {
    return server.getAccount(account.accountId());
  }
}

// Helper function to display balance of an account
async function showBalance(acc) {
  const balance = await getXLMBalance(acc.accountId());
  console.log(`${formatAccount(acc.accountId())}: ${balance} XLM`);
}

// Function to make a payment from source to destination account
async function makePayment(source, dest, description = "Payment") {
  console.log(
    `\nPayment: ${formatAccount(source.accountId())} → ${formatAccount(
      dest.accountId(),
    )} (10 XLM)`,
  );

  const accountBeforePayment = await loadAccount(source);
  console.log("Before payment:");
  await showBalance(accountBeforePayment);

  let payment = sdk.Operation.payment({
    source: source.accountId(),
    destination: dest.accountId(),
    asset: sdk.Asset.native(),
    amount: "10",
  });

  let tx = buildTx(accountBeforePayment, custodian, [payment]);

  await submitAndPollTransaction(tx, description);

  const accountAfterPayment = await loadAccount(source);
  console.log("After payment:");
  await showBalance(accountAfterPayment);
}

// Run the main function
runAllMuxedExamples();
```

</CodeExample>

### Running the examples

- **All Examples**: `runAllMuxedExamples()` - Runs setup once and executes all three examples
- **Individual Examples**:
  - `runUnmuxedExample()` - Basic G→G payment
  - `runMuxedToUnmuxedExample()` - Muxed→Unmuxed payment
  - `runMuxedToMuxedExample()` - Muxed→Muxed payment

:::note

When running individual examples, ensure you call `preamble()` first to set up and fund the accounts.

:::

### More examples

As is the case for most protocol-level features, you can find more usage examples and inspiration in the relevant test suite for your favorite SDK. For example, [here](https://github.com/stellar/js-stellar-base/blob/master/test/unit/muxed_account_test.js) are some of the JavaScript test cases.

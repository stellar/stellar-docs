---
title: Claimable Balances
description: Split a payment into two parts by creating a claimable balance.
sidebar_position: 20
---

import { CodeExample } from "@site/src/components/CodeExample";
import Details from "@theme/Details";

Claimable balances were introduced in [CAP-0023](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0023.md) and are used to split a payment into two parts.

- Part 1: sending account creates a payment, or ClaimableBalanceEntry, using the Create Claimable Balance operation
- Part 2: destination account(s), or claimant(s), accepts the ClaimableBalanceEntry using the Claim Claimable Balance operation

Claimable balances allow an account to send a payment to another account that is not necessarily prepared to receive the payment. They can be used when you send a non-native asset to an account that has not yet established a trustline, which is useful for anchors onboarding new users. A trustline must be established by the claimant to the asset before it can claim the claimable balance, otherwise, the claim will result in an `op_no_trust` error.

It is important to note that if a claimable balance isn’t claimed, it sits on the ledger forever, taking up space and ultimately making the network less efficient. **For this reason, it is a good idea to put one of your own accounts as a claimant for a claimable balance.** Then you can accept your own claimable balance if needed, freeing up space on the network.

Each ClaimableBalanceEntry is a ledger entry, and each claimant in that entry increases the source account’s minimum balance by one base reserve.

Once a ClaimableBalanceEntry has been claimed, it is deleted.

## Operations

### Create Claimable Balance

For basic parameters, see the Create Claimable Balance entry in our [List of Operations section](../../../learn/fundamentals/transactions/list-of-operations.mdx#create-claimable-balance).

#### Additional parameters

- **`Claim_Predicate_` Claimant**: an object that holds both the destination account that can claim the `ClaimableBalanceEntry` and a `ClaimPredicate` that must evaluate to true for the claim to succeed.

- **`ClaimPredicate`**: a recursive data structure that can be used to construct complex conditionals using different `ClaimPredicateTypes`. Below are some examples with the `Claim_Predicate_` prefix removed for readability. Note that the SDKs expect the Unix timestamps to be expressed in seconds.

  - `UNCONDITIONAL`: Can claim at any time.
  - `BEFORE_RELATIVE_TIME(X)`: Can claim if the close time of the ledger including the claim is before X seconds, plus the ledger close time in which the `ClaimableBalanceEntry` was created.
    - `NOT( BEFORE_RELATIVE_TIME(X) )`: Can claim if the close time of the ledger including the claim is at or after X seconds, plus the ledger close time in which the ClaimableBalanceEntry was created.
  - `BEFORE_ABSOLUTE_TIME(X)`: Can claim if the close time of the ledger including the claim is before X (Unix timestamp).
    - `NOT( BEFORE_ABSOLUTE_TIME(X) )`: Can claim if the close time of the ledger, including the claim is at or after X (Unix timestamp).
  - Can claim between X and Y Unix timestamps (given X < Y) - `AND(NOT(BEFORE_ABSOLUTE_TIME(X))`, `BEFORE_ABSOLUTE_TIME(Y))`

- `OR( BEFORE_ABSOLUTE_TIME(X)`, `NOT( BEFORE_ABSOLUTE_TIME(Y) ) )`: Can claim outside X and Y Unix timestamps (given X < Y).

- `ClaimableBalanceID` ClaimableBalanceID is a union with one possible type (`CLAIMABLE_BALANCE_ID_TYPE_V0`). It contains an SHA-256 hash of the [OperationID](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0023.md#user-content-fn-id-arithmatic-d2727bb47f78787e54824bc772d9861c) for Claimable Balances.

- `ClientBalanceID`: Hex of `ClaimableBalanceID` returned after a successful `CreateClaimableBalance` operation. It is required when claiming the `ClaimableBalanceEntry` with the `ClaimClaimableBalance` operation.

### Claim Claimable Balance

For basic parameters, see the Claim Claimable Balance entry in our [List of Operations section](../../../learn/fundamentals/transactions/list-of-operations#claim-claimable-balance).

This operation will load the `ClaimableBalanceEntry` that corresponds to the `ClientBalanceID` and then search for the source account of this operation in the list of claimants on the entry. If a match on the claimant is found, and the ClaimPredicate evaluates to true, then the ClaimableBalanceEntry can be claimed. The balance on the entry will be moved to the source account if there are no limit or trustline issues (for non-native assets), meaning the claimant must establish a trustline to the asset before claiming it.

### Clawback Claimable Balance

This operation claws back a claimable balance, returning the asset to the issuer account, burning it. You must claw back the entire claimable balance, not just part of it. Once a claimable balance has been claimed, use the regular clawback operation to claw it back.

Clawback claimable balances require the client balance ID.

Learn more about clawbacks in our [Clawback Guide](./clawbacks.mdx).

## Example

The below code demonstrates how an account (Account $\mathcal{A}$) creates a ClaimableBalanceEntry with two claimants: $\mathcal{A}$ (itself) and Account $\mathcal{B}$ (another recipient).

### Setup

Each of these accounts can only claim the balance under unique conditions. $\mathcal{B}$ has a full minute to claim the balance before $\mathcal{A}$ can reclaim the balance back for itself.

:::note Claimant Permanence

[Currently](https://github.com/stellar/stellar-protocol/discussions/1504#discussioncomment-10117060), you cannot recover a claimable balance if none of the predicates can be fulfilled. The reclaim example below acts as a safety net for this situation.

:::

<Details summary="Click here to see helper functions">

<CodeExample>

```go
func fundAccount(rpcClient *client.Client, address string) error {
	ctx := context.Background()

	// Use GetNetwork method from client
	networkResp, err := rpcClient.GetNetwork(ctx)
	if err != nil {
		return err
	}

	if networkResp.FriendbotURL != "" {
		friendbotURL := networkResp.FriendbotURL + "?addr=" + url.QueryEscape(address)
		resp, err := http.Post(friendbotURL, "application/x-www-form-urlencoded", nil)
		if err != nil {
			return err
		}
		defer resp.Body.Close()

		if resp.StatusCode != 200 {
			return fmt.Errorf("friendbot failed with status: %d", resp.StatusCode)
		}
		return nil
	}

	return fmt.Errorf("friendbot not configured for network - %s", networkResp.Passphrase)
}

func panicIf(err error) {
	if err != nil {
		log.Fatal(err)
	}
}
```

</CodeExample>

</Details>

<CodeExample>

```python
import time
from stellar_sdk.xdr import TransactionResult, OperationType
from stellar_sdk.exceptions import NotFoundError, BadResponseError, BadRequestError
from stellar_sdk import (
    Keypair,
    Network,
    Server,
    TransactionBuilder,
    Transaction,
    Asset,
    Operation,
    Claimant,
    ClaimPredicate,
    CreateClaimableBalance,
    ClaimClaimableBalance
)

	var txResult xdr.TransactionResult
	err := xdr.SafeUnmarshalBase64(resp.ResultXDR, &txResult)
	if err != nil {
		return "", err
	}

	if results, ok := txResult.OperationResults(); ok && len(results) > 0 {
		operationResult := results[0].MustTr().CreateClaimableBalanceResult
		return xdr.MarshalHex(operationResult.BalanceId)
	}

try:
  aAccount = server.load_account(A.public_key)
except NotFoundError:
  raise Exception(f"Failed to load account")

# Create a claimable balance with our two above-described conditions.
bCanClaim = ClaimPredicate.predicate_before_relative_time(60)

soon = int(time.time() + 60)
aCanClaim = ClaimPredicate.predicate_not(
  ClaimPredicate.predicate_before_absolute_time(
    soon
  )
)

# Create the operation and submit it in a transaction.
claimableBalanceEntry = CreateClaimableBalance(
  asset = Asset.native(),
  amount = "64",
  claimants = [
    Claimant(
      destination = B.public_key,
      predicate = bCanClaim
    ),
    Claimant(
      destination = A.public_key,
      predicate = aCanClaim
    )
  ]
)

transaction = (
  TransactionBuilder (
    source_account = aAccount,
    network_passphrase = Network.TESTNET_NETWORK_PASSPHRASE,
    base_fee = Network.MIN_BASE_FEE
  )
  .append_operation(claimableBalanceEntry)
  .set_timeout(180)
  .build()
)

transaction.sign(A)
try:
  txResponse = server.submit_transaction(transaction)
  print("Claimable balance created!")
except (BadRequestError, BadResponseError) as err:
  print(f"Tx submission failed: {err}")
```

```js
const sdk = require("stellar-sdk");

async function main() {
  let server = new sdk.Server("https://horizon-testnet.stellar.org");

  let A = sdk.Keypair.fromSecret(
    "SAQLZCQA6AYUXK6JSKVPJ2MZ5K5IIABJOEQIG4RVBHX4PG2KMRKWXCHJ",
  );
  let B = sdk.Keypair.fromPublicKey(
    "GAS4V4O2B7DW5T7IQRPEEVCRXMDZESKISR7DVIGKZQYYV3OSQ5SH5LVP",
  );

  let aAccount;
  try {
    aAccount = await server.loadAccount(A.publicKey());
  } catch (err) {
    console.error(`Failed to load ${A.publicKey()}: ${err}`);
    return;
  }

  // Create a claimable balance with our two above-described conditions.
  let soon = Math.ceil(Date.now() / 1000 + 60); // .now() is in ms
  let bCanClaim = sdk.Claimant.predicateBeforeRelativeTime("60");
  let aCanReclaim = sdk.Claimant.predicateNot(
    sdk.Claimant.predicateBeforeAbsoluteTime(soon.toString()),
  );

  let claimableBalanceEntry = sdk.Operation.createClaimableBalance({
    claimants: [
      new sdk.Claimant(B.publicKey(), bCanClaim),
      new sdk.Claimant(A.publicKey(), aCanReclaim),
    ],
    asset: sdk.Asset.native(),
    amount: "64",
  });

  let tx = new sdk.TransactionBuilder(aAccount, { fee: sdk.BASE_FEE })
    .addOperation(claimableBalanceEntry)
    .setNetworkPassphrase(sdk.Networks.TESTNET)
    .setTimeout(180)
    .build();

  tx.sign(A);

  try {
    let txResponse = await server.submitTransaction(tx);
    console.log("Claimable balance created!");
  } catch (err) {
    console.error(`Tx submission failed: ${err}`);
  }
}

main();
```

```java
import org.stellar.sdk.*;
import org.stellar.sdk.requests.RequestBuilder;
import org.stellar.sdk.responses.AccountResponse;
import org.stellar.sdk.responses.SubmitTransactionResponse;

import java.util.ArrayList;
import java.util.List;

public class StellarClaimableBalance {
  public static void main(String[] args) {
    Network.useTestNetwork();
    Server server = new Server("https://horizon-testnet.stellar.org");

    KeyPair aKeypair = KeyPair.fromSecretSeed(
      "SCZANGBA5YHTNYVVV4C3U252E2B6P6F5T3U6MM63WBSBZATAQI3EBTQ4"
    );
    String bPublicKey = "GA2C5RFPE6GCKMY3US5PAB6UZLKIGSPIUKSLRB6Q723BM2OARMDUYEJ5";

    AccountResponse aAccount;
    try {
      aAccount = server.accounts().account(aKeypair.getAccountId());
    } catch (Exception e) {
      throw new RuntimeException("Failed to load account");
    }

    // Create a claimable balance with our two above-described conditions.
    long soon = System.currentTimeMillis() / 1000L + 60;
    ClaimPredicate bCanClaim = ClaimPredicate.BeforeRelativeTime(60L);
    ClaimPredicate aCanReclaim = ClaimPredicate.Not(
      ClaimPredicate.BeforeAbsoluteTime(soon)
    );

    List<Claimant> claimants = new ArrayList<>();
    claimants.add(new Claimant(bPublicKey, bCanClaim));
    claimants.add(new Claimant(aKeypair.getAccountId(), aCanReclaim));

    CreateClaimableBalanceOperation entryCB = new CreateClaimableBalanceOperation.Builder(
      AssetTypeNative.INSTANCE, "64", claimants
    ).build();

    // Build, sign, and submit the transaction
    Transaction transaction = new Transaction.Builder(aAccount, Network.TESTNET)
      .addOperation(entryCB)
      .setBaseFee(Transaction.MIN_BASE_FEE)
      .setTimeout(180)
      .build();

    transaction.sign(aKeypair);

    try {
      SubmitTransactionResponse response = server.submitTransaction(transaction);
      System.out.println(response);
      System.out.println("Claimable balance created!");
    } catch (Exception e) {
      throw new RuntimeException("Failed to submit transaction");
    }
  }
}
```

```go
package main

import (
  "fmt"
  "time"

  sdk "github.com/stellar/go/clients/horizonclient"
  "github.com/stellar/go/keypair"
  "github.com/stellar/go/network"
  "github.com/stellar/go/txnbuild"
)

func main() {
  client := sdk.DefaultTestNetClient

  aKeys := keypair.MustParseFull(
    "SCZANGBA5YHTNYVVV4C3U252E2B6P6F5T3U6MM63WBSBZATAQI3EBTQ4"
  )
  B := "GA2C5RFPE6GCKMY3US5PAB6UZLKIGSPIUKSLRB6Q723BM2OARMDUYEJ5"

  aAccount, err := client.AccountDetail(
    sdk.AccountRequest{
      AccountID: aKeys.Address(),
    }
  )
  if err != nil {
    panic("Failed to load account A")
  }

  // Create a claimable balance with our two above-described conditions.
  soon := time.Now().Add(time.Second * 60)
  bCanClaim := txnbuild.BeforeRelativeTimePredicate(60)
  aCanReclaim := txnbuild.NotPredicate(
    txnbuild.BeforeAbsoluteTimePredicate(
      soon.Unix()
    )
  )
  claimants := []txnbuild.Claimant{
    txnbuild.NewClaimant(B, bCanClaim),
    txnbuild.NewClaimant(aKeys.Address(), aCanReclaim),
  }

  claimableBalanceEntry := txnbuild.CreateClaimableBalance{
    Destinations: claimants,
    Asset:        txnbuild.NativeAsset{},
    Amount:       "64",
  }

  tx, err := txnbuild.NewTransaction(
    txnbuild.TransactionParams{
      SourceAccount:        aAccount.AccountID,
      IncrementSequenceNum: true,
      BaseFee:              txnbuild.MinBaseFee,
      Timebounds:           txnbuild.NewTimeout(180),
      Operations:           []txnbuild.Operation{&claimableBalanceEntry},
    },
  )
  if err != nil {
    panic("Failed to build transaction")
  }
  tx, err = tx.Sign(network.TestNetworkPassphrase, aKeys)
  if err != nil {
    panic("Failed to sign transaction")
  }
  txResponse, err := client.SubmitTransaction(tx)
  if err != nil {
    panic("Failed to submit transaction")
  }
  fmt.Println("Claimable balance created", txResponse)
}
```

</CodeExample>

### Retrieval

At this point, the `ClaimableBalanceEntry` exists in the ledger, but we’ll need its client balance ID to claim it, which can be done in several ways:

1. The submitter of the entry ($\mathcal{A}$) can retrieve the client balance ID before submitting the transaction;
2. The submitter parses the XDR of the transaction result’s operations; or
3. Someone queries the list of claimable balances.

Either party could also check the [`/effects`](../../../data/apis/horizon/api-reference/resources/effects/README.mdx) of the transaction or query [`/claimable_balances`](../../../data/apis/horizon/api-reference/resources/claimablebalances/README.mdx) with different filters in Horizon. Note that while (1) may be unavailable in some SDKs as it's just a helper, the other methods are universal.

<CodeExample>

```python
# Method 1: Suppose `tx` comes from the transaction built above.
#           Notice that this can be done *before* submission.
#           Use zero for `CreateClaimableBalance` first op.
clientBalanceID = tx.get_claimable_balance_id(0)
print(f"Balance ID (1): {clientBalanceID}")

# Method 2: Suppose `txResponse` comes from the transaction submission
# above.
txResult = TransactionResult.from_xdr(txResponse["result_xdr"])
results = txResult.result.results

# We look at the first result since our first (and only) operation
# in the transaction was the CreateClaimableBalanceOp.
operationResult = results[0].tr.create_claimable_balance_result
clientBalanceID = operationResult.balance_id.to_xdr_bytes().hex()
print(f"Balance ID (2): {clientBalanceID}")

# Method 3: Account B could alternatively do something like:
try:
  balances = (
    server
    .claimable_balances()
    .for_claimant(B.public_key)
    .limit(1)
    .order(desc = True)
    .call()
  )
except (BadRequestError, BadResponseError) as err:
  print(f"Claimable balance retrieval failed: {err}")

clientBalanceID = balances["_embedded"]["records"][0]["id"]
print(f"Balance ID (3): {clientBalanceID}")
```

```js
// Method 1: Suppose `tx` comes from the transaction built above.
//           Notice that this can be done *before* submission.
//           Use zero for `CreateClaimableBalance` first op.
let clientBalanceID = tx.getClaimableBalanceId(0);
console.log("Balance ID (1):", clientBalanceID);

// Replace with your actual Claimable Balance ID
// Format: 72 hex characters (includes ClaimableBalanceId type + hash)
const BALANCE_ID =
  "00000000db1108ff108a807150d02b8672d9a8c0e808bff918cdbe5c7605e63a7f565df5";

// We look at the first result since our first (and only) operation
// in the transaction was the CreateClaimableBalanceOp.
let operationResult = results[0].value().createClaimableBalanceResult();
let clientBalanceID = operationResult.balanceId().toXDR("hex");
console.log("Balance ID (2):", clientBalanceID);

  try {
    console.log(`Looking up balance ID: ${balanceId}`);

    // Parse the claimable balance ID from hex XDR
    const claimableBalanceId = StellarSdk.xdr.ClaimableBalanceId.fromXDR(
      balanceId,
      "hex",
    );

    // Create ledger key for the claimable balance entry
    const ledgerKey = StellarSdk.xdr.LedgerKey.claimableBalance(
      new StellarSdk.xdr.LedgerKeyClaimableBalance({
        balanceId: claimableBalanceId,
      }),
    );

    console.log(`Fetching from RPC server...`);

    // Use SDK's getLedgerEntries method with XDR object array
    const response = await server.getLedgerEntries(ledgerKey);

    if (response.entries && response.entries.length > 0) {
      const claimableBalance = response.entries[0].val.claimableBalance();

      const asset = StellarSdk.Asset.fromOperation(claimableBalance.asset());

      console.log(`Found claimable balance`);
      console.log(`Amount: ${claimableBalance.amount().toString()}`);
      console.log(`Asset: ${asset.toString()} `);
      // Show claimant details
      console.log(`\nClaimants:`);
      claimableBalance.claimants().forEach((claimant, index) => {
        const destination = claimant.v0().destination().ed25519();
        console.log(
          `   ${index + 1}. ${StellarSdk.StrKey.encodeEd25519PublicKey(
            destination,
          )}`,
        );
      });
    } else {
      console.log(`Claimable balance not found`);
    }
  } catch (error) {
    console.error(`Error: ${error.message}`);
  }
}

clientBalanceID = balances.records[0].id;
console.log("Balance ID (3):", clientBalanceID);
```

```java
// Method 1: Suppose `tx` comes from the transaction built above.
//           Notice that this can be done *before* submission.
//           Use zero for `CreateClaimableBalance` first op.
String clientBalanceID = tx.getClaimableBalanceId(0)
System.out.println("Balance ID (1): " + clientBalanceID);

// Method 2: Suppose txResponse comes from the transaction submission above.
String txResponseResultXdr = txResponse.getResultXdr().get();
try {
  TransactionResult txResult = TransactionResult.decode(
    TransactionResult.class,
    Util.fromBase64(
      txResponseResultXdr
    )
    );
  OperationResult operationResult = txResult.getResult().getResults()[0];
  XdrDataInputStream xdrDataInputStream = new XdrDataInputStream(Util.fromBase64(txResponseResultXdr));
  TransactionResult result = TransactionResult.decode(xdrDataInputStream);

  CreateClaimableBalanceResult createClaimableBalanceResult = operationResult.getTr().getCreateClaimableBalanceResult();
  String clientBalanceID = Util.bytesToHex(createClaimableBalanceResult.getBalanceId().toXdrByteArray());
  System.out.println("Balance ID (2): " + clientBalanceID);
} catch (IOException e) {
  e.printStackTrace();
}

// Method 3: Account B could alternatively do something like:
try {
  Page<ClaimableBalanceResponse> balances = server.claimableBalances().forClaimant(
    B.getAccountId()
  ).limit(1).order(RequestBuilder.Order.DESC).execute();
  if (balances.getRecords().size() > 0) {
    String clientBalanceID = balances.getRecords().get(0).getId();
    System.out.println("Balance ID (3): " + clientBalanceID);
  }
} catch (IOException e) {
  System.out.println("Claimable balance retrieval failed: " + e.getMessage());
}
```

```go
// Method 1: Suppose `tx` comes from the transaction built above.
//           Notice that this can be done *before* submission.
//           Use zero for `CreateClaimableBalance` first op.
clientBalanceID, err := tx.ClaimableBalanceID(0)
check(err)
fmt.Println("Balance ID (1):", clientBalanceID)

import (
	"context"
	"fmt"
	"github.com/stellar/stellar-rpc/client"
	"github.com/stellar/stellar-rpc/protocol"

if results, ok := txResult.OperationResults(); ok {
  // We look at the first result since our first (and only) operation in the
  // transaction was the CreateClaimableBalanceOp.
  operationResult := results[0].MustTr().CreateClaimableBalanceResult
  clientBalanceID, err := xdr.MarshalHex(operationResult.BalanceId)
  check(err)
  fmt.Println("Balance ID (2):", clientBalanceID)
}

// Method 3: Account B could alternatively do something like:
balances, err := client.ClaimableBalances(sdk.ClaimableBalanceRequest{Claimant: B})
check(err)
clientBalanceID := balances.Embedded.Records[0].BalanceID
fmt.Println("Balance ID (3):", clientBalanceID)
```

</CodeExample>

### Claiming

With the client balance ID acquired, either $\mathcal{B}$ or $\mathcal{A}$ can actually submit a claim, depending on which predicate is fulfilled. We’ll assume here that a minute has passed, so $\mathcal{A}$ just reclaims the balance entry.

<CodeExample>

```python
tx = (
  TransactionBuilder(
    source_account = aAccount,
    network_passphrase = Network.TESTNET_NETWORK_PASSPHRASE,
    base_fee = server.fetch_base_fee()
  )
  .append_operation(
    ClaimClaimableBalance(
      balance_id = clientBalanceID
    )
  )
  .set_timeout(180)
  .build()
)

tx.sign(A)
try:
  txResponse = server.submit_transaction(tx)
  print(f"{A.public_key} claimed {clientBalanceID}")
except (BadRequestError, BadResponseError) as err:
  print(f"Tx submission failed: {err}")
```

```js
let tx = new sdk.TransactionBuilder(aAccount, { fee: sdk.BASE_FEE })
  .addOperation(
    sdk.Operation.claimClaimableBalance({
      balanceId: clientBalanceID,
    });
  )
  .setNetworkPassphrase(sdk.Networks.TESTNET)
  .setTimeout(180)
  .build();

tx.sign(A);
await server.submitTransaction(tx).catch(function (err) {
  console.error(`Tx submission failed: ${err}`);
});
console.log(A.publicKey(), "claimed", clientBalanceID);
```

```java
Transaction tx = new Transaction.Builder(aAccount, Network.TESTNET)
    .addOperation(
      new ClaimClaimableBalanceOperation.Builder(clientBalanceID).build();
    )
    .setBaseFee(tx.MIN_BASE_FEE)
    .setTimeout(180)
    .build();

tx.sign(A);

try {
    SubmitTransactionResponse response = server.submitTransaction(tx);
    System.out.println(A.getAccountId() + " claimed " + clientBalanceID);
} catch (Exception e) {
    System.err.println("Tx submission failed: " + e.getMessage());
}
```

```go
tx, err = txnbuild.NewTransaction(
    txnbuild.TransactionParams{
        SourceAccount:        &aAccount, // or Account B, depending on the condition!
        IncrementSequenceNum: true,
        BaseFee:              txnbuild.MinBaseFee,
        Timebounds:           txnbuild.NewInfiniteTimeout(),
        Operations:           []txnbuild.Operation{
          &txnbuild.ClaimClaimableBalance{BalanceID: clientBalanceID}
        },
    },
)
check(err)
tx, err = tx.Sign(network.TestNetworkPassphrase, aKeys)
check(err)
txResp, err = client.SubmitTransaction(tx)
check(err)
fmt.Printf("%s claimed %s\n", aKeys.Address(), clientBalanceID)
```

</CodeExample>

And that’s it! Since we opted for the reclaim path, $\mathcal{A}$ should have the same balance as what it started with (minus fees), and $\mathcal{B}$ should be unchanged.

---
title: Create an account
sidebar_position: 5
description: Learn about creating Stellar accounts, keypairs, funding, and account basics.
---

# Create an Account

import { CodeExample } from "@site/src/components/CodeExample";
import { Alert } from "@site/src/components/Alert";

_Before we get started with working with Stellar in code, consider going through the following examples using the [Stellar Lab](https://lab.stellar.org). The lab allows you create accounts, fund accounts on the Stellar test network, build transactions, run any operation, and inspect responses from Horizon via the Endpoint Explorer._

[Accounts](../../../learn/fundamentals/stellar-data-structures/accounts.mdx) are a fundamental building block of Stellar: they hold all your balances, allow you to send and receive payments, and let you place offers to buy and sell assets. Since pretty much everything on Stellar is in some way tied to an account, the first thing you generally need to do when you start developing is create one. This beginner-level tutorial walks through the four building blocks you'll need: generating keys, funding an account, creating another account, and fetching balances.

## Create a Keypair

Stellar uses public key cryptography to secure every transaction: each Stellar account has a keypair consisting of a **public key** and a **secret key**. The public key is always safe to share — other people need it to identify your account and verify that you authorized a transaction. It's like an email address. The secret key, however, is private information that proves you own — and gives you access to — your account. It's like a password, and you should never share it with anyone.

Before creating an account, you need to generate your own keypair:

<CodeExample>

```js
import { Keypair } from "@stellar/stellar-sdk";

// create a completely new and unique pair of keys
// see more about KeyPair objects: https://stellar.github.io/js-stellar-sdk/Keypair.html
const parent = Keypair.random();

console.log("Secret:", parent.secret());
console.log("Public:", parent.publicKey());
```

```java
// create a completely new and unique pair of keys.
// see more about KeyPair objects: https://stellar.github.io/java-stellar-sdk/org/stellar/sdk/KeyPair.html
import org.stellar.sdk.KeyPair;

KeyPair parent = KeyPair.random();
System.out.println("Public: " + parent.getAccountId());
System.out.println("Secret: " + new String(parent.getSecretSeed()));
```

```go
package main

import (
  "log"

  "github.com/stellar/go/keypair"
)

func main() {
  parent, err := keypair.Random()
  check(err)

  log.Printf("Secret: %s", parent.Seed())
  log.Printf("Public: %s", parent.Address())
}
```

```python
# stellar-sdk >= 11.0.0 required
from stellar_sdk import Keypair

parent = Keypair.random()
print(f"Secret: {parent.secret}")
print(f"Public: {parent.public_key}")
```

</CodeExample>

## Fund an Account

A valid keypair alone does not make an account. To prevent unused entries from bloating the ledger, Stellar requires every account to hold a [minimum balance](../../../learn/fundamentals/lumens.mdx#minimum-balance) of 1 XLM before it actually exists. On the public network you'd acquire lumens from an exchange; on the test network you can ask Friendbot — a friendly funding service — to create and fund the account for you. Each SDK below discovers the Friendbot endpoint via `getNetwork`, then issues the funding request.

<CodeExample>

```js
import { Keypair } from "@stellar/stellar-sdk";
import { Server } from "@stellar/stellar-sdk/rpc";

const server = new Server("https://soroban-testnet.stellar.org");

async function main() {
  const parent = Keypair.random();
  console.log("Secret:", parent.secret());
  console.log("Public:", parent.publicKey());

  const body = await server.requestAirdrop(parent.publicKey());
  console.log("SUCCESS! You have a new account:\n", body);
}

main().catch((err) => console.error(err));
```

```java
import java.io.IOException;
import java.net.URI;
import java.net.http.*;
import java.time.Duration;

import org.stellar.sdk.*;
import org.stellar.sdk.requests.sorobanrpc.*;

public final class FundAccount {
  private static final String RPC_URL = "https://soroban-testnet.stellar.org";
  private static final HttpClient HTTP = HttpClient.newBuilder()
      .connectTimeout(Duration.ofSeconds(20))
      .build();
  private static final SorobanServer SERVER = new SorobanServer(RPC_URL);

  public static void main(String[] args) throws Exception {
    KeyPair parent = KeyPair.random();
    log("Secret: %s", new String(parent.getSecretSeed()));
    log("Public: %s", parent.getAccountId());

    GetNetworkResponse networkInfo = SERVER.getNetwork();
    String friendbotUrl = networkInfo != null ? networkInfo.getFriendbotUrl() : null;
    check(friendbotUrl != null && !friendbotUrl.isBlank(), "Friendbot URL not provided by network");
    log("Using %s for friendbot funding", friendbotUrl);

    String response = requestFunds(friendbotUrl, parent.getAccountId());
    log("SUCCESS! You have a new account:\n%s", response);
  }

  private static String requestFunds(String friendbotUrl, String accountId)
      throws IOException, InterruptedException {
    String requestUrl = friendbotUrl + "?addr=" + accountId;

    HttpRequest request = HttpRequest.newBuilder()
        .uri(URI.create(requestUrl))
        .timeout(Duration.ofSeconds(30))
        .GET()
        .build();
    HttpResponse<String> response = HTTP.send(request, HttpResponse.BodyHandlers.ofString());
    check(response.statusCode() / 100 == 2,
        "Friendbot returned " + response.statusCode() + ": " + response.body());
    return response.body();
  }

  private static void check(boolean condition, String message) {
    if (!condition) {
      throw new IllegalStateException(message);
    }
  }

  private static void log(String format, Object... args) {
    System.out.println(String.format(format, args));
  }
}
```

```go
package main

import (
  "context"
  "io"
  "log"
  "net/http"
  "net/url"
  "strings"

  "github.com/stellar/go/keypair"

  "github.com/stellar/stellar-rpc/client"
)

const rpcURL = "https://soroban-testnet.stellar.org"

func main() {
  ctx := context.Background()
  cli := client.NewClient(rpcURL, nil)
  defer cli.Close()

  parent, err := keypair.Random()
  check(err)

  log.Printf("Secret: %s", parent.Seed())
  log.Printf("Public: %s", parent.Address())

  networkInfo, err := cli.GetNetwork(ctx)
  check(err)

  friendbotURL := strings.TrimSpace(networkInfo.FriendbotURL)
  if friendbotURL == "" {
    log.Fatal("friendbot URL not provided by network")
  }
  log.Printf("Using %s for friendbot funding", friendbotURL)

  body := requestAirdrop(friendbotURL, parent.Address())
  log.Printf("SUCCESS! You have a new account:
%s", body)
}

func requestAirdrop(friendbotURL, address string) string {
  resp, err := http.Get(friendbotURL + "?addr=" + url.QueryEscape(address))
  check(err)
  defer resp.Body.Close()

  body, err := io.ReadAll(resp.Body)
  check(err)
  if resp.StatusCode >= 400 {
    log.Fatalf("friendbot returned %s: %s", resp.Status, string(body))
  }

  return string(body)
}

func check(err error) {
  if err != nil {
    log.Fatal(err)
  }
}
```

```python
import requests
from stellar_sdk import *

RPC_URL = "https://soroban-testnet.stellar.org"
SERVER = SorobanServer(RPC_URL)


def get_friendbot_url() -> str:
  response = SERVER.get_network()
  if response.friendbot_url:
    return response.friendbot_url.strip()
  raise RuntimeError("Friendbot URL not provided by network")


def request_funds(friendbot_url: str, account_id: str) -> str:
  request_url = f"{friendbot_url}?addr={account_id}"
  resp = requests.get(request_url, timeout=30)
  if not resp.ok:
    raise RuntimeError(f"Friendbot returned {resp.status_code}: {resp.text}")
  return resp.text


if __name__ == "__main__":
  parent = Keypair.random()
  print(f"Secret: {parent.secret}")
  print(f"Public: {parent.public_key}")

  friendbot_url = get_friendbot_url()
  print(f"Using {friendbot_url} for friendbot funding")

  body = request_funds(friendbot_url, parent.public_key)
  print(f"SUCCESS! You have a new account: {body}")
```

</CodeExample>

## Create an Account

With a funded parent account you can build a transaction that creates another account on the ledger. Each example below performs Friendbot funding (so it can run standalone) and then submits a transaction containing a `CreateAccount` operation.

<CodeExample>

```js
import {
  Asset,
  BASE_FEE,
  Keypair,
  Networks,
  Operation,
  TransactionBuilder,
} from "@stellar/stellar-sdk";
import { Server } from "@stellar/stellar-sdk/rpc";

const server = new Server("https://soroban-testnet.stellar.org");
const testnetUsdc = new Asset(
  "USDC",
  "GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5",
);

async function main() {
  const parent = Keypair.random();
  const response = await server.requestAirdrop(parent.publicKey());
  console.log("SUCCESS! You have a new account:\n", response);

  const parentAccount = await server.getAccount(parent.publicKey());
  const child = Keypair.random();

  const tx = new TransactionBuilder(parentAccount, {
    fee: BASE_FEE,
    networkPassphrase: Networks.TESTNET,
  })
    .addOperation(
      Operation.createAccount({
        destination: child.publicKey(),
        startingBalance: "5",
      }),
    )
    .addOperation(Operation.changeTrust({ asset: testnetUsdc }))
    .setTimeout(180)
    .build();

  tx.sign(parent);

  const sendResp = await server.sendTransaction(tx);
  if (sendResp.status !== "PENDING") {
    throw new Error(`Transaction submission failed: ${sendResp.status}`);
  }

  const txResp = await server.pollTransaction(sendResp.hash);
  if (txResp.status !== "SUCCESS") {
    throw new Error(`Transaction failed with status ${txResp.status}`);
  }

  console.log("Created the new account", child.publicKey());
}

main().catch((err) => console.error(err));
```

```java
import java.io.IOException;
import java.net.URI;
import java.net.http.*;
import java.time.Duration;

import org.stellar.sdk.*;
import org.stellar.sdk.requests.sorobanrpc.*;

public final class CreateAccountExample {
  private static final String RPC_URL = "https://soroban-testnet.stellar.org";
  private static final String TESTNET_USDC_ISSUER =
      "GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5";
  private static final HttpClient HTTP = HttpClient.newBuilder()
      .connectTimeout(Duration.ofSeconds(20))
      .build();
  private static final SorobanServer SERVER = new SorobanServer(RPC_URL);

  public static void main(String[] args) throws Exception {
    KeyPair parent = KeyPair.random();
    GetNetworkResponse networkInfo = SERVER.getNetwork();
    String friendbotUrl = networkInfo != null ? networkInfo.getFriendbotUrl() : null;
    check(friendbotUrl != null && !friendbotUrl.isBlank(), "Friendbot URL not provided by network");
    String friendbotResponse = requestFunds(friendbotUrl, parent.getAccountId());
    log("SUCCESS! You have a new account:\n%s", friendbotResponse);

    Account parentAccount = SERVER.loadAccount(parent.getAccountId());
    KeyPair child = KeyPair.random();
    AssetTypeCreditAlphaNum12 usdcAsset =
        Asset.createNonNative("USDC", TESTNET_USDC_ISSUER);

    Transaction transaction = new TransactionBuilder(parentAccount, Network.TESTNET)
        .setBaseFee(Transaction.MIN_BASE_FEE)
        .setTimeout(TransactionBuilder.TIMEOUT_INFINITE)
        .addOperation(new CreateAccountOperation.Builder(child.getAccountId(), "5").build())
        .addOperation(new ChangeTrustOperation.Builder(usdcAsset, TESTNET_USDC_ISSUER).build())
        .build();
    transaction.sign(parent);

    long ledgerSeq = submitAndConfirm(transaction);
    log("Transaction confirmed in ledger %d", ledgerSeq);
    log("Created the new account %s", child.getAccountId());
  }

  private static long submitAndConfirm(Transaction transaction) throws IOException {
    SendTransactionResponse sendResp = SERVER.sendTransaction(transaction);
    check(sendResp.getStatus() == SendTransactionStatus.PENDING,
        "Transaction submission failed: " + sendResp.getStatus());

    GetTransactionResponse txResp = SERVER.pollTransaction(sendResp.getHash());
    check(txResp.getStatus() == GetTransactionResponse.Status.SUCCESS,
        "Transaction failed: " + txResp.getStatus());
    Long ledger = txResp.getLedger() != null ? txResp.getLedger() : txResp.getLatestLedger();
    check(ledger != null, "Transaction completed but ledger sequence unavailable");
    return ledger;
  }

  private static String requestFunds(String friendbotUrl, String accountId)
      throws IOException, InterruptedException {
    String requestUrl = friendbotUrl + "?addr=" + accountId;

    HttpRequest request = HttpRequest.newBuilder()
        .uri(URI.create(requestUrl))
        .timeout(Duration.ofSeconds(30))
        .GET()
        .build();
    HttpResponse<String> response = HTTP.send(request, HttpResponse.BodyHandlers.ofString());
    check(response.statusCode() / 100 == 2,
        "Friendbot returned " + response.statusCode() + ": " + response.body());
    return response.body();
  }

  private static void check(boolean condition, String message) {
    if (!condition) {
      throw new IllegalStateException(message);
    }
  }

  private static void log(String format, Object... args) {
    System.out.println(String.format(format, args));
  }
}
```

```go
package main

import (
  "context"
  "io"
  "log"
  "net/http"
  "net/url"
  "strings"
  "time"

  "github.com/stellar/go/keypair"
  "github.com/stellar/go/network"
  "github.com/stellar/go/txnbuild"
  "github.com/stellar/go/xdr"

  "github.com/stellar/stellar-rpc/client"
  "github.com/stellar/stellar-rpc/protocol"
)

const (
  rpcURL           = "https://soroban-testnet.stellar.org"
  testnetUSDCIssuer = "GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5"
  pollInitialDelay = time.Second
  pollAttempts     = 10
)

func main() {
  ctx := context.Background()
  cli := client.NewClient(rpcURL, nil)
  defer cli.Close()

  parent, err := keypair.Random()
  check(err)

  log.Printf("Secret: %s", parent.Seed())
  log.Printf("Public: %s", parent.Address())

  networkInfo, err := cli.GetNetwork(ctx)
  check(err)

  friendbotURL := strings.TrimSpace(networkInfo.FriendbotURL)
  if friendbotURL == "" {
    log.Fatal("friendbot URL not provided by network")
  }
  log.Printf("Using %s for friendbot funding", friendbotURL)

  body := requestAirdrop(friendbotURL, parent.Address())
  log.Printf("SUCCESS! You have a new account:\n%s", body)

  parentAccount, err := cli.LoadAccount(ctx, parent.Address())
  check(err)

  child := keypair.MustRandom()
  usdcAsset := txnbuild.CreditAsset{Code: "USDC", Issuer: testnetUSDCIssuer}

  tx, err := txnbuild.NewTransaction(txnbuild.TransactionParams{
    SourceAccount:        parentAccount,
    IncrementSequenceNum: true,
    BaseFee:              txnbuild.MinBaseFee,
    Preconditions: txnbuild.Preconditions{
      TimeBounds: txnbuild.NewInfiniteTimeout(),
    },
    Operations: []txnbuild.Operation{
      &txnbuild.CreateAccount{
        Destination: child.Address(),
        Amount:      "5",
      },
      &txnbuild.ChangeTrust{
        Line: usdcAsset.MustToChangeTrustAsset(),
      },
    },
  })
  check(err)

  tx, err = tx.Sign(network.TestNetworkPassphrase, parent)
  check(err)

  resp := submitAndAwait(ctx, cli, tx)
  log.Printf("Transaction confirmed in ledger %d", resp.Ledger)
  log.Printf("Created the new account %s", child.Address())
}

func requestAirdrop(friendbotURL, address string) string {
  resp, err := http.Get(friendbotURL + "?addr=" + url.QueryEscape(address))
  check(err)
  defer resp.Body.Close()

  body, err := io.ReadAll(resp.Body)
  check(err)
  if resp.StatusCode >= 400 {
    log.Fatalf("friendbot returned %s: %s", resp.Status, string(body))
  }

  return string(body)
}

func submitAndAwait(ctx context.Context, cli *client.Client, tx *txnbuild.Transaction) protocol.GetTransactionResponse {
  txnB64, err := tx.Base64()
  check(err)

  sendResp, err := cli.SendTransaction(ctx, protocol.SendTransactionRequest{Transaction: txnB64})
  check(err)
  if sendResp.Status != "PENDING" {
    log.Fatalf("transaction submission failed with status %s", sendResp.Status)
  }

  return pollTransaction(ctx, cli, sendResp.Hash)
}

func pollTransaction(ctx context.Context, cli *client.Client, hash string) protocol.GetTransactionResponse {
  delay := pollInitialDelay
  for range pollAttempts {
    resp, err := cli.GetTransaction(ctx, protocol.GetTransactionRequest{Hash: hash})
    check(err)

    switch resp.Status {
    case protocol.TransactionStatusSuccess:
      return resp
    case protocol.TransactionStatusFailed:
      log.Fatalf("transaction failed: %s", strings.Join(resp.DiagnosticEventsXDR, "\n"))
    }

    select {
    case <-ctx.Done():
      log.Fatalf("context cancelled while polling: %v", ctx.Err())
    case <-time.After(delay):
    }
    delay += pollInitialDelay
  }

  log.Fatalf("transaction %s not found after polling", hash)
  return protocol.GetTransactionResponse{}
}

func check(err error) {
  if err != nil {
    log.Fatal(err)
  }
}
```

```python
import requests
from stellar_sdk import *
from stellar_sdk.soroban_rpc import *

RPC_URL = "https://soroban-testnet.stellar.org"
TESTNET_USDC_ISSUER = "GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5"
SERVER = SorobanServer(RPC_URL)


def get_friendbot_url() -> str:
  response = SERVER.get_network()
  if response.friendbot_url:
    return response.friendbot_url.strip()
  raise RuntimeError("Friendbot URL not provided by network")


def request_funds(friendbot_url: str, account_id: str) -> str:
  request_url = f"{friendbot_url}?addr={account_id}"
  resp = requests.get(request_url, timeout=30)
  if not resp.ok:
    raise RuntimeError(f"Friendbot returned {resp.status_code}: {resp.text}")
  return resp.text


def submit_and_confirm(transaction):
  response = SERVER.send_transaction(transaction)
  if response.status != SendTransactionStatus.PENDING:
    raise RuntimeError(f"Transaction submission failed: {response.status}")

  tx_resp = SERVER.poll_transaction(response.hash)
  if tx_resp.status == GetTransactionStatus.SUCCESS:
    return tx_resp.ledger or tx_resp.latest_ledger
  raise RuntimeError(f"Transaction failed: {tx_resp.diagnostic_events_xdr}")


if __name__ == "__main__":
  parent = Keypair.random()
  friendbot_url = get_friendbot_url()
  request_funds(friendbot_url, parent.public_key)
  parent_account = SERVER.load_account(parent.public_key)

  child = Keypair.random()
  usdc_asset = Asset("USDC", TESTNET_USDC_ISSUER)

  tx = (
    TransactionBuilder(
      source_account=parent_account,
      network_passphrase=Network.TESTNET_NETWORK_PASSPHRASE,
      base_fee=TransactionBuilder.BASE_FEE,
    )
    .add_time_bounds(0, 0)
    .append_operation(
      CreateAccount(destination=child.public_key, starting_balance="5")
    )
    .append_operation(ChangeTrust(asset=usdc_asset))
    .build()
  )
  tx.sign(parent)

  ledger_seq = submit_and_confirm(tx)
  print(f"Transaction confirmed in ledger {ledger_seq}")
  print(f"Created the new account {child.public_key}")
```

</CodeExample>

## Fetch Balances

Once your accounts exist you can query their state. These snippets show how to read an account’s native balance and the balance of a trustline.

<CodeExample>

```js
import { Asset, Keypair } from "@stellar/stellar-sdk";
import { Server } from "@stellar/stellar-sdk/rpc";

const server = new Server("https://soroban-testnet.stellar.org");
const testnetUsdc = new Asset(
  "USDC",
  "GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5",
);

async function main() {
  const address = Keypair.random().publicKey();
  await server.requestAirdrop(address);

  const entry = await server.getAccountEntry(address);
  console.log("Balance for account:", address);
  console.log("XLM:", entry.balance().toString());

  const trustline = await server.getTrustline(address, testnetUsdc);
  console.log("USDC:", trustline.balance().toString());
}

main().catch((err) => {
  console.error(err);
  process.exitCode = 1;
});
```

```java
import java.io.IOException;
import java.util.Collections;

import org.stellar.sdk.*;
import org.stellar.sdk.requests.sorobanrpc.*;
import org.stellar.sdk.xdr.*;

public final class FetchBalances {
  private static final String RPC_URL = "https://soroban-testnet.stellar.org";
  private static final SorobanServer SERVER = new SorobanServer(RPC_URL);

  public static void main(String[] args) throws Exception {
    KeyPair parent = KeyPair.random();
    long nativeBalance = loadNativeBalance(parent.getAccountId());
    System.out.printf("Balance for account %s%n", parent.getAccountId());
    System.out.printf("XLM: %d%n", nativeBalance);

    long trustlineBalance = getTrustlineBalance(parent.getAccountId(),
        Asset.createNonNative("USDC", "GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5"));
    System.out.printf("USDC trustline balance (raw): %d%n", trustlineBalance);
  }

  private static long loadNativeBalance(String accountId) throws IOException {
    LedgerKey key = new LedgerKey();
    key.setDiscriminant(LedgerEntryType.ACCOUNT);
    LedgerKeyAccount accountKey = new LedgerKeyAccount();
    accountKey.setAccountID(KeyPair.fromAccountId(accountId).getXdrAccountId());
    key.setAccount(accountKey);

    GetLedgerEntriesResponse response = SERVER.getLedgerEntries(Collections.singletonList(key));
    LedgerEntryData data = LedgerEntryData.fromXdr(response.getEntries().get(0).getXdr());
    return data.getAccount().getBalance().getInt64();
  }

  private static long getTrustlineBalance(String accountId, org.stellar.sdk.Asset asset)
      throws IOException {
    LedgerKey key = new LedgerKey();
    key.setDiscriminant(LedgerEntryType.TRUSTLINE);
    LedgerKeyTrustLine trustLineKey = new LedgerKeyTrustLine();
    trustLineKey.setAccountID(KeyPair.fromAccountId(accountId).getXdrAccountId());
    trustLineKey.setAsset(asset.toXdr());
    key.setTrustLine(trustLineKey);

    GetLedgerEntriesResponse response = SERVER.getLedgerEntries(Collections.singletonList(key));
    if (response.getEntries().isEmpty()) {
      return 0L;
    }
    LedgerEntryData data = LedgerEntryData.fromXdr(response.getEntries().get(0).getXdr());
    TrustLineEntry trustLine = data.getTrustLine();
    return trustLine != null ? trustLine.getBalance().getInt64() : 0L;
  }
}
```

```go
package main

import (
  "context"
  "log"

  "github.com/stellar/go/amount"
  "github.com/stellar/go/keypair"
  "github.com/stellar/go/txnbuild"
  "github.com/stellar/go/xdr"

  "github.com/stellar/stellar-rpc/client"
  "github.com/stellar/stellar-rpc/protocol"
)

func main() {
  ctx := context.Background()
  cli := client.NewClient("https://soroban-testnet.stellar.org", nil)
  defer cli.Close()

  parent, err := keypair.Random()
  check(err)


  entry := getAccountEntry(ctx, cli, parent.Address())
  log.Printf("Balance for account %s", parent.Address())
  log.Printf("XLM: %s", amount.String(entry.Balance))

  usdc := txnbuild.CreditAsset{Code: "USDC", Issuer: "GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5"}
  trustline := getTrustlineEntry(ctx, cli, parent.Address(), usdc)
  log.Printf("USDC trustline balance (raw): %d", trustline.Balance)
}

func getAccountEntry(ctx context.Context, cli *client.Client, address string) *xdr.AccountEntry {
  ledgerKey := xdr.LedgerKey{
    Type: xdr.LedgerEntryTypeAccount,
    Account: &xdr.LedgerKeyAccount{AccountId: xdr.MustAddress(address)},
  }

  keyB64, err := xdr.MarshalBase64(ledgerKey)
  check(err)

  resp, err := cli.GetLedgerEntries(ctx, protocol.GetLedgerEntriesRequest{Keys: []string{keyB64}})
  check(err)
  if len(resp.Entries) == 0 {
    log.Fatalf("account %s not found", address)
  }

  var data xdr.LedgerEntryData
  check(xdr.SafeUnmarshalBase64(resp.Entries[0].DataXDR, &data))
  if data.Account == nil {
    log.Fatalf("ledger entry missing account data")
  }

  return data.Account
}

func getTrustlineEntry(ctx context.Context, cli *client.Client, account string, asset txnbuild.CreditAsset) xdr.TrustLineEntry {
  trustlineAsset, err := asset.MustToTrustLineAsset().ToXDR()
  check(err)

  ledgerKey := xdr.LedgerKey{
    Type: xdr.LedgerEntryTypeTrustline,
    TrustLine: &xdr.LedgerKeyTrustLine{
      AccountId: xdr.MustAddress(account),
      Asset:     trustlineAsset,
    },
  }

  keyB64, err := xdr.MarshalBase64(ledgerKey)
  check(err)

  resp, err := cli.GetLedgerEntries(ctx, protocol.GetLedgerEntriesRequest{Keys: []string{keyB64}})
  check(err)
  if len(resp.Entries) == 0 {
    log.Fatalf("trustline for %s:%s not found", asset.Code, asset.Issuer)
  }

  var data xdr.LedgerEntryData
  check(xdr.SafeUnmarshalBase64(resp.Entries[0].DataXDR, &data))
  return data.MustTrustLine()
}

func check(err error) {
  if err != nil {
    log.Fatal(err)
  }
}
```

```python
from stellar_sdk import *
from stellar_sdk.xdr import *

RPC_URL = "https://soroban-testnet.stellar.org"
TESTNET_USDC_ISSUER = "GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5"
SERVER = SorobanServer(RPC_URL)


def load_native_balance(account_id: str) -> int:
  key = LedgerKey(
    LedgerEntryType.ACCOUNT,
    account=LedgerKeyAccount(
      account_id=Keypair.from_public_key(account_id).xdr_account_id()
    ),
  )
  response = SERVER.get_ledger_entries([key])
  ledger_entry = LedgerEntryData.from_xdr(response.entries[0].xdr)
  return ledger_entry.account.balance.int64


def get_trustline(account_id: str, asset: Asset) -> int:
  key = LedgerKey(
    LedgerEntryType.TRUSTLINE,
    trust_line=LedgerKeyTrustLine(
      account_id=Keypair.from_public_key(account_id).xdr_account_id(),
      asset=asset.to_trust_line_xdr_object(),
    ),
  )
  response = SERVER.get_ledger_entries([key])
  if not response.entries:
    return 0
  ledger_entry = LedgerEntryData.from_xdr(response.entries[0].xdr)
  trustline = ledger_entry.trust_line
  return trustline.balance.int64 if trustline else 0


if __name__ == "__main__":
  account = Keypair.random()
  print(f"Balance for account {account.public_key}")
  print(f"XLM: {load_native_balance(account.public_key)}")

  usdc_asset = Asset("USDC", TESTNET_USDC_ISSUER)
  print(f"USDC trustline balance (raw): {get_trustline(account.public_key, usdc_asset)}")
```

</CodeExample>

Now that you’ve got an account, you can [start sending and receiving payments](send-and-receive-payments.mdx), or, if you're ready to hunker down, you can skip ahead and [build a wallet](../../apps/wallet/overview.mdx) or [issue a Stellar-network asset](../../../tokens/anatomy-of-an-asset.mdx).

<Alert>

The code samples keep error checking concise for readability. Always validate results in your applications and refer to the guide on [Error Handling](../../../data/apis/horizon/api-reference/errors/error-handling.mdx) for more strategies.

</Alert>

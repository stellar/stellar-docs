---
title: Create an account
sidebar_position: 5
description: Learn about creating Stellar accounts, keypairs, funding, and account basics.
---

# Create an Account

import { CodeExample } from "@site/src/components/CodeExample";
import { Alert } from "@site/src/components/Alert";
import Details from "@theme/Details";

_Before we get started with working with Stellar in code, consider going through the following examples using the [Stellar Lab](https://lab.stellar.org). The lab allows you create accounts, fund accounts on the Stellar test network, build transactions, run any operation, and inspect responses from Horizon via the Endpoint Explorer._

[Accounts](../../../learn/fundamentals/stellar-data-structures/accounts.mdx) are a fundamental building block of Stellar: they hold all your balances, allow you to send and receive payments, and let you place offers to buy and sell assets. Since pretty much everything on Stellar is in some way tied to an account, the first thing you generally need to do when you start developing is create one. This beginner-level tutorial will show you how to do that.

## Create a Keypair

Stellar uses public key cryptography to ensure that every transaction is secure: every Stellar account has a keypair consisting of a **public key** and a **secret key**. The public key is always safe to share — other people need it to identify your account and verify that you authorized a transaction. It's like an email address. The secret key, however, is private information that proves you own — and gives you access to — your account. It's like a password, and you should never share it with anyone.

Before creating an account, you need to generate your own keypair:

<CodeExample>

```js
import { Keypair } from "@stellar/stellar-sdk";

// create a completely new and unique pair of keys
// see more about KeyPair objects: https://stellar.github.io/js-stellar-sdk/Keypair.html
const parent = Keypair.random();

console.log("Secret:", parent.secret());
// ex: SAV76USXIJOBMEQXPANUOQM6F5LIOTLPDIDVRJBFFE2MDJXG24TAPUU7
console.log("Public:", parent.publicKey());
// ex: GCFXHS4GXL6BVUCXBWXGTITROWLVYXQKQLF4YH5O5JT3YZXCYPAFBJZB
```

```java
// create a completely new and unique pair of keys.
// see more about KeyPair objects: https://stellar.github.io/java-stellar-sdk/org/stellar/sdk/KeyPair.html
import org.stellar.sdk.KeyPair;

KeyPair parent = KeyPair.random();
log("Public: %s", parent.getAccountId());
// GCFXHS4GXL6BVUCXBWXGTITROWLVYXQKQLF4YH5O5JT3YZXCYPAFBJZB
log("Secret: %s", new String(parent.getSecretSeed()));
// SAV76USXIJOBMEQXPANUOQM6F5LIOTLPDIDVRJBFFE2MDJXG24TAPUU7
```

```go
package main

import (
  "context"
  "log"

  "github.com/stellar/go/keypair"
)

func main() {
  parent := keypair.MustRandom()
  log.Printf("Secret: %s", parent.Seed())
  log.Printf("Public: %s", parent.Address())
}
```

```python
# stellar-sdk >= 11.0.0 required
# create a completely new and unique pair of keys
# see more about KeyPair objects: https://stellar-sdk.readthedocs.io/en/latest/api.html#keypair
from stellar_sdk import Keypair

parent = Keypair.random()
print(f"Secret: {parent.secret}")
# Secret: SCMDRX7A7OVRPAGXLUVRNIYTWBLCS54OV7UH2TF5URSG4B4JQMUADCYU
print(f"Public Key: {parent.public_key}")
# Public Key: GAG7SXULMNWCW6LX42JKZOZRA2JJXQT23LYY32OXA6XECUQG7RZTQJHO
```

</CodeExample>

## Fund or Create an Account

A valid keypair, however, does not make an account: in order to prevent unused accounts from bloating the ledger, Stellar requires accounts to hold a [minimum balance](../../../learn/fundamentals/lumens.mdx#minimum-balance) of 1 XLM before they actually exist. Until it gets a bit of funding, your keypair doesn't warrant space on the ledger.

On the [public network](../../../learn/fundamentals/networks.mdx), where live users make live transactions, your next step would be to acquire XLM, which you can do by consulting our [section on lumens](https://stellar.org/learn/lumens). Because this tutorial runs on the [test network](../../../learn/fundamentals/networks.mdx), you can get 10,000 test XLM from Friendbot, which is a friendly account funding tool.

To do that, send Friendbot the public key you created. It’ll create and fund a new account using that public key as the account ID. If you're working on mainnet, however, you'll need to use the `CreateAccount` operation from an already-funded account and specify its starting balance, which the below example also demonstrate:

<CodeExample>

```js
import {
  TransactionBuilder,
  BASE_FEE,
  Networks,
  Operation,
  Asset,
  humanizeEvents,
} from "@stellar/stellar-sdk";
import { Server } from "@stellar/stellar-sdk/rpc";

// See https://developers.stellar.org/docs/data/apis/api-providers
const server = new Server("https://soroban-testnet.stellar.org");

// Not necessary for creation, just used later to demo balance fetch.
const testnetUsdc = new Asset(
  "USDC",
  "GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5",
);

(async function main() {
  try {
    const response = await server.requestAirdrop(parent.publicKey());
    console.log("SUCCESS! You have a new account:\n", response);
  } catch (e) {
    console.error("ERROR!", e);
  }

  // After you've got your test lumens from friendbot, we can also use
  // that account to create a new account on the ledger.
  var parentAccount = await server.getAccount(parent.publicKey());

  // Generate a random account.
  var childAccount = Keypair.random();

  let createAccountTx = new TransactionBuilder(parentAccount, {
    fee: BASE_FEE,
    networkPassphrase: Networks.TESTNET,
  })
    .addOperation(
      Operation.createAccount({
        destination: childAccount.publicKey(),
        startingBalance: "5",
      }),
    )
    // Not needed for creation, just used in the later example
    .addOperation(Operation.changeTrust({ asset: testnetUsdc }))
    .setTimeout(180)
    .build();

  // Sign the transaction with the account that was created from friendbot.
  createAccountTx.sign(parent);

  // Submit the transaction and wait for it to be accepted by the network.
  const sendTxResponse = await server.sendTransaction(createAccountTx);
  if (sendTxResponse.status !== "PENDING") {
    console.log(`There was an error: ${JSON.stringify(sendTxResponse)}`);
    throw sendTxResponse;
  }

  const txResponse = await server.pollTransaction(sendTxResponse.hash);
  if (txResponse.status !== "SUCCESS") {
    console.log(
      `Transaction status: ${txResponse.status}, events: ${humanizeEvents(
        txResponse.diagnosticEvents,
      )}`,
    );
  }

  console.log("Created the new account", childAccount.publicKey());
})();
```

```java
// The SDK does not have tools for creating test accounts, so you'll have to
// make your own HTTP request.
import java.net.*;
import java.io.*;
import java.util.*;

private static final String FRIENDBOT_URL = "https://friendbot.stellar.org/?addr=";
private static final String TESTNET_USDC_ISSUER = "GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5";
private static final HttpClient HTTP = HttpClient.newBuilder()
  .connectTimeout(Duration.ofSeconds(20))
  .build();
private static final SorobanServer SERVER = new SorobanServer(RPC_URL);

public static void main(String[] args) throws Exception {
  KeyPair parent = KeyPair.random();
  log("Secret: %s", new String(parent.getSecretSeed()));
  log("Public: %s", parent.getAccountId());

  String friendbotResponse = requestFunds(parent.getAccountId());
  log("SUCCESS! You have a new account:\n%s", friendbotResponse);

  Account parentAccount = SERVER.loadAccount(parent.getAccountId());

  KeyPair child = KeyPair.random();
  AssetTypeCreditAlphaNum12 usdcAsset = Asset.createNonNative("USDC", TESTNET_USDC_ISSUER);

  Transaction transaction = new TransactionBuilder(parentAccount, Network.TESTNET)
    .setBaseFee(Transaction.MIN_BASE_FEE)
    .setTimeout(TransactionBuilder.TIMEOUT_INFINITE)
    .addOperation(new CreateAccountOperation.Builder(child.getAccountId(), "5").build())
    .addOperation(new ChangeTrustOperation.Builder(usdcAsset, TESTNET_USDC_ISSUER).build())
    .build();
  transaction.sign(parent);

  SendTransactionResponse sendResp = sendTransaction(transaction);
  GetTransactionResponse txResp = SERVER.pollTransaction(sendResp.getHash());
  long ledgerSeq = txResp.getLedger() != null ? txResp.getLedger() : txResp.getLatestLedger();
  log("Transaction confirmed in ledger %d", ledgerSeq);
  log("Created the new account %s", child.getAccountId());
}

private static String requestFunds(String accountId) throws IOException, InterruptedException {
  HttpRequest request = HttpRequest.newBuilder()
    .uri(URI.create(FRIENDBOT_URL + accountId))
    .timeout(Duration.ofSeconds(30))
    .GET()
    .build();
  HttpResponse<String> response = HTTP.send(request, HttpResponse.BodyHandlers.ofString());
  check(response.statusCode() / 100 == 2, "Friendbot returned " + response.statusCode() + ": " + response.body());
  return response.body();
}
```

```go
package main

import (
  "context"
  "fmt"
  "io"
  "log"
  "net/http"
  "net/url"

  "github.com/stellar/go/keypair"
  "github.com/stellar/go/network"
  "github.com/stellar/go/txnbuild"

  "github.com/stellar/stellar-rpc/client"
)

const (
  rpcURL                = "https://soroban-testnet.stellar.org"
  friendbotURL          = "https://friendbot.stellar.org/?addr="
  pollInitialDelay      = time.Second
  pollAttempts          = 10
)

func main() {
  // Assume `parent` is still defined as above
  ctx := context.Background()
  cli := client.NewClient(rpcURL, nil)
  defer cli.Close()

  friendbotResponse := requestFunds(parent.Address())
  log.Printf("SUCCESS! You have a new account:\n%s", friendbotResponse);

  parentAccount, err := cli.LoadAccount(ctx, parent.Address())
  check(err)

  child := keypair.MustRandom()
  usdcAsset := txnbuild.CreditAsset{Code: "USDC", Issuer: testnetUSDCIssuer}

  tx, err := txnbuild.NewTransaction(txnbuild.TransactionParams{
    SourceAccount:        parentAccount,
    IncrementSequenceNum: true,
    BaseFee:              txnbuild.MinBaseFee,
    Preconditions: txnbuild.Preconditions{
      TimeBounds: txnbuild.NewInfiniteTimeout(),
    },
    Operations: []txnbuild.Operation{
      &txnbuild.CreateAccount{
        Destination: child.Address(),
        Amount:      "420",
      },
      // Not needed for creation, just used in the later example
      &txnbuild.ChangeTrust{
        Line: usdcAsset.MustToChangeTrustAsset(),
      },
    },
  })
  check(err)

  tx, err = tx.Sign(network.TestNetworkPassphrase, parent)
  check(err)

  resp := submitAndAwait(ctx, cli, tx)
  log.Printf("Transaction confirmed in ledger %d", resp.Ledger)
  log.Printf("Created the new account %s", child.Address())
}

func requestFunds(address string) string {
  resp, err := http.Get(friendbotURL + url.QueryEscape(address))
  defer resp.Body.Close()
  check(err)

  body, err := io.ReadAll(resp.Body)
  check(err)
  if resp.StatusCode >= 400 {
    log.Fatalf("friendbot returned %s: %s", resp.Status, string(body))
  }

  return string(body)
}
```

```python
# The SDK does not have tools for creating test accounts, so you'll have to
# make your own HTTP request.

# if you're trying this on Python, install the `requests` library.
import requests


def request_funds(address: str) -> bool:
  response = requests.get(f"https://friendbot.stellar.org?addr={address}")
  check(
    response.status_code == 200,
    f"ERROR! Response: {response.text}"
  )
  return response.text

parent = Keypair.random()
print(f"Secret: {parent.secret}")
print(f"Public: {parent.public_key}")

# Create+Fund the account via friendbot
body = request_funds(parent.public_key)
print(f"SUCCESS! You have a new account:\n{body}")

# Create+Fund the account via an existing account
child = Keypair.random()
usdc_asset = Asset("USDC", TESTNET_USDC_ISSUER)
parent_account = SERVER.load_account(parent.public_key)

tx = (
  TransactionBuilder(
    source_account=parent_account,
    network_passphrase=Network.TESTNET_NETWORK_PASSPHRASE,
    base_fee=TransactionBuilder.BASE_FEE,
  )
  .add_time_bounds(0, 0)
  .append_operation(
    CreateAccount(destination=child.public_key, starting_balance="5")
  )
  .append_operation(ChangeTrust(asset=usdc_asset))
  .build()
)
tx.sign(parent)

send_resp = send_transaction(tx)
tx_resp = poll_transaction(send_resp.hash)
ledger_seq = tx_resp.ledger or tx_resp.latest_ledger
print(f"Transaction confirmed in ledger {ledger_seq}")
print(f"Created the new account {child.public_key}")
```

</CodeExample>

Now for the last step: getting the account’s details and checking its balance. Accounts can carry multiple balances — one for each type of asset they hold. Because the Stellar network stores data in a key-value store, you must either (a) know which assets you hold or (b) let your users add them.

<CodeExample>

```js
async function fetchBalances(address: string) {
  // Assume that `server` and `testnetUsdc` still exist from before
  const accountEntry = await server.getAccountEntry(address);
  console.log("Balance for account: " + address);
  console.log("XLM:", accountEntry.balance().toString());

  // You can also fetch trustline or smart contract balances:
  const trustlineEntry = await server.getTrustline(address, testnetUsdc);
  console.log("USDC:", trustlineEntry.balance().toString());

  const xlmInContract = await server.getSACBalance(
    address,
    Asset.native(),
    Networks.TESTNET,
  );
  console.log("Smart USDC:", xlmInContract.balanceEntry.amount);
}
```

```java
String RPC_URL = "https://soroban-testnet.stellar.org";
String TESTNET_USDC_CONTRACT = "CBIELTK6YBZJU5UP2WWQEUCYKLPU6AUNZ2BQ4WWFEIE3USCIHMXQDAMA";

SorobanServer SERVER = new SorobanServer(RPC_URL);

// Assume `parent` is defined as above
long nativeBalance = loadNativeBalance(parent.getAccountId());
log("Balance for account %s", parent.getAccountId());
log("XLM: %d", nativeBalance);

long trustlineBalance = getTrustlineBalance(parent.getAccountId(), usdcAsset);
log("USDC trustline balance (raw): %d", trustlineBalance);

String sacAmount = getSacBalance(
  TESTNET_USDC_CONTRACT,
  AssetTypeNative.INSTANCE,
  Network.TESTNET);
log("XLM in USDC contract (raw): %s", sacAmount);
```

```go
package main

import (
  "log"
  "context"

  "github.com/stellar/go/xdr"

  "github.com/stellar/stellar-rpc/client"
  "github.com/stellar/stellar-rpc/protocol"
)

const (
  rpcURL                = "https://soroban-testnet.stellar.org"
  testnetUSDCContractID = "CBIELTK6YBZJU5UP2WWQEUCYKLPU6AUNZ2BQ4WWFEIE3USCIHMXQDAMA"
)

func main() {
  ctx := context.TODO()
  cli := client.NewClient(rpcURL, nil)
  defer cli.Close()

  // Assume `child` is defined as in the beginning
  accountEntry := getAccountEntry(ctx, cli, child.Address())
  log.Printf("Balance for account %s", child.Address())
  log.Printf("XLM: %s", amount.String(accountEntry.Balance))

  trustlineEntry := getTrustlineEntry(ctx, cli, child.Address(), usdcAsset)
  log.Printf("USDC trustline balance (raw): %d", trustlineEntry.Balance)

  sacAmount := getSACBalance(ctx, cli, testnetUSDCContractID,
    xdr.MustNewNativeAsset(), network.TestNetworkPassphrase)
  log.Printf("XLM in USDC contract (raw): %s", sacAmount)
}
```

```python
from stellar_sdk import *
from stellar_sdk.xdr import *

RPC_URL = "https://soroban-testnet.stellar.org"
TESTNET_USDC_ISSUER = "GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5"
TESTNET_USDC_CONTRACT = "CBIELTK6YBZJU5UP2WWQEUCYKLPU6AUNZ2BQ4WWFEIE3USCIHMXQDAMA"
SERVER = SorobanServer(RPC_URL)


def check_balances(address: str) -> None:
  usdc_asset = Asset("USDC", TESTNET_USDC_ISSUER)

  native_balance = load_native_balance(address)
  print(f"Balance for account {address}")
  print(f"XLM: {native_balance}")

  trustline = get_trustline(address, usdc_asset)
  print(f"USDC trustline balance (raw): {trustline}")

  # unrelated to the account
  sac_amount = get_sac_balance(
    TESTNET_USDC_CONTRACT, Asset.native(), Network.TESTNET_NETWORK_PASSPHRASE
  )
  print(f"XLM in USDC contract (raw): {sac_amount}")
```

</CodeExample>

Now that you’ve got an account, you can [start sending and receiving payments](send-and-receive-payments.mdx), or, if you're ready to hunker down, you can skip ahead and [build a wallet](../../apps/wallet/overview.mdx) or [issue a Stellar-network asset](../../../tokens/anatomy-of-an-asset.mdx).

<Alert>

In the above code samples, proper error checking is omitted for brevity. However, you should _always_ validate your results, as there are many ways that requests can fail. You should refer to the guide on [Error Handling](../../../data/apis/horizon/api-reference/errors/error-handling.mdx) for tips on error management strategies.

</Alert>

## Footnote

Some SDK languages have more utilities than others. Utility functions referenced above that aren't native to the SDKs are defined here, such as `pollTransaction` in the Go SDK.

<Details summary="Transaction submission">
<CodeExample>

```go
import (
  "context"
  "log"
  "strings"
  "time"

  "github.com/stellar/go/amount"
  "github.com/stellar/go/strkey"
  "github.com/stellar/go/xdr"

  "github.com/stellar/stellar-rpc/client"
  "github.com/stellar/stellar-rpc/protocol"
)

func submitAndAwait(
  ctx context.Context,
  cli *client.Client,
  tx *txnbuild.Transaction,
) protocol.GetTransactionResponse {
  txnB64, err := tx.Base64()
  check(err)

  sendResp, err := cli.SendTransaction(ctx, protocol.SendTransactionRequest{Transaction: txnB64})
  check(err)
  if sendResp.Status != "PENDING" {
    log.Fatalf("transaction submission failed with status %s", sendResp.Status)
  }

  return pollTransaction(ctx, cli, sendResp.Hash)
}

func pollTransaction(ctx context.Context, cli *client.Client, hash string) protocol.GetTransactionResponse {
  delay := pollInitialDelay
  for range pollAttempts {
    resp, err := cli.GetTransaction(ctx, protocol.GetTransactionRequest{Hash: hash})
    check(err)

    switch resp.Status {
    case protocol.TransactionStatusSuccess:
      return resp
    case protocol.TransactionStatusFailed:
      log.Fatalf("transaction failed: %s", strings.Join(resp.DiagnosticEventsXDR, "\n"))
    case protocol.TransactionStatusNotFound:
      // keep polling
    default:
      // unexpected status, continue polling in case it's transient
    }

    select {
    case <-ctx.Done():
      log.Fatalf("context cancelled while polling: %v", ctx.Err())
    case <-time.After(delay):
    }
    delay += pollInitialDelay
  }

  log.Fatalf("transaction %s not found after polling", hash)
  return protocol.GetTransactionResponse{}
}
```

```python
import time
from stellar_sdk import *
from stellar_sdk.soroban_rpc import GetTransactionStatus, SendTransactionStatus

RPC_URL = "https://soroban-testnet.stellar.org"
POLL_DELAY_SECONDS = 1
POLL_ATTEMPTS = 10

SERVER = SorobanServer(RPC_URL)

def send_transaction(transaction):
  response = SERVER.send_transaction(transaction)
  check(
    response.status == SendTransactionStatus.PENDING,
    f"Transaction submission failed: {response.status}",
  )
  return response

def poll_transaction(hash_: str):
  for attempt in range(POLL_ATTEMPTS):
    response = SERVER.get_transaction(hash_)
    if response.status == GetTransactionStatus.SUCCESS:
      return response
    if response.status == GetTransactionStatus.FAILED:
      raise RuntimeError(f"Transaction failed: {response.diagnostic_events_xdr}")
    time.sleep(POLL_DELAY_SECONDS * (attempt + 1))
  raise RuntimeError(f"Transaction {hash_} not found after polling")
```

</CodeExample>
</Details>

<Details summary="Retrieving account details">
<CodeExample>

```java
private static long loadNativeBalance(String accountId) throws IOException {
  LedgerKey key = new LedgerKey();
  key.setDiscriminant(LedgerEntryType.ACCOUNT);
  LedgerKeyAccount accountKey = new LedgerKeyAccount();
  accountKey.setAccountID(KeyPair.fromAccountId(accountId).getXdrAccountId());
  key.setAccount(accountKey);

  GetLedgerEntriesResponse response = SERVER.getLedgerEntries(Collections.singletonList(key));
  check(!response.getEntries().isEmpty(), "Account " + accountId + " not found");
  LedgerEntryData data = LedgerEntryData.fromXdr(response.getEntries().get(0).getXdr());
  check(data.getAccount() != null, "Ledger entry missing account data");
  return data.getAccount().getBalance().getInt64();
}
```

```go
import (
  "context"
  "log"

  "github.com/stellar/go/xdr"

  "github.com/stellar/stellar-rpc/client"
  "github.com/stellar/stellar-rpc/protocol"
)

func getAccountEntry(ctx context.Context, cli *client.Client, address string) *xdr.AccountEntry {
  ledgerKey := xdr.LedgerKey{
    Type: xdr.LedgerEntryTypeAccount,
    Account: &xdr.LedgerKeyAccount{
      AccountId: xdr.MustAddress(address),
    },
  }

  keyB64, err := xdr.MarshalBase64(ledgerKey)
  check(err)

  resp, err := cli.GetLedgerEntries(ctx, protocol.GetLedgerEntriesRequest{Keys: []string{keyB64}})
  check(err)
  if len(resp.Entries) == 0 {
    log.Fatalf("account %s not found", address)
  }

  var ledgerData xdr.LedgerEntryData
  check(xdr.SafeUnmarshalBase64(resp.Entries[0].DataXDR, &ledgerData))
  if ledgerData.Account == nil {
    log.Fatalf("ledger entry for %s missing account data", address)
  }

  return ledgerData.Account
}
```

```python
def load_native_balance(account_id: str) -> int:
  key = LedgerKey(
    LedgerEntryType.ACCOUNT,
    account=LedgerKeyAccount(
      account_id=Keypair.from_public_key(account_id).xdr_account_id()
    ),
  )
  response = SERVER.get_ledger_entries([key])
  check(response.entries, f"account {account_id} not found")

  account = LedgerEntryData.from_xdr(response.entries[0].xdr).account
  check(account is not None, "ledger entry missing account data")
  return account.balance.int64
```

</CodeExample>
</Details>

<Details summary="Retrieving trustline details">
<CodeExample>

```java
private static long getTrustlineBalance(String accountId, org.stellar.sdk.Asset asset) throws IOException {
  LedgerKey key = new LedgerKey();
  key.setDiscriminant(LedgerEntryType.TRUSTLINE);
  LedgerKeyTrustLine trustLineKey = new LedgerKeyTrustLine();
  trustLineKey.setAccountID(KeyPair.fromAccountId(accountId).getXdrAccountId());
  trustLineKey.setAsset(asset.toXdr());
  key.setTrustLine(trustLineKey);

  GetLedgerEntriesResponse response = SERVER.getLedgerEntries(Collections.singletonList(key));
  if (response.getEntries().isEmpty()) {
    return 0L;
  }
  LedgerEntryData data = LedgerEntryData.fromXdr(response.getEntries().get(0).getXdr());
  TrustLineEntry trustLine = data.getTrustLine();
  if (trustLine == null) {
    return 0L;
  }
  return trustLine.getBalance().getInt64();
}
```

```go
import (
  "context"
  "log"

  "github.com/stellar/go/xdr"

  "github.com/stellar/stellar-rpc/client"
  "github.com/stellar/stellar-rpc/protocol"
)

func getTrustlineEntry(ctx context.Context, cli *client.Client, account string, asset txnbuild.CreditAsset) xdr.TrustLineEntry {
  trustlineAsset, err := asset.MustToTrustLineAsset().ToXDR()
  check(err)

  ledgerKey := xdr.LedgerKey{
    Type: xdr.LedgerEntryTypeTrustline,
    TrustLine: &xdr.LedgerKeyTrustLine{
      AccountId: xdr.MustAddress(account),
      Asset:     trustlineAsset,
    },
  }

  keyB64, err := xdr.MarshalBase64(ledgerKey)
  check(err)

  resp, err := cli.GetLedgerEntries(ctx, protocol.GetLedgerEntriesRequest{Keys: []string{keyB64}})
  check(err)
  if len(resp.Entries) == 0 {
    check(fmt.Errorf("trustline for %s:%s not found", asset.Code, asset.Issuer))
  }

  var ledgerData xdr.LedgerEntryData
  check(xdr.SafeUnmarshalBase64(resp.Entries[0].DataXDR, &ledgerData))
  return ledgerData.MustTrustLine()
}
```

```python
def get_trustline(account_id: str, asset: Asset) -> int:
  key = LedgerKey(
    LedgerEntryType.TRUSTLINE,
    trust_line=LedgerKeyTrustLine(
      account_id=Keypair.from_public_key(account_id).xdr_account_id(),
      asset=asset.to_trust_line_xdr_object(),
    ),
  )
  response = SERVER.get_ledger_entries([key])
  if not response.entries:
    return 0
  ledger_entry = LedgerEntryData.from_xdr(response.entries[0].xdr)
  trust_line = ledger_entry.trust_line
  if trust_line is None:
    return 0
  return trust_line.balance.int64
```

</CodeExample>
</Details>

<Details summary="Retrieving the SAC balance held by a contract">
<CodeExample>

```java
private static String getSacBalance(String contractId, Asset asset, Network network) {
  GetSACBalanceResponse response = SERVER.getSACBalance(contractId, asset, network);
  if (response == null || response.getBalanceEntry() == null) {
    return "0";
  }
  String amount = response.getBalanceEntry().getAmount();
  return amount != null ? amount : "0";
}
```

```go
import (
  "context"
  "log"

  "github.com/stellar/go/amount"
  "github.com/stellar/go/strkey"
  "github.com/stellar/go/xdr"

  "github.com/stellar/stellar-rpc/client"
  "github.com/stellar/stellar-rpc/protocol"
)

func getSACBalance(ctx context.Context, cli *client.Client, contractID string, asset xdr.Asset, networkPassphrase string) string {
  targetContract, err := decodeContractID(contractID)
  check(err)

  sacContractHash, err := asset.ContractID(networkPassphrase)
  check(err)

  sacContractID := xdr.ContractId(sacContractHash)
  sacAddress := xdr.ScAddress{Type: xdr.ScAddressTypeScAddressTypeContract, ContractId: &sacContractID}
  targetAddress := xdr.ScAddress{Type: xdr.ScAddressTypeScAddressTypeContract, ContractId: &targetContract}
  balanceSymbol, err := xdr.NewScVal(xdr.ScValTypeScvSymbol, xdr.ScSymbol("Balance"))
  check(err)

  addressVal, err := xdr.NewScVal(xdr.ScValTypeScvAddress, targetAddress)
  check(err)

  vec := xdr.ScVec{balanceSymbol, addressVal}
  keyVal, err := xdr.NewScVal(xdr.ScValTypeScvVec, &vec)
  check(err)

  ledgerKey := xdr.LedgerKey{
    Type: xdr.LedgerEntryTypeContractData,
    ContractData: &xdr.LedgerKeyContractData{
      Contract:   sacAddress,
      Key:        keyVal,
      Durability: xdr.ContractDataDurabilityPersistent,
    },
  }

  keyB64, err := xdr.MarshalBase64(ledgerKey)
  check(err)

  resp, err := cli.GetLedgerEntries(ctx, protocol.GetLedgerEntriesRequest{Keys: []string{keyB64}})
  check(err)
  if len(resp.Entries) == 0 {
    return "0"
  }

  var ledgerData xdr.LedgerEntryData
  check(xdr.SafeUnmarshalBase64(resp.Entries[0].DataXDR, &ledgerData))

  balanceMap := ledgerData.MustContractData().Val.MustMap()
  for _, entry := range *balanceMap {
    key := string(entry.Key.MustSym())
    switch key {
    case "amount":
      return amount.String128Raw(entry.Val.MustI128())
    }
  }

  return "0"
}

func decodeContractID(contractID string) (xdr.ContractId, error) {
  bytes, err := strkey.Decode(strkey.VersionByteContract, contractID)
  if err != nil {
    return xdr.ContractId{}, err
  }
  var id xdr.ContractId
  copy(id[:], bytes)
  return id, nil
}
```

```python
def get_sac_balance(contract_id: str, asset: Asset, network_passphrase: str) -> int:
  target_contract = StrKey.decode_contract(contract_id)
  sac_contract_id = StrKey.decode_contract(asset.contract_id(network_passphrase))
  key = LedgerKey(
    LedgerEntryType.CONTRACT_DATA,
    contract_data=LedgerKeyContractData(
      contract=SCAddress(
        SCAddressType.SC_ADDRESS_TYPE_CONTRACT, contract_id=sac_contract_id
      ),
      key=_sac_balance_key(target_contract),
      durability=ContractDataDurability.PERSISTENT,
    ),
  )
  response = SERVER.get_ledger_entries([key])
  if not response.entries:
    return 0

  ledger_entry = LedgerEntryData.from_xdr(response.entries[0].xdr)
  contract_data = ledger_entry.contract_data
  if contract_data is None or contract_data.val.map is None:
    return 0

  for entry in contract_data.val.map.sc_map:
    if (
      entry.key.discriminant == SCValType.SCV_SYMBOL
      and entry.key.sym == SCSymbol(b"Balance")
    ):
      return scval_i128_to_int(entry.val)

  return 0
```

</CodeExample>
</Details>

<Details summary="Error handling and logging">
<CodeExample>

```java
private static void check(boolean condition, String message) {
  if (!condition) {
    throw new IllegalStateException(message);
  }
}

private static void log(String format, Object... args) {
  System.out.println(String.format(format, args));
}
```

```go
func check(err error) {
  if err != nil {
    log.Fatal(err)
  }
}
```

```python
def check(condition: bool, message: str) -> None:
  if not condition:
      raise RuntimeError(message)
```

</CodeExample>
</Details>

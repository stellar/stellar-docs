---
title: Create an account
sidebar_position: 5
description: Learn about creating Stellar accounts, keypairs, funding, and account basics.
---

# Create an Account

import { CodeExample } from "@site/src/components/CodeExample";
import { Alert } from "@site/src/components/Alert";

_Before we get started with working with Stellar in code, consider going through the following examples using the [Stellar Lab](https://lab.stellar.org). The lab allows you create accounts, fund accounts on the Stellar test network, build transactions, run any operation, and inspect responses from Horizon via the Endpoint Explorer._

[Accounts](../../../learn/fundamentals/stellar-data-structures/accounts.mdx) are a fundamental building block of Stellar: they hold all your balances, allow you to send and receive payments, and let you place offers to buy and sell assets. Since pretty much everything on Stellar is in some way tied to an account, the first thing you generally need to do when you start developing is create one. This beginner-level tutorial will show you how to do that.

## Create a Keypair

Stellar uses public key cryptography to ensure that every transaction is secure: every Stellar account has a keypair consisting of a **public key** and a **secret key**. The public key is always safe to share — other people need it to identify your account and verify that you authorized a transaction. It's like an email address. The secret key, however, is private information that proves you own — and gives you access to — your account. It's like a password, and you should never share it with anyone.

Before creating an account, you need to generate your own keypair:

<CodeExample>

```js
import { Keypair } from "@stellar/stellar-sdk";

// create a completely new and unique pair of keys
// see more about KeyPair objects: https://stellar.github.io/js-stellar-sdk/Keypair.html
const pair = Keypair.random();

pair.secret();
// ex: SAV76USXIJOBMEQXPANUOQM6F5LIOTLPDIDVRJBFFE2MDJXG24TAPUU7
pair.publicKey();
// ex: GCFXHS4GXL6BVUCXBWXGTITROWLVYXQKQLF4YH5O5JT3YZXCYPAFBJZB
```

```java
// create a completely new and unique pair of keys.
// see more about KeyPair objects: https://stellar.github.io/java-stellar-sdk/org/stellar/sdk/KeyPair.html
import org.stellar.sdk.KeyPair;
KeyPair pair = KeyPair.random();

System.out.println(new String(pair.getSecretSeed()));
// SAV76USXIJOBMEQXPANUOQM6F5LIOTLPDIDVRJBFFE2MDJXG24TAPUU7
System.out.println(pair.getAccountId());
// GCFXHS4GXL6BVUCXBWXGTITROWLVYXQKQLF4YH5O5JT3YZXCYPAFBJZB
```

```go
package main

import (
  "context"
  "log"

  "github.com/stellar/go/keypair"
)

func main() {
  ctx := context.Background()

  parent, err := keypair.Random()
  check(err)

  log.Printf("Secret: %s", parent.Seed())
  log.Printf("Public: %s", parent.Address())
}
```

```python
# stellar-sdk >= 11.0.0 required
# create a completely new and unique pair of keys
# see more about KeyPair objects: https://stellar-sdk.readthedocs.io/en/latest/api.html#keypair
from stellar_sdk import Keypair

pair = Keypair.random()
print(f"Secret: {pair.secret}")
# Secret: SCMDRX7A7OVRPAGXLUVRNIYTWBLCS54OV7UH2TF5URSG4B4JQMUADCYU
print(f"Public Key: {pair.public_key}")
# Public Key: GAG7SXULMNWCW6LX42JKZOZRA2JJXQT23LYY32OXA6XECUQG7RZTQJHO
```

</CodeExample>

## Create Account

A valid keypair, however, does not make an account: in order to prevent unused accounts from bloating the ledger, Stellar requires accounts to hold a [minimum balance](../../../learn/fundamentals/lumens.mdx#minimum-balance) of 1 XLM before they actually exist. Until it gets a bit of funding, your keypair doesn't warrant space on the ledger.

On the [public network](../../../learn/fundamentals/networks.mdx), where live users make live transactions, your next step would be to acquire XLM, which you can do by consulting our [section on lumens](https://stellar.org/learn/lumens). Because this tutorial runs on the [test network](../../../learn/fundamentals/networks.mdx), you can get 10,000 test XLM from Friendbot, which is a friendly account funding tool.

To do that, send Friendbot the public key you created. It’ll create and fund a new account using that public key as the account ID.

<CodeExample>

```js
import {
  TransactionBuilder,
  BASE_FEE,
  Networks,
  Operation,
  Asset,
  humanizeEvents,
} from "@stellar/stellar-sdk";
import { Server } from "@stellar/stellar-sdk/rpc";

// See https://developers.stellar.org/docs/data/apis/api-providers
const server = new Server("https://soroban-testnet.stellar.org");

// Not necessary for creation, just used later to demo balance fetch.
const testnetUsdc = new Asset(
  "USDC",
  "GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5",
);

(async function main() {
  try {
    const response = await server.requestAirdrop(pair.publicKey());
    console.log("SUCCESS! You have a new account:\n", response);
  } catch (e) {
    console.error("ERROR!", e);
  }

  // After you've got your test lumens from friendbot, we can also use
  // that account to create a new account on the ledger.
  var parentAccount = await server.getAccount(pair.publicKey());

  // Generate a random account.
  var childAccount = Keypair.random();

  let createAccountTx = new TransactionBuilder(parentAccount, {
    fee: BASE_FEE,
    networkPassphrase: Networks.TESTNET,
  })
    .addOperation(
      Operation.createAccount({
        destination: childAccount.publicKey(),
        startingBalance: "5",
      }),
    )
    // Not needed for creation, just used in the later example
    .addOperation(Operation.changeTrust({ asset: testnetUsdc }))
    .setTimeout(180)
    .build();

  // Sign the transaction with the account that was created from friendbot.
  createAccountTx.sign(pair);

  // Submit the transaction and wait for it to be accepted by the network.
  const sendTxResponse = await server.sendTransaction(createAccountTx);
  if (sendTxResponse.status !== "PENDING") {
    console.log(`There was an error: ${JSON.stringify(sendTxResponse)}`);
    throw sendTxResponse;
  }

  const txResponse = await server.pollTransaction(sendTxResponse.hash);
  if (txResponse.status !== "SUCCESS") {
    console.log(
      `Transaction status: ${txResponse.status}, events: ${humanizeEvents(
        txResponse.diagnosticEvents,
      )}`,
    );
  }

  console.log("Created the new account", childAccount.publicKey());
})();
```

```java
// The SDK does not have tools for creating test accounts, so you'll have to
// make your own HTTP request.
import java.net.*;
import java.io.*;
import java.util.*;

String friendbotUrl = String.format(
  "https://friendbot.stellar.org/?addr=%s",
  pair.getAccountId());
InputStream response = new URL(friendbotUrl).openStream();
String body = new Scanner(response, "UTF-8").useDelimiter("\\A").next();
System.out.println("SUCCESS! You have a new account :)\n" + body);
```

```go
package main

import (
  "context"
  "fmt"
  "io"
  "log"
  "net/http"
  "net/url"

  "github.com/stellar/go/keypair"
  "github.com/stellar/go/network"
  "github.com/stellar/go/txnbuild"

  "github.com/stellar/stellar-rpc/client"
)

const (
  rpcURL                = "https://soroban-testnet.stellar.org"
  friendbotURL          = "https://friendbot.stellar.org/?addr="
  pollInitialDelay      = time.Second
  pollAttempts          = 10
)


func main() {
  // Assume `parent` is still defined as above
  ctx := context.Background()
  cli := client.NewClient(rpcURL, nil)

  parentAccount, err := cli.LoadAccount(ctx, parent.Address())
  check(err)

  child := keypair.MustRandom()
  usdcAsset := txnbuild.CreditAsset{Code: "USDC", Issuer: testnetUSDCIssuer}

  tx, err := txnbuild.NewTransaction(txnbuild.TransactionParams{
    SourceAccount:        parentAccount,
    IncrementSequenceNum: true,
    BaseFee:              txnbuild.MinBaseFee,
    Preconditions: txnbuild.Preconditions{
      TimeBounds: txnbuild.NewInfiniteTimeout(),
    },
    Operations: []txnbuild.Operation{
      &txnbuild.CreateAccount{
        Destination: child.Address(),
        Amount:      "5",
      },
      // Not needed for creation, just used in the later example
      &txnbuild.ChangeTrust{
        Line: usdcAsset.MustToChangeTrustAsset(),
      },
    },
  })
  check(err)

  tx, err = tx.Sign(network.TestNetworkPassphrase, parent)
  check(err)

  resp := submitAndAwait(ctx, cli, tx)
  log.Printf("Transaction confirmed in ledger %d", resp.Ledger)
  log.Printf("Created the new account %s", child.Address())
}

func requestAirdrop(address string) string {
  resp, err := http.Get(friendbotURL + url.QueryEscape(address))
  check(err)
  defer resp.Body.Close()

  body, err := io.ReadAll(resp.Body)
  check(err)
  if resp.StatusCode >= 400 {
    log.Fatalf("friendbot returned %s: %s", resp.Status, string(body))
  }

  return string(body)
}
```

```python
# The SDK does not have tools for creating test accounts, so you'll have to
# make your own HTTP request.

# if you're trying this on Python, install the `requests` library.
import requests

response = requests.get(f"https://friendbot.stellar.org?addr={pair.public_key}")
if response.status_code == 200:
    print(f"SUCCESS! You have a new account :)\n{response.text}")
else:
    print(f"ERROR! Response: \n{response.text}")
```

</CodeExample>

Now for the last step: getting the account’s details and checking its balance. Accounts can carry multiple balances — one for each type of currency they hold. Because the Stellar network stores data in a key-value store, you must either (a) know which assets you hold or (b) let your users add them.

<CodeExample>

```js
// Assume that `pair`, `server`, and `testnetUsdc` still exist from before
const accountEntry = await server.getAccountEntry(pair.publicKey());
console.log("Balance for account: " + pair.publicKey());
console.log("XLM:", accountEntry.balance().toString());

// You can also fetch trustline or smart contract balances:
const trustlineEntry = await server.getTrustline(pair.publicKey(), testnetUsdc);
console.log("USDC:", trustlineEntry.balance().toString());

const testnetUsdcSac =
  "CBIELTK6YBZJU5UP2WWQEUCYKLPU6AUNZ2BQ4WWFEIE3USCIHMXQDAMA";
const xlmInContract = await server.getSACBalance(
  testnetUsdcSac,
  Asset.native(),
  Networks.TESTNET,
);
console.log("XLM in USDC contract:", xlmInContract.balanceEntry.amount);
```

```java
import org.stellar.sdk.Server;
import org.stellar.sdk.responses.AccountResponse;

Server server = new Server("https://horizon-testnet.stellar.org");
AccountResponse account = server.accounts().account(pair.getAccountId());
System.out.println("Balances for account " + pair.getAccountId());
for (AccountResponse.Balance balance : account.getBalances()) {
  System.out.printf(
    "Type: %s, Code: %s, Balance: %s%n",
    balance.getAssetType(),
    balance.getAssetCode(),
    balance.getBalance()
  );
}
```

```go
package main

import (
  "log"
  "context"

  "github.com/stellar/go/xdr"

  "github.com/stellar/stellar-rpc/client"
  "github.com/stellar/stellar-rpc/protocol"
)

const (
  rpcURL                = "https://soroban-testnet.stellar.org"
  testnetUSDCContractID = "CBIELTK6YBZJU5UP2WWQEUCYKLPU6AUNZ2BQ4WWFEIE3USCIHMXQDAMA"
)

func main() {
  ctx := context.TODO()
  cli := client.NewClient(rpcURL, nil)

  // Assume `child` is defined as in the beginning
  accountEntry := getAccountEntry(ctx, cli, child.Address())
  log.Printf("Balance for account %s", child.Address())
  log.Printf("XLM: %s", amount.String(accountEntry.Balance))

  trustlineEntry := getTrustlineEntry(ctx, cli, child.Address(), usdcAsset)
  log.Printf("USDC trustline balance (raw): %d", trustlineEntry.Balance)

  sacAmount := getSACBalance(ctx, cli, testnetUSDCContractID,
    xdr.MustNewNativeAsset(), network.TestNetworkPassphrase)
  log.Printf("XLM in USDC contract (raw): %s", sacAmount)
}
```

```python
from stellar_sdk import *
from stellar_sdk.xdr import *

RPC_URL = "https://soroban-testnet.stellar.org"
TESTNET_USDC_ISSUER = "GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5"
TESTNET_USDC_CONTRACT = "CBIELTK6YBZJU5UP2WWQEUCYKLPU6AUNZ2BQ4WWFEIE3USCIHMXQDAMA"
SERVER = SorobanServer(RPC_URL)


def check_balances(address: str) -> None:
    usdc_asset = Asset("USDC", TESTNET_USDC_ISSUER)

    native_balance = load_native_balance(address)
    print(f"Balance for account {address}")
    print(f"XLM: {native_balance}")

    trustline = get_trustline(address, usdc_asset)
    print(f"USDC trustline balance (raw): {trustline}")

    # unrelated to the account
    sac_amount = get_sac_balance(
        TESTNET_USDC_CONTRACT, Asset.native(), Network.TESTNET_NETWORK_PASSPHRASE
    )
    print(f"XLM in USDC contract (raw): {sac_amount}")
```

</CodeExample>

Now that you’ve got an account, you can [start sending and receiving payments](send-and-receive-payments.mdx), or, if you're ready to hunker down, you can skip ahead and [build a wallet](../../apps/wallet/overview.mdx) or [issue a Stellar-network asset](../../../tokens/anatomy-of-an-asset.mdx).

<Alert>

In the above code samples, proper error checking is omitted for brevity. However, you should _always_ validate your results, as there are many ways that requests can fail. You should refer to the guide on [Error Handling](../../../data/apis/horizon/api-reference/errors/error-handling.mdx) for tips on error management strategies.

</Alert>

## Footnote

Some SDK languages have more utilities than others. Utility functions referenced above that aren't native to the SDKs are defined here, such as `pollTransaction` in the Go SDK.

<Details summary="Transaction submission">

<CodeExample>

```go
import (
  "context"
  "log"
  "strings"
  "time"

  "github.com/stellar/go/amount"
  "github.com/stellar/go/strkey"
  "github.com/stellar/go/xdr"

  "github.com/stellar/stellar-rpc/client"
  "github.com/stellar/stellar-rpc/protocol"
)

func submitAndAwait(
  ctx context.Context,
  cli *client.Client,
  tx *txnbuild.Transaction,
) protocol.GetTransactionResponse {
  txnB64, err := tx.Base64()
  check(err)

  sendResp, err := cli.SendTransaction(ctx, protocol.SendTransactionRequest{Transaction: txnB64})
  check(err)
  if sendResp.Status != "PENDING" {
    log.Fatalf("transaction submission failed with status %s", sendResp.Status)
  }

  return pollTransaction(ctx, cli, sendResp.Hash)
}

func pollTransaction(ctx context.Context, cli *client.Client, hash string) protocol.GetTransactionResponse {
  delay := pollInitialDelay
  for range pollAttempts {
    resp, err := cli.GetTransaction(ctx, protocol.GetTransactionRequest{Hash: hash})
    check(err)

    switch resp.Status {
    case protocol.TransactionStatusSuccess:
      return resp
    case protocol.TransactionStatusFailed:
      log.Fatalf("transaction failed: %s", strings.Join(resp.DiagnosticEventsXDR, "\n"))
    case protocol.TransactionStatusNotFound:
      // keep polling
    default:
      // unexpected status, continue polling in case it's transient
    }

    select {
    case <-ctx.Done():
      log.Fatalf("context cancelled while polling: %v", ctx.Err())
    case <-time.After(delay):
    }
    delay += pollInitialDelay
  }

  log.Fatalf("transaction %s not found after polling", hash)
  return protocol.GetTransactionResponse{}
}
```

```python
import time
from stellar_sdk import *
from stellar_sdk.soroban_rpc import GetTransactionStatus, SendTransactionStatus

RPC_URL = "https://soroban-testnet.stellar.org"
POLL_DELAY_SECONDS = 1
POLL_ATTEMPTS = 10

SERVER = SorobanServer(RPC_URL)

def send_transaction(transaction):
    response = SERVER.send_transaction(transaction)
    check(
        response.status == SendTransactionStatus.PENDING,
        f"Transaction submission failed: {response.status}",
    )
    return response

def poll_transaction(hash_: str):
    for attempt in range(POLL_ATTEMPTS):
        response = SERVER.get_transaction(hash_)
        if response.status == GetTransactionStatus.SUCCESS:
            return response
        if response.status == GetTransactionStatus.FAILED:
            raise RuntimeError(f"Transaction failed: {response.diagnostic_events_xdr}")
        time.sleep(POLL_DELAY_SECONDS * (attempt + 1))
    raise RuntimeError(f"Transaction {hash_} not found after polling")
```

</CodeExample>

</Details>

<Details summary="Retrieving account details">

<CodeExample>

```go
import (
  "context"
  "log"

  "github.com/stellar/go/xdr"

  "github.com/stellar/stellar-rpc/client"
  "github.com/stellar/stellar-rpc/protocol"
)

func getAccountEntry(ctx context.Context, cli *client.Client, address string) *xdr.AccountEntry {
  ledgerKey := xdr.LedgerKey{
    Type: xdr.LedgerEntryTypeAccount,
    Account: &xdr.LedgerKeyAccount{
      AccountId: xdr.MustAddress(address),
    },
  }

  keyB64, err := xdr.MarshalBase64(ledgerKey)
  check(err)

  resp, err := cli.GetLedgerEntries(ctx, protocol.GetLedgerEntriesRequest{Keys: []string{keyB64}})
  check(err)
  if len(resp.Entries) == 0 {
    log.Fatalf("account %s not found", address)
  }

  var ledgerData xdr.LedgerEntryData
  check(xdr.SafeUnmarshalBase64(resp.Entries[0].DataXDR, &ledgerData))
  if ledgerData.Account == nil {
    log.Fatalf("ledger entry for %s missing account data", address)
  }

  return ledgerData.Account
}
```

```python

def load_native_balance(account_id: str) -> int:
    key = LedgerKey(
        LedgerEntryType.ACCOUNT,
        account=LedgerKeyAccount(
            account_id=Keypair.from_public_key(account_id).xdr_account_id()
        ),
    )
    response = SERVER.get_ledger_entries([key])
    check(response.entries, f"account {account_id} not found")

    account = LedgerEntryData.from_xdr(response.entries[0].xdr).account
    check(account is not None, "ledger entry missing account data")
    return account.balance.int64
```

</CodeExample>

</Details>

<Details summary="Retrieving trustline details">

<CodeExample>

```go
import (
  "context"
  "log"

  "github.com/stellar/go/xdr"

  "github.com/stellar/stellar-rpc/client"
  "github.com/stellar/stellar-rpc/protocol"
)

func getTrustlineEntry(ctx context.Context, cli *client.Client, account string, asset txnbuild.CreditAsset) xdr.TrustLineEntry {
  trustlineAsset, err := asset.MustToTrustLineAsset().ToXDR()
  check(err)

  ledgerKey := xdr.LedgerKey{
    Type: xdr.LedgerEntryTypeTrustline,
    TrustLine: &xdr.LedgerKeyTrustLine{
      AccountId: xdr.MustAddress(account),
      Asset:     trustlineAsset,
    },
  }

  keyB64, err := xdr.MarshalBase64(ledgerKey)
  check(err)

  resp, err := cli.GetLedgerEntries(ctx, protocol.GetLedgerEntriesRequest{Keys: []string{keyB64}})
  check(err)
  if len(resp.Entries) == 0 {
    check(fmt.Errorf("trustline for %s:%s not found", asset.Code, asset.Issuer))
  }

  var ledgerData xdr.LedgerEntryData
  check(xdr.SafeUnmarshalBase64(resp.Entries[0].DataXDR, &ledgerData))
  return ledgerData.MustTrustLine()
}
```

```python
def get_trustline(account_id: str, asset: Asset) -> int:
    key = LedgerKey(
        LedgerEntryType.TRUSTLINE,
        trust_line=LedgerKeyTrustLine(
            account_id=Keypair.from_public_key(account_id).xdr_account_id(),
            asset=asset.to_trust_line_xdr_object(),
        ),
    )
    response = SERVER.get_ledger_entries([key])
    if not response.entries:
        return 0
    ledger_entry = LedgerEntryData.from_xdr(response.entries[0].xdr)
    trust_line = ledger_entry.trust_line
    if trust_line is None:
        return 0
    return trust_line.balance.int64
```

</CodeExample>

</Details>

<Details summary="Retrieving the SAC balance held by a contract">

<CodeExample>

```go
import (
  "context"
  "log"

  "github.com/stellar/go/amount"
  "github.com/stellar/go/strkey"
  "github.com/stellar/go/xdr"

  "github.com/stellar/stellar-rpc/client"
  "github.com/stellar/stellar-rpc/protocol"
)

func getSACBalance(ctx context.Context, cli *client.Client, contractID string, asset xdr.Asset, networkPassphrase string) string {
  targetContract, err := decodeContractID(contractID)
  check(err)

  sacContractHash, err := asset.ContractID(networkPassphrase)
  check(err)

  sacContractID := xdr.ContractId(sacContractHash)
  sacAddress := xdr.ScAddress{Type: xdr.ScAddressTypeScAddressTypeContract, ContractId: &sacContractID}
  targetAddress := xdr.ScAddress{Type: xdr.ScAddressTypeScAddressTypeContract, ContractId: &targetContract}
  balanceSymbol, err := xdr.NewScVal(xdr.ScValTypeScvSymbol, xdr.ScSymbol("Balance"))
  check(err)

  addressVal, err := xdr.NewScVal(xdr.ScValTypeScvAddress, targetAddress)
  check(err)

  vec := xdr.ScVec{balanceSymbol, addressVal}
  keyVal, err := xdr.NewScVal(xdr.ScValTypeScvVec, &vec)
  check(err)

  ledgerKey := xdr.LedgerKey{
    Type: xdr.LedgerEntryTypeContractData,
    ContractData: &xdr.LedgerKeyContractData{
      Contract:   sacAddress,
      Key:        keyVal,
      Durability: xdr.ContractDataDurabilityPersistent,
    },
  }

  keyB64, err := xdr.MarshalBase64(ledgerKey)
  check(err)

  resp, err := cli.GetLedgerEntries(ctx, protocol.GetLedgerEntriesRequest{Keys: []string{keyB64}})
  check(err)
  if len(resp.Entries) == 0 {
    return "0"
  }

  var ledgerData xdr.LedgerEntryData
  check(xdr.SafeUnmarshalBase64(resp.Entries[0].DataXDR, &ledgerData))

  balanceMap := ledgerData.MustContractData().Val.MustMap()
  for _, entry := range *balanceMap {
    key := string(entry.Key.MustSym())
    switch key {
    case "amount":
      return amount.String128Raw(entry.Val.MustI128())
    }
  }

  return "0"
}

func decodeContractID(contractID string) (xdr.ContractId, error) {
  bytes, err := strkey.Decode(strkey.VersionByteContract, contractID)
  if err != nil {
    return xdr.ContractId{}, err
  }
  var id xdr.ContractId
  copy(id[:], bytes)
  return id, nil
}
```

```python
def get_sac_balance(contract_id: str, asset: Asset, network_passphrase: str) -> int:
    target_contract = StrKey.decode_contract(contract_id)
    sac_contract_id = StrKey.decode_contract(asset.contract_id(network_passphrase))
    key = LedgerKey(
        LedgerEntryType.CONTRACT_DATA,
        contract_data=LedgerKeyContractData(
            contract=SCAddress(
                SCAddressType.SC_ADDRESS_TYPE_CONTRACT, contract_id=sac_contract_id
            ),
            key=_sac_balance_key(target_contract),
            durability=ContractDataDurability.PERSISTENT,
        ),
    )
    response = SERVER.get_ledger_entries([key])
    if not response.entries:
        return 0

    ledger_entry = LedgerEntryData.from_xdr(response.entries[0].xdr)
    contract_data = ledger_entry.contract_data
    if contract_data is None or contract_data.val.map is None:
        return 0

    for entry in contract_data.val.map.sc_map:
        if (
            entry.key.discriminant == SCValType.SCV_SYMBOL
            and entry.key.sym == SCSymbol(b"Balance")
        ):
            return scval_i128_to_int(entry.val)

    return 0
```

</CodeExample>

</Details>

<Details summary="Error handling">

<CodeExample>

```go
func check(err error) {
  if err != nil {
    log.Fatal(err)
  }
}
```

```python
def check(condition: bool, message: str) -> None:
    if not condition:
        raise RuntimeError(message)
```

</CodeExample>

</Details>

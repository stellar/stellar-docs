---
title: Complete Guide to Integrating Goldsky with Stellar Frontend Applications
description: Learn how to set up data indexing, create pipelines, and build production-ready frontend applications using Goldsky's Stellar indexer.
---

# Complete Guide to Integrating Goldsky with Stellar Frontend Applications

## Introduction to Indexers

### What are Indexers?

Indexers are specialized data infrastructure tools that continuously monitor blockchain networks, extract relevant data, and organize it in a queryable format. Think of them as sophisticated data pipelines that transform raw blockchain data into structured, accessible information for applications.

In the context of Stellar, indexers serve as the bridge between the complex, low-level blockchain data and your application's need for fast, reliable access to specific information. Rather than querying the Stellar network directly for every piece of data your application needs, indexers pre-process and store this information in optimized databases.

### Role in Data Management and Retrieval

Indexers play several critical roles in modern blockchain application architecture:

**Data Transformation**: Raw blockchain data is often in formats that are difficult to work with directly. Indexers transform this data into structured formats like JSON or SQL tables that are familiar to web developers.

**Performance Optimization**: Instead of making expensive blockchain queries in real-time, indexers pre-compute and cache frequently needed data, dramatically improving application response times.

**Historical Data Access**: Blockchain nodes typically only maintain recent state. Indexers preserve historical data, enabling applications to show trends, analytics, and historical context.

**Real-time Updates**: Modern indexers provide real-time data streams, allowing applications to react immediately to blockchain events without constant polling.

**Query Flexibility**: Indexers enable complex queries across multiple data types (transactions, events, account states) that would be impossible or extremely expensive to perform directly on-chain.

### Types of Data Indexers Can Provide

Stellar indexers like Goldsky can provide comprehensive access to various data types:

**Transaction Data**: Complete transaction history including payments, account creation, trust line changes, and all other Stellar operations with full metadata and success/failure status.

**Smart Contract Events**: Detailed logs from Soroban smart contracts, including event topics, data payloads, and execution context, enabling applications to track contract interactions and state changes.

**Account Information**: Real-time and historical account balances, trust lines, signers, and other account-level data across all assets on the Stellar network.

**Protocol-Specific Data**: For DeFi protocols like Blend, indexers can extract and structure protocol-specific events like lending, borrowing, liquidations, and governance actions.

**Aggregated Metrics**: Pre-computed statistics like trading volumes, user counts, protocol TVL (Total Value Locked), and other analytics that would be expensive to calculate on-demand.

**Cross-Chain Data**: Advanced indexers can correlate Stellar data with other blockchain networks, providing a unified view for multi-chain applications.

## Setting up Data Retrieval with Goldsky

### Installing and Configuring Goldsky CLI

The first step in working with Goldsky is installing their command-line interface (CLI), which provides the primary method for configuring data pipelines and managing your indexing infrastructure.

```bash
# Install the Goldsky CLI globally

# Option 1: macOS/Linux (using the install script)
curl https://goldsky.com | sh

# Option 2: Any platform (via npm, requires Node.js)
npm install -g @goldsky/cli

# Verify the installation was successful
goldsky --version
```

After installation, you'll need to authenticate with your Goldsky account:

```bash
# Log in to your Goldsky account
goldsky login

# This will open a browser window for authentication
# Follow the prompts to complete login
```

Once authenticated, verify your setup and explore available datasets:

```bash
# Check your account status
goldsky account

# List available datasets
goldsky datasets list
```

### Understanding Stellar Data Schema

Before creating pipelines, it's essential to understand the structure of Stellar data available through Goldsky. The Stellar blockchain data is organized hierarchically:

```
Ledger
â”œâ”€â”€ Transactions[]
    â”œâ”€â”€ Operations[]
    â””â”€â”€ Events[]
```

**Contract Events Schema**: The most commonly used data type for DeFi applications, contract events contain rich information about smart contract interactions:

```typescript
interface ContractEvent {
  id: string;
  transaction_hash: string;
  transaction_id: number;
  max_fee?: number; // Made optional as not all events have these fields
  fee_charged?: number;
  successful: boolean;
  ledger_sequence: number;
  closed_at: number;
  in_successful_contract_call: boolean;
  contract_id: string;
  type: number;
  type_string: string;
  topics: string;
  topics_decoded: string;
  data: string;
  data_decoded: string;
  contract_event_xdr: string;
}
```

**Transaction Schema**: For applications that need to track broader transaction patterns:

```typescript
interface Transaction {
  transaction_hash: string;
  account: string;
  account_sequence: number;
  max_fee?: number; // Made optional for consistency
  fee_charged?: number;
  successful: boolean;
  ledger_sequence: number;
  closed_at: number;
  // ... additional fields
}
```

### Step-by-Step Pipeline Creation

#### Method 1: Visual Pipeline Builder (Goldsky Flow)

For users who prefer a visual interface, Goldsky provides a web-based pipeline builder:

1. **Access Goldsky Flow**:

   ```bash
   goldsky flow
   ```

2. **Configure Data Source**: Select `stellar.events_v2` as your data source and specify the starting point (earliest, latest, or specific ledger).

3. **Add Filters**: Create SQL transformations to filter for specific events:

   ```sql
   SELECT *
   FROM events_v2
   WHERE contract_id = 'BLEND_CONTRACT_ID'
   AND type_string = 'supply_collateral'
   ```

4. **Configure Output**: Choose your destination (PostgreSQL, webhook, or API endpoint).

#### Method 2: YAML Configuration (Recommended for Production)

For production applications, YAML configuration files provide better version control and reproducibility:

```yaml
# blend-events-pipeline.yaml
name: blend-supply-collateral-events
resource_size: s
apiVersion: 3

sources:
  stellar_events:
    type: dataset
    dataset_name: stellar.events_v2
    version: 1.0.0
    start_at: earliest

transforms:
  blend_supply_events:
    type: sql
    sql: |
      SELECT
        id,
        transaction_hash,
        ledger_sequence,
        closed_at,
        contract_id,
        type_string,
        topics_decoded,
        data_decoded,
        successful
      FROM stellar_events
      WHERE type_string = 'supply_collateral'
        AND successful = true
        AND contract_id LIKE '%blend%'
      ORDER BY closed_at DESC
    primary_key: id

sinks:
  postgres_sink:
    type: postgres
    secret_name: YOUR_POSTGRES_SECRET
    from: blend_supply_events
    table: blend_supply_events
```

Deploy the pipeline:

```bash
goldsky pipeline apply blend-events-pipeline.yaml --status ACTIVE
```

#### Creating API Endpoints

For frontend applications, you'll often want to create API endpoints that your application can query directly:

```yaml
# blend-api-pipeline.yaml
name: blend-api-endpoint
resource_size: s
apiVersion: 3

sources:
  stellar_events:
    type: dataset
    dataset_name: stellar.events_v2
    version: 1.0.0
    start_at: latest

transforms:
  recent_blend_events:
    type: sql
    sql: |
      SELECT
        transaction_hash,
        ledger_sequence,
        closed_at as timestamp,
        JSON_EXTRACT(data_decoded, '$.amount') as amount,
        JSON_EXTRACT(data_decoded, '$.user') as user_address,
        JSON_EXTRACT(data_decoded, '$.asset') as asset_code
      FROM stellar_events
      WHERE type_string = 'supply_collateral'
        AND successful = true
        AND closed_at > UNIX_TIMESTAMP() - 86400
      ORDER BY closed_at DESC
      LIMIT 100
    primary_key: transaction_hash

sinks:
  webhook_sink:
    type: webhook
    url: https://your-api.com/webhook/blend-events
    from: recent_blend_events
```

## Frontend Integration

### Understanding the Goldsky Architecture

Unlike direct API services, Goldsky operates as a data pipeline platform that streams indexed blockchain data to your own infrastructure. This means your frontend application doesn't connect directly to Goldsky - instead, you:

1. **Create Goldsky pipelines** that stream data to your database or webhook endpoints
2. **Build your own API** that queries your database
3. **Connect your frontend** to your own API endpoints

This architecture provides better performance, reliability, and control over your data.

### Setting Up Your Data Infrastructure

First, you'll need a database to receive the streamed data. Here's how to set up a PostgreSQL database for Blend protocol events:

```sql
-- Create table for Blend supply collateral events
CREATE TABLE blend_supply_events (
    id VARCHAR(255) PRIMARY KEY,
    transaction_hash VARCHAR(255) NOT NULL,
    ledger_sequence BIGINT NOT NULL,
    closed_at BIGINT NOT NULL,
    contract_id VARCHAR(255) NOT NULL,
    type_string VARCHAR(100) NOT NULL,
    topics_decoded TEXT,
    data_decoded JSONB, -- Using JSONB for better performance
    successful BOOLEAN NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Add indexes for better query performance
CREATE INDEX idx_blend_events_closed_at ON blend_supply_events(closed_at);
CREATE INDEX idx_blend_events_contract ON blend_supply_events(contract_id);
CREATE INDEX idx_blend_events_type ON blend_supply_events(type_string);
-- Added GIN index for JSON queries
CREATE INDEX idx_blend_events_data_decoded ON blend_supply_events USING gin (data_decoded);
```

:::tip Alternative: Using Prisma ORM

If you prefer using Prisma for type-safe database operations, here's how to set up the same schema:

```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model BlendSupplyEvent {
  id               String   @id
  transactionHash  String   @map("transaction_hash")
  ledgerSequence   BigInt   @map("ledger_sequence")
  closedAt         BigInt   @map("closed_at")
  contractId       String   @map("contract_id")
  typeString       String   @map("type_string")
  topicsDecoded    String?  @map("topics_decoded")
  dataDecoded      Json?    @map("data_decoded") // Using Json type for Prisma
  successful       Boolean
  createdAt        DateTime @default(now()) @map("created_at")

  @@index([closedAt])
  @@index([contractId])
  @@index([typeString])
  @@map("blend_supply_events")
}
```

Then generate the client:

```bash
npx prisma generate
npx prisma db push
```

:::

:::tip Alternative: Using Supabase

For even faster setup, you can use Supabase which provides a hosted PostgreSQL database with a great developer experience:

1. **Create a Supabase project** at [supabase.com](https://supabase.com)

2. **Run the SQL in Supabase SQL Editor**:

```sql
-- Same SQL as above, Supabase handles the rest
CREATE TABLE blend_supply_events (
    id VARCHAR(255) PRIMARY KEY,
    transaction_hash VARCHAR(255) NOT NULL,
    ledger_sequence BIGINT NOT NULL,
    closed_at BIGINT NOT NULL,
    contract_id VARCHAR(255) NOT NULL,
    type_string VARCHAR(100) NOT NULL,
    topics_decoded TEXT,
    data_decoded JSONB,
    successful BOOLEAN NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

3. **Get your connection string** from Project Settings â†’ Database :::

### Building Your API Layer

Create API endpoints that your frontend can consume. Here's a Next.js API route example:

```typescript
// pages/api/blend-events.ts
import { NextApiRequest, NextApiResponse } from "next";
import { Pool } from "pg";

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});

export interface BlendSupplyEvent {
  id: string;
  transaction_hash: string;
  ledger_sequence: number;
  closed_at: number;
  user_address: string;
  amount: string;
  asset_code: string;
}

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse,
) {
  if (req.method !== "GET") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const { limit = "50", user, asset } = req.query;

    let query = `
      SELECT 
        id,
        transaction_hash,
        ledger_sequence,
        closed_at,
        data_decoded->>'user' as user_address,
        data_decoded->>'amount' as amount,
        data_decoded->>'asset' as asset_code
      FROM blend_supply_events
      WHERE successful = true
    `;

    const params: any[] = [];
    let paramIndex = 1;

    if (user) {
      query += ` AND data_decoded->>'user' = $${paramIndex}`;
      params.push(user);
      paramIndex++;
    }

    if (asset) {
      query += ` AND data_decoded->>'asset' = $${paramIndex}`;
      params.push(asset);
      paramIndex++;
    }

    query += ` ORDER BY closed_at DESC LIMIT $${paramIndex}`;
    params.push(parseInt(limit as string));

    const result = await pool.query(query, params);

    res.status(200).json({
      events: result.rows,
      total: result.rowCount,
    });
  } catch (error) {
    console.error("Database query error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
}
```

:::tip Alternative: Using Prisma in API Routes

Here's the same API endpoint using Prisma for better type safety:

```typescript
// pages/api/blend-events.ts
import { NextApiRequest, NextApiResponse } from "next";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse,
) {
  if (req.method !== "GET") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const { limit = "50", user, asset } = req.query;

    const events = await prisma.blendSupplyEvent.findMany({
      where: {
        successful: true,
        ...(user && {
          dataDecoded: {
            path: ["user"],
            equals: user,
          },
        }),
        ...(asset && {
          dataDecoded: {
            path: ["asset"],
            equals: asset,
          },
        }),
      },
      orderBy: {
        closedAt: "desc",
      },
      take: parseInt(limit as string),
      select: {
        id: true,
        transactionHash: true,
        ledgerSequence: true,
        closedAt: true,
        dataDecoded: true,
      },
    });

    const transformedEvents = events.map((event) => ({
      ...event,
      user_address: event.dataDecoded?.user,
      amount: event.dataDecoded?.amount,
      asset_code: event.dataDecoded?.asset,
    }));

    res.status(200).json({
      events: transformedEvents,
      total: events.length,
    });
  } catch (error) {
    console.error("Database query error:", error);
    res.status(500).json({ error: "Internal server error" });
  } finally {
    await prisma.$disconnect();
  }
}
```

:::

:::tip Alternative: Using Supabase Client

For Supabase, you can use their JavaScript client for even simpler database operations:

```typescript
// pages/api/blend-events.ts
import { NextApiRequest, NextApiResponse } from "next";
import { createClient } from "@supabase/supabase-js";

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!,
);

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse,
) {
  if (req.method !== "GET") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const { limit = "50", user, asset } = req.query;

    let query = supabase
      .from("blend_supply_events")
      .select("*")
      .eq("successful", true)
      .order("closed_at", { ascending: false })
      .limit(parseInt(limit as string));

    if (user) {
      query = query.eq("data_decoded->>user", user);
    }

    if (asset) {
      query = query.eq("data_decoded->>asset", asset);
    }

    const { data: events, error } = await query;

    if (error) throw error;

    res.status(200).json({
      events: events || [],
      total: events?.length || 0,
    });
  } catch (error) {
    console.error("Database query error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
}
```

Install the Supabase client:

```bash
npm install @supabase/supabase-js
```

:::

### Frontend Data Fetching

Create a client to fetch data from your own API:

```typescript
// lib/blend-api-client.ts
export interface BlendSupplyEvent {
  id: string;
  transaction_hash: string;
  ledger_sequence: number;
  closed_at: number;
  user_address: string;
  amount: string;
  asset_code: string;
}

export class BlendApiClient {
  private baseUrl: string;

  constructor(baseUrl: string = "") {
    this.baseUrl = baseUrl;
  }

  async getBlendSupplyEvents(
    options: {
      limit?: number;
      user?: string;
      asset?: string;
    } = {},
  ): Promise<BlendSupplyEvent[]> {
    try {
      const params = new URLSearchParams();

      if (options.limit) params.append("limit", options.limit.toString());
      if (options.user) params.append("user", options.user);
      if (options.asset) params.append("asset", options.asset);

      const url = `${this.baseUrl}/api/blend-events?${params.toString()}`;
      const response = await fetch(url);

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      return data.events || [];
    } catch (error) {
      console.error("Error fetching Blend supply events:", error);
      throw error;
    }
  }

  async getEventsByUser(userAddress: string): Promise<BlendSupplyEvent[]> {
    return this.getBlendSupplyEvents({ user: userAddress });
  }

  async getEventsByAsset(assetCode: string): Promise<BlendSupplyEvent[]> {
    return this.getBlendSupplyEvents({ asset: assetCode });
  }
}
```

### React Hooks for Data Management

Create reusable React hooks:

```typescript
// hooks/useBlendEvents.ts
import { useState, useEffect } from "react";
import { BlendApiClient, BlendSupplyEvent } from "../lib/blend-api-client";

export function useBlendEvents(
  options: {
    limit?: number;
    user?: string;
    asset?: string;
  } = {},
) {
  const [events, setEvents] = useState<BlendSupplyEvent[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const client = new BlendApiClient();

    async function fetchEvents() {
      try {
        setLoading(true);
        const data = await client.getBlendSupplyEvents(options);
        setEvents(data);
        setError(null);
      } catch (err) {
        setError(err instanceof Error ? err.message : "Unknown error");
      } finally {
        setLoading(false);
      }
    }

    fetchEvents();
  }, [options.limit, options.user, options.asset]);

  return { events, loading, error };
}
```

### Displaying Data Effectively in Applications

Create polished UI components that present the indexed data in an intuitive, user-friendly format:

```tsx
// components/BlendEventsTable.tsx
import React from "react";
import { BlendSupplyEvent } from "../lib/blend-api-client";

interface BlendEventsTableProps {
  events: BlendSupplyEvent[];
  loading: boolean;
  error: string | null;
}

export function BlendEventsTable({
  events,
  loading,
  error,
}: BlendEventsTableProps) {
  if (loading) {
    return (
      <div className="flex justify-center items-center p-8">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
        <span className="ml-2">Loading Blend events...</span>
      </div>
    );
  }

  if (error) {
    return (
      <div className="bg-red-50 border border-red-200 rounded-md p-4">
        <div className="text-red-800">
          <strong>Error:</strong> {error}
        </div>
      </div>
    );
  }

  if (events.length === 0) {
    return (
      <div className="text-center p-8 text-gray-500">
        No Blend supply events found.
      </div>
    );
  }

  return (
    <div className="overflow-x-auto">
      <table className="min-w-full bg-white border border-gray-200">
        <thead className="bg-gray-50">
          <tr>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Transaction
            </th>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              User
            </th>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Amount
            </th>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Asset
            </th>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Time
            </th>
          </tr>
        </thead>
        <tbody className="bg-white divide-y divide-gray-200">
          {events.map((event) => (
            <tr key={event.transaction_hash} className="hover:bg-gray-50">
              <td className="px-6 py-4 whitespace-nowrap">
                <a
                  href={
                    "https://stellar.expert/explorer/public/tx/" +
                    event.transaction_hash
                  }
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-blue-600 hover:text-blue-800 font-mono text-sm"
                >
                  {event.transaction_hash.substring(0, 8)}...
                </a>
              </td>
              <td className="px-6 py-4 whitespace-nowrap">
                <span className="font-mono text-sm">
                  {event.user_address.substring(0, 8)}...
                </span>
              </td>
              <td className="px-6 py-4 whitespace-nowrap">
                <span className="text-sm font-medium">
                  {parseFloat(event.amount).toLocaleString()}
                </span>
              </td>
              <td className="px-6 py-4 whitespace-nowrap">
                <span className="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-green-100 text-green-800">
                  {event.asset_code}
                </span>
              </td>
              <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                {new Date(event.closed_at * 1000).toLocaleString()}
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}
```

### Real-time Data Updates

For applications requiring real-time updates, implement WebSocket connections:

```typescript
// hooks/useRealtimeBlendEvents.ts
import { useState, useEffect, useRef } from "react";
import { BlendSupplyEvent } from "../lib/blend-api-client";

export function useRealtimeBlendEvents() {
  const [events, setEvents] = useState<BlendSupplyEvent[]>([]);
  const [connected, setConnected] = useState(false);
  const wsRef = useRef<WebSocket | null>(null);

  useEffect(() => {
    const wsUrl = process.env.NEXT_PUBLIC_WS_URL || "ws://localhost:3001/ws";
    const ws = new WebSocket(wsUrl);
    wsRef.current = ws;

    ws.onopen = () => {
      setConnected(true);
      // Subscribe to Blend supply events from your own WebSocket server
      ws.send(
        JSON.stringify({
          type: "subscribe",
          channel: "blend-supply-events",
        }),
      );
    };

    ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        if (data.type === "event" && data.event_type === "supply_collateral") {
          setEvents((prev) => [data.event, ...prev.slice(0, 99)]); // Keep last 100
        }
      } catch (error) {
        console.error("Error parsing WebSocket message:", error);
      }
    };

    ws.onclose = () => {
      setConnected(false);
    };

    ws.onerror = (error) => {
      console.error("WebSocket error:", error);
      setConnected(false);
    };

    return () => {
      ws.close();
    };
  }, []);

  return { events, connected };
}
```

## Complete Application Example

Here's a complete dashboard application that demonstrates all the concepts covered in this guide:

```tsx
// pages/blend-dashboard.tsx
import React, { useState } from "react";
import { BlendEventsTable } from "../components/BlendEventsTable";
import { useBlendEvents } from "../hooks/useBlendEvents";
import { useRealtimeBlendEvents } from "../hooks/useRealtimeBlendEvents";

export default function BlendDashboard() {
  const [viewMode, setViewMode] = useState<"historical" | "realtime">(
    "historical",
  );
  const {
    events: historicalEvents,
    loading,
    error,
  } = useBlendEvents({ limit: 100 });
  const { events: realtimeEvents, connected } = useRealtimeBlendEvents();

  const displayEvents =
    viewMode === "historical" ? historicalEvents : realtimeEvents;

  return (
    <div className="min-h-screen bg-gray-50">
      <div className="max-w-7xl mx-auto py-6 sm:px-6 lg:px-8">
        {/* Header */}
        <div className="bg-white shadow rounded-lg mb-6">
          <div className="px-4 py-5 sm:p-6">
            <h1 className="text-3xl font-bold text-gray-900">
              Blend Protocol Dashboard
            </h1>
            <p className="mt-2 text-sm text-gray-600">
              Real-time and historical supply collateral events from the Blend
              protocol on Stellar
            </p>
          </div>
        </div>

        {/* Controls */}
        <div className="bg-white shadow rounded-lg mb-6">
          <div className="px-4 py-5 sm:p-6">
            <div className="flex items-center justify-between">
              <div className="flex space-x-4">
                <button
                  onClick={() => setViewMode("historical")}
                  className={
                    "px-4 py-2 rounded-md text-sm font-medium " +
                    (viewMode === "historical"
                      ? "bg-blue-600 text-white"
                      : "bg-gray-200 text-gray-700 hover:bg-gray-300")
                  }
                >
                  Historical Data
                </button>
                <button
                  onClick={() => setViewMode("realtime")}
                  className={
                    "px-4 py-2 rounded-md text-sm font-medium " +
                    (viewMode === "realtime"
                      ? "bg-blue-600 text-white"
                      : "bg-gray-200 text-gray-700 hover:bg-gray-300")
                  }
                >
                  Real-time Feed
                </button>
              </div>

              {viewMode === "realtime" && (
                <div className="flex items-center">
                  <div
                    className={
                      "w-3 h-3 rounded-full mr-2 " +
                      (connected ? "bg-green-500" : "bg-red-500")
                    }
                  ></div>
                  <span className="text-sm text-gray-600">
                    {connected ? "Connected" : "Disconnected"}
                  </span>
                </div>
              )}
            </div>
          </div>
        </div>

        {/* Stats Cards */}
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
          <div className="bg-white overflow-hidden shadow rounded-lg">
            <div className="p-5">
              <div className="flex items-center">
                <div className="flex-shrink-0">
                  <div className="w-8 h-8 bg-blue-500 rounded-md flex items-center justify-center">
                    <span className="text-white font-bold">ðŸ“Š</span>
                  </div>
                </div>
                <div className="ml-5 w-0 flex-1">
                  <dl>
                    <dt className="text-sm font-medium text-gray-500 truncate">
                      Total Events
                    </dt>
                    <dd className="text-lg font-medium text-gray-900">
                      {displayEvents.length.toLocaleString()}
                    </dd>
                  </dl>
                </div>
              </div>
            </div>
          </div>

          <div className="bg-white overflow-hidden shadow rounded-lg">
            <div className="p-5">
              <div className="flex items-center">
                <div className="flex-shrink-0">
                  <div className="w-8 h-8 bg-green-500 rounded-md flex items-center justify-center">
                    <span className="text-white font-bold">ðŸ’°</span>
                  </div>
                </div>
                <div className="ml-5 w-0 flex-1">
                  <dl>
                    <dt className="text-sm font-medium text-gray-500 truncate">
                      Total Volume
                    </dt>
                    <dd className="text-lg font-medium text-gray-900">
                      {displayEvents
                        .reduce(
                          (sum, event) => sum + parseFloat(event.amount),
                          0,
                        )
                        .toLocaleString()}
                    </dd>
                  </dl>
                </div>
              </div>
            </div>
          </div>

          <div className="bg-white overflow-hidden shadow rounded-lg">
            <div className="p-5">
              <div className="flex items-center">
                <div className="flex-shrink-0">
                  <div className="w-8 h-8 bg-purple-500 rounded-md flex items-center justify-center">
                    <span className="text-white font-bold">ðŸ‘¥</span>
                  </div>
                </div>
                <div className="ml-5 w-0 flex-1">
                  <dl>
                    <dt className="text-sm font-medium text-gray-500 truncate">
                      Unique Users
                    </dt>
                    <dd className="text-lg font-medium text-gray-900">
                      {new Set(displayEvents.map((e) => e.user_address)).size}
                    </dd>
                  </dl>
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* Events Table */}
        <div className="bg-white shadow rounded-lg">
          <div className="px-4 py-5 sm:p-6">
            <h2 className="text-lg font-medium text-gray-900 mb-4">
              {viewMode === "historical" ? "Historical" : "Real-time"} Supply
              Events
            </h2>
            <BlendEventsTable
              events={displayEvents}
              loading={viewMode === "historical" ? loading : false}
              error={viewMode === "historical" ? error : null}
            />
          </div>
        </div>
      </div>
    </div>
  );
}
```

## Environment Configuration

Set up your environment variables for your own infrastructure:

```bash
# .env.local
DATABASE_URL=postgresql://username:password@localhost:5432/your_database
GOLDSKY_API_KEY=your-goldsky-api-key-from-project-settings
```

Note: You get your Goldsky API key from your [Project Settings](https://app.goldsky.com/dashboard/settings) page, not from environment variables.

## Production Optimization

### Performance Optimization

For production applications, implement these optimization strategies:

```yaml
# Optimized pipeline configuration
name: optimized-blend-events
resource_size: m # Use medium for better performance
apiVersion: 3

sources:
  stellar_events:
    type: dataset
    dataset_name: stellar.events_v2
    version: 1.0.0
    start_at: latest # Only process new events

transforms:
  filtered_events:
    type: sql
    sql: |
      SELECT
        id,
        transaction_hash,
        ledger_sequence,
        closed_at,
        contract_id,
        type_string,
        topics_decoded,
        data_decoded
      FROM stellar_events
      WHERE type_string IN ('supply_collateral', 'withdraw_collateral', 'borrow', 'repay')
        AND successful = true
        AND contract_id = 'YOUR_BLEND_CONTRACT_ID'
        AND closed_at > UNIX_TIMESTAMP() - 604800
    primary_key: id

sinks:
  optimized_sink:
    type: postgres
    secret_name: YOUR_SECRET
    from: filtered_events
    table: blend_events
    batch_size: 1000 # Optimize batch size
```

### Error Handling and Retry Logic

Implement robust error handling:

```typescript
// lib/robust-goldsky-client.ts
export class RobustGoldskyClient {
  private async fetchWithRetry<T>(
    url: string,
    options: RequestInit,
    maxRetries: number = 3,
  ): Promise<T> {
    let lastError: Error;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const response = await fetch(url, options);

        if (!response.ok) {
          throw new Error(
            "HTTP " + response.status + ": " + response.statusText,
          );
        }

        return await response.json();
      } catch (error) {
        lastError = error as Error;

        if (attempt < maxRetries) {
          // Exponential backoff
          const delay = Math.pow(2, attempt) * 1000;
          await new Promise((resolve) => setTimeout(resolve, delay));
          continue;
        }
      }
    }

    throw lastError!;
  }
}
```

### Caching Strategy

Implement intelligent caching:

```typescript
// lib/cache.ts
interface CacheEntry<T> {
  data: T;
  timestamp: number;
  ttl: number;
}

export class DataCache {
  private cache = new Map<string, CacheEntry<any>>();

  set<T>(key: string, data: T, ttlSeconds: number = 300): void {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl: ttlSeconds * 1000,
    });
  }

  get<T>(key: string): T | null {
    const entry = this.cache.get(key);

    if (!entry) return null;

    if (Date.now() - entry.timestamp > entry.ttl) {
      this.cache.delete(key);
      return null;
    }

    return entry.data;
  }
}
```

### Monitoring and Analytics

Add performance monitoring:

```typescript
// lib/monitoring.ts
export class PerformanceMonitor {
  static trackApiCall(
    endpoint: string,
    duration: number,
    success: boolean,
  ): void {
    // Send metrics to your monitoring service
    console.log(
      "API Call: " +
        endpoint +
        ", Duration: " +
        duration +
        "ms, Success: " +
        success,
    );

    // Example: Send to analytics service
    if (typeof window !== "undefined" && (window as any).gtag) {
      (window as any).gtag("event", "api_call", {
        endpoint,
        duration,
        success,
      });
    }
  }

  static trackError(error: Error, context: string): void {
    console.error("Error in " + context + ":", error);

    // Send to error tracking service (e.g., Sentry)
    if (typeof window !== "undefined" && (window as any).Sentry) {
      (window as any).Sentry.captureException(error, {
        tags: { context },
      });
    }
  }
}
```

## Troubleshooting Guide

### Common Pipeline Issues

**Pipeline Not Receiving Data**:

```bash
# Check pipeline status
goldsky pipeline status your-pipeline-name

# View pipeline logs
goldsky pipeline logs your-pipeline-name

# Verify data source
goldsky datasets describe stellar.events_v2
```

**Data Filtering Problems**:

- Verify contract IDs are correct and properly formatted
- Check that event type strings match exactly (case-sensitive)
- Ensure time ranges are reasonable and not too restrictive

**Performance Issues**:

- Use appropriate resource sizes for your data volume
- Implement proper indexing on frequently queried fields
- Consider data retention policies to manage storage costs

### Frontend Integration Issues

**API Connection Problems**:

```sql
-- Check if events exist in source
SELECT COUNT(*)
FROM stellar.events_v2
WHERE type_string = 'supply_collateral'
AND closed_at > UNIX_TIMESTAMP() - 3600;

-- Verify contract ID filtering
SELECT DISTINCT contract_id
FROM stellar.events_v2
WHERE type_string = 'supply_collateral'
LIMIT 10;
```

**Real-time Connection Issues**:

```typescript
// Add connection testing
export async function testDatabaseConnection(): Promise<boolean> {
  try {
    const response = await fetch("/api/health");
    return response.ok;
  } catch (error) {
    console.error("Database connection test failed:", error);
    return false;
  }
}
```

## Best Practices Summary

1. **Start Simple**: Begin with basic event filtering before adding complex transformations
2. **Monitor Performance**: Track API response times and error rates
3. **Implement Caching**: Reduce API calls with intelligent caching strategies
4. **Handle Errors Gracefully**: Provide meaningful error messages to users
5. **Optimize Queries**: Use specific filters to reduce data processing costs
6. **Plan for Scale**: Design your data architecture to handle growth
7. **Test Thoroughly**: Validate your pipelines with historical data before going live

This comprehensive guide provides everything needed to successfully integrate Goldsky with your Stellar frontend application, from initial setup through production deployment.

For additional support and resources, visit the [Goldsky documentation](https://docs.goldsky.com/chains/stellar) or join the Stellar developer community.

```

```

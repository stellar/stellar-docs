---
title: Integration Tests with Mainnet Data
hide_table_of_contents: true
description: Integration testing uses dependency contracts instead of mocks.
sidebar_position: 4
draft: true
---

Testing with mainnet data is another form of [integration test], where not only mainnet contracts can be used, but also their data on mainnet.

Our ability to test a contract that relies on another contract is limited to our own knowledge of this other contract and the different states it can get into. If the pause contract has relatively complex state behind it, and can return more values than just true or false, it's unlikely that we can exactly replicate the real contract behavior. There exists a gap between the test and reality.

Testing with mainnet data is one way to close the gap.

The [Soroban Rust SDK] and [Stellar CLI] come together to make possible testing with mainnet data.

### How to Write Tests with Mainnet Data

The following is an example of a test that includes a dependency contract into the test, rather than mock it. The test is written to test the [increment-with-pause contract] and the [pause contract]. The contract has an `increment` function that increases a counter value by one on every invocation. The contract depends on the pause contract to control whether the increment functionality is paused.

The following tests set up the `increment-with-pause` contract, as well as import and register the real pause contract using it's wasm file.

If the pause contract was deployed on mainnet it could be retrieved with the stellar-cli:

```
stellar contract fetch --id C... > pause.wasm
```

And imported into the tests with:

```rust
mod pause {
    soroban_sdk::contractimport!(file = "pause.wasm");
}
```

The following test registers not only the increment-with-pause contract, but also the pause contract. The test checks that when the pause contract is not paused that the increment contract operates as expected. When it is paused, the increment function errors. Once it's unpaused the function operates as expected again.

```rust
#[test]
fn test() {
    let env = Env::default();

    // highlight-start
    let pause_id = env.register(pause::WASM, ());
    let pause_client = pause::Client::new(&env, &pause_id);
    // highlight-end

    let contract_id = env.register(
        incrementContract,
        IncrementContractArgs::__constructor(&pause_id),
    );
    let client = IncrementContractClient::new(&env, &contract_id);

    pause_client.set(&false);
    assert_eq!(client.increment(), 1);

    pause_client.set(&true);
    assert_eq!(client.try_increment(), Err(Ok(Error::Paused)));

    pause_client.set(&false);
    assert_eq!(client.increment(), 2);
}
```

Most tests, whether they're unit, mocks, or integration tests, will look very similar to the test above. The tests will do four things:

1. Create an environment, the `Env`.
2. Register the contract(s) to be tested.
3. Invoke functions using the generated client.
4. Assert the outcome.

[increment-with-pause contract]: https://github.com/stellar/soroban-examples/blob/main/increment-with-pause/src/lib.rs
[pause contract]: https://github.com/stellar/soroban-examples/blob/main/pause/src/lib.rs
[integration test]: ./integration-tests
[Making Cross-Contract Calls]: ../conventions/cross-contract
[Soroban Rust SDK]: ../../../tools/sdks/library#soroban-rust-sdk
[Soroban Rust SDK]: ../../../tools/cli

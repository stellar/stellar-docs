---
sidebar_position: 4
title: 2. Storing Data
description: Write a simple Soroban contract that stores and retrieves data.
---

The [increment example] demonstrates how to write a simple contract that stores data, with a single function that increments an internal counter and returns the value.

[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)][oigp]
[oigp]: https://gitpod.io/#https://github.com/stellar/soroban-examples/tree/v0.9.2

[increment example]: https://github.com/stellar/soroban-examples/tree/v0.9.2/increment

## Run the Example

First go through the [Setup] process to get your development environment configured, then clone the `v0.9.2` tag of `soroban-examples` repository:

[Setup]: setup.mdx

```
git clone -b v0.9.2 https://github.com/stellar/soroban-examples
```

Or, skip the development environment setup and open this example in [Gitpod][oigp].

To run the tests for the example, navigate to the `increment` directory, and use `cargo test`.

```
cd increment
cargo test -- --nocapture
```

You should see the output:

```
running 1 test
count: U32(0)
count: U32(1)
count: U32(2)
test test::test ... ok
```

## Code

```rust title="increment/src/lib.rs"
#![no_std]
use soroban_sdk::{contract, contractimpl, symbol_short, vec, Env, Symbol, Vec, log};

const COUNTER: Symbol = symbol_short!("COUNTER");

#[contract]
pub struct IncrementContract;

#[contractimpl]
impl IncrementContract {
    /// Increment increments an internal counter, and returns the value.
    pub fn increment(env: Env) -> u32 {
        // Get the current count.
        let mut count: u32 = env.storage().instance().get(&COUNTER).unwrap_or(0); // If no value set, assume 0.
        log!(&env, "count: {}", count);

        // Increment the count.
        count += 1;

        // Save the count.
        env.storage().instance().set(&COUNTER, &count);

        // The contract instance will be bumped to have a lifetime of at least 100 ledgers.
        // If the lifetime is already more than 100 ledgers, this is a no-op. Otherwise,
        // the lifetime is extended to 100 ledgers. This lifetime bump includes the contract
        // instance itself and all entries in storage().instance(), i.e, COUNTER.
        env.storage().instance().bump(100);

        // Return the count to the caller.
        count
    }
}
```

Ref: https://github.com/stellar/soroban-examples/tree/v0.9.2/increment

## How it Works

Open the `increment/src/lib.rs` file to follow along.

### Contract Data Keys

Contract data is associated with a key. The key is the value that can be used at
a later time to lookup the value.

`Symbol` is a short (up to 32 characters long) string type with limited
character space (only `a-zA-z0-9_` characters are allowed). Identifiers like
contract function names are represented by `Symbol`s.

The `symbol_short!()` macro is a convenient way to pre-compute short symbols up to 9 characters in length at compile time using `Symbol::short`. It generates a compile-time constant that adheres to the valid character set of letters (a-zA-Z), numbers (0-9), and underscores (\_). If a symbol exceeds the 9-character limit, `Symbol::new` should be utilized for creating symbols at runtime.

```rust
const COUNTER: Symbol = symbol_short!("COUNTER");
```

### Types of Contract data

Contract data is made up of three different types: `Persistent`, `Temporary`, and `Instance`. All contract data has a "lifetime" that must be periodically bumped. If an entry's
lifetime is not periodically bumped, the entry will eventually reach the end of its lifetime and "expire". Each type of storage functions similarly, but have different fees and expiration behavior. Whenever a
`Temporary` entry expires, it is deleted from the ledger and is permanently inaccessible. Whenever a `Persistent` or `Instance` entry expires, it is inaccessible, but can be
"restored" and used again via the [`RestoreFootprintOp`]. As a general rule, `Temporary` storage should only be used for data that can be easily recreated or is only valid for a period
of time, where `Persistent` or `Instance` storage should be used for data that can not be recreated and should kept permanently, such as a user's token balance. For more information
about the different storage types, see [Contract Data Type Descriptions](#Contract-Data-Type-Descriptions).

### Contract Data Access

The `Env.storage()` function is used to retrieve access and update a counter. The executing contract is the only contract that can query or modify contract data that it has stored. The data stored is viewable on ledger anywhere the ledger is viewable, but contracts executing within the Soroban environment are restricted to their own data.

The `get()` function gets the current value associated with the counter key.

```rust
let mut count: u32 = env
    .storage()
    .instance()
    .get(&COUNTER)
    .unwrap_or(0); // If no value set, assume 0.
```

If no value is currently stored, the value given to `unwrap_or(...)` is returned instead.

Values stored as contract data and retrieved are transmitted from the environment and expanded into the type specified. In this case a `u32`. If the value can be expanded the type returned will be an `Ok(u32)`, otherwise the type returned will be an `Err(_)`. The final `unwrap()` in the above code snippet is assuming the value will always be a `u32`. If a developer caused it to be some other type a panic would occur at the unwrap.

The `set()` function stores the new count value against the key, replacing the existing value.

```rust
env.storage().instance().set(&COUNTER, count);
```

To access a given type of storage, use `Env.storage().persistent()`, `Env.storage().temporary()`, and `Env.storage().instance()`.
Each storage type is in a separate key space. To demonstrate this, see the code snippet below:

```rust
const EXAMPLE_KEY: Symbol = symbol_short!("KEY");
env.storage().persistent().set(&EXAMPLE_KEY, 1);
env.storage().temporary().set(&EXAMPLE_KEY, 2);

env.storage().persistent().get(&EXAMPLE_KEY); // Returns Ok(1)
env.storage().temporary().get(&EXAMPLE_KEY); // Returns Ok(2)
```

### Managing Contract Data Lifetimes

The `Env.storage().storage_type().bump()` function is used to extend a contract data entry's lifetime inside a smart contract function. The `bump()` function is a conditional lifetime bump which
extends an entry's lifetime up to a given length of time, measured in ledgers.

```rust
env.storage().instance().bump(100);
```

This call to `bump()` ensures that the current lifetime of the contract instance entry is at least 100 ledgers. If this is called and the contract instance entry has a current lifetime of 50 ledgers,
the lifetime will be extended up to 100 ledgers. If this is called and the contract instance entry has a current lifetime of 150 ledgers, the lifetime will not be extended and the `bump()` call is a no-op.

All `Instance` storage is stored in a single contract instance `LedgerEntry` and shares a single lifetime. This means that one call to `Env.storage().instance().bump()` will extend the lifetime of all `Instance`
entries, as well as the contract instance itself. For `Temporary` and `Persistent` storage, each entry has its own lifetime and must be bumped individually. The interface is slightly different and takes the key
of the entry being bumped as well as the new lifetime.

In addition to contract defined lifetime extensions using the `bump()` function, a contract data entry's lifetime can be extended via the [`BumpFootprintExpirationOp`] operation.

## Tests

Open the `increment/src/test.rs` file to follow along.

```rust title="increment/src/test.rs"
#[test]
fn test() {
    let env = Env::default();
    let contract_id = env.register_contract(None, IncrementContract);
    let client = IncrementContractClient::new(&env, &contract_id);

    assert_eq!(client.increment(), 1);
    assert_eq!(client.increment(), 2);
    assert_eq!(client.increment(), 3);
}
```

In any test the first thing that is always required is an `Env`, which is the Soroban environment that the contract will run in.

```rust
let env = Env::default();
```

The contract is registered with the environment using the contract type.

```rust
let contract_id = env.register_contract(None, IncrementContract);
```

All public functions within an `impl` block that is annotated with the `#[contractimpl]` attribute have a corresponding function generated in a generated client type. The client type will be named the same as the contract type with `Client` appended. For example, in our contract the contract type is `IncrementContract`, and the client is named `IncrementContractClient`.

```rust
let client = IncrementContractClient::new(&env, &contract_id);
```

The values returned by functions can be asserted on:

```rust
assert_eq!(client.increment(), 1);
```

## Build the Contract

To build the contract, use the `soroban contract build` command.

```sh
soroban contract build
```

A `.wasm` file should be outputted in the `target` directory:

```
target/wasm32-unknown-unknown/release/soroban_increment_contract.wasm
```

## Run the Contract

If you have [`soroban-cli`] installed, you can invoke contract functions in the Wasm using it.

```sh
soroban contract invoke \
    --wasm target/wasm32-unknown-unknown/release/soroban_increment_contract.wasm \
    --id 1 \
    -- \
    increment
```

The following output should occur using the code above.

```
1
```

Rerun the invoke with the `--footprint` option to view the [footprint] of the invocation, which is the ledger entries that the contract will have read or written to.

```sh
soroban contract invoke \
    --wasm target/wasm32-unknown-unknown/release/soroban_increment_contract.wasm \
    --id 1 \
    --footprint \
    -- \
    increment
```

```
Footprint: {"readOnly":[{"contractData":{"contractId":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],"key":{"static":"ledgerKeyContractCode"}}}],"readWrite":[{"contractData":{"contractId":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],"key":{"symbol":[67,79,85,78,84,69,82]}}}]}
```

### Contract Data Type Descriptions

The general usage and interface is identical for all storage types. They differ only in fees and expiration behavior as follows:

- `Temporary`
  - Cheapest fees.
  - Permanently deleted on expiration, cannot be restored.
  - Suitable for time bounded data (i.e. price oracles, signatures, etc.) and easily recreateable data.
  - Unlimited amount of storage.
- `Instance`
  - Most expensive fees (same price as `Persistent` storage).
  - Recoverable after expiration, can be restored using the [`RestoreFootprintOp`] operation.
  - Shares the same lifetime as the contract instance. If the contract instance has not expired, instance data is guaranteed to be accessible and not expired.
  - Limited amount of storage available.
  - Suitable for "shared" contract state that cannot be `Temporary` (i.e. admin accounts, contract metadata, etc.).
- `Persistent`
  - Most expensive fees (same price as `Instance` storage).
  - Recoverable after expiration, can be restored using the [`RestoreFootprintOp`] operation.
  - Does not share the same lifetime as the contract instance. If the contract instance is not expired, `Persistent` data may be expired and need to be restored before invoking the contract.
  - Unlimited amount of storage.
  - Suitable for user data that cannot be `Temporary` (i.e. balances).

For more detailed guidelines on how to use contract data, see [`Contract Data Best Practices`].

### Contract Data Best Practices

:::info

Soroban is a pre-release and at this time outputs footprints in an unstable JSON format.

:::

[footprint]: ../fundamentals-and-concepts/persisting-data.mdx#footprints-and-parallel-contention

Run it a few more times to watch the count change.

Use the `soroban` to inspect what the counter is after a few runs.

```sh
soroban contract read --id 1 --key COUNTER
```

[`soroban-cli`]: ../getting-started/setup#install-the-soroban-cli
[`BumpFootprintExpirationOp`]: ../fundamentals-and-concepts/state-expiration#BumpFootprintExpirationOp
[`RestoreFootprintOp`]: ../fundamentals-and-concepts/state-expiration#RestoreFootprintOp
[`Contract Data Best Practices`]: ../fundamentals-and-concepts/persisting-data.mdx#contract-data-best-practices

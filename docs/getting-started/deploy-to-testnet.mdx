---
sidebar_position: 3
title: 2. Deploy to Testnet
description: Deploy a smart contract to a live test network.
---

<head>
  <title>Deploy a smart contract to a live test network.</title>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="Deploy a smart contract to a live test network."
  />
  <meta
    property="og:description"
    content="Deploy and interact with smart contract on a live test network called Testnet."
  />
  <link
    rel="canonical"
    href="https://soroban.stellar.org/docs/getting-started/deploy-to-testnet"
  />
</head>

To recap what we've done so far, in [Setup](setup.mdx):

- we set up our local environment to write Rust smart contracts
- installed the soroban-cli
- configured the soroban-cli to communicate with the Soroban Testnet via RPC
- and configured an identity to sign transactions

In [Hello World](hello-world.mdx):

- we created a new Astro project that is configured to include Soroban contracts
- we walked through the hello-soroban contract
- and ran some simple unit tests for the hello-soroban contract

## Deploy

The next step is to deploy our hello-soroban contract to Testnet. Since we have already configured our local environment to connect with Testnet, and created an identity to sign transactions, all we need to do for the deployment is to run the following command:

```bash
soroban contract deploy \
  --wasm target/wasm32-unknown-unknown/release/hello_soroban.wasm \
  --source alice \
  --network testnet
```

This returns the ID of the contract, starting with a `C`. Let's put it somewhere semi-permanent so we can use it later. Copy that value and put it into a file in the `.soroban` directory called `hello-id`. You may need to create the `.soroban` folder first with `mkdir .soroban`.

```bash
echo "C...[your contract id here]" > .soroban/hello-id
```

## Interact

Now that we have our contract deployed to Testnet, we can interact with it! This tutorial will go over two ways to interact with Soroban contracts:

- interacting with the contract directly via the `soroban-cli`
- interacting via the generated JavaScript contract clients in a web app

We'll start with taking a look at interacting with the contract from the `soroban-cli` and then go on to generate JavaScript clients for our contract so that we can interact with it from the Astro web app.

### Call the contract with `soroban-cli`

To call the `hello` method on our `hello-soroban` contract, run the following with the `to` argument set to "CLI".

```bash
soroban contract invoke \
  --id $(cat .soroban/hello-id) \
  --source alice \
  --network testnet \
  -- \
  hello \
  --to CLI
```

The following output should appear.

```json
["Hello", "CLI"]
```

In the background, the CLI is making RPC calls to the Soroban network. For information on that checkout out the [RPC](../reference/rpc.mdx) reference page.

:::info

The `--` double-dash is required!

This is a general [CLI pattern](https://unix.stackexchange.com/questions/11376/what-does-double-dash-mean) used by other commands like [cargo run](https://doc.rust-lang.org/cargo/commands/cargo-run.html). Everything after the `--`, sometimes called [slop](https://github.com/clap-rs/clap/issues/971), is passed to a child process. In this case, `soroban contract invoke` builds an _implicit CLI_ on-the-fly for the `hello` method in your contract. It can do this because Soroban SDK embeds your contract's schema / interface types right in the `.wasm` file that gets deployed on-chain. You can also try:

```bash
soroban contract invoke ... -- --help
```

and

```bash
soroban contract invoke ... -- hello --help
```

:::

### Generate an NPM package for the Hello Soroban contract

Our suggested way to interact with contracts from frontends is to generate an NPM package for the contracts. These generated libraries work with any JavaScript project (not a specific UI like React), and make it easy to work with some of the trickiest bits of Soroban, like encoding [XDR](https://soroban.stellar.org/docs/fundamentals-and-concepts/fully-typed-contracts).

To generate a client library for our `hello-soroban` contract, we are going to use the CLI command `soroban contract bindings typescript`. From the `astro-soroban-tutorial` directory, run

```bash
soroban contract bindings typescript \
  --network testnet \
  --contract-id $(cat .soroban/hello-id) \
  --output-dir node_modules/hello-soroban-client
```

:::note

This again makes use of [command expansion](https://www.gnu.org/software/bash/manual/html_node/Command-Substitution.html), which only works with bash-compatible shells. If you are using Windows or some other shell, you will need to copy the contract id from `.soroban/hello-id` and paste it into this command, or figure out how command expansion works in your shell.

:::

We attempt to keep the code in these generated libraries readable, so go ahead and look around. Open up the new `node_modules/hello-soroban-client` directory in your editor. If you've built or contributed to Node projects, it will all look familiar. You'll see a `package.json` file, a `src` directory, a `tsconfig.json`, and even a README. The README is a great place to start. Go ahead and give it a read.

As it says, when using local libraries, we've had the [most success](https://github.com/stellar/soroban-example-dapp/pull/117#discussion_r1232873560) when generating them directly into the `node_modules` folder, and leaving them out of the `dependencies` section. Yes, this is surprising, but it works the best.

The template added several scripts in the root `package.json` file, including a script that wraps the `soroban contract bindings typescript` command into `npm run bindings:hello`. There is also a `postinstall` script that calls `bindings:hello` after every install to make sure that the generated library stays up-to-date. This means you won't need to manually run the `soroban contract bindings typescript` command again.

Let's run `npm install` now to make sure that all of our dependencies are installed.

### Call the contract from the frontend

Now let's open up `src/pages/index.astro` and take a look at the code that calls the hello-soroban contract using the generated library:

```typescript title="src/pages/index.astro"
 ---
import { Contract, networks } from 'hello-soroban-client';

const greeter = new Contract({
  ...networks.testnet,
  rpcUrl: 'https://soroban-testnet.stellar.org', // from https://soroban.stellar.org/docs/reference/rpc#public-rpc-providers
});

const greeting = await greeter.hello({ to: 'Soroban' });
 ---
```

Then the greeting is displayed in the first `<h1>` tag:

```typescript title="src/pages/index.astro"
<h1>
  <span class="text-gradient">{greeting.join(" ")}</span>
</h1>
```

Now start the dev server:

```bash
npm run dev
```

And open [http://localhost:4321](http://localhost:4321) in your browser. You should see the greeting from the contract!

You can try updating the `{ to: 'Soroban' }` argument. When you save the file, the page will automatically update.

### What's happening here?

If you inspect the page (right-click, inspect) and refresh, you'll see a couple interesting things:

- The "Network" tab shows that there are no Fetch/XHR requests made. But RPC calls happen via Fetch/XHR! So how is the frontend calling the contract?
- There's no JavaScript on the page. But we just wrote some JavaScript! How is it working?

This is part of Astro's philosophy: the frontend should ship with as few assets as possible. Preferably zero JavaScript. When you put JavaScript in the [frontmatter](https://docs.astro.build/en/core-concepts/astro-components/), Astro will run it at build time, and then replace anything in the `{...}` curly brackets with the output.

When using the development server with `npm run dev`, it runs the frontmatter code on the server, and injects the resulting values into the page on the client.

In this case, our `greeter.hello({ to: 'Soroban' });` method is making an RPC call on the server, and the response from that call is being injected onto our index page where we put `{greeting.join(' ')}`.

You can try building to see this more dramatically:

```bash
npm run build
```

Then check the `dist` folder. You'll see that it built an HTML and CSS file, but no JavaScript. And if you look at the HTML file, you'll see a static "Hello Soroban" in the `<h1>`.

During the build, Astro made a single call to your contract, then injected the static result into the page. This is great for contract methods that don't change, but probably won't work for most contract methods. In the next section we'll create a new contract that has interactive methods, so we can explore how to handle that with Astro.

## Summary

In this lesson, we learned how to:

- deploy a contract to Testnet
- interact with a deployed contract from `soroban-cli`
- generate an NPM client library for our contract and interact with it from the frontend app

Next we'll add a new contract to this project, which will show off a little bit of Soroban's storage capabilities.

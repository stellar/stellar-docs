All right, I'll get started.Uh, so.Welcome everyone.Uh, today I'll be.Speaking about CAP 74 which uh.Introduces host functions for the uh.BN24 pairing friendly curve.Um, so as.You as you may know, Stellar already has.Support for has host function support.For the BLS 12 through 381 curve which.Was chosen over BN24 uh due to growing.Support for it uh and security.Uh but.We've gotten ecosystem feedback um that.There are existing use cases that rely.On B2 BM 52 BN254 and adding native.Support for it will make it easier to.Implement those use cases on stellar.The other option would be to adapt those.Use cases uh to to use the um the.Existing VLS host functions.Uh but that.Would be prohibitively expensive in some.Cases.So this proposal the main part of this.Proposal is that it adds uh three host.Functions uh G1 add G1 malt and a.Pairing check uh which gives us parody.With the uh BN24 pre-ompiles in the EVM.Now there have been some discussions.About extending this uh in particular.Adding a host function uh for G1.Multiscaler multiplication but this.Proposal doesn't include that.uh at the.Moment we're just trying to support the.Existing BN24 use cases uh and this.Should be sufficient and for for any new.Use cases uh I the uh recommendation is.To use BLS.Uh the the CAP also specifies uh new new.Cost types for the BN operations which.Are similar to uh the cost types that we.Added for BLS they're just a subset.Because BN has a subset of host.Functions and Yeah.Uh it's a a pretty.Pretty short cap.Um.Uh we also define the field the field.And groups.And uh yeah uh are there any questions?
If there aren't any questions.Um Oh,.If there aren't any questions.Tor's typing.Yeah, it's a pretty straightforward cap.Um, if if anyone has any questions, you.Can tag me on Discord and we can we can.Have discussion.Uh, but if not, I'll uh.I'll pass it off to Jay to discuss.Adding host support for Poseidon and.Hash functions.Can you hear me?
Yeah, I can hear you,.J.Okay, wonderful.Yeah, great.Uh, I.Just want to add on what Sid just uh.Talked about.Um so yeah the ecosystem.Um technically they could use uh all.These BRS functions but in the proving.Proving framework including like this.The circuit um like switching those.Curves off is it's in reality it's more.Challenging than u than we thought.It's.Not just a simple curve swap but.Sometimes those protocols can be evolved.And circles have to be recompiled with.Different curve.Um and then there's.Also different type of uh issues with.Like different u like proving systems.Support one curve versus another.So.BN254 is is mostly for backward.Compatibility.uh and also uh we've also.Added a solorone example of importing.The BN 254 inside the solar contract.Which works uh but it takes I think like.500 million instruction to do one.Pairing.So that that is also.Prohibitive.Just wanted to point out.The like these two specific rational why.This is needed.Uh cool.Uh and uh yeah I will start on yes thank.You an yes uh so the poseidon hash.Function has also been uh one of the.Requested.Uh primitive to add into solar um so.I've recently just looked into this I.Don't have a CAP yet but I will uh lay.Out uh what I what I found and and sort.Of the different approaches u like.Informally here and I'll work on the cap.Uh probably be ready in the next couple.Days.Um so yeah, first of all, why is.This also needed.In the proving uh in the DK application?
In the proving uh in the DK application?
In the proving uh in the DK application?
Um.Uh the the commitment scheme uh is a lot.Of commitment scheme is hash hash based.Meaning you hash something and then you.Prove that this thing has been hashed is.Without revealing it.So the hash.Function is is critical and then uh for.The hash function that's used um is also.Important in terms of the performance of.The prover side.Um so from what I uh.From what I understand um not expert but.Uh from what I understand is using the.Right hash function like Poseidon can.Reduce the number of arithmetic argu uh.The the arithmetic gates the arguments.By an order of magn like two orders of.Magnitude.So this this is a fairly big.Difference that's why uh a lot most of.The um like the circuits use these field.Uh field based hash functions and.Poseidon and pose then two are two of.The most widely used ones.Um so the.Next next question is why do we need to.Support in the uh in the host uh.Although the proof is generated offchain.And the verification of the proof is uh.Doesn't involve hashing um the hash is.Needed because some applications need to.Maintain um for example a mer tree of of.Different uh coins for example and then.To prove the coin's existence they can.Prove without uh without hashing but to.Update it on chain or some any kind of.State that involves hashing uh to be.Proven it it needs to use a hash to to.Update.So to to to be consistent we.Need to make sure that the hash function.That's being proven is same hash.Function as what's being used for.Contract uh state update.So that's kind.Of a big u overview of rational and.Poseidon functions uh these are these.Are not two these are not one function.It's rather a family of functions or.It's a rather it's a it's an approach um.That based on on sponges um and then um.Ways to connect it connect these uh.Sponges to provide different.Permutations with different input So.It's fairly generic.Um you can.In terms of you can plug in uh different.Parameters like for example if you.Require a higher security parameter then.The round parameters will be larger and.Also depending on how many inputs you.Need to hash at once also how many uh.Output the throughput uh the number of.Runs needs to be uh adjusted.So, so in.The Prooseidon uh paper there's.Different implementations of different.Versions of Prooseidon uh given on the.Requirement as well as underlying uh.Field.So here we the primary field what.We have to support uh for compatibility.Is BN24.And also BS2381.So that's a that's a two uh requirement.And based on these requirement some of.These parameters can be decided um but.Some of them are still um can be some of.Can be uh cho choices.So we need to.Really decide uh what level of.Flexibility we want to supported with.Um so in this discussion uh last the.Discussion thread the last post uh I've.Laid out the three approaches that I.Feel we could support it.Um so these.Are in terms of u from the most high.Level to the most low level.So number.One we support it as hash functions.Directly.So for that we we will support.Poseidon Poseidon 2 um and the two.Curves um and then.So yeah I think this is the most.Straightforward one um but the but the.Limitation is that we are we need to.Kind of decide on the parameters.Uh internally like like there's a so so.In the in the Prooseidon um paper they.Describe how to choose these parameters.And they they choose it.They provide a.Script to how to generate these.Parameters and own guideline on how how.To choose them and in reality from from.What I know seems like different.Applications.Uh sometimes generate their own.Parameters.I'm talking about these.Internal like round constants like these.Matrixes.Um so so if if someone from.Another ecosystem.Um that generates a proof with a.Different instantiation of Prooseidon.Then potentially here we could not uh.Support it.So, so, so there's a little.Bit of compatibility uh risk uh we we.Have to um decide but I think for for.This one most parameters are fairly.Straightforward.Uh and then we need to.Make sure that the major uh prover.The the major prover can be supported.Like the circum or no and we we just.Need to make sure that whatever.Parameter we choose is compatible with a.Major that wants whether we wanted to.Migrate to stellar with so that's number.One uh number two is to expose the.Internal poseidon building blocks so um.As I briefly mentioned earlier the.Prociding hashing um is a is a sponge.Based um like a um uh block cipher it.Consists of absorbing the input per.Permuting them and then squeezing them.So uh one of the uh ecosystem member uh.Antonio suggested that we could support.The generic uh interface um to to.Provide these and then users can just.Choose the parameters or choose the.Security parameters field and all that u.And then we can expose these options uh.Through the SDK.Um I like this.Approach.Um but I think it's maybe a.Little bit it involves a little bit of.Figuring out the requirements for the uh.The libraries and then the the the level.Of details we wanted to expose how to.Expose them to SDK.I'm I'm not I'm not.Expert in the this part yet.Uh so I.Will say that this one right now um I.Would I would say this is a a less.Favorable option.Um and for I think one.Of the one of the main advantage for.This one is that Osan and Poseion 2 they.Use very similar interface.Potentially this this one is more.Cleaner uh that we just support this and.Then the two different uh variants can.Be supported like more uniformly.Doesn't add complexity.Station.Yeah.Um yeah, I think.Yeah, this requires the user to.Understand what they're doing and how to.Instantiate the hasher with these.Options.Yeah I think yeah I'll also talk about.Number three because uh I think exposing.The host function.Uh exposing the hash function is the.Most uh straightforward approach but in.Reality it's just the different.Parameters we we can support them all.But then uh with.With the internal building block it's.Possible that we could uh let uh give.More flexibility but yeah I Think that's.Kind of the main rationale but in how to.Do it we have to think it more carefully.&gt;&gt; wanted to say that for approach two and.Probably three uh it's not like we have.To put much burden on the users it's.Just that we can build uh SDK functions.Right that uh do the same cache.Functions for example because you have.An option one but there is a huge.Benefit of uh you know not introducing.Like uh combinatorial explosion of the.Code types into host which I think is a.Really bad property of approach one.Right it seems like instead of just.Setting a few cost types we need a lot.Of them and if you wanted to do.Something more complex we would need.Even more and this is I think a lot of.Maintenance burden and a lot.Complexity in the protocol which I think.Kind of would be nice to avoid.So I.Feel like these parameters could be.Implemented in the SDK.So user.Complexity would remain the same.The.Only question is really performance at.This point.Yeah, I I disagree on the cost type.Part.Uh because I think uh doing two.And three can reduce the amount of cost.Types potentially because these are just.&gt;&gt; uh three building building blocks and.Then yeah.&gt;&gt; to be clear I totally agree with you.I'm saying that I do not like option one.Because in option one we need a cost.Type per.&gt;&gt; hash and per uh whatever curve and.Perity which is an argument of the.Function which uh is what I refer to.This explosion right we have like three.Different inputs to that so I think.We're on the same page here I agree that.&gt;&gt; we probably want to have more limited.And like number of cost types that can.Be useful building blocks.&gt;&gt; Yeah.Uh and by the way, uh.Also the RT uh it.I think for for a minimum uh we just we.Need to support RT 2 uh to support the.Merco tree or binary Merkel tree.Um but.We.Fairly certain we don't need four right.Now and then one maybe.So at a minimum.Maybe just a R of two but I would need.To confirm it if this is uh this is just.What we need.Yeah, I still feel like it.Is like a really hacky design, right?
Is like a really hacky design, right?
Is like a really hacky design, right?
Like we have a host functions, it has an.Like we have a host functions, it has an.Argument, but it can have only like.Couple of values.But.&gt;&gt; I don't know.I I would really try to.Stay with the building blocks and do.Work on the SDK side if it is feasible.From you know the instruction count.Standpoint.So number three is uh going a step.Further.um to to do this without.Providing any uh Prooseidon host.Functions because uh the algorithm.Itself is fairly uh they say.It's more like applying.Uh like applying um arithmetics.Repeatedly in iterations.Um so in.Theory most of the heavy costs are in.The field arithmetics which we already.Provide for BS 12381 and then for BN we.Are going to provide them.Question is can we just do this on the.Guest side so I did a bit of experiment.Um what what I wrote yeah hash 2 takes.About uh 17.6 6 million instructions.This is trying to um like do the.Optimized implementation or I think it.It's with the current implementation.That's the best we can do and out of.Which only like around three million.Other crypto arithmetics.Um the main.Reason is that every like to do every uh.Irrespective you have to go round trip.Uh to the host and then to do the bite.To internal representation conversion.And then internal type for for efficient.Arithmetic requires if I remember.Correctly it's a Montgomery form.So it.Needs to do some arithmetic to convert.The numbers into uh some form that's.Efficient for uh multiplication for.Multiplication or division for example.So there's quite a lot of these.Overhead.So the s the the thought.Process is if we can uh bundle these.Into some u um like more efficient.Uh field arithmetic functions such as.Dot product and matrix multiplication.Um is it possible that we can reduce.That cost?
Um I don't have a straight.Answer for that but um my intuition is.That we can include we can we can reduce.That significantly but maybe not to the.Level that we require.Um for reference.Uh to hash uh a mer tree of uh a million.Entries we need 20 hash operations.This would require um at least you know.10 to five times reduction of of that.Number.Um so I think we can.Like reducing these operations.Um it's.It's doubtful that we'll get close to.The upper bound that uh we we're.Shooting for.Um yeah bit of rationale.Reason into that is because even though.We can provide the matrix multiplication.These matrix are fairly small like 3x3.So we're not bundling like a thousand.Operation into one we are just bundling.Like you know nine and then the the rest.Of it still like was code and these.Loops and which will still have.Significant overhead that's why I feel.Like this approach even though it's more.Attractive it it probably wouldn't.Wouldn't work well and also it will.Require the user to handle their.Preciding implementation.So overall I.Think uh in my opinion uh number one is.Uh is probably the best option uh to.Support it today.Um and then we need to.Think more about these parameters and.Choices.&gt;&gt; any numbers for option one.&gt;&gt; like how much more is it?
Yeah, I uh yeah, in number three, uh I.Yeah, I uh yeah, in number three, uh I.Added up all the uh metered cost for.Arithmetic.They are about 2.5 million.So I I would say um number one would be.Much more closer to that.Uh there's.Still.Like some like extra cost of like memory.Allocation and like.Like the the conversions still a bit but.I would say it will be much closer to uh.2.5 million.Are the numbers in three uh like when.You say optimize is that like what do.You mean by that?
Is that like a native.Call that you tested.&gt;&gt; 17 million?
&gt;&gt; 17 million?
&gt;&gt; 17 million?
&gt;&gt; Yeah, it's not uh it's not a native.&gt;&gt; Yeah, it's not uh it's not a native.Call.It's was contrast.So, it's.Basically implementing.Poseidon uh cache uh in in W was but.Calling the host functions for BS uh.Scalar add multiply and these functions.Um, optimize just means that I try I try.What I can or what I know to uh make.Sure that these calls are all necessary.And then we're not wasting like.Unnecessary convergence and things like.That.&gt;&gt; Okay.Okay.I I don't know the in terms of CPU.Cost.I don't know how much they will be.Different.It's more like uh the.Complexity and the maintenance.Um so I.Would imagine if done properly they will.Be pretty similar in terms of.Performance but it's more like the.Question of yeah we want to expose that.Level.&gt;&gt; right.Again for the complexity I.Sure I get the argument like I I think.Really complexity.I said can be moved on the SDK right.I think what is important here is.Protocol complexity and I feel like one.Is more protocol complexity just from.From the standpoint of maintaining the.Permutations of different input.So if.Two is really yeah it's unique as the.Same.So so yeah if you had a number for.Two and if you knew that it's not.Significantly worse than one and I feel.Like two is much better option.I haven't done enough uh.Exploration in that direction yet.Yeah,.We I'll try that in the update.But even for two, we need at least.Uh Prooseidon and Prooseidon two because.These spongy implementations are.Um so that we're talking.About.Uh yeah like at least maintaining like.Six.Six of these functions essentially.But it it just feels much better.Still because it's like at least finite.And it covers like all the cases, right?
And it covers like all the cases, right?
And it covers like all the cases, right?
&gt;&gt; Yeah.So as Nika points out like if.Friendly isn't hard for coded so you.Know something new needs to be done.And can do it as a guest layer.Yeah I'll I'll do a little bit.More exploration to two and uh yeah if I.Yeah I'll update on thread.Yeah, Alex, I think yeah, that's a yeah,.That's a agreement.I think yeah, two is.More flexible.Um, it's just little bit.Of complexity to to do it, right?
Yeah, I think um.Yeah, I think um.In option two,.Even though we expose these.Primitives, the internal parameters.Would still have to be.Like I think these interfaces don't let.You specify the.Like the security parameters like the.The the long constants matrixes.Um so.Yeah one thing one other thought I had.Was should we expose those or should we.Like let let the user initiate the hash.With set of parameters they they want.And how relevant would that be uh for uh.Most ecosystem but I haven't figured out.Answer to that yet so there's.Potentially they're doing two with.Maximum in top interoperability you.Could be more complex.&gt;&gt; Different parameters like would they.Impact the runtime or are they just.&gt;&gt; No, it's just numbers.&gt;&gt; No, not not runtime.Yeah, it's.It's just different hash.Output will be different.But the.Runtime is just the uh yeah the.Width of the inputs and the number of.Runs.So yeah long time I think we with.Number two we can we can have that.Metered with uh like per iterations but.The security parameter is just the.Choice of.Uh yeah like the choice of hash states.That don't provide different outputs.Yeah, I agree.Like if we.Add a capability to provide.Configuration and it does not change.Host complexity much then we should do.&gt;&gt; because.&gt;&gt; okay.&gt;&gt; from the hosting point I would be.Concerned about the metering but since.We can meter it all the same I don't see.Like why would pass in an additional.Vector or something as an input but.Um but we introducing too much.Complexity here.I think yeah mix yeah two.Would be a a good yeah good solution for.Interoperability.I'll spend more time.On that.Hey guys.Hey.&gt;&gt; Can you hear me?
&gt;&gt; Can you hear me?
&gt;&gt; Can you hear me?
&gt;&gt; Yes.&gt;&gt; Yes.&gt;&gt; I'm in a bit of a loud environment.So,.You know,.You can hear me.Um, yeah.So, I joined.In the middle, so maybe I missed some.Things, but I think I kind of understood.J's proposal.um with a hardcoded.Option, an option that enabled us to.Configure MDS and run constants.Um seems to me that the.Configurable option is the is a good way.To go because that still optimizes the.Hash function itself run faster after.The initialization but enable some.Flexibility.Uh the one thing um I think we need to.Ensure is and I don't entirely.Understand how it works is uh how often.We need to initialize the potent initial.Initialization types.Um like let's say for milling.As instructions.Uh so um I think uh it would be good to.Understand whether say to deploy um as a.Separate contract and then poly to.Whether the initialization only occurs.Once deployment is done.So that those.Are details that are less familiar.So as long as we can guarantee that the.Initialization of the hash doesn't often.Think abilities disadvantage.Um yeah I don't know any specific.Questions lots of when doing stuff so.Actually guy was looking into that as.Well yesterday he was looking into.Implementations from what we saw uh Tom.When we did it with you when we had the.Budgets uh it seemed So if it's around.For milling instructions and then the.Hashes themselves are around 10 million.For everything running wasn't right but.As long as for instance those four.Million instructions happen.In my limitation one positive that's.That's not too bad.Sorry, could you repeat the part?
What's.The forming instruction?
The forming instruction?
The forming instruction?
&gt;&gt; Uh, that's the that's the construction.&gt;&gt; Uh, that's the that's the construction.Of the house.&gt;&gt; Oh, okay.Uh,.I think we.Yeah, I'm thinking like if if it's like.A contract like every contract has its.Own uh the the seat for uh like the RNG.For example.Similarly, every every.Contract can set its own the state and.Then they can once it's set it should be.Uh.Yeah that should be the initial cost.Yeah I'm not also familiar I'm also not.Very familiar with the internal working.Of like these hashes so I need to look.Look a bit into it but I imagine the.Initialization is just one time and.Absorbing.&gt;&gt; yeah and then yeah you need to and then.To use you have to absorb it first.That would be like probably based on the.Number of inputs.So the initialization is.Just like uh reading the checking the.Conference.It's not a stateful or.Something that So as long as that's.Done,.&gt;&gt; you can hash.&gt;&gt; Yeah, that's right.&gt;&gt; Yeah, I guess it's per No, it can be per.Per it can be per contract life.That's a good question that then you.Need to serialize it somehow.Betweenations or if you're uh if you're.Invoking a method from another contract.That then I guess can just keep invoke.Getting cached and we can keep invoking.That but hey I I'm talking here about.Lesson.But but yeah I mean it's it's not for.Invocation it's it's.How however long you can do.&gt;&gt; Um I have a com I have a question about.What you wrote.So uh why why would it.Matter whether other V projects uh have.Different configuration witnesses apart.From unless you want some.To be inter between different.Channels.Other than that we can speak around for.Answers.Uh, sure.Makes sense.I mean, it's not.It's not uh it's definitely there's.Definitely an advantage to having the.Same parameters that.I think I think it makes.Sense.U Yeah.Allowing the.Constants to be overwritten uh for Yeah.For different chains and different.Projects.Yeah, good point.Thanks GPT.So uh I think that's uh seems like.That's the main uh questions and.Concerns is the interoperability and the.Uh flexibility.So yeah, I will look into.Option two in more depth and then I will.Update that thread and then CAP will.Follow.Uh is there any other questions?
I guess also to also to add I guess it.I guess also to also to add I guess it.Would be good to look at the parameters.Of the circum lead the standard the.Circum library and uh see what they.Correspond to in terms of other stuff in.Specific projects uh because I I so far.I've replaced them with something that.Works on interoperable between what I.Could that work in cir and rust.And m.So that's a riding stand library.If we.Can go back to the stand library and use.The parameter that probably that.Simplifies C.&gt;&gt; Oh okay.So, so did you say you.You you changed those parameters in.Order to.&gt;&gt; Yeah, basic basically on on both ends.Both on serum uh.&gt;&gt; on the rough end.Basically parameters that I keep from.Side implemented forum but.Um I need to check if it depends on the.Fun library or from other library system.That I found.That's how it's hard to.Double check that if we could exceed to.The default CD parameter that would be.Good.&gt;&gt; And probably they probably work on other.Project.So perhaps supporting.&gt;&gt; right like supporting like a default set.If if it's not overwritten like default.To like a circum or something.Cool.If no other questions, I guess.Hand it over to you, Bri.You want to.Close the meeting?.

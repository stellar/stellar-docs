Okay let's get started so welcome.Everyone this is a SOROBAN design.Discussion in these meetings we.Discuss some of the core decisions.That we need to make when we're building.Soroban which is a platform for smart.Contracts that is in active.Development right now and is being.Integrated integrated with Stellar .Today we're talking about off next which.Is a proposal that Dima put together. to address some of our authentication.And authorization needs on the network. so I think that without further Ado. this is the second time we're talking.About off next the first time was before.The holidays a lot of folks were were.Were out so I think we're gonna start.With an overview by Dima then dive.Into questions.And ideally you will be able to make.A decision or get close we would.Close without decision today so Dima.Can you take it.Yeah hi everyone you hear me.Okay yeah okay sounds good thank you. so a quick overview I will.Probably skip on the motivation for the.Sake of time I will just say that the.General modulation is that we are aren't. too excited about the state the.Others currently now it's a bit too.Fragmented and to limit it in some.Senses well it's too flexible in other.Cases and it's not necessary so this.Proposal tries to build something into.The protocol. that would be those flexible but.Also standardized so that contracts can.Inter operate and the client software.Can Implement certain things just once.Without tweaking them for every contract.So on a high level The Proposal consists.Of.Two big components the first being.Account abstraction and second being.Standardized signature payloads and.Invocation authorization.So to play on this point account.Abstraction is a well-known concept on.In other chains and basically is that.Instead of passing some entities that.Are tied to some.Crypto algorithms such as.Some public keys or something like that.Or instead of trying all those to say.Classic server accounts. we make the.Contracts to operate on some abstract.Entities called accounts and from the.Contraction Point account is just an.Object that has an address that can be.Used to throw balances for example or.For any account related information or.Transfer balances to this account.And it has a way to authorize the.Invocations of the functions it's not. the contract in the contract business.Logic how exactly the account does that.So hence the abstraction and the.Accounts themselves can be implemented.Both in a built-in fashion some of our.Built-in tokens and the building.Implementation will cover the classic.Store account so they will all get their.Default account contract right but they.Also can be customized right for example.If someone comes up is a new.Cryptogram like this Quantum resistance.For example right or you know there are.Hardware votes that currently don't.Support her at all it is possible to.Write an account contract that will.Perform this custom authentication but.The possibilities are much better than.That it is possible to have a literally.Complex multi-6 schemes that are.Probably currently not possible the.Class Explorer accounts for example it.Is possible to record different mode.Async..Or different tokens spent or different.Balances spent basically this is a smart.Contract I guess that's the bottom line.Of it. so yeah this is the first component.And the second component is.About the signature payloads because.Again currently signature pivot system.Of preform we have like the SDK.Implementation of some structured.Payloads but this is just in one SDK.It's not 600 days in any way. so the proposal here is that instead.Relying on contracts to Define their own.Signatures schema.We provide the generic ones that should.Hopefully be flexible enough to keep all.The use cases.So.The payload obviously would include some. context information such as network.ID but the main thing and the main.Innovation here is that instead of just.Signing a single contract call.It is possible to sign a whole tree of.Course or even like Forest of trees.Nature okay. basically.From the contract standpoint when the.Contract requires an account to.Authorize family vacation. the Urban cost like the power wheel..Add this into a post deck of all Trace.Calls and build a context Tower so.Basically when authorized this code from.Some contract the.Payload for this call should contain.Obviously the currently executed.Contracting function but also the call.Stack of the authorized invocations.Leading to it and the contract provided.Arguments so basically it's only since a.Contract needs to provide these.Arguments for the authorization and.Everything else is inferred.Automatically based on the current .Coast Tech and stuff like that.The Proposal also.Includes.That generalized Finance Management okay.I think we wanted today different this.But for the sake of overview ready is.That. cost will contain we will manage.Nonsense per contract and per account.Address so that basically neither.Regular contracts nor account contracts.Need to worry about that and this comes.With some benefits like nouns can be.Consumed only for the top level.Invocation and not any subsequence of.Contract calls. plus Ledger access and more.Flexibility for the users.That's rather benefits.Uploaded so now.So these are two key Concepts and.I think another interesting high level.Point is that.Things housing is Paradise.For the cases of complex contracts .PreFlight can be utilized.To build this the signature payloads. this is like like when we are talking.About the contracts that have more than.A single signature like it's a current.World or modern single authorized and.Location it's a house next World. it may be tricky to figure out like. what exactly needs to be signed like.The contract may be delegated to some.Contracts that dynamically depends on.Their input and things like that so. in order to figure out. what exactly needs to be signed in.Order to be able to execute a certain.Contract call. we introduce a mechanism in.Pre-flight that we'll basically Trace.Those authorization calls and build the.Proper payload.And the cool thing here is that this.Stage like there is no signatures.Participating and basically no no.Commitment to any security reasons from.The user so the only thing that the.Private needs is the other addresses of.The account that participate in the.Invocation.What else.Yeah I think that's pretty much it on.The high level.I just think quite like so there's a.Bunch of other things but I think we.Would want to look .Yeah I think that's a great starting.Point and we can open it up for.Questions I'm especially interested in.The perspective of the DAP developer so.Paul if you have any comments there I.Think that the original auth that we.Built or what we now call Advanced off.The the point in which we realized it.Was a bit problematic is when we had you.Know daps and walls try to implement it.And it became clear that it's you know.It's a lot to handle so I'm really.Interested to hear about this one in.That perspective foreign.Talk a little bit more about what.Actually goes into the signature payload.Specifically like do wallets have to.Sign.Only the sub tree sections were like.Account the authorized is called or they.Have to sign every like cross-contract.Call or.Yeah yeah as I've mentioned basically.Their trees over the coast not to.Exit full trees or whatever as a.Basically this is a.Subset of the whole country of the.Contract were the.Current account oh not currently there.Can't be interested in all Traders.Something so let's say we have an.Account a that once so sorry we have.A contract is that once the user to.Authorize it then it delegates to.Contract BS that doesn't touch right.They return Then B code CZ that's.Authorize the users and that cost tags.Are user Sciences a and then C B will be.Omitted so you know there is no yes.There is no time in a sense for all well.It seems much more flexible right yeah.That's okay so I feel like a exchange.Swap for example you would really only.Have to sign like the token withdrawal.From your wallet.Yes sir like basically yeah you need to.Still approve your token to some router.Contract and then router contract can.Route your token in any direction or.Vice versa like you may sign like some.Low levels of operation that just swaps.You with someone and you don't really.Care how exactly this is being routed.Again your signature is required under.This bottom level operation so both ways.Work and also an important note on.Signatures. that I haven't mentioned is that.Wallets would sign the hash of the whole.Payload and this is mostly for the sake.Of compatibility it's whatever hard of.Our wallets and possible features.Basically we want to bound their.Signature pivot size.Like the actual signature go outside.It's not premature yeah so the.Wallets take the entire subtree hash.That then sign that so there's only one.Second sure okay cool thank you yes.Dima yeah yeah I have a question about.And I'm going to steal a list questions.What What In the case that you want to.Pass an invalid signature one of the.Subcontact with the purpose of taking a.Different path in the in the contact.Execution.Right and explicitly you want to fail.One of them.Yeah this is here okay so like I mean. I'm interested to see like an actual.Use case for that because.From there like this only influences.Pre-flight right from the preference.Standpoint like I describe this feature.Where we can record the authorizations.But the side effect of recording them is.That we treat them all as successful. it is not impossible to mock failures.In the preferred API it's like basically.Not a protocol change I'm not convinced.This is something we actually should do.And it's really unclear to me.Why would you ever want this to be the.Game basically in my mind like if.It's fine for the authorization failures.To be recoverable. for example you know you want to.Clear like multiple trades and at once.And in a general case trades may not.Clear for multitude of reasons one of.Them being that signatures for the.Trades for this trade are incorrect.And you don't want for example to fail.Other trades if you're just patching.Things together right this is a fair.Case but I think this case is only.Meaningful during the on-chain execution..I think it is fine for the pre-flight.For example to execute the hate this.Scenario because it will be probably.It will consume more gas and build.Access knowledge your entries than do.It in case of failure so it will make it.Superset of what is executed in chain. of course it is possible to write.Some really weird contract Logics.That would try to reorder trace the.Account but again I'm not quite.Convinced that ever a good idea and .There won't be a good support for that.From the pre-flight standpoint for.Example.And but but I think there is a pretty.Good reason to not support it because.You kind of have this recursive.Dependency where like you want your.Signatures to depend on the function.Input but then if your signature.Defines like what the signature should.Be you get this basically cyclic.Dependency rate. so I I'm not convinced this is a good.Idea basically like.What I would want contracts to do.Normally is that. if you call contracts function with.Certain arguments it comes with a.Certain signature preload and this.Relationship should be deterministic.Right and it should not involve.Signatures in the input. which is actually one of the problems.With the current Advanced awesome.Because we are like.Are we used to like include some.Information from the signatures while.Building pillows for another signatures.And it's pretty messy and how to.Painting and power so yeah.Yeah and another question this change.Implies that you need to do the.Cryptographic verification.Posts.Transaction execution right are they.Very end right because you need to build.The pre-image and in order to build a.Pre-image you need to run.The contact right so not on the simulate.Side but when you actually go and.Execute it.You need to run the entire smart contact.Three right and only at the end you have.The pre-image that you can verify with.Signature that's actually not true right.Like it's a bit of an implementation.Detail and I think it may change but in.The current prototype. what happens is that since we kind of.Decouple authentication and.Naturalization. well at first the whole tree has to.Be passed .In some way along the transaction right.So the transaction should know in the.First place whatever if you are claiming.You have time.So from the smartphone perspective for.Example it's possible to examine the.Whole tree that's trying to or trades.From the authentication perspectives.There is just this curved payload which.Is the hash of something and from the.Authentication standpoints the only.Thing we need to do to it is to.Basically verify the signature of this.Payload is correct and in case of.Mounted sync accounts find all the.Signers right. so basically the current.Implementation the authentication.Happens so easily the first time the.Account writes to trade something. and actually the same goes to.Evaluating the whole tree over the.Course in the vote like the latter part.May I may not change but I think yeah.There is really no need to do anything.Until the end of the contract execution.We just. do verification as soon as possible.So basically.You've like.If Thompson is not like if some were.Deep in the subject there is a cause.That hasn't been authorized will find.Out about it as soon as we reach this.Point but not.I see so the entire tree is effectively.Submitted as part of the transaction.Right yeah it is and yeah I have seen.Your suggestion on the dog that maybe.Instead of passing like the whole show.Explicitly we made Parts ashes of its.Nodes which probably may be fine in.Terms of the transaction sites but yeah.It really only matters for the.Transaction part of the things. not for the actual execution yeah so.My concern here is that people are going.To use.The existing contact a.Infrastructure to develop like deep.Executed contact tree right and when.That happened we can have several.Hundreds of contracts executed right per.Transaction.And I just kind of like a horrified of.The idea that as a result of that we're.Going to have hundreds of signature in.Each transaction.Account.So again there is only a single.Signature per account right and said.Like.The signature flow is you take the.Payload which is basically a network.Plus a vector of the invocations you.Want to or trade you hash it you sign.The hash that's it ah so there is only a.Single signature then the first time.Execution time is the first time the.Account tries to try something we verify.The signature. and then we will just do basically.Matching like weather resist .Invocation is present in the tree or not.Now .To the Deep tree topic I don't think.It's .It's the new route it has any relevance.To this because it's not like it's.Impossible to close up to contract now.And the bank accounts versus these right. like you cannot probably execute a.Hundreds of contract calls even if they.Don't do any actualization shift because.It will run out of gas before that like.We are going to have gasoline it on the.Transaction so. and I think it's completely.It will always be a better idea to have.A single contract than a multiple.Contracts than multiple contracts into.These things and because cow in a.Contract comes at the cost so.Yeah next week very differentiation.Yeah right thank you. can I give us a question about the to.Do with this you know what gets signed.In the subtrees and going back to deem.Of a example you provided when you .When you're answering one of polls.Questions. you describe a situation where an.Is signing. like that you're calling a contract.And that contract is calling three other.Contracts a b and c and this account.Just wants to sign the call to.Contract a and the call to contract B. in that situation is that does that.Mean that count a science two sub trees.Like separately so they provide two.Signatures Play sign a and they sign b.Or are they because a few times it's.Been mentioned that an account only ever.Provides one signature is there some way.That somehow they sign those two sub.Trees but it's only one signature or how.Does how does that work yeah so.Basically as I said like technically.You're not signing the tree you're a.Sign in a forest of treats. so for example if you have a top.Level router contract that doesn't.Require any authorization but then you.Make two subcontract calls that are.Authorized that would spawn to all trees.Right because they will have different.Top level or trades nodes. which I think is fine like you still.Need just one signature over that as.I said I'm always saying like one.Signature per account account here is.An account object it doesn't mean.Like that it's Unique so if your.Transaction accepts two accounts and.They happen to be. to have the same address very long.Try to duplicate them and then there are.A little bit of signatures so you know.When I'm talking about like single.Single short per account that's only in.The context of that account like in the.Context of the whole transaction there.May be a return number of accounts and.Some of them maybe duplicates and they.Will have their own signatures too so if.You don't try to be any more collaborate.Here so it's yeah one per account not.More.Okay so in that in that situation where. account one wants to sign contract a.And the contract tree a c but they don't.Want to sign the top level.Like the very very top level contract.Call they they would provide two.Signatures they would sign like the sub.Tree for contract a the subtree for.Contract C and then they would include.Those two signatures. is that is that right.Okay so at first I want to make points.That I think it's more like it's.Important to practice say that it's not.That account wants to do something it's.What the contract wants to do because.The source of the signature pullouts in.The first place is the contract it's .Not the account the count row is to .Verify the signature like an account.Contract account in a more broad context.Or always to sign stuff eight and seven.Basically depending on the call tree you.Will get different results for example.If you have a contract.As I said that calls independently into.Say contract B and contract c.But you provide it once at the top level.You'll get a single payload.So let's say you have a contract a that.Doesn't require authorization itself.But it does go into contracts bncs and.Direct prioritization. if you provide contract a then you.Will get a single payload with both.Invocations but on the other hand you.Could. just pre-sign contract B and contract.C and then write like you don't want.To know the user to know about your top.Level contract then your top level.Contractual when you take care about.Having two different accounts right but.It will be still possible to forward the.Signature so basically it's whatever.The contracts Define and whatever you.Try to prep white or build signatures.For it's driven by the contract.Interfaces so I mean.It's probably a good idea to try to.Implement things in a way that. only a single signature is needed so.That you know we have some Atomic.Operation per account that may involve.Arbitrary number of subcontractables but.Nothing limits you from you know using.Small result present calls but you will.Need to this needs to be reflected in.The contract interface and.Implementation that's right so what.You're saying is that. contract a could just sign the entire.Tree if they wanted to.Yeah like you you would need some.Criticize.Instead of so if you just so just.Ignoring PreFlight for a second just.Assuming that the developers here.Know how to build these trees themselves.They know how to do all the signage.Themselves I'm not really too interested.In the automation just yet but. a developer could choose to sign the.Entire tree and they would be signing a.B and c. or they can choose to sign just the.Subtree A and Justice subtree C and.Include those two signatures.Basically yeah like as one is your.Forest of trees corresponds to what what.Has been authorized you should be fine.So you know if but basically what you.Can do like if you're in full control of.All the execution paths you will just.Look at where your authorization secure.And you would include all this into.The signature pivot where signing it and.Then you basically can embed this sub.Trees in arbitrary called trees .You care about as well for example the.Same topology.And a signature Bionic.A signature on a tree will just mean.That whatever the address is for that.Signature is authorized anywhere in that.Tree where that address shows up is that.Correct.Authorized anywhere the contract .Calls all tries on it right so there is.Anywhere contract requested.Authorization.I have a question related to this about.Authorization context and the call stack.So if you if you invoke a contract a.That calls B and you know B is the only.One that calls authorized then a is not.Part of the context how long someone to.Front run a by submitting B.I'm wondering if there are any security.Issues or weird use cases here and if we.Should consider requiring the full call.Stack by default with the option to.Authorize the subset the cost stack and.Then the concern here is a high level if.It's possible for the front run to.Prevent I expected logic from running.Well it sounds right like at first.That was a consideration to include like.The full cost tax but the scenarios like.We have just discussed such scenarios.Like it's rather limited and makes use.Cases like exchanges much trigger to.Implement properly because you know you.May care only about like swapping the.Token and you don't want to care about.Like how exactly it has been solved.And and so from training some.Contracts would indeed need some.Front-end prevention in place so for.Example you know coming back to the.Batching the operations example right so.Let's say your contract clears multiple.Swaps and swap May Fail for multiple.Reasons one of them is run signatures.Another one is front run right someone.Front Trends is Swap and it's no longer.Valid right. this case is really not different.From any other failure like just write.Contract in a way that it gracefully.Handles the failures and you should be.Good. as for security issues I mean.It is possible to write a contract in.Such a way that you can transfer into.Signature for it and it's one to the.Right thing but it's probably on the.Contract and so I can implementation.Issue right.Normally what you should require is.Easier to sign should be it should be a.Some sort of atomic operation that the.User should intend to perform it.Shouldn't be some middle step so for.If I want to create a clinical balance.For example a simple thing right I.Want to transfer the token to the.Contract and I want to create an entry. on behalf of this user. I could drive this incorrectly and.Take just the signature for a transfer.And you can.From transit signature quarter transfer.But that's obviously about what I should.Do is I should reverse the authorization.The whole thing I'll use the pro or.Whatever so I mean.Bugs would exist for any sort of.Authorizations but.I don't really see an inherent security.Risk here and so on as you don't require.The user to sign some non-atomic.Things that you will build storage.So let's say coming back to the swap.Example let's say you did something.Based on the swap outcome then probably.You would want to or trades your top.Level contract that does the swaps.Because it does something else will.Probably need to be or trade right and.You don't want it to be functional.Right so and also there's a front.Training prevention topic.Never mind okay go ahead yeah so like.The you said it makes sense like the the.One thing I'm concerned about is you.Know the the authorization authorization.Context is determined by the contracts.Right as you mentioned and the user.Is just going to sign whatever.Pre-flight returns so and these bugs are.Not that like you know if you don't have.A great understanding of how. this authorization that these.Authorization Mechanics Work you may not.See it when you look at the contract and.The user is just going to sign whatever.Pre-file returns so it may not be you.Know at any point easy to see what the.Issue is until until it's too late. so that's just my concern I don't.Know if no I'm still not sure if this.Is so go ahead yeah yeah I know my.Intuition is that again this is probably.The case for any sort of traditions like.Let's say you understand the whole tree.Like do you really think that add in.Like a bunch of stuff does a tree would.Like prevent some weird cases when.You sign something that you didn't think.Yeah I'm not sure. but I think a great thing that.Structural payloads are always it's.It should be easy to implement a generic.Forward support for just parsing this.Tree and finding the relevant code you.Know like if you send something to The.Exchange that it's supposed to sell.Token a for you and you get your payload.And your vote says hey this is going to.Withdraw like 10x of the token a that.You actually wanted to trade then you.Know you probably won't find this and.Wait you wouldn't worry about this too.Much.So yeah there is definitely like more.Control from the interesting point. in a generic scenario I agree that .Some things might be vulnerable and.These are wouldn't know about that but.I'm yeah I don't have a good.Understanding of how prevalent would.This be or how dangerous would this be.Because well.And so it could be.Contracted a flowed in multiple wage.Rate and you wouldn't know so it's I.Guess the question of trust and you.Know only using the things that matter.And the fact that we at least can easily.Know what the contract trying to go to.Your tokens or whatever other.Commodities you have. it's already a big wins here. because like kind of limits the.Impact simulator.Lee yeah I have a question but it's it's.A little bit derailing so.I feel like I want to if anyone else has.Questions that are moral on the line of.What we're already talking about that.Might be best to do first. so I'm interested in Anna have a.Proposal interacts with the simple.Invoker auth case that we we currently.Support today so. I think when timer was describing.Before you know we developed the current.Version of sorbenorth we realized that.It's actually relatively. complicated to use and so then we.Went and had added invoker auth which is.Basically the same as message.sender in.The ethereum world.And the way that it's implemented is the.Source account on the operation is the.Invoker and so a contract can just say.Who's the invoker and they'll either get.Back and address they'll get back an.Address which is either the source.Account on the operation or the contract.That's calling them.Yeah I saw I understand that the.Proposal basically says okay there's the.Proposal replaces the complicated and.The simple auth we have today and.Creates a single unified interface that.Contracts use to. verify that the address is authorized. I'm just wondering like if there's a.Way that we can retain the simplicity so.That for the vast majority of contracts. enter the wallets and contract.Interactions they still have the.Simplest form of in terms of like what.They need to sign it's like the simplest.Without needing to go and sign these.Call statues.Well.I mean the host Tech tree for the case.That is currently an invoker case it's.Pretty much equivalent to just the.Conflicting location right because it.Consists only of a single invocation and. you know you just add a vector around.The things that already exists. so even if that call has like so.I'm calling just one contract but that.Contract may be calling five other.Contracts as a part of its.What it's going to go do. those calls may be unimportant to me.So maybe they're just calling out to an.Oracle again some information. again Nano Trace calls are not.Included in the payload wait this is an.Important point I want to reiterate.Again.That what what these are Sciences only.The authorized upset of the whole.Country.So it doesn't include any in between or.Side calls.Even if the authorized call is the top.Layer so even if I'm.Like the top call is going to be.Authorized.Ultra is doesn't propagate anywhere.Authorize means that I'll try this and.Only this added in the current context.That's it it doesn't say anything about.Inside invocation so that curse would.Not contain things that are not done on.Your behalf.So whatever the contract calls into .Doesn't matter for the secret signature.So for the case where invoker is used.Currently I mean invoker cannot be.Propagated currently right you cannot.Forward the invoker to the other.Contract which actually they have seen.From discussion it's kind of a bit.Annoying and confusing right because you.May sometimes want to propagate it.But yeah this is a side like in this.Exact use case when you don't propagate.The top level account anywhere the.Signature pillow it will be almost.Exactly the same module of the different.Structure rate instead of like having a.Single contract and invocation you will.Handle it support into a vector and.That's pretty much it and you will have.A signature a few different plates so.You know from adapt perspective it.Will be marginally harder to build this.Payload but you know doesn't need to.Account for anything new so just need to.Use a bit different structures and .From the transaction State Savings.Endpoint like we are keeping the.Invoker making sure to like save on.Signatures and you know if the source.Account thanks a whole transaction and.The contract call it is possible to.Mark that it is an invoker and do not.Require like a second signature.The optimization part is there two and.Yeah the only thing that kind of changes.From the contract interface 10 point is.That yeah you need to pass the account.Explicitly and intercourageon account we.May or may not introduce some sugar in.SDK to simplify that and make it so you.Don't really need to type what you want.To authorize but you know it's like one.Line of code. we also want to do this for the sake.Of Click so if you can but. I don't think it's too big of a.An issue to basically do this but on the.Other hand like it is now possible to.For the constant to do things on behalf.Of accounts in the sub course which is.Not possible within local current which.I think is yeah yeah of course.Yeah I think I think an optimization.Like if if there is some way for us to.Retain an optimization where The Source.The Source account could still be used.To authorize. I guess the because I'm not really.Too concerned about that one line of.Code that a contract has to add. I'm more concerned about what that.The story is for a Dap or a wallet.Developer.Yeah but the transaction you know a.Number of things I need to sign like .Like a you know like a hardware wallet.Needing to sign the Stellar transaction.As well as this blob which is like two. so two rounds of signing they need to.Go through versus if the if 99 of.Contract calls really only just need.That Source account you know they really.Only then have to sign just the.Transaction once which is.Yeah yeah I think you definitely want to.Preserve that it's increase that for.The signature key test when you know.You'll pay for the transaction that your.Qualities or one contract it's.Definitely easier to. just passing a signal curvy so.Basically yeah it doesn't go anywhere. but it will be possible to do.Everything in this single signature. how frequently this will be used.Compared to something else we don't know.Yet because we have discussed a lot of.The cases and you know some third-party.Page for the fees but you know that's.Something you've got a secret you know.It's a case for the user to just send a.Transaction to Samsung do to your.Business and this multi-help.Transactions hopefully possible to sign.Other corporations at once while still.Being compatible with something.Are there any other questions either.From anyone on the stage or the audience.I have a minor question that maybe like.You can you can explain like in the.Prototype why is authorize called.Authorized instead of something like.Verify authorization.I think that was done intentionally but.I don't recall the reason. I no I don't think there is reasons.Okay.Yeah I mean.Odd trays it's like.I don't know.I'll try this current invocation but if.It's confusing you can use whatever name. defines you to go.To college verify that's radiation as.Well check I don't know.Okay so I think there's.Yeah I think the the last one we touched.On which is having to sign multiple.Payloads for the even for a simple.Case. I think that's a no-go I think we.Need to either optimize for that. or or scrap this at the end of the.Day people are using external signing.Applications people are using Hardware.Wallets. and we need to figure out for the.Simple use case how to sign a single.Payload.Yeah okay so let's stay so I'm yeah I'm.Not saying this is going to go anywhere.As simple use cases will be possible but.You know for the complex use cases you.May end up needing to send two things.But yeah.Do you mean the simple use case would be.Satisfied by just keeping the existing.Invokerol with capability or are you.Meaning that we would introduce an.Optimization into this proposal so that.The contract still uses the same method.They still call Dot authorize or dot.Verify authorization yeah nothing.Changes somehow comes from the The.Source account Yeah so basically we.Don't truly awake.The whole driver for this proposal.Was to kind of have unified account .Oh sorry unified Contracting rupees and. you know I find it kind of.Problematic that.You kind of hard code your contract to.Use invoker right if you don't use.Advanced host on the current approach.And that's kind of bad right because if.You want to use this in a different.Context you cannot it's hard cut a teas.And Walker. so the contract interface itself uses.What's next it uses accounts and.Addresses and the abstraction and you.Know one of the implementations of that.Abstract account even though it's kind.Of built into host but it's just.Invokers rate it's just one of.Implementation of the abstract account.Contracts shouldn't worry about that.It's all implemented in the host and.It's in the current prototype as well. so yeah.Let's Chooser and by simple use case I.Mean the cases when there is only single.Accounts it needs to trace operations.You know throughout multiple accounts.And one of them can actually can be.Invoker but that's reason to pre-size.Something but they want me to sign the.Storage induction so hopefully you know.A majority of the case is only single.Signatures needed.So just to be on the same this is.Implemented in your host prototype for.Off next right now yeah it's in the Pro.Tab right now.So this is an important thing and it's.Important.And is the way that that works that .You it's only the top level contracts.But if they call Dot authorize they.Would see the source account as being.Yeah they actually will see wait.Basically the trees teeth sharing the.Transaction payload but instead of.Cutting the signature you pass nothing.And instead of passing the account ID.You pass the flag because it's an.Invoker it's similar to how we handle.Invoker currently in advanced cars it's.Just move to the transaction structure.Itself.Right I'm just wondering because in.Vegas today is only it has no depth.Like yeah now it has depth yeah now it.Will have depth because the transaction.Has the whole tree of the coast so.Basically you are signing the tree.Itself which is why it is safe okay so.So this the way the way it's currently.Implemented it's not really messaged us.And it's like the.Transaction.origin from ethereum it.Sounds like is the way that it's working.I I'm not sure but I think the key.Factor here is that you explicitly you.Still explicitly out price calls right.It's not like you just gave for a.Contract blanket permissions to call.Things on your behalf it is really.Just it's keeping the signature.Verification part because you when.You're assigning the transaction or.Operation you are also assigning the.Whole authorized call stack payload. that you've been talking about before.So yeah so basically yes the world would.Need to show you that hey as a part of.This operation you. maybe a sign in multiple token.Operations for example right but you.Know from the signature standpoint it.Needs to still be sanctioned once.So it's basically like msg.center but.Better because like energy the center is.Like contingent on the fact that you.Have signed the top level and location.Here you sign all the invocations.That you need to try.Yep okay yeah I'm the reason I just.Mentioned that the transaction of origin.Is because I'm just trying to think of.If there's .Anything that we really need to worry.Because it feels a little bit more like.Transaction.origin in the you know you.Could you're the source account you call.This contract either calls another.Contract you tell that other contract.That you're authorizing as the invoker.So that other contract is authorized.With the top level Source account.Yeah I think I think yeah I think I.Think it's probably fine because you're.Right it's reflected in you still have.To specify yeah yeah.Right there is really no way no matter.What kind of authorization you use and.So it's no way to somehow hide the.Subcontract call that prefers.Authorization so there is really no way.To hide some token withdrawals number.Deep in the trade those still circuits.No matter what or it will just fail.Because you haven't seen it. yeah.Any other questions from the stage of.The audience.Okay so I think you know dima's done.A great job at answering all these.Questions I think there's a still. most of the concerns are around the.You know what is the contract for the.Gap developer and to get insights into.That I think we need to regroup and.Probably come up with some you know.Minimal prototypes that help us.Understand that so hopefully that's.Something that we can put together. soon enough and .Discuss again.And if.No one has anything else they want to.Ask or to add then I think we can call.It a day.Yes maybe if you have a few more minutes.I have one question it's yeah.About the non replay protection.If a transaction fails because the.Call stack change will the nodes be.Consumed or not.Yeah the non-consumption is actually .Trick using. May.Need to think more about that in the.Current implementation.Nonce is basically tied to the top level.Or try it's called. which may or may not be the right.Thing to do which means that.It's something fails.Basically okay if the whole transaction.Fails The Ledger state is completely.Rolled back those announced won't.Won't be consumed.If a top level contractor tries succeeds.But. some subcontract call fails and.The top level contract handles is Grace.Collisions and not smart Bureau project.Thank you.Okay we we may need to discuss this.Further because this can be an issue.With like at some point.The transaction fail.And then becomes available again because.The code stack is available again.Someone can just run through you.And replace the transaction.Doesn't make sense.Yeah I mean the transaction replay.But basically again frontrun is kind of.Weird because it's it shouldn't be an.Issue most of the time because someone.Would do what you wanted to do anyway. yeah yeah but what you wanted to do.At one point may not be what you wanted.To do in the future so let's say I want.To transact with one with one inch to.Spend my.Money then these fails so I spend my.Money with another Exchange.And then someone replay the previous.Transaction and spend my money again.Like we can discuss this more but.Basically.Yeah I think like I think this kind of.Brings another topic which is.Exploration which I don't think we have.Discussed and they didn't do anything in.The proposal.It may be a generally useful feature to.Have you know for your.Signature to have expiration and that.Even could be a part of the standard.Payload so that we could distribute.Expired payloads. but yeah I think it's kind of.Complementary to our question okay yeah.Yeah the Norms could be Ledger bonded or.Time bonded.That may be a good idea okay yeah yeah.We can discuss this and yeah it would be.Nice to try to come up with basically.Some Sooners and the sink they can get.Abused somehow because. thanks Tebow so we are approaching.Time thank you so much for everyone and.Dima especially for you for prepping.This and for answering the questions we.Will regroup and update on Discord.Thank you all.

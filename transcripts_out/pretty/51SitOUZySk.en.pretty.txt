Hello everyone and welcome to the the.Last Stellar developer meeting uh this.Year and um on the agenda for today we.Have two things uh we have Jay from the.The core engineering team they'll talk.About some new additions uh in protocol.22 and then he is going to give some.Demos so uh I will.Invite Jay to join me here on stage.Hello hello can you hear me yeah I can.Hear you okay great um hi everyone uh.I'm I'm Jay core developer uh today I'm.Going to uh walk you through the.Building blocks that we introduced uh in.Protocal 22 which went live U this month.A couple weeks ago um uh specifically.Around uh the The cryptographic.Primitives uh namely bs2 381.Um.So yeah so the CAP for bs2.3d1 is uh CAP 59 which was introduced um.I would say three or four months ago um.But today I'm going to focus on just.Like a high level overview of what you.Can do with uh different uh types of.Functions introduce as well as the the.SDK interface and I'm also going to show.A couple examples uh simple ones to.Illustrate how you can make use of these.Core functionality today to build useful.Applications so uh let's get.Started first let me share my.[Music].Screen okay so um.Yeah yeah walking through u a few things.Um so first just briefly uh uh take you.Through the CAP uh since this is not a.Protocol meeting I'll just be really.Brief and not spend uh any time.Explaining the details and nuances you.Can read more about them um.So yes so this CAP CAP 59 uh is about uh.Bs12.381 so the brs1 123 3d1 is a is a new uh.Curve that that's added um so.The well it's not a new it's not one.Curve it's rather like a family of.Curves U there's namely the the G1 which.Is the base field and then the G2 which.Is the extension field and what's what's.What's useful about uh this curve.Specifically is that you can you can.Compute uh pairings uh which is taking a.Point in G1 uh pointing G2 repair them.And then it Maps into a different point.In a in a higher higher degree uh space.Um so at a high level what why is this.Useful you might ask so just like.Cryptography we wanted to uh compute uh.Like we want to do computations and we.Want we don't want to do them in a a.Plain manners right um just like ecdsa.You you utilize the.Um properties of eliptic curve and then.Uh and then the particularly the uh.Discrete logarithmic problem is is hard.To solve meaning that if you multiply a.Point a certain times um on the curve.And get a different curve it's really.Hard to invert that process to get the.Number that you multiplied with which.Makes it useful for private key and.Public key so same principle here um B2.C1 is just eliptic curve um and it can.It can used it can be used for.Signatures which I we show in our first.Example first example later on but it's.Also it can do a lot more um so yeah so.The so the high level G of this is that.Uh using the new the new curve you can.Do encrypted computation that follows.Certain rules and these are the basic.Building blocks which uh people use to.Build um more advanced and interesting.Applications such as CK.Knock all right so yeah so here are the.New host functions introduced uh I think.The total is like 12 if I remember.Correctly um there's a yeah the basic.Ones uh Point addition uh.G1 um Point uh Point multip.Multiplication with a constant um MSM.Which is basically a scaler like a.Vector multiplication which is yeah just.Multiplying a vector of number by a.Vector of points and then add them.Up so and then uh so these ones uh the.Hash to curve in map to curve uh these.Ones are if you use if you want to uh.Use a digital signature scheme like if.You want to map a random message onto.The curve and and and uh map to a point.Perform the uh cryptographic functions.On it you first have to take that.Message and you have to Hash it onto the.Curve um internally how it works uh very.Briefly is that it there's a h this hash.Function sh 256 and then you also.Provide something called a DST which is.The domain separate uh Separation The.Domain separation tag which is just a.Tag that you append to every message.Such that your applications domain.Separate from say like ethereum's.Application like um so it's always good.To have a unique uh DST for every.Application to avoid some kind of.Intricate attack um so the basically how.It works is that it just hashes like.Repeatedly hashes that message uh into.Um a certain lens which corresponds to.The uh the length of the the point on.The curve and then it checks if that.Point is on the Curve um and then if not.It it add one and repeat and then um.Once it is on the curve then it.Multiplies by some co-actor to send this.Curve to the correct subgroup um.So this is just getting a little bit.Into more detail is that these curves.Obviously they are uh Prime uh like they.Prime field so the the it's the numbers.On this curve are are modulus of a of a.Large Prime in this case um the prime.Number is.381 bits long thus the name U BR is 12.381 and the subgroup is is different.Subgroup is the number of points.That we pick or like the the definition.Of the curve pick such that these uh.Operations are defined so the subgroup.Is a subset of all available points on.The BS 81 curve and then the for this.Particular case the subgroup size is 256.Bit uh so which is very convenient to be.Represented as a big U.256 and so uh yeah some of the uh host.Functions here actually uh if you look.At they're called f which basically.Takes some U 256 vales and then like add.Them together like these numbers.Represent the the scalar in the.Definition of of this particular curve.Where the the modulus of the scaler.Equals the subgroup size so this is.Useful um for um manipulating the points.Like multiplying them and then making.Sure that this scaler is actually like.Represented by the points on the curve.Like yeah.So we just covered uh hash to curve and.Then um yeah then we repeat for G2 which.Is which is different uh group of points.Um same thing here map to G uh map map.To G2 hash to G2 and then the important.One or I guess uh the most interesting.One that um the applications built off.Of is the pairing so.So what the parent does is uh I'm I'm.Going to borrow some other uh slides.Here so this is.A this is just like a onepage uh.Explanation for BL signature which will.Cover in a bit in our example and here.Is just the definition of a pairing.Which takes a point in the first group.Um point on the second group pair them.Up and send it to a different group.Uh the interesting about the paing is.That it is bilinear which means that it.Is linear with respect to both the.First U term as well as the second term.So uh so here you see pairing of uh P.Plus s um is equal to pairing of P times.Pairing of s and same same here on the.Second term Q Plus R you can um pair.Them separately and multiply together so.The reason here is a multiplication.Uh again this is just some details is.That because uh the paing result is sent.To like a higher degree um the 12th.Degree uh that's part of the name BR is.12 so we need to get to the 12th uh.Degree extension field uh which is a.Multiplic multiplicative Group which.Means you can perform like.Multiplications um instead of a additive.Group which is our G1 and G2 so just.Some details but important fact is that.You can uh these relationships can hold.And then by the extension of it uh if.You have a u on the left side if you.Have a p repeated uh eight times uh this.Is essentially multiplying the result.Eight times and then which is equivalent.To taking the uh this paring result the.Plain par result of p and Q and exponent.Take the exponent a and then you can.Move this a either you know on the left.Side or on the right side or move it out.It doesn't it doesn't matter so the.Pairing uh this pair relationship can be.Quite useful um as we see in the example.Of uh both signature as well as a uh SN.Verification okay so I think that goes.Over well we just covered the FR which.Is the field this is just a this is just.A very simple uh um like modular.Arithmetics but with a very uh specific.Module like addition uh.Subtraction.Multiplication uh power inversion and.That's.All so now let's look at the SDK so how.Does this look uh inside the SDK which.Is which is what you'll be um.Interfacing with is so if you look at.The SD there's a it sits inside the.Crypto library and then there's a brst.381 um module so the all the functions.Are exposed inside the BRS 12 381 module.Um so the few additional functions like.Checking if a if a point is in the.Subgroup um but overall there is a.Pretty much one to one correspondence.Between the host function and the SDK.Function oh and also uh one interesting.To notice is there's a two addition.Method um one is just a plain addition.And then the other one is the checked.Edition so so the reason for that is uh.So remember what I said earlier was uh.The BL 12 381 points are defined over a.Particular subgroup um but.But but just the the addition operation.Can perform on any point on the curve.Doesn't have to belong to the subgroup.But in order for that addition to be.Useful for our pairings and for our um.Other uh like a SN operation like they.Have to be in the subgroup but the.Subgroup check is is is kind of.Expensive so if you have a contract.Which does like a number of these.Additions and only you want to make sure.The end result is on the subgroup then.You can use uh the plain add function.Which is not taking.Um yeah which is not taking the uh the.The check it's just it's just point.Doing the addition whereas if you wanted.To be safe and then you wanted to use.The the checked ad which performs the uh.The the subgroup check uh in in the end.Modifcation yeah these are all very.Standard yeah repeat for.G2 parent.Check oh yeah okay uh one thing about.The parent check here um like I uh.Mentioned earlier uh in this equation uh.This is a parent check it's check.Checking a pairing of two points equals.Some relationship of pairing like with a.Uh either like a a result of a pairing.Multiplied by each other or like.Additional terms but the the pairing.Result itself uh is is a point on a.Higher degree uh in a higher degree um.Extension F12 and then to compute that.F12 is very expensive so the parent.Check is intended such that we we can uh.Perform multiple pairings uh together.And then check that this the end result.Uh equals to one which means this.Pairing uh returns true or false if it.Satisfies true otherwise it's false uh.The the benefit of that is that these.Intermediate result they can be they can.Be performed on a a much lower degree.Which is much more efficient and only at.The very end do you have to or you don't.Have to but like internally the.Algorithm will send that to the uh uh.The 12's order and then do the.Comparison check with uh the the U the.Number one in 12 extension so so the.Reason for that is uh in most of the.Applications either in signature.Checking or in in SN verification um you.Only need to do pairing to to check.Certain relation hold like in a SN for.Example uh you are checking that your.Polinomial uh contains a certain.Structure uh by that you are Computing.Uh some.Polinomial uh relations and then you're.Checking that the left side equals right.Right right hand side uh this relation.Hold so you you in in now the point you.Actually need that 12 degree extension.Point all you have to do is to make sure.The left side equal right side so so far.I haven't uh heard of any application.That specifically needs the result of.The pairing so that's why we went with.This design of just passing a vector of.G1 Vector of G2 uh perform pairwise Che.Pairing and then check the result in the.End if it's equal than uh equal to one.Then return true otherwise return false.So it's just a.It's other line mass is the same but.Just uh you know something to be be.Aware like it's it's not taking a single.Point pair with a single point but.Taking a vector of pair with a vector.Um and then these ones we covered okay.So I think that's it for the building.Block oh it took 20 minutes it's.Probably should probably speed up a.Little huh.Okay so let's talk about the the useful.Applications U first first of all the.BRS signatures uh so I think I went.Through this in one of the protocol.Meeting earlier so I just keep it a.Little more brief uh because the other.Ones I think more interesting uh so the.BR signature uh the way it works I'm.Trying to find the paragraph that does.Explanation so yeah so so here there's a.There's some some kind of secret key and.Then oh sorry this is a public key.Uh okay so the the public key is some.Number times the point uh the generator.Point and then the the signature is uh.The public key times hash of the message.And by the parent property if you just.If you do the uh the public key and the.Hash of the message and then you move.The uh the Scala part uh around in the.End you just you get a you get a a check.Which is the uh the generator so the the.Pairing of the of the public key and the.Hash of message equals the the pairing.Of the the generator and then the the.The signature so yeah if you it's fairly.Straightforward the public key here.Sorry I don't know why you call PK it's.Actually just a secret key here uh you.Can move it.It appears on the left in the beginning.But you can move it on the right and.Then this becomes the the the signature.So the left and right must hold if this.Signature is valid and the good thing.About it is that uh if you have the same.Message and then multiple public Keys.Signing the message then you can.Essentially just aggregate all the.Signatures together and aggregate all.The Public Public Keys together uh do.This off chain and all you have to do is.Just to verify one pairing um then you.Can you know verify potentially hundreds.Of signatures all at once um and this is.Only this is uh um if the messages are.Same but if the message are unique then.For every message like M number message.There will be like M plus one parent.Checks um so that's the general idea of.The UHS signature so let's see the.Example uh so.So we have.Uh.Here hope you can see the code here uh.So this one example is already in the s.Bomb uh example repo uh you can look at.It today uh I try to keep it documented.Um I think it's fairly straightforward.Uh in the it's a pretty much as.Increment contract but the increment is.Uh requires an O which is a uh for every.Time you increment it will check called.Check or and then check some the.Signature payload and the uh and then.The public key so inside here is.Basically just loading loading the.Aggregate public key uh loading your uh.Uh domain separation tag um and then.Construct the vector and call pairing.That's all that is and then you can look.At the test which is doing most of the.Uh setups um.Here it contains 10 pairs of signatures.Um applying the aggregation and.Signature aggregation and then here just.Runs the test which invokes the check.All with some random.Payload um if I run.That yeah the.Signature uh signature passes and then.It dumps out the the budget and then.Yeah so this simple operation is like 31.Uh 31 million CPU instructions um so.Yeah remember this is 10 10 different.Signatures on the same payload um so 31.31 million to verify 10 signature you.Can do also more if they.More so that's a very brief uh walk.Through of the uh the V signature so uh.Now I want to go go and uh do something.Uh new and the potentially interesting.Which is the the cross 16 verifier so in.Order to show that we have the building.Block to build real ZK applications um I.Went and uh generated a very simple.Simple proof and then uh Ed a very uh.Simple impementation of the grass 16 uh.Verifier to verify that proof and uh I.Want to uh walk you through it.So I don't know if we have enough time.For me to.Actually.Uh so do do we do we have time how much.Time we have yeah yeah yeah take the.Time you need yeah okay yeah because I I.Do want to just walk you through the.Steps that that's required to um to.Generate the the proof and and and see.See it in action because a lot of a lot.Of this is is looks like magic when you.First run it like just dump dumped a.Bunch of things so okay.So here um don't know if you can see the.Link here but I'm basically using uh.Circum U circum doio uh if you just.Search for it at the installation the.Getting started guy um so circum is a is.A tool so.Circum uh and snjs is a pair of tools.One is for defining the circuit which is.A arithmetic relation of what you're.Trying to compute and then snjs is a is.A tool that allows you to take in the.Circuit and and do all kinds of.Computations and generate the proof and.Also verify the proof so what we're.Doing is uh we're going to just follow.This exact guide here uh.Generate Define the circuit uh do all.The setup necessary generate the proof.And then once we have the proof we will.Write our own contract uh to verify it.In soron instead of verified in.Snjs okay so let's.Screen all right hope you can see.My both of my.Screens so so I did little bit of.Preparation so uh here's a brand new.Folder I have these two files uh these.Are the exact instructions here it tells.You to copy the input copy the circle I.Just did in advents so we don't have to.Go through that so the first thing um it.Wants you to do is to install these.Dependencies which I already did so we.Can skip that and the second one is that.Uh it tells you to uh Define the circuit.In the circum language the the circle is.Really uh simple it's the simplest you.Can get basically multiplying two.Numbers and then and then output the the.Result of the.Multiplication um however the the uh.Interesting part is that these inputs A.And B are uh private inputs so in the.End uh your proof will prove that this.Computation was done correctly uh uh.Without revealing What A and B is so.Only the only public output will be C uh.The um the number the result of the.Multiplication so what we what we did.Here is just copy this exact program uh.Into this multiplier.File and then the next.One uh compiling the circuit so yeah so.Scales gives you the the Circ.Instructions um how to do that so this.Is basically just writing this circuit.In in in some formats and uh so that it.Can can be understood by um the other.Tools.Um but there's one thing we have to.Change on this.Command which is BRS.12381 um so the reason that we need to.Specify this is the the circuit.Compilation uh needs to know the range.Of like the the the range of uh prime.Number so it needs to take the prime the.Prime number the 3 381 uh one bit number.Associated with with our curve right.This B 12 31 and use that as a as as a.Curve to generate this circuit otherwise.It I don't know what happens although I.Haven't tried but you should you should.Do that so once you do that um it will.Generate the multiplier in this R1 CS.Format and then some other stuff so the.R1 CS is a rank one constraint system um.Why is it called so so think of any.Complex computation like a a know a squ.* Bal C something like that um you can.Always break it down into simpler.Computation by creating intermediate.Gates and then assigning intermediate.Gates to you know more intermediate and.Then like in the end you you just.Compute two things to an output.So so the the the process of R1 CS is.Just uh comp uh deconstruct a complex.Computation in something into something.Simple as a left left hand side times.Right hand side equals an output whereas.Both left hand side right hand side and.Output are rank one which means the.Highest polinomial degree is one so you.Can have like a plus b but not a.Square so that's what it.Is okay once you do that um the next.Step is to compute the witness so so at.This point we have the circuit which is.Our structure of our computation but in.Order to to compute it like in order to.To be verifiable we have to comput it.With some inputs and then generate uh.The proofs and all that so here is just.Defining the the input I I did did here.Which is exactly what it's using so it.Tak.3 * 11 so the output will be uh 33 um.But we don't we won't know about this.Three and.11 so once we have that uh we will enter.The uh the JS.Library okay it's empty right uh it's.Generate yeah some other AO generated uh.Code to compute uh stuff so what we do.Here is.Uh actually copy this one but I'll input.This.Some okay so this one is just generating.Uh the the witnesses.Uh and then you can also do this with.C++ and then once you do that you have.The uh the witness file I don't think we.Can load it yet but it's just a.Um yeah the the witness uh is just the.Input basically um.Like I think the witness is it private.Or just probably I I don't I forgot the.Exact terminology but it's possible that.The witness is just a public output U so.So so only the C part 33 is contained in.The.Witness okay now comes to the proving.Part so yeah so so here here there's a.Bunch of commands if you do it for the.First time it will look fairly weird.Because it's telling you to generate uh.A power to ceremony um so what what it.What it really is is um so in order to.Yeah so in order to compute uh the proof.So okay so remember we have the R1 CS.File and then the R1 CS is just a system.With equations of different uh nodes and.Then every equation is just a simple.Rank one left right equals output uh.Multiplication and and and so the the.Next step in order to uh make that into.Some kind of provable structure is to uh.Convert this into a qap which is a uh qu.Quadratic arithmetic program what it.Does is to on each side the left right.And output it uh fits uh a number of.Polinomial that evaluate to uh at.Certain points so the number of.Equations is is a number of constraints.And at each constraint the polinomial.Will evaluate at a different points so.To keep them separate and then a pol.Polinomial is the aggregation of smaller.Pol polinomial defined over each unique.Node so um what you what you think in.The and is just.A instead of left left times right.Equals output you have a left side.Polinomial uh of some degree degree.Which which matches the number of.Constraints and same for right hand side.And the opposite side um.And and in order to to verify this.Polinomial computed correctly uh we so.Here here's a key here's a key uh.Concept U is in order to verify the.Computational polinomial all you have to.Do is to verify the computation of a.Polinomial at a single random Point um.So this may sound little you know.Counterintuitive in the beginning but if.You if you have polinomial of degree two.Then there can be only two roots and.Then if you have two polinomial of.Degree two you you subtract them.Together it can still only have two.Roots so which means that it can the two.Polinomial can only be identical at n.Number of points where n being the.Degree of the polinomial so even if we.Have you know hundreds thousands of.Constraints in our circuit the space the.Total space of our uh uh of our SN the.The prime modulus or rather the subgroup.Is 200 200 56 bits long so it is.Impossible for any uh Collision to.Happen in in real chance so this this a.Key concept of how to like how to.Convert this polinomial into a u into a.Non interactive check which is you just.Need to make sure that it's evaluated at.A truly random uh value and then this.The verifier or anyone can just take the.Output of that and then make sure and.Then check the verification that uh the.The polinomial equality holds with.Pairing uh what we introduce here so.This is what it does so so the power of.To here the the long story short is just.The the steps necessary to generate that.Random point at which the polinomial are.Evaluated that's really what it is um so.I'm going to spe speed around through.These steps here um it's not really that.Interesting there's a lot of output you.Can look at it later.Sorry B 12.31 that's the first step contribute to.Ceremony some random.Text it's going to compute set up some.Ceremony and then um the gr 16 requires.A a public uh a Universal setup which is.For the whole like you have to do once.And then the per Circle specific setup.So that's the second step here.So this was the last command prepare.Phase two and then yeah.Just set up the circle specific.Stuff okay and then.Uh and then contribute to.The another text okay so now we have the.The um the proving key and the.Verification key set up for this circuit.And the next step is to generate the.Proof okay so in the end we have uh this.Proof.Yeah which which uh contains uh ter.Terms which is like encrypted evaluation.Of polinomial at some.Public public.Json do we get.That oh um I think I sent it to the.Previous folder but yeah the.Public should just have one value here.Um which is 33 so uh to verify uh verify.A proof to so what what we need to do is.To write a uh a.Contract um this here it makes really.Easy for you to do so there's a step.Where you can um call to generate a.Ethereum u solidity contract for.Verifying.And then uh.Four yeah.Here yeah so the cont itself is um it's.Not that interesting um I'm not familiar.Too much with solidity but most of the.Logic here is just packing bits into.Memories and then in the end it's called.This caring on you know a bunch of terms.So we can easily convert that into a Sor.Bond and the output of you know our.Contract is just this much it it.Verifies the proof takes a verification.Key which is some um like G1 G2 points.Uh and then approve which contains also.Points in G1 G2 public signal in this.Case just one which is 33 encoded into.The scale a field.Number um and then aggregate the input.And then uh yeah construct the back to.Check paing and that's really it and.Then I did uh I copied all of the the.Outputs um it's a it will be a different.One than what we gener earlier because.There an entropy I I because of the.Random randomness um but but I did this.Earlier I just copied all these uh the.The pro the proof part and the ver if.Ification key part this is proof and.Then this is the VK and then construct.The the key construct the proof and then.Just call uh the verify proof and assert.That this result uh must be true because.The we've putting uh you know the output.At 33 so which is matches our public.Output so let's run this.Test okay so it finished and you can see.That this verifying the ZK proof uh.Takes around 30 like 41 million CPU.Instructions it performs uh four parent.Checks per some addition multiplication.In G1 space so if you have more public.Input then there will be more.Multiplication and additions here but.The pairing is only there's only four.Pairing so the so the total CPU is.Roughly this this amount um yeah I think.That's it uh sorry for taking uh longer.Than expected but uh this is it and.Hopefully that you can see that this is.Um this is uh you know exciting stuff.That you can use to build uh DK.Application today you may ask what's the.Use of it um you know the real.Interesting part is is in the circuit.Part um so instead of proving you know a.B and c you can write a much uh.Interesting one like you know proving.Hash like comput computation of a hash.Or or knowing a pass in a Merle tree.Which is like proof of possession or.Something like that so all the.Innovations you know a lot of it can can.Happen on the Contra side which is what.You guys uh you know are that that stuff.So yeah really looking forward to uh.Seeing what comes out of it and yeah uh.Let me know if you have questions we.Also have a Discord threat feel free to.Post it there and I'll hand it over to.Cin great thank you so much this was uh.This was really good I think the.Examples and and walking through the.Code really made it U easier to.Understand and and see see potential.With so I know we have one question uh.Let me see Elliot was asking a question.Earlier about if the host functions are.All that's needed for CK snarks on.Stellar or if there's still additional.Functionality that's missing I don't.Know if you have an answer for that yeah.To to verify the SN it's all we need um.Okay so there there are some some quoes.In SDK which we we we build it like in.The um like we provide the the the most.Generic like interface to expose this.For but there's a little bit corks like.You like for example ear U see in order.To try to store that um I have to store.The Bice instead of the G1 G2 but that's.The fix and also to compute the uh.Negation of a point uh you have to do it.On the contract side but yeah uh in.Terms of verification all the tools are.There um but there may be some ux gap.Which I'm discovering and should be.Fixing soon and also with your guys help.We will be able to make it better yeah.But in terms of verification that's it.But in terms of pro proving um so as you.See proving has to happen offchain and.Then that's quite elaborate uh toour set.And also like different um Suites of uh.You know there's different Frameworks of.U like Marin uh you know gr 16 Plank and.And all the other other tools that you.Can use so we haven't provide any of.That and we don't uh endorse any of it I.Was just using the snjs as a example.Because that's one of the you know most.Well known um and then yeah that also.The the public ceremony aspect uh yeah.We don't have it on chain so but yeah.You can verify it but not there's no.Proving um uh tour CH available at the.Moment okay great any any other.Questions feel free to put them in the.Chat I don't.Think that's the case.Uh we are kind of running out of time so.I.Will save the the uh walk through of.Quick start for the next meeting um but.Yeah if there's no other questions then.I think.U we will stop it right here let's.See.Yeah.Okay well thank you Jay thank you for.For for for your presentation it was.Really good I think uh I think going.Forward when we when we add new.Functionality in in protocol when we uh.Upgrade the network I think it's it's.Relevant to to maybe spend some time in.In these meetings to to go over some of.The new new functionality and some of.The the things we can do as a developer.Um so yeah um look forward to to more of.This kind of presentations but thank you.J Jay and thank you for everyone who.Joined have a good holiday thank you you.Guys happy holiday bye.

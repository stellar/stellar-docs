Okay, I'll get started.Um, hi everyone.Today, uh, we are going to be talking.About CAP 75, which is a proposal to add.Two new host functions to support.Poseidon and Poseidon 2 head functions.Um, so the CAP itself is fairly.Straightforward.Um, two new host.Functions.Um it it's pretty standalone.Doesn't involve any of the uh previous.Protocols mostly uh except uh using the.BLS and BN field.Um but I want to spend.A little bit time on the approaches that.We decided on and the rationale behind.This approach.So uh first of all just a.Quick uh introduction on on the.Motivation why do we want the Poseidon.And Poseidon 2 hatches.Um so so.The Poseidon and Poseidon 2 they are.I'll call them Poseidon family.So they.Are they are family of hashes basically.It accept a range of parameters and then.Uh you can configure it to to compute.Output.So what it what it is is it's a.Sponge based.Uh hash function which means it consists.Of a sponge.Uh that absorbs input um and fit output.Which is a variable length input various.Variable length output uh function and.Internally there's a permutation which.Is fixed input fixed output and the the.Reason that u it is useful along with.Other um catches of similar design is.That it directly operate uh natively on.The on the prime field.And as you can.As you know uh most of the zero.Knowledge applications uh are built off.Of the prime field such as uh BRS or.BM254.Which makes Poseidon uh natively work uh.With with this field and they are ideal.In DK application.Just to give a rough.Idea, it uh the amount of constraints uh.To generate using a regular hash like a.SH 256 versus Poseidon is two order of.Magnitude difference.So it's a lot of.Proof side less proof side complexity.And time to use Poseidon.So for for contrast um so proof.Allocation typically don't involve.Rehashing or anything.Um but for.Contract implementing uh logic such as a.Mer tree that you want to generate proof.Of um you want to have the same hash.Implementation.Um between your contract and what you.Use when you generate the proof for that.Mole tree.I think that's quite obvious.Um and to have the Prooseidon.Implemented uh on the on the gas side or.Or contrast side uh is quite expensive.Even with the functions that we already.Provide uh for BLS uh field arithmetics,.There's still a lot of round trips.Between converting a few element to.Bytes and and things like that.So uh.That's why we we want to support.Prooseidon uh as native host functions.So just a recap of where we were last.Time.Last time we proposed um a few uh.Three uh possible approaches to this.Uh.First is just to provide the hash.Functions uh plain and simple.um you.Know for different field uh you know for.For different field uh combination of B.And BLS combination of PID and PIN 2 and.A combination of uh number of hash.Input.So this gives us uh what like.Eight different type of host functions.That will cover a lot of use cases.Um.But this approach isn't good because.We've uh from the feedback and from the.Evidence that a lot of these hashes they.Require uh particular parameters these.Parameters are not set in stone.So.Different implementations could choose.Them differently.So even if we specify.Them uh in uh in the host for example.Someone else might need a different way.To provide a parameter.So this way.Isn't just provide a hash function isn't.The most um maintainable way and what.About providing more host functions for.Those field arithmetics and also it.Wouldn't solve the problem because even.If we provide things like matrix.Multiplication the pose hashing involves.A lot of rounds of permutation each.Round is doing this multip.Multiplication so we still end up with a.Lot of these cause and a all of these.Round trips.Um so one of the proposals.Ended up last time was um can we provide.A more generic interface uh for the for.The sponge hash uh namely the uh to.Absorb some input doing permutations and.Spit out the output and then be and let.It be parameterized.So um yeah so that's what we settled on.On last time and and yeah so now to.Transition to this cap.So this cap.Proposes a slightly different approach.Uh which which I call approach four um.That from the discussion thread for for.Anyone who's following.So approach four.Is instead of providing the launch.Interface we provide the internal.Permutation functions that the launch.Hash uses.Um so why why why is that?
So.So the the sponge is the sponge is a.It's sort of its own animal.It's a.Different animal than the permutation.Um, sponge design had many different.Considerations.Uh for different applications.For.Example, not only for hatching but also.For um like uh generating like a random.Stream of bytes or uh or for MAC uh.Method message authentication code um or.For for random uh like for receable.Random value generator like these.Applications are all u designed.Scope of a sponge.So the sponge needs.To be more flexible.It needs to uh.Maintain a state.It needs to um in some.Some cases it requires switching between.Absorbing and squeezing and then.Switching back.So the sponge interface.Itself isn't.It isn't a single definition that we can.Um just just take uh because uh and.Itself is also has some some complexity.In it.Um however the internally all the.Sponge function they call the same.Permutation uh function.So after so in.Both stun absorb and squeeze uh the the.Input and output before it was the input.Is passed and then the permutation is.Applied and and the permutation is.Applied and the output is squeezed.So at the center of it is just this.Permutation function that takes a fixed.Length input and a fixed length output.So this is much more uh maintainable and.It's much more uh easy to support in.Solarong without ramifications because.It's just a simple cryptographic.Building block and the sorbound host.Doesn't need to maintain any any state.Um so there's no like state related.Issues for like what if you make a.Subcontract call do they you know.Reinitialize a sponge and how to do.That.So, so by by supporting Prooseidon.Permutation instead of the full.Prooseidon hash uh it gives us a lot of.Flexibility.Maintaining sort of host.And also sponge itself for for a h for a.Simple hash algorithm that's um like a.Binary hashing.Of of a Merkel node for example isn't.That complicated.is just basically it's.Just a single round of taking the input.And applying the permutation and.Spitting out the output.I've written.Down a little pseudo code that basically.Is what it is in the cap.So, so just to.Recap, the sponge interface is.Complicated.Uh it the the sponge is.Designed for many different use cases,.Not just hash.Even though for hash the sponge is.Really simple uh we don't want to just.Baking a simple sponge implementation.Inside host while this is much easier to.Do it in the contract or in the guest or.In the SDK.Um but it is makes much more sense to to.Support the primitive that's mostly the.Most expensive uh operations happen.Which is the permutation function uh.Inside the sort of host.So that's the high level motivation and.Uh now I can go through the actual two.Functions being proposed.Uh one is a.Prooseidon permutation and second one is.Prooseidon 2 permutation.Uh the two.Look fairly fairly similar.So um so.Just a bit of background Prooseidon is.The original version developed in 20.2019.uh Poseidon 2 is a a improved.Version of that developed in uh 2023.Internally they they work slightly.Different.Poseidon 2 has u improved the.Internal matrix um shapes and then add.Uh pre uh relication add add a single.Layer of pre-apply but overall it works.Fairly similar.Um so I'll just cover.The Poseidon one.So the process permutation takes the.Input which is a vector object that is.Your uh vector of field element and then.The second thing is the field type.So I think it probably makes sense to.Have field type as a symbol but in the.Cap I I'm putting U32 um should be.Equivalent but yeah field basically is a.Enum that um specify which field you you.Want your um permutation function to be.Defined on and of course your input will.Be passed in the same field as the.Permutation.Um matrix and all that.Uh, and the rest.Of it is just internal parameters for.The for the hat functions.Um, so that's.Pretty much it.Um, but I'll just spend.Maybe a few a couple minutes just.Explaining what these fields are.Uh, t.Is the capacity parameter.So it's the.Um capacity the internal sorry not the.Capacity but the internal state uh size.The internal state side much must match.The input uh and also must match the.Size of internal matrix.It is.Decomposed of the rate which is number.Of you can think of as number of input.You need to hatch at once plus some.Capacity which gives you additional.Security parameters.uh d is the degree.Of the the fbark which is the um.Internal.One of the internal step in the.Permutation before applying the matrix.Multiplication.So for bn and bs both.Both fields uh d is equal to five.So we.May we may just only accept the equals 5.U but of course for other field in the.Future could be different.uh the round.F round t these are the internal partial.Round and the for round these are the.Number of round the matrix.Multiplication happens um so the uh yeah.Uh so the there's also a linear layer.Which is u sorry the the linear layer is.A run uh the mod matrix multiplication.But the nonlinearity is provided by the.Run constants which is also matrix but.Specified for each run.So the so the MD.MDS matrix uh for hash two function is.3x3 run constant um is a is another.Matrix with dimension n by m where n is.The number of run and m is three.So that's a high high level run through.Of the different parameters.Uh the.Second one is fairly similar.The only.Difference is that uh the internal MDS.Matrix uh in the second version is a.Diagonal matrix uh because of the.Precision 2 improvement.In terms of cost type.So we so we manage I think we we can.Manage to ship this as a native uh solar.Bond library which means that all of the.Operations um they are already existing.And were defined.These include the.Field arithmetic for adding and the.Multiplication and things like that.There's no particular peridon specific.Metering parameters we need to support.But we do have to add these ban 254.Field u arithmetic cost types um which.Is a very opportune timing because we.Have the CAP 74 which has b24.Um scala field and uh pairing.&gt;&gt; I went through the parameters.Metering.Rationale.Yes.So that the rationale.Why hash function uh why we don't.Provide a hash function out of box.Rather than providing the um permutation.Primitive.It is explained.And yeah just to also mention these.Parameters they are.Yeah so so some of them they are they.Are kind of defined based on the.Application like if you have a curve of.If you want to do hashing with BN25 uh.254 then the degree is five you can.Change that and then the sum of them is.Depend on the actual application uh.Which is how many inputs you want to.Hash at once and then based on the size.Of the input these parameters um like t.And then the number of runs they need to.Be adjusted um the original procidum.Paper provides scripts and guidelines.For how to generate these parameters um.In general uh I think uh most.Applications have their own.Um they they have they use a a set of.Generated parameters like CIRCOM does.And Noel does and to provide the maximum.Um like safetiness uh we would have.These as part of preset uh in the SDK.So like the SDK SDK interface will look.Exactly just like a hash two that takes.Two input and then internally you may be.Able to specify the set of parameter.Like a circum parameter or or neural.Parameter things like that and then we.We also possibly uh expose these.Poseidon permutation as a as a more like.A hazmat interface something that.Advanced users that know what they're.Doing can can call uh with their own.Parameters but we we will make them uh.The distinction more clear.Yeah.In terms of testing um there's a.Reference implementation for Prooseidon.And um so Horizon lab has a reference.Imitation for Poseidon 2 and in the same.Repo has Poseidon one.That's the one we.Likely going to adopt.And it also.Provides test vectors for both one and.Two in different fields and parameter.And then there's also the original.Prooseidon uh paper that come with a a.Sage script implementation with some.Reference vectors which we will also.Match our implementation with in our.Tests.There's a draft implementation and I.Think that's it.Now four is open for questions.So I did a very rough well I.Wouldn't say too rough but like the.Implementation is fairly.Mostly good and then the the field for.BRS is already there.So I did a um.Number on on the on the reference test.Cases uh for BLS uh.The 3x3 matrix case which is the hash.Two operation that's about half a.Million CPU instruction.So it's a lot a.Lot better than what I projected last.And then the 5x5 matrix case I.Believe that's like cache three input.That's around 1 million CPU.So yeah that's well below our target.Ceiling which we want to support around.20 hash cores in a single contract.Oh, okay.You want me to close it?
Okay.Bye, everyone.

WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:59.999 align:start position:0%
Okay, I'll get started. hi everyone. Today, we are going to be talking about CAP 75, which is a proposal to add two new host functions to support Poseidon and Poseidon 2 head functions. So the CAP itself is fairly straightforward. two new host functions. It it's pretty standalone doesn't involve any of the previous protocols mostly except using the BLS and BN field. But I want to spend a little bit time on the approaches, that we decided on and the rationale behind this approach. So first of all just a quick introduction on on the motivation why do we want the Poseidon and Poseidon 2 hatches. So. So
00:01:00.000 --> 00:01:59.999 align:start position:0%
the Poseidon and Poseidon 2 they are I'll call them Poseidon family. So they are family of hashes basically it accept a range of parameters. And then you can configure it to to compute output. So what it is is it's a sponge based hash function, which means it consists of a sponge, that absorbs input and fit output, which is a variable length input various variable length output function and internally there's a permutation, which is fixed input fixed output and the the reason, that u it is useful along with Other catches of similar design is, that it directly operate natively on the prime field. And as you can as you know most of the zero
00:02:00.000 --> 00:02:59.999 align:start position:0%
knowledge applications are built off of the prime field such as BRS or BM254 BM254, which makes Poseidon natively work with with this field and they are ideal in DK application. Just to give a rough idea, it the amount of constraints to generate using a regular hash like a SH 256 versus Poseidon is two order of magnitude difference. So it's a lot of proof side less proof side complexity and time to use Poseidon. So for for contrast. So proof allocation typically don't involve rehashing or anything. But for contract implementing logic such as a mer tree, that you want to generate proof of you want to have the same hash implementation implementation between your contract and what you use. When you generate the proof for, that
00:03:00.000 --> 00:03:59.999 align:start position:0%
mole tree. I think, that's quite obvious. And to have the Prooseidon implemented on the gas side or or contrast side is quite expensive. Even with the functions, that we already provide for BLS field arithmetics, there's still a lot of round trips between converting a few element to bytes and and things like, that. So, that's why we we want to support Prooseidon as native host functions. So just a recap of where we were last time. Last time we proposed a few three possible approaches to this. First is just to provide the hash functions plain and simple. You know for different field you know for for different field combination of B and BLS combination of PID and PIN 2 and a combination of number of hash
00:04:00.000 --> 00:04:59.999 align:start position:0%
input. So this gives us what like eight different type of host functions, that will cover a lot of use cases. But this approach isn't good. Because we've from the feedback and from the evidence, that a lot of these hashes they require particular parameters these parameters are not set in stone. So different implementations could choose them differently. So even. If we specify them in in the host for example someone else might need a different way to provide a parameter. So this way isn't just provide a hash function isn't the most maintainable way and what about providing more host functions for those field arithmetics and also it wouldn't solve the problem. Because even. If we provide things like matrix multiplication the pose hashing involves a lot of rounds of permutation each
00:05:00.000 --> 00:05:59.999 align:start position:0%
round is doing this multip multiplication. So we still end up with a lot of these cause and a all of these round trips. So one of the proposals ended up last time was can we provide a more generic interface for the sponge hash namely the to absorb some input doing permutations and spit out the output. And then be and let it be parameterized. So yeah so, that's what we settled on on last time and and yeah. So now to transition to this cap. So this CAP proposes a slightly different approach, which which I call approach four, that from the discussion thread for for anyone who's following. So approach four is instead of providing the launch interface we provide the internal permutation functions, that the launch
00:06:00.000 --> 00:06:59.999 align:start position:0%
hash uses. So why why why is, that? So. So the the sponge is a it's sort of its own animal. It's a different animal than the permutation. sponge design had many different considerations considerations for different applications. For example, not only for hatching. But also for like generating like a random stream of bytes or or for MAC method message authentication code or for for random like for receable random value generator like these applications are all u designed scope of a sponge. So the sponge needs to be more flexible. It needs to maintain a state. It needs to in some some cases it requires switching between absorbing and squeezing. And then
00:07:00.000 --> 00:07:59.999 align:start position:0%
switching back. So the sponge interface itself isn't it isn't a single definition, that we can just just take. Because and itself is also has some some complexity in it. However the internally all the sponge function they call the same permutation function. So after. So in both stun absorb and squeeze the the input and output before it was the input is passed. And then the permutation is applied and the output is squeezed. So. So at the center of it is just this permutation function, that takes a fixed length input and a fixed length output. So this is much more maintainable and it's much more easy to support in solarong without ramifications. Because
00:08:00.000 --> 00:08:59.999 align:start position:0%
it's just a simple cryptographic building block and the sorbound host doesn't need to maintain any any state. So there's no like state related issues for like what. If you make a subcontract call do they you know reinitialize a sponge and how to do, that. So. So by by supporting Prooseidon permutation instead of the full Prooseidon hash it gives us a lot of flexibility flexibility maintaining sort of host and also sponge itself for for a h for a simple hash algorithm, that's like a binary hashing of of a Merkel node for example isn't, that complicated. Is just basically it's just a single round of taking the input and applying the permutation and spitting out the output. I've written down a little pseudo code, that basically is what it is in the cap. So. So just to
00:09:00.000 --> 00:09:59.999 align:start position:0%
recap, the sponge interface is complicated. It the the sponge is designed for many different use cases, not just hash. Even, though for hash the sponge is really simple we don't want to just baking a simple sponge implementation inside host. While this is much easier to do it in the contract or in the SDK. But it is makes much more sense to to support the primitive, that's mostly the most expensive operations happen, which is the permutation function inside the sort of host So, that's the high level motivation, and now I can go through the actual two functions being proposed. One is a Prooseidon permutation and second one is Prooseidon 2 permutation. The two
00:10:00.000 --> 00:10:59.999 align:start position:0%
look fairly fairly similar. So. So just a bit of background Prooseidon is the original version developed in 20 2019. Poseidon 2 is a a improved version of, that developed in 2023. Internally they they work slightly different. Poseidon 2 has u improved the internal matrix shapes. And then add pre relication add add a single layer of pre-apply. But overall it works fairly similar. So I'll just cover the Poseidon one. So the process permutation takes the input, which is a vector object, that is your vector of field element. And then the second thing is the field type. So I think it probably makes sense to have field type as a symbol. But in the CAP I I'm putting U32 should be
00:11:00.000 --> 00:11:59.999 align:start position:0%
equivalent. But yeah field basically is a enum, that specify, which field you you want your permutation function to be defined on and of course your input will be passed in the same field as the permutation permutation matrix and all, that. and the rest of it is just internal parameters for the hat functions. so, that's pretty much it. But I'll just spend maybe a few a couple minutes just explaining what these fields are. t is the capacity parameter. So it's the capacity the internal sorry not the capacity. But the internal state side much must match the input and also must match the size of internal matrix. It is decomposed of the rate, which is number of you can think of as number of input
00:12:00.000 --> 00:12:59.999 align:start position:0%
you need to hatch at once plus some capacity, which gives you additional security parameters. D is the degree of the the fbark, which is the internal internal one of the internal step in the permutation before applying the matrix multiplication. So for bn and bs both both fields d is equal to five. So we may just only accept the equals 5 u. But of course for other field in the future could be different. The round f round t these are the internal partial round and the for round these are the number of round the matrix multiplication happens. So the yeah. So the there's also a linear layer, which is u sorry the the linear layer is a run the mod matrix multiplication
00:13:00.000 --> 00:13:59.999 align:start position:0%
but the nonlinearity is provided by the run constants, which is also matrix. But specified for each run. So the. So the MD MDS matrix for hash two function is 3x3 run constant is a is another matrix with dimension n by m where n is the number of run and m is three. So, that's a high high level run through of the different parameters. The second one is fairly similar. The only difference is, that the internal MDS matrix in the second version is a diagonal matrix. Because of the precision 2 improvement in terms of cost type. So we. So we manage I think we we can manage to ship this as a native solar bond library, which means, that all of the operations they are already existing and were defined. These include the
00:14:00.000 --> 00:14:59.999 align:start position:0%
field arithmetic for adding and the multiplication and things like, that. So there's no particular peridon specific metering parameters we need to support. But we do have to add these ban 254 field u arithmetic cost types, which is a very opportune timing. Because we have the CAP 74, which has b24 scala field and pairing. So I went through the parameters metering metering rationale. Yes. So, that the rationale why hash function why we don't provide a hash function out of box rather than providing the permutation primitive. It is explained and yeah just to also mention these parameters they are
00:15:00.000 --> 00:15:59.999 align:start position:0%
so. So yeah. So so some of them they are kind of defined based on the application like. If you have a curve of. If you want to do hashing with BN25 254. Then the degree is five you can change, that. And then the sum of them is depend on the actual application, which is how many inputs you want to hash at once. And then based on the size of the input these parameters like t. And then the number of runs they need to be adjusted the original procidum paper provides scripts and guidelines for how to generate these parameters in general I think most applications have their own they they have they use a a set of generated parameters like CIRCOM does and Noel does and to provide the maximum
00:16:00.000 --> 00:16:59.999 align:start position:0%
like safetiness we would have these as part of preset in the SDK. So like the SDK SDK interface will look exactly just like a hash two, that takes two input. And then internally you may be able to specify the set of parameter like a circum parameter or or neural parameter things like, that. And then we we also possibly expose these Poseidon permutation as a more like a hazmat interface something, that advanced users, that know what they're doing can can call with their own parameters. But we we will make them the distinction more clear. Yeah. In terms of testing there's a reference implementation for Prooseidon. And so Horizon lab has a reference
00:17:00.000 --> 00:17:59.999 align:start position:0%
imitation for Poseidon 2 and in the same repo has Poseidon one. That's the one we likely going to adopt. And it also provides test vectors for both one and two in different fields and parameter. And. Then there's also the original Prooseidon paper, that come with a a sage script implementation with some reference vectors, which we will also match our implementation with in our tests. Tests. There's a draft implementation and I think, that's it. Now four is open for questions.
00:18:00.000 --> 00:18:59.999 align:start position:0%
Okay.
00:19:00.000 --> 00:19:59.999 align:start position:0%
Yeah. So I did a very rough well I wouldn't say too rough. But like the implementation is fairly mostly good. And then the the field for BRS is already there. So I did a number on on the reference test cases for BLS the 3x3 matrix case, which is the hash two operation, that's about half a million CPU instruction. So it's a lot better than what I projected last time. And. Then the 5x5 matrix case I believe, that's like cache three input, that's around 1 million CPU. So yeah, that's well below our target ceiling, which we want to support around 20 hash cores in a single contract.
00:20:00.000 --> 00:20:59.999 align:start position:0%
questions. Okay. Back to you, C. Oh, okay. You want me to close it? Okay. Bye, everyone.
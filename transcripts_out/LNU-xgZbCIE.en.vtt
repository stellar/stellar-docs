WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:59.999 align:start position:0%
Hear me, my name is Julia Martinez, senior developer Advocate, and I'm super excited to get today's session kicked off, where we will be learning the ins and outs of Russ smart contract development. So I'll go ahead and kick it off with a quick introduction. Again, my name is Julian Martinez, senior developer Advocate and Common Man here at the Stellar Development Foundation. Once again, over the next- I guess half an hour to an hour or So, depending on how you guys are feeling- we're going to dive into some basic smart contract development, and we may even scale it up to maybe getting into a staking smart contract. Just kind of depends on how the flow goes, all right. So first things first. We're going to go ahead and dive into a great online IDE tool here. It's called okashi. Again, okashi is an online IDE. It's really good for iterating on your smart contract ideas. It's got a cool code window where you can type in all your syntax. There's the contract window where you can actually call the functions related

00:01:00.000 --> 00:01:59.999 align:start position:0%
To the smart contract that you've just you just coded. There's also a console window here that shows the output of the smart contract calls, or the function calls, rather. So, If you'd like to follow along, you can actually scan this QR code and, as I'm updating the smart contract online, you should be able to see the smart contract being updated on your local machine as well. So what I'm going to do here is bring okashi to my main screen. You should be able to see it here, all right? So this is okashi again. We have the code window ready for all the syntax and you know this is where the bulk of your logic will live for your smart contracts. We have the contract window, which is going to hold all the functions and will allow you to, you know, execute and invoke different functions that live on that contract. And you have your console window here, which is just going to

00:02:00.000 --> 00:02:59.999 align:start position:0%
Output the, I guess, or it's going to show the return data of the function call itself. All right, So let's go ahead and dive into rust and sorond. If you don't already know, sorond is Stellar's smart contract platform. So a few things here, first things. First, you see the flag nod. That is to tell the compiler to not use Russ standard Library sorb on Smart contracts- this flag- and optimize for smaller contracts So they don't take up as much space on The Ledger. This makes for, you know, good forward term thinking for things like State bloat and overall just being mindful of not taking up more space and storage than you need to, Because in the future it can lead to bottlenecks and user experience and overall just becomes IM manageable. So you see, here on line three, you Soroban SDK. This is Because Soroban uses a

00:03:00.000 --> 00:03:59.999 align:start position:0%
Special dialect of rust with dedicated data types and some special attributes. So we're importing a couple of attributes here, namely contract implementation, the N data type, symbol, string and symbol short. Now let's go ahead and cover a few of these two attributes. Reg are mainly pertain to telling the compiler to treat all the following syntax as a contract would be treated. So When it comes to the contract implementation, it exposes all the publicly facing functions to the environment for processing through different mechanisms like testing, static envir, static function testing, Etc. So with EnV, this data type is going to be responsible for accessing smart contract storage within the contract itself, as well as data from The Ledger. So you'll see how we use

00:04:00.000 --> 00:04:59.999 align:start position:0%
This a little bit later When we're creating a key value kind of like storage mechanism for the smart contract symbol. Now, symbol is a- I don't want to say it's another term for string, But you can think of it as a string. So there are two types of symbols: short symbol, which is a string of up to nine characters, And then long symbol, which is a string of up to 32 characters. But the difference here is that long symbols actually require you to pass in the N data type before constructing them. Here, on the next data type we have, the string is exactly what it sounds like. Here it's going to be a concatination of letters. Symbol short is a function that we use to kind of just quickly create short symbols. In this case we're going to create a short symbol for the word title. Now you see here on line five, const title symbol equals symbol short title. We're just going to use this as

00:05:00.000 --> 00:05:59.999 align:start position:0%
Kind of like a label for the key value system that we're about to set up. So again you see: const title symbol equals symbol short, And then we're using the word title. All right, here on line seven you see the contract attribute, followed by line eight, Pub struct- title contract. So we're creating an empty struct and all sorond smart contracts will follow a similar pattern. You see a contract attribute, the empty struct with the name of the contract itself, And Then followed by a contract implementation attribute And then the implementation of the actual contract. So let's go ahead and start writing some functions here. This is our title contract and the main purpose of this is to kind of illustrate the key value system When it comes to storage. So I'm going to create a value for a key And then I'm going to go ahead and, well, I'm going to create the key value, get her and Setter. So

00:06:00.000 --> 00:06:59.999 align:start position:0%
We're going to be able to set a value to a key. Then we're going to be able to retrieve that value from a key. So let's go ahead and say Pub function. We're going to say set, title. This is going to take in two arguments. We're going to say m of the type n. We're going to take in a string, and this is going to be for the title value. We're not going to return anything. So we'll go ahead and get right into the logic. Again, referring back to the n data type up here, you see M storage. We have to go instance, do set, And then we're going to actually, If you see set, we're going to say set and title, And then we're going to bring the argument from the title or bring in the argument title in from the functions here or the argument

00:07:00.000 --> 00:07:59.999 align:start position:0%
Here. So let's go ahead and compile this. Let's see If this works again. You see, and storage: we're taking in the or we're accessing the smart contract storage. Here we have instance, which is a certain type of data type for Soroban smart contracts, of which there are three: temporary, persistent and instance. And then you see the set method here, where we're actually setting a value to the title key And then the value will be title. But it looks like we have some errors here. Unused variable signature Little literal. Cannot find type title in this scope. Okay, public function string title and storage: okay, we got some issues here. So let's see what we got.

00:08:00.000 --> 00:08:59.999 align:start position:0%
And storage in title H. So this looks like it was compiled. Function set title: all right, I'm just going to go ahead and do a quick sanity check. I do have the correct function on the side here. I'm also wondering If this is going to work. All right, let's go ahead and see what the issue was in the last set title and title. Okay, not sure what the issue was here, But let's go ahead and let's see If we can actually debug it side by side. Let's go ahead and find the difference. See this, see If this compiles. It probably won't

00:09:00.000 --> 00:09:59.999 align:start position:0%
Okay. Well, I'm not sure what the issue was here, But long story short, here is the correct function. As you can see, we see Pub function, set title. We're taking in two arguments. One is the data type n. The next is the data type string for our title. We're accessing the smart contract storage, Again by typing m Storage Instance. Again, there are three types of storage in sorb on Smart contracts and they each kind of serve a purpose When it comes to how long you want your data to live by default, again, temporary, instance and persistence. For this use case, we're just going to use instance. We have the set method here, where we are setting a value to the key title and the value will be the title argument that we're passing in. So let's

00:10:00.000 --> 00:10:59.999 align:start position:0%
Go ahead and set a title. We'll say: soron rocks, cool. It looks like our function call went through and we didn't get any return data. However, to access this or to access the data that we just set to the contract storage, we need to create a getter function. So to do this we actually just have to follow the same structure here- Pub function, we have to say get title. We're only passing in one argument that is of type in, and If we want to return a string. So for this we're going to go end storage instance and we're going to say and title, and we are going to say do unwrap,

00:11:00.000 --> 00:11:59.999 align:start position:0%
Or I'm going to say string from string and we're going to pass in the n and we're going to say default message, all right, So default message here. So what is this doing? Let's see If this compiles. First, don't want to hit a block. Okay, instance instant. So it looks like we got a typo here, all right. So what are we doing in this function? You see Pub function, get title. So we have one argument that we're returning or one argument that we're taking in that's of N, And then we're returning the data type string. So here you see n Storage. Again,

00:12:00.000 --> 00:12:59.999 align:start position:0%
This is how we access the contract storage. You see instance, which is the storage type, doget, which is the metal, the method to retrieve data, and you see the key title. So retrieving the value that lives at the key title. And to access this value, see Unwrap. And Now, usually this would be fine, right? But If no value lives at that key, Then you need to have some like error handling, right. So If there is no value that lives at this key, we're just going to return a default message in the form of this string that we defined. So let's go ahead and get the title, all right. So this is a new deployment inside of a contained web browser, inside contained web app. So technically, I have not set any data to this new deployment after creating this function. So I click get title, the default message will be returned, right. So get title default message. I'll go

00:13:00.000 --> 00:13:59.999 align:start position:0%
Ahead and set a new title. We'll say Stellar rules, all right. So we set a new title. Instead of Soroban rules, we'll say Stellar rules. We go ahead and get that all right. Cool. So now you see that we are able to set some data with the set title right, And then we can get the data by retrieving it using the get title method. Now, once again, this was okashi, which is an online ID for sorond smart contracts. Now what I'd like to do is actually U the kind of tutorial over to the CLI part of things and we'll actually start coding and deploying on testnet, which you can actually do on okashi as well. But I do want to get you guys familiar with the tools that the SDF offers, mainly Because, when it comes to the Stellar CLI, this will be

00:14:00.000 --> 00:14:59.999 align:start position:0%
One of your best friends When, or Stellar smart contract development Journeys. So let's go ahead and switch the windows here. All right, close this out for Now. All right, So getting started with the Stellar CLI and rust on your local machine takes three easy steps, right? So what you're going to want to do to make this easier for yourself is to actually scan this QR code here at the bottom left. This will take you right to the getting started section of the docs, where you'll be able to find these exact commands. You'll them right into your CLI. But for the sake of the tutorial, I might as well kind of go through the steps with you guys. So we see curl, Proto, https, tslb 1 2 s,

00:15:00.000 --> 00:15:59.999 align:start position:0%
F, https, and we're going to say rust up, ROP, sh. So what this is going to do- tlv, T, lsv, https, RS. Okay, So what this is going to do is install the rust tool chain on your computer. I've actually done this already, So you can see I have rust version 1 79 it takes a little While, so I will kind of spare you guys on moving forward So fast, Because I know it takes about two and a half minutes. So in the mean time I can kind of go through the installment process. For the rest of the tools, we say rust up and Target, add wasum. Oh my gosh. 32-

00:16:00.000 --> 00:16:59.999 align:start position:0%
Unknown, unnown. The demo effect, unknown- all right. So what this is going to do is tell the Russ compiler to compile Russ smart contracts into wasum and it's going to Output those files into a Target directory. We'll see this process a little bit later, But yeah, so that's what the second command does, is tells the Russ compiler to compile Russ files into WM. And the last command: we have cargo install and we have locked Stellar CLI. So this is going to install Stellar CLI, the latest version. So we're on version 2 2 0 and I know again, this would probably take around 2 and a half minutes. So If you're following along and it takes a little While, not to

00:17:00.000 --> 00:17:59.999 align:start position:0%
Worry I'll move slow throughout the rest of the tutorial. So just to kind of like make sure we have the correct version of Stellar installed, we'll say Stellar DV. Again, you see, Stellar 2 2 0 cool. So what we'll do next is we'll actually go here and we're going to say Stellar contract. Actually we'll say Stellar, And then we'll take a look at all the methods that you see the commands here: completion, contract, events, Keys, XDR, network, Etc. So let's go ahead and dive into contract. We'll go ahead and clear this out. We'll say Stellar contract And then we'll say init and we want Hello World. So hello and world, all right. So you see the messages here writing hello world, Etc, ET, all these good, all

00:18:00.000 --> 00:18:59.999 align:start position:0%
These files being written, and you see it has injected a cargo or a rust project right into the directory that we were working for or working from. And let's go ahead and click into our cargo Tomo file. You see a backwards compatible SDK s, Soroban, SDK 20 3 point2. This is a local issue, So I'm just going to go ahead and restart my rust analyzer see If that fixes this little error. But we're going to go ahead and dive right into the hello world directory. So we'll CD hello world, cool. And let's take a look at the contract here and you see an older contract that we were not using or not an older contract, But you see a boilerplate contract that is different from the one that we're using. However, I'm just going to go ahead and bring the contract that we're using right into here and we're actually going to work right from

00:19:00.000 --> 00:19:59.999 align:start position:0%
This, this. So you see this here, where we have the Hello World project that we're in, and one cool thing about the Stellar CLI is that you can actually generate key pairs right from the clii itself. So what we're going to do is exactly that. I'll go ahead and go to Stellar Ci or stellers keys and we'll go ahead and list the keys we have already. So Stellar Keys LS will list the different key pairs that you have available to actually sign transactions, and what that means is, every time you deploy a contract or invoke a function, Etc, that takes fees, right, So there has to be a source account assigned to that transaction to pay that fee. Now we have two that exist already, But let's go ahead and demonstrate how to create a new one and we'll say Stellar generate, we'll say Stell Keys

00:20:00.000 --> 00:20:59.999 align:start position:0%
Generate, and we'll Define the network testet, and we'll give this a name. So for this name we want it to be shy. So let's go ahead and generate a new key pair called sty for the testet network. Cool, you see that the function has went through or the method has been executed. Ed, let's see LS right. So you see stroy, Alice and Joe, and we'll see address shy and N Stellar Keys show Shy. All right, you see the two key or you see the key pair here. This is the public key and private Key. By the way, I'm just doing this for demonstration purposes only. Please never share your private key with anybody. But here is what happens When you generate a new key pair

00:21:00.000 --> 00:21:59.999 align:start position:0%
Using the Stellar Keys generate method. As you can see, the address it begins with G and the source account or the source key that begins with s. So, moving forward, let's go ahead and deploy this smart contract to the network and we're going to go ahead and say Stellar contract deploy. And we'll say, actually we have to start with Stellar contract build, Stellar contract built. And again, what this is going to do is actually compile the rust smart contract into its wasm format here and it'll be in the directory wasum Dash or wasm thir 2- unknown D- unknown. It'll take a little bit, maybe around 1 to two minutes, maybe less, all right. So about 1 minute we'll go ahead and look at the

00:22:00.000 --> 00:22:59.999 align:start position:0%
Release directory. You see here WM 32- unnown D- unknown. In the release directory you have the hello world wasm file. That's Because we're actually still defining this project as Hello World. So When it gets compiled you'll see that it gets compiled into the name of the project itself. So to resolve that we would actually have to go and change the name of this project as a whole. But we won't do all that for the sake of this demo. So we're still working from the hell World directory and we are going to deploy the Stellar smart contract onto testnet. So we'll say contract deploy- right, and we have to define the wasum is going to be Target wasm release and we'll say hello, world and was. And we'll say the network it's going to

00:23:00.000 --> 00:23:59.999 align:start position:0%
Be testet and we're going to say source is going to be shy, all right. So this is the command to deploy contracts onto the network. You see, Stellar contract deploy. You're defining the wasum location, right where the location of the wasum file, So the compiled file of the smart contract. You see network is test net And then the source is troopy. So let's go ahead and send this transaction, fingers crossed. We get a contract ID back, all right, that was very fast. And you see that this begins with the letter c. So let's go ahead and go back to our key pair. Just a quick lesson on how addresses are defined on Stellar. You see, G is for the public address, C is for contract addresses, s is for Source account or Source keys or private Keys, rather, all right. So we've deployed the contract and here

00:24:00.000 --> 00:24:59.999 align:start position:0%
Is our ID. Let's go ahead and call some functions on that contract. So let's go ahead and do Stellar. We got to do contract and for this we're going to do invoke and we're going to define the ID here and we're going to say testet, source is going to be stroy. And then we are going to find our function by doing the following: say dash, we're going to call the function or Define the function, And then we're going to Define the argument here. So set title takes in one argument for title and we're going to use quotes and we're going to say Stellar, smart contracts. Ah, that's too long. We'll just say Stellar, drop,

00:25:00.000 --> 00:25:59.999 align:start position:0%
Cool. All right, you can see here that there is an unrecognized sub command. So what does that mean? Basically means that I spelled a command wrong, right? So one cool thing about the error messaging with the CLI is that it'll actually kick back some functions that it thought that you meant. So we see here: set title. You can use an underscore or a dash or a hyphen. I'm going to go with the underscore here and we're going to go ahead and we're going to demonstrate calling that function. So we'll say set title and we have the correct function name. So it should work. It looks like it did and let's go ahead and get title, all right? So, just like that, we've used the Stellar CLI to create a

00:26:00.000 --> 00:26:59.999 align:start position:0%
New keyp pair, deploy a smart contract to the test network and invoke the functions for that smart contract. And, just to do a quick recap, some of the smart contract Basics that we learned today were data types as well as a little bit of the ins and outs of contract storage. So really quickly, I kind of want to recap those again. We have contract comp, cont, contract implementation, which are both attributes specific to soron and which is responsible for getting data for the smart from the smart contract, as well as a blockchain on Stellar, we call it the Ledger. You have symbol, which is either a string of up to nine characters or 32 characters. String, which is the string that you're familiar with. Symbol short, which is a function that helps you create short symbols. So that's a little bit about the data types. And now, When it comes to contracts storage, we kind of went into some 101

00:27:00.000 --> 00:27:59.999 align:start position:0%
For key values, I guess. Structure on Stellar smart contracts. Here you see, on line five cons: title symbol equals symbol, short. Again, we're just using this line as a placeholder to kind of have an easy reference for a key that we, that we're naming throughout the smart contract attribute with the blank struct, with the title here- and this is basically how all Soroban smart contracts look- the contract implementation attribute, followed by the implementation of the struct or the contract itself and the functions. Here you see Pub, FN, set, title. Again, we're taking in two arguments. The first one: you will always see n as an argument within each function for soron smart contracts and this will kind of be like the pattern that you'll see throughout your development Journey with Stellar. So

00:28:00.000 --> 00:28:59.999 align:start position:0%
Just get familiar with this structure. Al together. So we have en as the first argument And then title as the next argument, taking in a string value. Again, to access storage within a smart contract you have to write the syntax end Storage Dot, And then the type of storage. So in this case, instance, But again three types: temporary instance and persistent. To set of value to a key, you call the set method right And then you're defining the key. So in this case title, which is a placeholder, or the title or the name of the key, And then the value that we're setting is the argument that we're passing in for the function, also called title. All right, And then to retrieve that data you have to go and through a similar process, But reverse. So, again, accessing the smart contract Storage and Storage instance, right, Getet is the method that you'll

00:29:00.000 --> 00:29:59.999 align:start position:0%
Be using. You're referencing a key for the key in the smart contract storage, So the key here title, and to get the value of the key you have to use the unwrap method. In this case we're planning for errors, So we're saying unwrap, and If no value lives at that key, Then return this default message. All right, so that's a quick recap about on some basic SM contracts, But we do have quite a bit of time left. So I'm going to go ahead and kind of just like dive into some more Advanced smart contract methods or not methods, a little bit more smart contract, a little bit more advanced smart contract logic, and I'm going to go ahead and just kind of freestyle this. But I do have a staking repo that you guys can reference for your own kind of like studies If you want to, and you could find it here in this QR code. So

00:30:00.000 --> 00:30:59.999 align:start position:0%
This will take you to a hackathon repo that I set up that has a couple directories. In it. You'll find a workshop directory and I think you'll also find a slides directory, But we'll be working from the workshop directory here. You should see staking and data types, So I'll go ahead and give you a quick overview on how data types kind of look and, I guess, how they're implemented here. So some of the main things that you're going to want to know is like enumeration, right, one thing that we use here kind of at When it comes to Stellar smart contract development, we often use enumerations as Maps. So When, what does that mean? Right, When you look at a data key of a smart contract, When you look at a data key of a smart contract, you're basically setting a key value system similar to the key value system that we defined earlier.

00:31:00.000 --> 00:31:59.999 align:start position:0%
When we go back to- I guess we can go back to this basic smart contract here: hello world, all right. So you see con title, right, this is the key, And then again we're setting the value later with the title, right, So key is title And then the value is also named title. So If we go back to the staking smart contract right, go ahead and dive into it. You see here the data key we can set. We can host many keys and throughout the smart contract logic we can Define the values for these Keys. So we'll actually just Dive Right into this smart contract over the next 30 minutes And then by the end of it, you should be able to understand more data types, more ins and outs of smart contract storage, And then we'll kind of like take a look at some more examples of Setters and Getters as well as cross contract calls. All right, So go ahead and strap in stick with me. Thank you So much

00:32:00.000 --> 00:32:59.999 align:start position:0%
If you've been with us thus far and I hope you're learning something. Yeah, So let's go ahead and get it kicked off again. At the top you see no STD again. That's to tell the smart cont or to tell the compiler not to use Russ standard Library When compiling Russ smart contracts or When compiling sorb on Smart contracts, keeping them optimized small So they don't take up So much space on the Ledger. Again, on line three, you see us Soroban SDK- some familiar attributes we saw from the last example: contract implementation. Now you see contract type. This is to derive a certain type of what's it called? Certain type of? How do I put this object from the sorond SDK and treat it accordingly So we can dive into the ins and outs after, and I'd be happy to get you more information on how

00:33:00.000 --> 00:33:59.999 align:start position:0%
Attributes work after the stream. So here you see. VC Vector is a, an array of conc, continuable data. So what does that really mean? It's just an array, not specific to types. You can have a vector for Strings, Vector for symbols. Etc address is just the way that we, or the data type for Soroban smart contract addresses U byes n, which is a fixed bytes array or fixed bytes value. You have the end data type, which is again used for accessing data on the blockchain and Ledger, And then interal- we're not going to get into this- But ve- again, this is the actual data typee. V here, in lowercase, is the function that we use to quickly create vectors. All right, So let's go ahead and dive into

00:34:00.000 --> 00:34:59.999 align:start position:0%
The data key enumeration here in the comment. It kind of explains everything. But this is used to represent the state variables stored in the smart contract storage. Again, it allows for super easy, convenient access to data within the smart contract. We covered this a little bit earlier. But each one of these Keys here has a value that's attached to them. So you see public enumeration data key and a list of all the keys within this, within the contract. You see contributions- in parentheses address. So what does this mean? This means contributions is attached to many keys, So all these Keys must hold the data type address right. So address a, b, c and d, u. But all of these addresses are mapped to one value. So basically this data key will record which address made which contribution, right. Rors is just going to be a vector of all the

00:35:00.000 --> 00:35:59.999 align:start position:0%
Addresses that have made contributions. Token is just going to be the address of the token that the contract corresponds with. Share token is going to be the. We're actually going to Mint a token from this contract to use as a share token. So we're going to distribute tokens When a user makes a deposit and here we're actually going to write that into the contract itself. Is active is going to be a Boolean. So If this value is true, certain logic ensues. If this value is false, again a certain path of logic ensues. Admin is going to be an, So this address will have certain capabilities and be able to hold domain over various functions. Initialized is going to be a Boolean that tells the caller whether or not this contract is or is not already initialized. All right, So this is our staking contract. Right

00:36:00.000 --> 00:36:59.999 align:start position:0%
And again you see the contract attribute, empty struct with the name contract implementation attribute, and let's go ahead and dive into our functions. So this is our initialized function. It takes in three arguments again, and the execution environment of the contract admin. Pretty obvious. It's the address of the admin token: wasm hash. This is an interesting one Because we'll actually be creating a new token right from the wasum hash itself And then the token will be the address of the deposit token contract. So the acceptable token for the campaign, for the staking campaign, So it must cor. The token being deposited must correspond with the address that is set here within the smart contract function during this initialized call. And the token wasm has. We're actually going to be able to use a wasm hash to access an interface whereby we will

00:37:00.000 --> 00:37:59.999 align:start position:0%
Be minting a random token or a just generated token, a soron token If you will, to people who make deposits to the campaign. All right, So diving in, you see some familiar functions here, all right. So first thing we're going to do is set the admin address in storage, So n, storage Instance set- again as previously covered- and to access the smart contract Storage. To access, you know, the actual part of the smart contract for storage instance is the type of storage we're accessing. Set is the method and just a quick variation from the demonstration before you see. And data key And then admin: same thing as before. When you see the other smart contract here, right, let's go ahead and open this same thing as you see here. And storage instance set and title, let's go ahead

00:38:00.000 --> 00:38:59.999 align:start position:0%
And go back here. End storage set and data key, admin: here it's just defined in this data key, So you're just literally accessing that. And then you're passing in the argument for the admin argument here in the function: all right. So you see, let share contract, equal token, create contract. We're actually able to do this by importing. Do we import the token data type? All right. So there is a module here, mod token, and we're actually importing that, importing this module, this file here into the main smart contract and what this will do is import the pre compiled Soroban token contract file and will allow the main smart contract to use the functions that live on this contract. So

00:39:00.000 --> 00:39:59.999 align:start position:0%
Actually from a compiled wasum file we're importing that into the main smart contract, rather. So where were we? I'm getting all ahead of myself here. So that's how we're able to use the token U file, the token smart contract, to call the function create contract. So let share token. Right. Here we're going to create a new contract cont by calling the create contract method that lives on the token file and we're going to use the token wasm hash here to create pretty much the token file of the token contract from this compiled wasm hash and we're going to take in. We're going to call that interface at the token contract that we are setting in the initialized function. Here again you see token client

00:40:00.000 --> 00:40:59.999 align:start position:0%
New, all right. So we're going to create a new token kind of like interface over the share contract And then again we're going to call the initialize function. So here we're going to set the admin as the current contract address, So the staking contract itself. We're going to Define the decimal places And then we're going to define the symbol. So just a quick recap. What are we doing here? We're going to say: let the share token equal a new token contract, right. So we're going to create a new token contract. Again, token wasm has token address, all right. So we've created a new token And then on that new token, we're call the initialize function and this is what

00:41:00.000 --> 00:41:59.999 align:start position:0%
We're initializing that new token with, all right. So, moving forward, let's go ahead and see what else is happening. We have end storage instance set, So we're setting the token key with the token smart contract address And then, again moving forward, we're setting the share token key value as the share contract address And then we're setting initialize to true. So after this is all set in, done, most of the data Keys have been defined. You have the token being defined as the actual token address that has been passed in by the user. The share token is defined When the share token is deployed and initialized is active, hasn't come into play yet. Admin was passed in the initialized function And then initialized. The value here gets changed at the very end of the initialized sequence, all right. So, moving forward, we have start campaign and what this is going to do is just basically set the isactive value to true.

00:42:00.000 --> 00:42:59.999 align:start position:0%
The thing here to note is that we're actually making a super cool use of authorization, the authorization framework on Stellar. So you see: Pub function campaign, admin address. So admin Require off. This means that the person making the call must be the same value that is passed in the admin argument. I can't pass in G2. If my address is G1. So this will fail If I'm passing in an address that is not the wallet that I'm calling from. So let current admin equals end storage instant get. So we're defining the current admin, right. So we're saying we're going to get the current admin from the contract storage here by unwrapping the key, the data key, admin, And then we're going to say: If there is no value that lives there- which it

00:43:00.000 --> 00:43:59.999 align:start position:0%
Should, right, Because we've just initialized a smart contract- Then we're just going to return this current contract address and we're going to say: here we're going to create an assertion. If the admin does not match, or If the admin address that was passed in for the argument does not match the current admin address value, Then we're going to panic and we're going to make this function fail. All right. So If that's all good, Then we're going to say: end storage instance Set data key is active, right. So once we set that value to true, the campaign has started and let's go ahead and take a look at what that means. Right, So we can go the other way: stop the campaign again. Same exact logic, except for here at the end. For setting that value data key is active to false. After this, we can easily check the campaign status. Right, Pub function: check

00:44:00.000 --> 00:44:59.999 align:start position:0%
Campaign status. We're returning a Boolean value, So same as from the demonstration before: M storage Instance Getet with the- I guess, Target location, for lack of a better term, And then we're using the unwrap or method. If there's no value that lives at the key is active, we're going to return false by default. All right, So go, let's go ahead and take a look at the deposit functions, in which draw functions. I just want to make sure that we are in fact using the isactive variable. Doesn't look like we are okay. Actually we are here, all right, So let's go ahead and dive right into it. So what does this function do? This function will actually record a deposit made by a contributor If the staking campaign is active. So it takes in four arguments and, as always, going to be the execution environment of the contract contributor, the address of the? U person making the deposit, the

00:45:00.000 --> 00:45:59.999 align:start position:0%
Token, the address of the token to deposit and obviously the amount. So the contribution in tokens- here you see contributor- require off, meaning that again, only the wallet making the call is allowed to make the call. I can't call deposit And then pass in another wallet address. It has to be the wallet that I am making the call from, that I am clicking the button with all right. So let's go ahead and move forward. If the status okay, let is active, equals, And then we're going to Define this value as a Boolean value, Then we're going to call the function check campaign status, right, So we get that return value and we Define that is active. We going say If active is not true, we're going to panic and return this message: campaign is inactive. Long story short: If the campaign is not active, you can't make a deposit. All right, moving forward. We

00:46:00.000 --> 00:46:59.999 align:start position:0%
Have token client- new, all right. So we're going to put the interface over the token address, right. So in this case we're using the sorond smart contract address and we're putting the interface over and we're going to call the transfer method. So we're calling the trans on the XLM token address- at least according to the test here- and we're going to transfer that over to the. We're going to transfer that from the contributor, from the wallet, making the call over to the current contract address, So the staking contract. And then we're going to transfer the amount specified in the Contra or in the call here. Next we're going to Mint the share token to the contributor. So we have let share token equal, get share token again. Remember in the initialized function we deployed a new token called share token And then we recorded the address of that

00:47:00.000 --> 00:47:59.999 align:start position:0%
Share token to the smart contract storage. So here in this call get share token, we're able to retrieve the address of the share token. We're creating a new client or interface to lay over the share token, right? We're saying token Mint, right. So we're telling the share token to Mint an amount of share token tokens to the contributor. And then here we set the contribution right. So there's a command in here or a function in the smart contract called set contribution that manages the value for the contributor key according to the address. So, set contribution. We're saying getting the address of the contributor And then setting the amount to that key, all right. And then, similarly, If we go to the withdrawal function, it works exactly the

00:48:00.000 --> 00:48:59.999 align:start position:0%
Same But in Reverse. So we say, Pub function, withdraw, contributor, address, recipient and token. So you see, contributor, require off. Again, super cool here that you can just use the require author, the authorization framework right in the smart contract, SDK, to kind of have this Dynamic authorization framework for things like managing different calls from addresses. So again, you see, contributor, do require off, meaning that only the wallet making the call can make. This call can't be another address. Right, you must pass in: the address that you're using is active. Again, we're doing a call to a function that exists within the smart contract that returns a true or false value. So Boolean value, If is active, does not return true, Then the campaign or the withdrawal will be null, right, it will not go through. So

00:49:00.000 --> 00:49:59.999 align:start position:0%
Again, the campaign must be active to make a withdrawal. We should probably change, change that, all right, cool. So we're getting a couple values here. So let contribution equal equals self get user contribution. This is going to return a, an amount. We'll go ahead and dive into how that comes into play a little bit later. Again, token client new, laying that interface over the token address. So in this, So this time it's going to be XLM, at least according to the test. And then we're going to say, from this current contract address, from the staking address, we're going to transfer XLM over to the recipient and the amount will be the contribution amount that is defined here and get user contribution. Next we're going to go ahead and keep moving forward. Let share token equals get share token. So we're returning an address value here and again, laying that interface over the

00:50:00.000 --> 00:50:59.999 align:start position:0%
Share token address and calling the burn method. The contributor is going to be the, I guess wallet is going to Target and the amount that it's going to burn is the contribution amount. So, again, total contribution being defined here. And then you see the burn happening here, So the address of the contributor burning their entire contribution. And, last But not least, you see set contribution. We're going to take in the contributor value, or the contributor address, and set the value of that key contributions to Z. All right. So that's a quick rundown and I'd like couple of cool things that happened during this time. So again, we have our data keys and smart contract storage, right, data key here, a good place to keep all your keys. All these Keys have values. How do you manage these values? Well, you use the set method, right. So that's the contract storage right. So

00:51:00.000 --> 00:51:59.999 align:start position:0%
To set a value to a key you have to go n storage instance Set. To get a value from a key you have to go and storage Instance Getet. So there's some data types and contract sorts action happening there. And then one cool thing that I'd like to point out is the cross contract calls. So When you actually, When we're looking at the deposit function, one thing that we may have looked over is that we're actually making a cross contract call. So you see, token client new. All this is is that we're using the token contract right. We're using this token contract to access functions at another address outside of the staking contract. So token client new, laying the interface over the external address, which is the token address, And then

00:52:00.000 --> 00:52:59.999 align:start position:0%
We're calling the transfer function on that token address. That is defined by this import here. So that might be a lot for some, But this is a cross contract call and it's made super easy by being able to use this contract import function whereby you can actually import wasum files, So compiled Russ smart contract files, and actually call the functions from these compiled Russ smart contract files on other contracts, and it's all super Compact and very, I guess, malleable, for lack of a better term, all right. So let's go ahead and actually dive into some tests here. I'll just go ahead and quickly go into the staking directory. We'll go ahead and run cargo test. All right, there wasn't very much action here, But we have one huge test for everything

00:53:00.000 --> 00:53:59.999 align:start position:0%
That kind of goes over all of the things that we just went over. Let's go ahead and just kind of like, dive in here. You see, the test contribute. We're letting the end be defined as like a simulated environment, or the end here is just going to be like a default environment being simulated. Here we're saying all authorizations have been accepted, So users are able to call different functions. When it comes to the authorization framework that we have used here, it's going to make it easier for us to kind of get around any blocks that may occur. All right, So we're generating a couple of new addresses, some mock addresses If you will, by using the generate method. So address generate. We're using two, So one for admin, one for user. We're creating a token contract. So token 1 equals create token contract, right, So

00:54:00.000 --> 00:54:59.999 align:start position:0%
Create token contract. We're going to- we won't dive into the ins and outs of this just yet, But essentially it's going to create like a mock token and we're going to be able to use the functions from the token file or this token RS file on this token contract. So you see, we're taking in one argument, which is it the? Which is the address, the admin address, and we're going to return a token client. So we're going to register like a default kind of asset contract available from the SDK and we're going to set the admin as the admin address, all right. So let's go ahead and keep moving forward. Contract ID equals register contract. We're going to pretty much just like upload the staking contract here using this command client. We're going to define a new client, So a new interface for the staking contract at

00:55:00.000 --> 00:55:59.999 align:start position:0%
This contracted ID. And again, mind you, this is all kind of just like setting up the environment, all right. So you see here, token one Mint- this is some setup here that we're just minting the user, kind of like prefunding their wallet to interact with the contract. Assert that the token or the token balance for the user is what we just minted. So a th here. You see initialize, So client, Initialize. So When you see the word client, it just means that you're interacting with the staking contract. So client initialize- this could be staking contract- Initialize. Here you see the admin token wasm that we're using And then the token one address. So let's go ahead and dive into this token wasm file or this token wasm function. So you see: function install: token WM is going to return a by value and what

00:56:00.000 --> 00:56:59.999 align:start position:0%
We're doing- reporting the sorond token contract that we just kind of have pre compiled here and we're going to upload that to the contained simulated blockchain that we're working in from the test environment. But the main thing to focus on here is that we're using, we're importing the token file and we're able to use different functions from this token file thanks to this installed token wasm function. So again, this returns a bytes 32 value and that's what we're going to use within the test, all right. So client Initialize: we're passing in the token wasum value And then we're passing in the token address. Right, we're calling the function start campaign. So this is going to set the is active value to true and again, we can't make deposits or withdrawals unless that is active value is true. Moving forward: client Deposit. So we're taking in a

00:57:00.000 --> 00:57:59.999 align:start position:0%
Deposit from a user, which token that they're depositing and the amount that they are depositing, we're going to say: assert that the user contribution of the user that just deposited matches the total deposit that they made and we're going to assert that the to total share token balance of that user matches the deposit of, matches the initial deposit. That's all should have right Now. And Then we're going to go ahead and test the withdrawal function U, making sure that the user, after they make the withdrawal, has zero contributions left within the contract. So again, just as an example, When we run that test, everything is okay and all of this logic passes the way. It should. All right. So that's about it for me. Again, If you want to check out the DeFi contracts portion or If you want to check out the, I'll go ahead and like go

00:58:00.000 --> 00:58:59.999 align:start position:0%
Through the links again one more time. So we have the okashi link here. If you want to check out the set title smart contract in an online IDE kind of environment, you know that contract should be built out. You should be able to just quickly hit compile, start testing out all of the functions that live there. Again, this setup slide, this QR code here, is going to take you to the setup part of the getting started section of the docs. You're just going to run three simple commands to get started with the Stellar CLI. If you want to check out some more advanced smart contracts that we just went through, including more advanced what's it called data storage, cross contract calls, as well as some more various examples of Getters and Setters, you can go ahead and check out this QR code here, which will take you to the consensus hackathon, and you should see a couple of directories, namely staking and data

00:59:00.000 --> 00:59:59.999 align:start position:0%
Types. All right. So in conclusion, I always tell developers to read the docs, as you can never go wrong with that. Feel free to scan this QR code here and it will take you right to the `stellar.org/developers` landing page, where you'll see all the good developer docs that you will need. And, last But not least, once again, my name is Julian Martinez, senior developer advocate here at SDF. It's been an absolute pleasure. I love talking about this stuff. You know really love having developer workshops and tutorials- happy to do them anytime, and I really hope that you guys all learned something today. If you have any questions, Then please do hop in the developer Discord or the Stellar Discord. In the should be Soroban ddev or Dev dhel- any one of those channels in general. Just join the Discord and you can also ping me at the God

01:00:00.000 --> 01:00:59.999 align:start position:0%
Handore. Again, that's atthe godhand And then an underscore sign If you have any questions. But yeah, thanks again. So much for your time and I hope to see you all soon. Take care.
WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:59.999 align:start position:0%
Okay let's get started. So happy Thursday everyone this is Soroban Design Discussion an Open Protocol Meeting in, which we discuss design decisions for the Thor law and smart contracts platform to be launched very soon today we're going to be talking about State exploration. So without further Ado I'm gonna hand it over to Garand yeah. So I know we haven't talked about the expiration in a second. But I think before we were kind of talking high level what the interface wanted to be. And then now we're actually starting to implement pieces of it. And so kind of the timeline for this is first we're going to start charging for rent on futurenet. But not actually have any penalties for a rent balance of zero or negative just so, that we can make sure, that you know the the rent is being charged correct and, that sort of stuff Next Step will. Then be to add ways to a bump rent. But again still with no consequences on futurenet. And then once we have the the rent bump
00:01:00.000 --> 00:01:59.999 align:start position:0%
and the rent charging correctly implemented will actually enable consequences and essentially what, that means is, that an entry will need to have a non-zero or non-negative rent balance to be usable. But we still won't actually be sending entries to the archive and doing them from The Ledger for some time still in addition to, that once the rent system is in place we'll. Then roll out temporary entries, which are the entry types, that have a TTL, that expire after a certain amount of ledgers and the CTL is variable. And so I know we've talked about kind of like at a high level. But we're actually starting to implement this rent stuff. And so there's a couple of open questions both in the rent proposal and in the temporary storage proposal, that we want to talk about in detail so. When we initially talked we didn't have automatic rent payments on access and this was an implementation issue with the way the bucket list is structured. However now we've changed the way in, which we actually record rent balances on Ledger. And so we can bump
00:02:00.000 --> 00:02:59.999 align:start position:0%
rent on every access. And so with, that in mind we've changed the way, that we structure run payments how it currently looks is every data accessed in a smart contract call receives some small Baseline rent bump this isn't expected to be a very large rent bump. But it's something small and automatic. Now this includes not only contract data, that's accessed. But also the contract instance itself and also the contract wasm code. And so this also allows you to bump the smart contract itself and the smart contract code without needing any extra intervention or anything and. Because this is a small incremental bump, that's bumped automatically it means, that smart contracts and entries, that are used frequently don't really need to worry about rent you know something like usdc, that's used every day will have enough rent balance via these automatic bumps to never have to worry about doing a manual run bump. And so this automatic interface is a lot easier and covers a lot of the weird
00:03:00.000 --> 00:03:59.999 align:start position:0%
cases in ux kind of pain points, that we were seeing before. When we didn't have these automatic ram pumps. Now the open question here is with regards is what do we want to do to in addition to having these automatic ramp bumps what interface do we want to expose for the quote-unquote manual rent bumps. And so this we have two kind of fields of thought here. So what a manual run bump is is say you have an entry, that's not accessed very often. So you have like a token balance, that you only use every six months or one year but. When you use it you want it to be accessible very fast. And so you want to be I'm not in the archive and remain on The Ledger. So automatic rent bumps are not sufficient for this use case. Because you're not accessing it very often. And so the automatic rent bumps aren't large enough to keep this wallet or this token balance on The Ledger. And so we want an interface where a user can do a explicit manual rent bump instead of doing the small
00:04:00.000 --> 00:04:59.999 align:start position:0%
incremental run bump say I want six months or one year or 10 years or something like, that of rent for this entry entry. And so kind of the two ways to do, that are either a via a manual operation where the invoker of the operation specifies the set of keys, that they want to bump. And so this is the the most manual approach. But it's also has some benefits one of the significant drawbacks, though is, that the user calling this function needs to know what key belongs to them, which isn't always easy. So in for instance in a token contract you may be able to have just one entry and one key for each user's balance, that's relatively easy to discover you know like whatever my balance key is on usdc. But there may be other entries, that are also associated with your account in addition to, that balance entry. So for instance a token contract may also have a nonce, that's required to do transactions with your
00:05:00.000 --> 00:05:59.999 align:start position:0%
token balance and. If a user only knows about the token balance ID. But doesn't know about the non-sid they may pay a bunch of rent on their token balance and have, that active on The Ledger. But then in six months. When they want to do their transaction they didn't pay rent on the non-century. And so they still have to wait to get the nonce value out of the archive archive. And so one approach to this is to allow the contract to Define rent bump behavior and we do this by exposing a rep bump host function to the smart contracts and what this allows contracts to do is to codify on the contract itself rent bump behavior in addition to the automatic rent bumps. And so in our token contract example say, that there is both a rent balance and also a nonce, that are have separate Keys. Now I'm not saying this is a the most efficient approach. But this is an approach. And so what the contract could do is it could Define a bump my account function and this bumped my account function I will use the host function to bump both
00:06:00.000 --> 00:06:59.999 align:start position:0%
the token balance and also the nonce value associated with the user. And so in this way the user can just call the bump my account or about my account function. And then bump their account by six months a year the specified amount or. However much is codified in the smart contract and this allows the smart contract developers to abstract away a lot of the Run interface to the user. And so the user still can bump run manually. But doesn't need to know exactly what entries belong to them So it's a significantly easier user experience and also allows the contract to Define some sort of automatic behavior in addition to, that supplied by the protocol. So for instance the protocol might say a bump every access by 10 ledgers worth of rent. But then the smart contract developer might say oh for my use case I want to automatically Bump by a 100 or a thousand Ledger entries. And so they can use this rent bump host function to Define additional rent bump behavior in addition to, that automatic rent bump
00:07:00.000 --> 00:07:59.999 align:start position:0%
that the protocol has. Now even the the benefits, that this can provide a better user experience. But this opens the door to either malicious griefing or just accidental overspending of fees this is kind of dangerous. Because it allows the contract to Define arbitrary rent to take from the user's transaction fee fee. And so this can't be gamed in a malicious way. Because there's no Financial benefit to paying a bunch of rent for other entries entries like there is no way for the attacker to steal rent fees in any way. But this could be a griefing aspect where a contract call could say pay one year rent for all these unrelated entries, that aren't important to you. But still take, that from your refundable fee. Now again code audits could catch these attacks. But it could be very difficult. Because for instance they could name an entry such as like they could give an entry in a inconspicuous name like
00:08:00.000 --> 00:08:59.999 align:start position:0%
author entry and have every call pay one year of rent to an off entry where it could be actually a different entry type, that's used maliciously. And so even, though exposing this host function could provide a better user experience it also opens the door to these kind of large fees, that contracts can Define. And so I guess, that's our first open question is regardless of. If the host function is accessible via Smart contracts it will be accessible as a manual operation call regardless. And so the question is do we want to just have, that manual operation call where the invoker has to specify every single key to bump or do we want to also open up this host function to the smart contracts and allow smart contracts to Define their own rent bump Behavior I have an opinion on this, that I want to talk about about everyone else thinking. Because I've been thinking a person can
00:09:00.000 --> 00:09:59.999 align:start position:0%
involve this and I'm really biased towards just doing a single post operation as it is invoked in a standalone fashion and not go with contractifying pump Behavior at least 41. Because as Grant has mentions right really a lot of issues with houses can be misused. But also really even. If you think about the ux aspect of it like we are talking about some abstract user here I'm not sure it's an abstract user who does the bump it's rather some program in between, that does, that which is probably evolved right and for example. If you are talking about the token balances I don't see any significant technical difference between implementing bumping your balance entries rent why it's a great
00:10:00.000 --> 00:10:59.999 align:start position:0%
operational a separate contract call it's some sense it needs to be coded in the board interface right. And then provide it to the user like hey you know what your interests are about to expire and another thing is, that I really don't think there are too many entries, that user should ever care about about pumping them I'd say this must be just balances and NFTs and you know even. If you have this Ledger key based approach it doesn't seem overly complicated to have support for them and have some basic white braces just builds the correct bump transaction for a given contract interface for example. So I don't see this as a pqx issue. But I do
00:11:00.000 --> 00:11:59.999 align:start position:0%
see a lot of issues with no exposing this to the contracts and it just doesn't seem like a super straightforward feature to communicate with how contract developers should use it like I don't think they have a good strategy for this. Now so yeah, that's my opinion here it feels a bit or slightly inconsistent the fact, that the the current storage model definitely encourage access through host functions rather than directly through through like Ledger entry keys. And so to have this additional system, that does encourage access directly to the Ledger entry keys, that that sounds a bit inconsistent to me well we kind of abstract to let your excess away right to you like this adapt developers to need to care about with your Footprints and basically rent can be improved
00:12:00.000 --> 00:12:59.999 align:start position:0%
with some ideas floating around those were like maybe allow to specify pumps on the footprint for example or as Pro to the awake as a parallel entry to the footprint to, that you know you can do it as a transactional basically I think it's the main. And then the question is yeah whether we put this responsibility on the contract developers or on the engineers, that builds the transactions and I'm saying, that probably it should be on the side of whoever is paying for the transaction right. Because that's them who are pins are in and really for a lot of contracts there is no single strategies the contract Trader can raise realistically Define in terms of how the bump should be defined well kind of same stamping to do, that right. But in the end it's the entity, that pays for the transaction who needs to decide what to
00:13:00.000 --> 00:13:59.999 align:start position:0%
do with the rent pumps Delaney bumps at home right. But it's a contract developer, that has the full understanding of what in the contract State actually relates to a specific account account right. So where where will this information be captured well yes. But you know I'm not sure like it needs to do anything this is a bumps like I can see the functions just expose the entries, that need to be pumped. But I'm really concerned about just doing the pumps myself from the contract like having some metadata, that says hey you need to bump, that for a given address is fine fine. But fully programmatic access seems to to be able to do much more and a lot of this doesn't seem like the right thing
00:14:00.000 --> 00:14:59.999 align:start position:0%
to do also it's been like you know pumpkin for thousands of ledgers. Then this might not be a user intention and yeah this just creates some pretty confusion ux for the contract users yeah current question. So a I do like the the concept, that the end user oh no I should say the con the smart contract author can can write his own function to modify the default Behavior I think, that's great I'm a little bit concerned, that the smart contract developer would need to write, that method it's something, that I kind of like not feel very comfortable around. Because it guarantees a user errors and ideally. If we could do anything, that
00:15:00.000 --> 00:15:59.999 align:start position:0%
would provide out of box experience where it would just walk. Then it would be much better even. If they just walk wouldn't be the optimal solution well I think in either case case whether we expose the host function or not it will not be necessary to define the sore function. Because we do have the protocol floor automatic bump rent, which happens regardless. And so this is just for. If you want in addition to the automatic a small incremental rent payments do you want additional control over how you bump and I also won't clarify, that this doesn't overwrite the default Behavior will happen whether you use the host function or not. So say like the for instance just for an example the default behavior is to bump every entry by 10 Ledger's worth of rent. If you also in addition to, that say use the rent bomb function to add another 100 ledgers worth of rent to a token balance the
00:16:00.000 --> 00:16:59.999 align:start position:0%
resulting rent bump would be 110. The 10 ledgers, that were automatically bumped and the 100 ledgers added on top of, that by the host function. And so you're answer your question the automatic rent bump interface attempts to kind of give the best out of the box solution as possible with the thinking being, that the most accessed entries will have the most rent and be the most readily available. And so this is an addition to, that default Behavior. If that answers your question okay yes let's answer my question thank you. Now I think one one interesting point, that moods is bringing up in the chat Dima for you in particular is, that should we allow contracts to Define initial rent balances balances. Because if we don't of newly created entries entries. Because this kind of has the same attack surface or I guess attack service isn't the right word. But perhaps the same accidental or purposeful misuse issue of exposing the rent bump function. But it's a really poor interface. If
00:17:00.000 --> 00:17:59.999 align:start position:0%
every newly created entry just has the minimum amount of rent and you need to immediately do a host function operation. If you're calling to create to bump the rent. So I guess what do you think with respect to newly created entries and should we special case, that even. If we don't expose the rent on post function again like I'll try to answer quickly. Because we wanted to say something. But I'm I'm still not sure. If it's a good idea either I feel like I should think more in terms of how can say contract user provides a needed brand pump pump maybe as an additional fear as I said like maybe some annotation on footprint or something. Because really. If you think about it as a contract writer like you're writing a token contract what should be the initial rent balance on a new balance entry I cannot really answer this question for
00:18:00.000 --> 00:18:59.999 align:start position:0%
every user I'm not sure anyone anyone can. So my intuition is, that for entries where we actually want to ever bump the rent balance balance it's highly likely, that it's easier to decide how much does it want to pump it. So yeah I'm I'm really not sure like how contract writers would Define this initial balance in the same way, that's my opinion here yeah. So first of all I just want to say it is interesting, that we have, that we are discussing like these multiple approaches to essentially automatic for the user bumping the rim and I think whenever we do have like multiple things at play like this we do have this potential for it to become very confusing for developers about you know. When do they need to make get involved and do something themselves versus. When
00:19:00.000 --> 00:19:59.999 align:start position:0%
can they rely on the automatic. So maybe just something to keep in mind like. If we are going to have these multiple approaches approaches, that that's just something we need to think about like complexity. But to the idea of having you know the contract do the bumping it sounds to me like it's sort of owning two responsibilities and I'm not we're talking about those two responsibilities together and maybe we can split them apart. And so the first one is knowledge about the keys and, that does really sound clearly to me like something, that the contract is is responsible for contracts decide you know what storage how to arrange their storage it's not really in the user domain to you know to know, that information. And so it does really, that makes sense to me, that okay contract should be responsible and sort of telling a user somehow, that you know these are the keys, that relate to you know I guess I sort of we sort of expose it already
00:20:00.000 --> 00:20:59.999 align:start position:0%
through Footprints I guess you know you can look at the footprint from your transaction and say like oh I've I've affected these entries. And so you know. If I want these entries to live on past some some future point I probably want to bump them them and you know what the footprint is ahead of the transaction. Because you have to provide it. So you know, that that's maybe an interesting thing we can utilize. And then the second part of the contract function is decisioning about how much to bump or at least, that's one of my understanding Karen, that the contract would actually decide how much the month and, that seems less clear to me about where the responsibility lies. Because I agree with Dima like. If I'm a contract developer running contract or token contract or any sort of contract I don't really know how long this user needs this data you know you might be using the token contract for just this one transaction or for a short period of time or maybe you're you know you're locking up an asset for a long period of time it's really unclear to the contract developer. So I feel like
00:21:00.000 --> 00:21:59.999 align:start position:0%
if we can find a way to keep the decision about how much to bump in the hands of the user. While not needing the user to have knowledge about the keys or maybe using the footprint in some ways so, that users or applications, that users are using you know can use the footprint to to you know to discover those keys yeah I think one interesting thing might be like say like we have like this automatic bump and just allow, that to be a user-defined field in the footprint. So for instance we could say like it must be at least 10 ledgers just for the health of the network no one should be able to you know avoid automatic payments. But then you can Define an arbitrary number. Now the issue is I think, that that might be a little too not granular enough. So for instance say. If I want to. If I'm praying a token
00:22:00.000 --> 00:22:59.999 align:start position:0%
or creating a a balance for the first time for a wallet and I want to last six months I say okay I want my default rent bump to be six months and so, that would handle you know all the keys I touch in the creating of, that new entry but. If we just have, that one number to encapsulate everything I would also be bumping the wasm by six months in the contract instance by six months. Because I touched those two as well, which is probably not what the user intended. And so I think I kind of agree with how you put it, that there's knowledge of the keys, that's the contract responsibility. And then there's the knowledge of how much you want to bump, which is a use case specific thing based on the invoker and the issue is like. If we just have one parameter, that for the default rent bump, that doesn't encapsulate knowledge about the keys. But then the issue is. If you want to say say have Define a rent bump for every key in the read write footprint, that again is putting in this, that's putting
00:23:00.000 --> 00:23:59.999 align:start position:0%
essentially like the knowledge of the keys on the invoker again, which is kind of something we want to get away from well well yeah I mean the invoker is potentially multiple parties. Because there's the you know user to the consumer the end user. And then there's an application, that they're using to interact with the contract and, that application they're using could potentially make some sort of broad assumptions you know maybe for token contracts a an application Level Up or might be able to handle, that granularity like as you're pointing out they might be able to identify okay the balances look like this you know have this key maybe I it doesn't really extend well to other contracts, though
00:24:00.000 --> 00:24:59.999 align:start position:0%
yeah. So I guess. So I don't know do we have any like key takeaways. Then I mean. Because I agree, that that and I just feel like the barrier to to exposing the rent interface to users can be somewhat High and I don't know. If it's a good interface interface. Now again like this might be you know acceptable. If you know like every like people are interacting with the network primarily through wallets and sophisticated kind of l2s like, that. But I don't know it just seems like a high onus to put on a user to essentially have to invoke periodic hose function operations in order to maintain state, that they are accessing through smart contract calls it just seems like the most reasonable interface for the caller of the contract is for the contractor to take care of of the
00:25:00.000 --> 00:25:59.999 align:start position:0%
contract state is it possible, that maybe we could find some some okay. So I agree with what you're saying. And so I'm wondering. When we discover what the footprint for contracts are I wonder. If there's a way for us to include without some sort of this is what the contract recommends you use and maybe this is this might get too complicated. But you know. If a token contract could say to a user this is somehow defined like this is the recommended rent pump for my contract. But usually still in control or maybe, that's pointless. Because then you know everybody's just going to do what the contract says and we're essentially building something, that we don't really need the flexibility around well maybe what we could do actually say actually okay I kind of. So I think the best of the Both Worlds is we want
00:26:00.000 --> 00:26:59.999 align:start position:0%
the contractor to be able to define the keys we want the user to define the amount. So maybe what we can do is instead of having the footprint parameter be the global footprint pump what we can do is we can define a new parameter called auxiliary rent bump it's just a single value inside the footprint. And then I guess we could expose this to the smart contract in some way. And then the smart contract could call the rent bump host function. But the value of the ledgers to bump must be the auxiliary value provided by the user. And so I think this still has some potential gamification or griefing. If the contract would use, that to bump keys, that are not relevant to the user I mean I feel like, that's just a, that's a class of bug, that just needs to be audited and I think, that's kind of you know there are many smart contract bugs, that fall into, that area. But then I think this might provide you like a good middle ground where the contract can still say
00:27:00.000 --> 00:27:59.999 align:start position:0%
what keys need to be bumped and the user can supply the value. And so say this value could default to zero just for safety reasons. But then say. If a user is accessing their contract or their their token wallet they could say, that I want to rent Bump by six months everything, that the contract deems should be bumped, which they signify by calling like this auxiliary rent bump done inside the smart contract some thoughts on this approach yeah I think something like, that could could work pretty well and either presenting, that how you just described as you know you just provide one Valley in the transaction or maybe you could actually just provide a value next to every footprint, which they'd functionally worked the same way. But you know it would give you a little bit of flexibility for some power use cases where maybe you maybe a a power user is wanting to
00:28:00.000 --> 00:28:59.999 align:start position:0%
specify explicit footprint entries is having more. But I did I think, that ID does start to shift the responsibilities into the right places yeah I'm not necessarily against the footprints and it's always the same wondering about is how much more useful reads than let's say yeah separate cost functions it does the same Plus the contract and just a little bit worried about mix in a lot of things together right. So you have a transaction with a plus something useful make a payment for example right. But then you also have this another completely unrelated operation this transaction, which is Bump
00:29:00.000 --> 00:29:59.999 align:start position:0%
rent instead of relevant entries by kind of like by time periods you have defined. So doesn't really need to be the same operation maybe it is okay to just have this as two separate operations it can be composed needed well I mean what would, that look like then. Because I mean I think the the issue is the the set of the knowledge of the set of keys, that needs to be bound right where I think I agree, that like the the per like the per key approach could be good for power users I still think we need like a you know one size fits all I want to bump by this amount. Because I could see from a user perspective saying you know bump this set of keys by six months you have to define the set of keys and all, that sort of stuff but. If you're sending transactions and be like I want all my things to live for six months. So I can say send this transaction transaction rent amount six months
00:30:00.000 --> 00:30:59.999 align:start position:0%
and. Then the smart contract developers determine what is important to, that user to fill into, that auxiliary space I feel like, that works for most use cases again we are kind of mixing up what user is like do people really like. If they think about how our contracts would be used right chances are probably there is some Gap, that like with some web apps, that actually builds the transactions for you like whereas the rain should fit it like I'm writing. So you had DEX right today really expose rent bumps in my UI to the users like how's it would work. So I think, that there's I think, that's a really good question Dima and and I think there's there there are two answers to this I think there's one class of interactions, that come directly from adapt front end and and from, that perspective you're right like the dApp
00:31:00.000 --> 00:31:59.999 align:start position:0%
knows exactly what Ledger Keys an account refers to. Because it's the same developer who wrote the smart contract there's another class of interactions, that's like more generalized interactions these happen either through through either through like wallet interface like General wallet interfaces or they happen maybe through you know various compositions like I'm not using an AMM directly. But I'm using it through some sort of like an aggregator or through like a balancer like contract, that actually splits my my my liquidity between different contracts. So I think the like what you're describing it like directly interacting with Ledger keys, that only happens in like the one case where the the origin of the transaction is you know is kind of
00:32:00.000 --> 00:32:59.999 align:start position:0%
developed by the same developer of the smart contract but, that's not the general use case oh what I mean is actually not who knows the keys what I mean is what is the UI or ux for actually setting up zero. So let's say we go for this idea whenever you know you can somehow pass some additional rent balance as a part of your transaction, that does something else. Then the question is like no matter like who knows the keys how the user would actually Supply this number number like I really feel like this should be progress about responsibility most of the time, that's really sometimes it you need to bump probably has something to do with something your own and this is something your voltage is responsible for for. So I'm yeah I'm not sure. If it works well it's
00:33:00.000 --> 00:33:59.999 align:start position:0%
a model or some other entities and wallet builds a transaction. Because as I said like you're doing something completely unrelated unrelated leads like especially. When you are talking about some more complex religion scenarios right how would you even expose some brand pumps to the user leak just I'm sorry arbitrary they are about to trade these tokens okay how about bumping some random major entries I don't know doesn't seem like they're right you asked to me, which is why I was kind of arguing about this idea about just having a standalone process for this this, which I agree has its own issues. But at least you know the your story is pretty clear here, that hey you have a vote for example and my interests you know balance lifetime very connectors maybe I'm missing something fundamental
00:34:00.000 --> 00:34:59.999 align:start position:0%
about what you like how things work. But he just really seems like two different things, that we want to bundle together in the same transaction and one of the things is not completely obvious to think to, that main use case as I think regardless of of whether we bundle it or not the problem, that you're presenting you know who's responsible for it you know does the wallet just do it for you, that problem exists so. If we bundle it the problem exists. If we don't bundle it problem still exists and to Thomas point about you know the different use cases and your point about wood wallages too and I think, that's, that's fair like consumer wallets are probably going to make some default decision around you want to have six months or a year for your balance. And then you can recover from the archive archive and it's those other power users, that are maybe gonna or those other composition use cases where the rent is going to become more
00:35:00.000 --> 00:35:59.999 align:start position:0%
interesting. Because maybe in a composition use case you don't need, that balance to have a starting rent of it six months, that's it might be a waste of ease ease maybe you only need it for a day the thing is like from the for the wild example I think the issue is, that. If we don't Define or. If we don't allow contracts to Define rental Behavior the issue is token or wallet speak erc20, which is an interface whereas rent bumps aren't an interface issue they're an implementation issue. So two different tokens could just be erc20 compliant. But Implement erc20 in different ways. So token a might have two entries you need to bump whereas token B just has one entry you need to bump. So I feel like just kind of saying oh hey the you know middle the middleware software is sophisticated enough to know how to bump I don't know. If that's an assumption, that can be made I mean I think we'd essentially like for wallets we'd need like an erc20 rent version
00:36:00.000 --> 00:36:59.999 align:start position:0%
that defines rent behavior in a way. Because I feel like I just think, that just like the the key structure is just. So integral. And so implementation specific I'm skeptical of leaving, that up to anyone other than the contract developer as long as there was an interesting question from what's in the chapter regardings something like a liability balance and I think and as we're end goal we haven't been talking much about this weather some cases the rent payments are needed at all. Because well interest can be unarchived and in case of this liability balance for example yes it's maybe not in the user interest for this entry to leave one kinds of Ledger but. If you are using the unique storage storage right it shouldn't be possible to at
00:37:00.000 --> 00:37:59.999 align:start position:0%
least recreate the sanction, which the contract developer could leverage I I'm not really familiar with this liability bones use cases like how to force the user to actually pay your availability. But you know. If you want them to continue their contract you can just benefit from the unique entry and it doesn't really matter. If it got archived right. Because it won't be recreatable and users just won't be able to reuse the contract I don't know what is the other unfortunately mechanisms. But basically the point I wanted to make it's probably not super bad. If interest sometimes get evicted from the ledgers this is kind of by Design especially. If it's rarely accessible and it's a downside hopefully isn't is, that huge. So probably, that. While we are talking here about how bumps work we should recognize, that that you know
00:38:00.000 --> 00:38:59.999 align:start position:0%
we should make sure, that the ux for actually actually restoring the entry in Ledger is saying. Now so, that even. If you cannot mess up the pump project you still not In Too Deep of a trouble, which which I don't know. If anything something else for the liability use case in the liability case you know the the library still exists right just it may not be unledgeable. Because it expired expired. So and anyone can recreate it. So I don't know. If it's a is, that an actual concern right as long as you understand, that the liability is there like you know you could anyone can recreate it and put it back in the Ledger or I think recreate's not the the correct word here. But restore it. Because like in Europe in the example you gave essentially what would happen is. If it expired and a user tried to do it it's you
00:39:00.000 --> 00:39:59.999 align:start position:0%
you. If you use the unique storage interface, which you should for this particular use case. Then the contract knows, that the thing is in the archive. Because that's one of the benefits of unique storage is, that it essentially provides information. If the entries in the archive are not. And so through the unique storage interface you know, that the liability exists somewhere. And so the transaction just fails. But the liabilities not live. Because you can't check it. And so I don't think there's a security risk in the rent. Because I think rent should never be used for like lifetime management or something like, that that's a temporary entry concern concern. So I think like concerns as to like expiration are handled via the recreatable and unique interface rent is just more of a convenience factor. Because how you pay rent shouldn't have any functional differences it might just make your operation slower. If you need to go restore something. But I think high level here I think
00:40:00.000 --> 00:40:59.999 align:start position:0%
kind of what I'm understanding is we probably want to investigate rent information the footprint I think whether, that looks like a per key rent or an overall rent bump or something like, that is still TBD. But I think. If I understand correctly, that's kind of demo, that is, that kind of like I don't know fulfills your you're not allowing smart contracts to game the system. But kind of still allowing smart contracts to Define some behaviors at I guess investing is something the footprint is, that kind of the idea we want to go forward with on this issue yeah and is, that the way like I'm not necessarily against this. But like I see some issues with this approach. But probably it makes more sense than just you know asking contract developer to to write the manual pumps it's both complicated and those are wrong yeah and I think we really need to
00:41:00.000 --> 00:41:59.999 align:start position:0%
think about the initial balances like even, though as I mentioned lately it might be kind of problematic to Define it in a general case we we should think about what what is the same default value very easily like even. If it's not customizable. Because it's kind of an interesting problem as well right like you don't want to create an entry, that lives like for a really short period of time, that you don't want to overcharge users well we actually have a implementation specific value for this, which is I think at the bottom of the rent proposal, which is based on the structure of the bucket list and how archiving Works minimum rent balance has to be enough rent for the entry to live into level six six, which I believe is 4 000 ledgers. And so we can make the default higher than, that but, that is the absolute minimum just from an implementation standpoint the minimum has to be at least four thousand ledgers ledgers. If that value is too low then. If like
00:42:00.000 --> 00:42:59.999 align:start position:0%
I think, that's what four thousand times five seconds I think, that's like a day or something maybe 12 hours exactly. But I mean. If that's too low we can increase it. But we can't go lower than, that and but, that's kind of interesting right. Because if you think about something you can balance you would think like about months of life and five hours is like why less than, that. So yeah, that's what I'm saying like I guess we will need to see what's the actual prices will be. Because because it seems really counterintuitive, that the entries, that are kind of supposed to be permanent entries in The Ledger are at the same time very short Cliff. Because we hopefully will be able to create temporary entries, that are alive for let's say weeks right. But at the same time I think there's also a valid use case for a qualm quote short-lived short-lived for instance like. If I just want to initialize a cold store wallet I like
00:43:00.000 --> 00:43:59.999 align:start position:0%
initialize it transfer a million usdc. And then don't want to use it for 10 years I mean it makes sense to just give the minimum rent balance pay, that. And then let go into the archive. Because I'm not going to use it for a. While so I think, that there's still I think keeping the minimum low probably provides the most flexibility. But I guess kind of what I was imagining from a functional standpoint is you would probably want to just create all entries with the minimum rent balance initially. But then be able to essentially like bundle bundle and immediately run bump was kind of what I had in mind from a from an implementation standpoint, that would probably be easiest now. If we don't provide a host function or. If we don't provide a footprint approach, that becomes challenging. Because you essentially have to bundle operations at, that point, which I don't think would be really possible to implement you'd have to implement, that not in the sore bomb. But somewhere else
00:44:00.000 --> 00:44:59.999 align:start position:0%
but I think. If we have some sort of footprint approach I think, that would probably be the best way is just to default initialize every restorable entry with the four thousand letters worth of rent and then. If the footprint defines any additional bumps provide those Bumps by the footprint interface yeah I think, that sounds really good I and I just sort of lean further on it I do think I assume we're still talking about the contract still is the one, that can do, that auxiliary bump. So ideally you know in the best case scenario the contract developer has given this thought and they're acting in good faith sorry they're doing the right thing and they're just using, that auxiliary bump for the records, that need to be used. So they might not exactly re-bump everything everything. But the worst case scenario is, that they do you know they don't really think about it and they do bump everything in the footprint. So as a user you do sort of
00:45:00.000 --> 00:45:59.999 align:start position:0%
have a some boundaries in place it's not like a malicious user can do lots of damage they can at worse only bump everything, that's in the footprint, which would be of limited size anyway yeah and in the case, that the contract is malicious. Then like a a powerful a power user or. If a power user just thought they knew better than the contract they could always just set their you know auxiliary bump to zero. And then even. If the smart contract tried to bump everything in the footprint footprint you wouldn't be screwed and you could just essentially get around the auxiliary Behavior. If you had motivation to do. So I think oh sorry timer no I just wanted to say, that I wouldn't put too much effort into protecting against like malicious smart contracts you know. If a smart contract is malicious there's like plenty of other ways, that it can screw you over. And so trying to protect the against malicious smart contractors trying to protect against like buggy smart contracts is you know it's it's a
00:46:00.000 --> 00:46:59.999 align:start position:0%
it's a fight you can't win yeah I actually yeah I think, that's yeah I wanted to say I don't fully agree with this. Because really. If you think about us like any token operations need to be explicitly signed and wait wait my concern about all this customizable pump stuff is, that basically you kind of are doing very implicit operation on a token, which is much added to interpret. Because other reason, that really things, that kind of can impact the user are probably out authorized explicitly. While here you have something implicit, which is why I'm more concerned about, that than about the contracts they just trying to please show like 100 XLM from you for no good reason. Because that's at least very easy to trace and explain whereas like
00:47:00.000 --> 00:47:59.999 align:start position:0%
you know with you're paying rent for something you shouldn't be paying rent for much harder to evaluate you'll be able to print everything. But I wouldn't just dismiss the same it cannot do anything I think we kind of can try to be a bit more conservative here here I mean like it's not like this is you're signing a transaction this is coming out of your wallet I mean all of these fees are coming from refundable fee right like even. If you do like the you know auxiliary rent bump is still coming out refundable fee. And so you have an upper bound right. And so I guess feel like. If a contract is malicious or buggy I mean you pre-flight and you're like oh wow this refundable fee is like absurdly high you're not going to submit, that transaction. And so I think. Because we kind of have like this safe bound both. If we provide a parameter in the footprint to Define the amount of bump to rent, that's one bound plus just the amount of fees you
00:48:00.000 --> 00:48:59.999 align:start position:0%
have is another Bound in refundable fee. So I feel like those two things bound the damage pretty well such, that I think, that the rewards the ux rewards outweigh the potential drawbacks just. Because it's. So bounded and. Because it's fee based and not token based yeah I mean. If he exposes refundable fee in explicit Fashions and great kind of voluminous same book yeah just to be clear all all rent payments come from a fundable fee both the automatic payments and the auxiliary rent bump host function would also draw the funds from refundable fee cool I think just responding to China's comment about you know let's not focus too heavily on malicious malicious I get it I think this design does does lender itself well to just just
00:49:00.000 --> 00:49:59.999 align:start position:0%
separating the responsibility. So they land on you know the response to parties, that are best equipped to handle those responsibilities the fact and I think just naturally out of, that you know we get a slightly better story for what can a contract do malicious for you. But I don't think this is really fully solves, that problem like you said. So and nor do we nor can we I mean I think it puts sufficient boundaries in place, that any sort of malicious behavior wouldn't wouldn't wouldn't be outrageous. So I think we probably have a pretty good feel of the rent pump issue. If if there are any final comments I think we have like 10 minutes left. If we want to move on to a second topic any last parting words. So
00:50:00.000 --> 00:50:59.999 align:start position:0%
we don't actually have a second topic for today or I mean it might be a second rent topic I mean sorry oh okay there's the second one topic. And then the third and the fourth sorry yeah I think like it's it's very clear, that a it sounds like in terms of like implementing and move forward you know obviously it's the bumping by Ledger key is is a building block, that we need anyway. So we can you know keep in implementing in, that direction and it does sound like we need to potentially like enumerate all the options for how the contract exposes you know more fine great information about you know what Ledger keys are actually associated with an account whether it's through the host function you describe whether it's through the Ledger footprint maybe it's even just I don't know like an ecosystem standard for you know there's a function you can call, that gives you
00:51:00.000 --> 00:51:59.999 align:start position:0%
all the Ledger keys, that are associated with an account. So I think we just need to like enumerate over all of these and probably like revisit them no I think, that makes sense I think we probably need to iterate on this design a little bit. But I think we have some good building blocks from the conversation conversation. Now yeah. So I guess we all have a ton of time. But I'll introduce this I'm kind of the second rent related issue and we also have a a temporary entry related issue, that we won't get to today. But for rent there's also an issue of outstanding rent balance. When things are deleted. So I think I don't know how often often this will actually come up in practice as two entries being deleted with large amounts of outstanding rent balance balance. But initially it seems reasonable to refund refund the rent balance to the invoker of the delete operation
00:52:00.000 --> 00:52:59.999 align:start position:0%
this kind of provides network incentive to delete entries, which we do want to have. Because we want you know. If an entry is not going to be used we want to provide incentives somehow for it to be deleted before it hits the archive. Because once it hits the archive it stored in the archive indefinitely Or Intel restored at least. And so to keep the archive size small even, though it's not as big of an issue as having a large Mouse and The Ledger we still want to incentivize deletion the issue is. If you provide rent balance refunds on deletion you open the door to some sophisticated tax and to some kind of patterns. So the issue is, that even, though many different users might be contributing to the rent fund or many different accounts might be funding the rent balance only a single account redeems the rewards. When it's deleted and especially since we are defining this automatic rent bump at the protocol layer this could lead open the door to some interesting attacks. So
00:53:00.000 --> 00:53:59.999 align:start position:0%
for instance say you have like a contract, that's used very often like an AMM or a big DEX what they could do is they could just touch one key on every invocation and it could have like an innocuous name it could be called like off entry or like auth check or something like, that something, that would be difficult to detect in the code auditing auditing. And then they could just like essentially have 10 XLM or whatever like or 10 letters worth of rent or the minimum rent balance just continually be added to this object. And then periodically the admin could. Then call an admin function, that just deletes and recreates this object essentially getting all the rent balance this is kind of a malicious attack. But even a non-malicious attack you could imagine where many different users are contributing to like some swap or something like, that the swap has a large amount of rent. And then whoever like liquidates the swap or liquidates or drains liquidity pull and deletes the entry can also get this additional rent balance, that was paid for by many different users and so. Because of these
00:54:00.000 --> 00:54:59.999 align:start position:0%
two issues it seems, that we don't want to refund rent balance on deletion just have any outstanding rent balance be burned whenever you delete something, that doesn't seem like a great interface. But there doesn't seem to be a good way of refunding rent without running into these weird edge cases, that can be gamed. So I guess thoughts in General on rent refunds and. If we should think about this in a different way just wanted to mention, that we have considered an alternative for we would record, which account has created the entry. And then refunds, that account account. But besides the fact, that it doesn't avoid all the possible issues the problem with this approach is, that that it's really like adding a significant amount of Ledger space and it's not obvious whether the additional fee incurred by the fact, that you are writing bigger entries will be offset
00:55:00.000 --> 00:55:59.999 align:start position:0%
enough with your refunds I mean we have discussed this in a bit different context. But I think it still applies here like we are increasing entries sometimes quite significantly and we want to refund someone. So it's not clear. If this is not positive or not, which is why, that's probably not a good option I would also say, that the, that particular alternative was in the context of temporary entries, which have a single pair I don't think, that approach would work in the restorable entries with rent balances. Because many different users in addition to the user, that created could be paying into rent fees. So for instance you can imagine like the the contract admin created the entry with the minimum balance. And then every user the contract bumps it up to a very high state or to a very large amount of rent. Because it was used frequently in touch frequently it doesn't make sense, that the outstanding balance should go to the
00:56:00.000 --> 00:56:59.999 align:start position:0%
original Creator who only paid them rent. So yeah context of 10 Ventures, that works. But doesn't really work in the restorable entry context yes it's kind of fair. But also I want to say, that you do not allow the leading contracts currently and they I don't think people. So or this is not this is for contract data not for contract instances right yeah. But but yeah I imagine like the most common shared data is through the contract instance. But but yeah anyway I just wanted to say, that the alternative was out there and yeah as you said it doesn't solve those issues and it also has a significant cost attached to it, which is why yeah I guess are there any objections to burning rent or outstanding rent balances balances. Because it seems on paper to not be a great interface. But I think it's probably the best and most Fair way to go about things
00:57:00.000 --> 00:57:59.999 align:start position:0%
Garen how is this handled in other networks or is this just in the context of the state inspiration this is just in the context of State expiration no other network has like rent balances like this. So I don't think there's really any pre pre-context or right. But on the EVM you do get a refund for clearing space right yeah. So you'd still like get Base reserve back and stuff like, that. But I think it's difficult. Because I mean on the EVM there's still like one pair. And then the refund is relatively small whereas here the rent balance could be a somewhat significant value value potentially and there's also multiple payers, which complicate things a little bit more okay. So I think we're at time and obviously obviously I think we all need to think about, that
00:58:00.000 --> 00:58:59.999 align:start position:0%
some more. So maybe start a thread in sorobondev on on refunds and we can revisit, that later sounds good well thank you all foreign foreign thank you all and see you next week.
WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:59.999 align:start position:0%
All right welcome everyone to today's protocol meeting where where we'll discuss two Core Advancement Proposal Gren will be speaking about CAP 65, that introduces a reusable module cache, which Garand actually alluded to last week and after, that Dimo will speak about CAP 64, which pertains to sbon authorization and memos with, that I'll hand it over to grden. So this is a probably smallest cap, that I've done. So far and certainly the simplest to describe U. But it does actually have a fairly dramatic effect effect this really only makes sense in in the context of CAP CAP 62. So this is CAP sorry no I'm CAP 62 this only makes sense in the context of the other CAP yeah no no sorry I'm doing CAP 65 this makes sense in the
00:01:00.000 --> 00:01:59.999 align:start position:0%
context of CAP 62 sorry getting all my 60s tangled up here. So in 62 Garen pointed out, that we in a position where we can basically keep the live letter state in memory constantly. Because of the the the ability to you know evict live state to disk and and account for the movement of of data between dis and memory explicitly in in protocol events, that are surfaced to the user. So the user can tell you know what what they're paying for and and what they're getting out of paying for the things being in memory versus you know allowing a detail to expire and and having it move to dis and, that that obviously produces the ability to reduce IO costs. But there's another thing, that we can do on, that that, that load or evict event. When when things move from dis to memory or memory to disk, that actually sort of solves a problem for us, that we have had for a long time, that has been holding us back from doing something very obvious. So it's a very
00:02:00.000 --> 00:02:59.999 align:start position:0%
obvious optimization, that we've wanted to do since the beginning of Soroban, which is to Cache the compiled ready- to run version of Any Given smart contract in memory and it's ready to run form. So the the wasm bite code, that you upload is essentially not ready to run it's it hasn't it has been validated. When you uploaded it. But theoretically it should be validated again before running. But also it gets translated into a sort of a secondary internal format for execution and in the future. If we ever use a jit this will actually be an even more involved process. But there is nonetheless even with an interpreter there's a translation phase and the important thing to understand is, that translation phase is fast. But it still takes time and you want to run your transactions as fast as possible. And so at the moment. If you look at. If if you sort of look at a execution profile of a contract. When it's running today. When you invoke a contract your transaction actually spends a fair amount of its time in many cases as much as half or or even 2ir or three4 of its time just to during the doing the the
00:03:00.000 --> 00:03:59.999 align:start position:0%
translation getting it ready to run coming from. So so we pull the bik code off of dis. And then we retranslate it. And then jump into it and execute it. And then basically throw, that away and the reason we and. And then do it again for the next trans transaction and the next transaction and we do this over and over again. Because we don't really have a clear way of. If we were to cash it from one transaction to the next deciding who should pay for populating the cash and who should be able to B basically free ride on things already being in the cach and how to sort of reflect, that in the fee model U there's a lot of complexity here I don't really want to go into all the different options I mean I'm sure you can think of a way of making it work off the top of your head many people have we talked about this a lot. When we were developing the structure of Soroban and we couldn't really come up with one, that didn't have some weird incentive, that allowed people to you know price other people out of the transaction queue in in a way, that was unfair or or wound up making them overpay in certain circumstances in ways
00:04:00.000 --> 00:04:59.999 align:start position:0%
that we wouldn't be able to refund stuff like, that. So ultimately up until. Now we have not done, that up until. Now for the first year sort of year or. So of of zoran's existence it has executed in this fairly wasteful fashion where it is reparsing retranslating modules from their serialized WM form into their ready to run form on every single transaction and, that that has been something we know you know we want to get back to we know we want to figure out the correct way to deal with it it longer term and have longer lived caches of, that translated form and. And so with CAP 62 our our opening became obvious this is the clear opening where we can do it and in fact we can do the most aggressive form of it. Because there's this very large amount of data, that will be kept in in memory all the time, which is essentially the entire live part of this orbon part of the bucket list so, that's you know to do levels of
00:05:00.000 --> 00:05:59.999 align:start position:0%
filtering here but. If you sort of step back the the contracts, that are in the live portion of the the Ledger themselves collectively we've done some measurements they're not very big all told it's you know 10 megabytes or something right. Now it's not actually a ton of data even. If we saw substantially substantial growth in in the blockchain sort of all anticipated scenarios don't show it exceeding memory and CAP 62 really makes it clear, that there's a model for bounding, that growth and for charging for it appropriately so, that as, that growth occurs you know we can manage essentially pressure on it to keep it under control to to have it have not become arbitrarily huge and, that means the caching question just gets very simple we just cach everything as soon as something is pulled off of dis we're just going to immediately compile and cache it we we'll translate it into its ready to execute form and we'll just stick it in reusable cash and we will reuse, that cash from from one transaction to the next. So all of the per transaction
00:06:00.000 --> 00:06:59.999 align:start position:0%
costs for for translation go away and, that's like, that's the whole CAP it's actually very straightforward in the context of 62. So I've talked a lot to sort of give you the background for it. But the actual CAP itself is is utterly trivial there's nothing to it as soon as you turn it on your costs just just drop through the floor you everything just goes faster and it's cheaper. So pretty easy sell I don't think there's an awful lot of reason to object to it unless you can think of a reason why you don't want to you know avoid doing work multiple times s it's it's just a freebie we really should have done this earlier on it's just we didn't know how to make it work and, and now we have a fairly clear model for making it work. So I've already implemented this I've run the experiments on mainnet running it in parallel on a local development validator and it's much much cheaper substantial cost cost savings there are a couple of interesting Corner cases to deal with in terms of like like. If you upload a contract. And then try to run it inside the transaction, that you
00:07:00.000 --> 00:07:59.999 align:start position:0%
inside The Ledger, that you uploaded it in so. If you do like an upload and run immediately we have to be a little bit careful there in terms of like. When the cach gets repopulated or incrementally populated with sort new additions. But the worst case scenario of all of those is just, that you get charged today, which is the the you know you get charged the cost of translating it on the fly in addition to the cash population, which we're just going to eat those costs entirely we're not even going to include the cost of cash population and eviction. Because they're. So much lower than the io cost of even bringing stuff in a note of memory in the first place. But there there's there's a little bit of sort of careful accounting to to make sure it all works. But essentially the the user experience is just everything goes faster. So should be very straightforward I don't. If anyone has questions I'm happy to answer them. But I would be surprised. Because there there's really not much to this CAP except cash work and
00:08:00.000 --> 00:08:59.999 align:start position:0%
yeah. So regarding the edge cases can we maybe specify them explicitly in the camp. Because I noted well not quite specified and like my current understanding from looking at the implementation is, that we compile contracts contracts specifically. When we add entries to the backet P can be Iden to the backet list specifically after running each and every transaction in The Ledger it's also SPS a weird a case where. If you have an Appo transaction and the transactions, that cost and apply this contract in the same wager or whatever is your reason. Then we basically have kind of an invocation of a contract, that does not actually appro anything. But it still won't result in a c heat so, that's right yeah yeah I guess it is something to I
00:09:00.000 --> 00:09:59.999 align:start position:0%
think gu this here I think it is something, that we probably need to specify more explicitly in the CAP with respect to the why said it's just, that in this particular case I don't think you can ever get the correct simulation result like again I don't know why would you do, that. But simulation will probably assume like. If you do not upload any contracts. Then your contract has been cashed like every contract your has been cashed and th is this through a next case scenario where it actually is not cashed and it's not in memory. So basically your fees and resources will be off and yeah I guess just worst pointing out in the CAP I can I can clarify the conditions I do like I think you're right in, that that's, that's a fairly Edge case. Because you would have to be simulating an execution of a contract, that wasn't present on the chain on the assumption, that maybe someone will up the same transaction set as you yeah
00:10:00.000 --> 00:10:59.999 align:start position:0%
I I don't know why anyone does, that. But protocol kind of has to handles this anyways sure yeah yeah and and it does it'll it'll it'll it falls back gracefully it just is going to charge you more than you expected. And then you'll transaction would fail okay. But it's a I I'll document, that in the CAP yeah yeah just yeah y else okay, that was easy one. So I guess we move on to the next one yeah it doesn't look like there are any any questions. So Dimo. If you want to get started started yeah yeah type okay yeah. So yeah C 64 it's actually the cab itself is not, that hard uation and
00:11:00.000 --> 00:11:59.999 align:start position:0%
implementation wise. But I guess the discussion Ser more around the requirements from what are trying to Sol here here. So for some background memos are an element of every transaction every store transaction, that are almost nonobservable by the protocol the only thing, that protocol does with transactions is well it is it has will be signed as a part of the transaction envel. But otherwise memory is just some arbitrary payload, that protocol has no concerns thinking about and it would be fine. If like it was just an arbitrary thing, that has no value attached to it maybe it's for marketing transactions or something. But it happens, that so, that exchanges are used memers from for multiaction even, though
00:12:00.000 --> 00:12:59.999 align:start position:0%
a currency store has soal nukes accounts, which allow single public key have huge amount of different sub accounts, that are not represented on chain. But can be marked by some integer integer identifier for historical reasons most of the exchanges are just using the transaction memers and the way it works is, that. When you want to deposit tokens from your own vet to. Then change account exchange would give you two values to consider. When making a transaction the first value is well the destination account, which is a normal store account and the second value is memo usually some integer, that is assigned to your account on, that exchange. So basically in this way can maintain only a few public is they
00:13:00.000 --> 00:13:59.999 align:start position:0%
don't need to create a new account for every user and for store it's actually very meaningful. Because on St there are no State less accounts like since the account is not just a public key. But literally a wer entry. So you need to create it first. So it makes perfect sense, that exchange just runs this offchain multiflection for redution the overall version for maintaining large sets of users, that's kind of the historical background. Then exchanges do use MOS For Better or Worse mied accounts are like more modern way to do, that. But not actually being used not, that much then. When tan came out it didn't care about memos for the reason mentioned before like from the
00:14:00.000 --> 00:14:59.999 align:start position:0%
protocal perspective on paper M do n and this actually spawn kind of a vulnerability. If anyone wanted to use mammas in the context of the exchanges with San and I think there is a security security there is post in the security sections of tore the advisory regarding this issue I probably will not talk much about it. Because like not super relevant. Because like it has been fixed and no one has been affected. But the gist of it is, that it is not possible for a custom account to sign for the transaction memo memo and what this means is, that for example imagine you wanted to deposit money to The Exchange from your customer
00:15:00.000 --> 00:15:59.999 align:start position:0%
account even. If exchange could take St band payments without any issues you actually have no way to sign the mem of the transaction and. If you recall the your account on Exchange your deposit deposit into to is actually combination of the some public key. So the account and a memo and yeah. When when you're making a sban transfer there is simply no way to sign for the memo and in the context of vulnerabilities, that means, that well. If you were to attach your off for the transfer to some to transaction with the memo the store transaction by definition is signed by some classic account. Because well your transfer is a thrand transfer from a custom account and unfortunately as of today it cannot sign for the whole transaction. And then anyone could
00:16:00.000 --> 00:16:59.999 align:start position:0%
take your San off for the transfer and attach it to a different transaction with a different member it is obviously vulnerability but. If you think about it like it is kind of unlikely, that this situation would come up in the first place. Because well as I mentioned like you literally cannot make a stun transfer is a memo. So like the whole preconditions to this situation situation I kind of you're like you need have two account both of each must be fasted and only one of them is set in memo other one is not set in memo so, that's kind of the state of the things and the way like the protocol deals with the. If you potentially shooting yourself in direct by us memers with San transactions in the exchange context, that car simply does not allow such transactions to be present in The
00:17:00.000 --> 00:17:59.999 align:start position:0%
Ledger they rejected before entering the the mle. But we still want to have some solution for interacting with the exchanges using the custom account and C 64 is about like the most straightforward kind of solution there is hopefully the least necessary amount of work for exp me to support. Because it uses the old ways of using memos it just makes them usable from the San point and the way it makes meem usable from the San point is very straightforward you just find as a part of your San pres payload you may set some memo, that you expect to be present in the transaction and this signs for it explicitly. When you are
00:18:00.000 --> 00:18:59.999 align:start position:0%
building your signature P it's basically makes it. So you actually. Now can Cree the suran transfer operation from customer account to some arbitrary exchange the account and your signature will also be a signature of your memo. And then this us payot will only be valid. If it is a part of transaction, that as a match in memo. So well you still need to have two accounts. So need to kind of trust there is no way to actually prevent the prevent there is no way to take your o, that you sign foran and attach it to a transaction with a different memo and there is basically no way to make the transfer not go where it was supposed to go and obviously the next step would
00:19:00.000 --> 00:19:59.999 align:start position:0%
be like. If you were to implement it I must make it clear like even. If you were to use it like there is no guarantee, that exchanges will support it. But at least in order to support, that they just need to increase the scope of the transactions, that are, that they monitoring like. Because I would imagine like on a high level okay don't have access to your code obviously. But on a high level what they would do is they would look at the intern in of transactions somehow identify the payment. And then look at the payment transaction and identify the memo is this change they need to also look at the Rob on transer operations again mattera should look the same in terms of like having the balance of the account increased. Then is in exactly the same place of the
00:20:00.000 --> 00:20:59.999 align:start position:0%
transaction as it for classic. So this is a CAP the payment operations to C address it is like a an opposite basically. When you think of interaction with the exchanges to operations you want to support it's are deposits and withdrawal mean deposit is I have my vet I want to send money to The Exchange. And then do some trading on the exchange and withdrawal means I have some balance token on my non noncustodial exchange account and I want to move it back to my crypto wet, that I own this is withdraw and payments to C address are actually about supporting this DS. So it is kind of related. But it's not in scope of this C and
00:21:00.000 --> 00:21:59.999 align:start position:0%
I'm I'm not sure like you're doing it for this protocol or we doing this all. But current CAP is specifically about the the deposits yeah. So this is basically what is proposed and there are obviously Alternatives such as like hey why not use nuk's accounts and as I mentioned L ex changes don't affort them anyway anyway. Then hey why not come up with a solution for Tran multi Flexin and again exchanges don't use it yet and it is e compling and U it probably requires much more design work and, which is no very obvious way of how to do motortion with turbance it is also meaningful. So what this C does is basically kind of fixes an immediate issue we have. But it
00:22:00.000 --> 00:22:59.999 align:start position:0%
does not close the doors for future modifications or coming up with the new ways of M reflection accounts and for on. But this one seem like the best thing we could do, that is like it has probably the biggest to up is the existing infrastructure UC approaches, that that are out there everything like like other solutions would be probably much more Divergent from what happens. Now and kind of releases the and adoption okay I think just it for the overview. Now this my yes Mamas and events are currently not specified by exist CAP does not
00:23:00.000 --> 00:23:59.999 align:start position:0%
talk about the events, which makes sense it is about mem memers. But the cap, that we have to edit for the next week, that is two under the active discussion is about trying to generalize the events between classic and San. So meet metadata protic operations in they format, that you don't need to write custom person Logic for classic andand and may be a part of this event stream in some some Cas Cas. But yeah I don't know. If they want to discuss this. Now or not the part we have disc yeah and yes in General on more I guess the main phos
00:24:00.000 --> 00:24:59.999 align:start position:0%
question about this C is want not support members at all. Because they're kind of bad and people have isses SYM and I think there is some mar Just. Because of D reasons and. If other folk disagrees andbe Pi up oh in the chat maybe someone wants to camp
00:25:00.000 --> 00:25:59.999 align:start position:0%
on the stage may be as well call Caper still has mem in the system domain yes it's basically I would say my opinion this is, that memers do exist and they are in use for. Now for better worse and it makes sense for San to support them for the
00:26:00.000 --> 00:26:59.999 align:start position:0%
time being. If we have a better generic solution for, that we probably should try to come up with this separately and just try to the CRI. So my expectation is, that it will take a long time before I this P it deated to. If anyone wants to speak up maybe face. Because creting, though everyone is typing
00:27:00.000 --> 00:27:59.999 align:start position:0%
sounds like there's a there's more to discuss related to the the memos. But it doesn't it it should affect CAP 64 right yeah I feel like yeah they. When discussion can be contined synchronously. But before I move on like I just want to ask everyone again like. If anyone has any strong opinions in terms of why you shouldn't do CAP 64 go. Now yeah great yeah is I understand the CAP 64 as it is is very very narrow the
00:28:00.000 --> 00:28:59.999 align:start position:0%
the use case is it's hyper focused on addressing the existing classic use case and it's really surgical just to address the problem there is there and I understand like you know toas bring out you know why not solve this in a way way, that works for more than, that yeah and I get, that I guess my question is like there are some advantages. So even I mean obviously like. If we can solve this in a more generic way, that would be pretty cool and I we probably can. But there are also some advantages. If we do solve it really surgically. Because we sort of can rework back to the transaction memo being something, that you can rely on and
00:29:00.000 --> 00:29:59.999 align:start position:0%
so I think, that's valuable. But maybe, that's not valuable. So I'm not actually sure to. If you're saying, that that's actually not as valuable as what I think it's valuable or what some other of us think is valuable. If we do think, that's valuable is there anything about this proposal, that prevents us from loosening this constraint in the future like. If we go ahead with this proposal the network adops the proposal and Transaction memers what exchanges can continue to rely on in a year from now or six months from now can we loosen the requirements so, that every or can have its own memo or something like, that like is, that are we sort of going down a path where it's going to be really difficult to walk walk back right. So there are Thal things here let me start with the why don't we drop the requirement for text member to my, that transaction m I don't think it's a good idea
00:30:00.000 --> 00:30:59.999 align:start position:0%
because unlike the memo basically the transaction memo and You observe a successful transaction without doing any additional work you can say, that parties have all the parties have times this memo and in case of app 64 you can also say, that the Rel or par have time for this member as well. If you have a transaction, that has some s on o and there is no requirement for the memers to mat the transaction memo. When you're looking at the transaction you cannot tell anything about the nature of this payLo. Because like besides like minor space optimization I think the main conten this comes up in is ay why don't we use it for to allow something like payments to multiple multiple ex destinations at
00:31:00.000 --> 00:31:59.999 align:start position:0%
once in the same transaction well the issue is is, that. If you keep relying on the the transaction like in case of memos you actually don't have any confidence for any given us the it has been used and the member has actually made the P go through. And so on. So basically you put a lot more Demand on find all, that pieces of data together Downstream system. So not only do they need to jump from the event to the transaction. But they also need to make sure, that there are events for every us present in the transaction and everything matches it inst nothing basically yeah there is no extra P or something and I think it's really food guy and like. If
00:32:00.000 --> 00:32:59.999 align:start position:0%
someone forgets about this tck and they can be tricked into thinking, that something has been transferred to them by attaching an extra entry of tbos with some extra memo maybe you know might as a destination account of some methods in there something. So basically it is like given, that s us is really flexible. Because like really it has to support custom accounts and you do not verify it beforehand you can only verify it during the execution actually been consumed I don't think it's a good idea to just put memo in there without any size to the actual transaction. But so here basically like the fact, that the T the transaction M ures the fact, that like there is no ambiguities there in terms of like
00:33:00.000 --> 00:33:59.999 align:start position:0%
memers are actually getting and I recognize it's really restrictive. But I think it's also for the better for. Now and for a more General solution I think it should have something to do this day event, that you don't need to do any work Downstream trying to figure out like. If this is the right memo right M reflection ad for this particular event I think instead event should explicitly tell what is this mul ID, that confirms this particular event and I think this is why this whole discussion about the events have turned up. Because like. If you were to come up with solution, that is event based. Then it will probably make sense to also involve the current members the events to just keep the scem across all the different types of operations okay
00:34:00.000 --> 00:34:59.999 align:start position:0%
now I need to read the comments again and yeah I think. If yeah to the question. If we can relax this requirement I like given the security implications I not sure it is a good idea. But again just said I'm not sure it's a good idea in I think you need a bit PR approach unless of course we figure out how to TI The Memo from the ask and to the event and the sure it is possible at all
00:35:00.000 --> 00:35:59.999 align:start position:0%
so. If a question about like centralized exchanges would need to make some code changes either without change we is, that without, that memo change we actually basically some sort of M support is a requirement to support deposits like it's not the only thing to do. But it is a requirement. Because if they can of do multiflection I think it is very far to ask them to create an actual physical account for every user and accable for the network well. So basically like. If you don't propose any multiaction solution at all I
00:36:00.000 --> 00:36:59.999 align:start position:0%
think there is no way to ask ches to implement anything we need this something and the the argument for this CAP is, that well this Fon is very close to what they already doing whereas. If you try to come up with some another more General system, that's also contingent and adapting. So this whole system whatever it is I don't know yet, that's what it is is e
00:37:00.000 --> 00:37:59.999 align:start position:0%
going ont try some context like a recter may have been some discussion here on Discord about supporting mixed accounts
00:38:00.000 --> 00:38:59.999 align:start position:0%
in San in general general and the trickiest thing about any sort of multile seran and the reason for why we are not like coming in with some maybe more generic multilex app you're not coming out with one yet is, that since in sban you kind of manage your own storage it is pry to distinguish between cases. When you do care about multiflection and you don't care about mation for example consider a classic mixed account let's say you have a transfer let's say we just add it to the thron address well. When you throw the balance in your for example in your custom tokens for Multiplex account. Then you specifically want all the multi account for the for time there the same
00:39:00.000 --> 00:39:59.999 align:start position:0%
key but. When you're in an event you specifically want the event to cons to contain the multiplex account destination and. When you verifying us you also want to make sure, that you're sending, that the transfer happen to the exact Multiplex account, that has been specified in the transaction and I'm going not show you there a generic way of basically for for the contract developer to be aware of like. When they should or shouldn't treat accounts as multilex and this is the primary reason why like mix accounts are not supported by San by turban at all today and also is a reason for why like there's no great solution for Mar collection in foran yet. But think function, that is
00:40:00.000 --> 00:40:59.999 align:start position:0%
not doing anything the contract player maybe. But again I'm not sure yet how would this work like there another argument for why we have doing something simpler. So right I think. If like do we have anying topics, that need to be discussed now. Because I guess we can continue as the man Horizon discussion I think hly yeah I'll leave a link to the discussion
00:41:00.000 --> 00:41:59.999 align:start position:0%
the chat and we can continue there. But it doesn't sound like there are any more immediate questions for CAP 64 at the moment moment yeah. So HP yeah yeah let to force I I've expressed my opinion we can continue discussion the discussion, that. If some yeah we can continue discussing. And then, that thread and sounds like, that's it for for today. So thanks gr and Dima for presenting and thanks everyone for listening we'll see you next week unless Le George have any questions. So typing
00:42:00.000 --> 00:42:59.999 align:start position:0%
all right, that's it. Then see you next week
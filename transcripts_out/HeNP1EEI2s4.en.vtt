WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:59.999 align:start position:0%
Everyone and welcome to our weekly Soroban Design Discussion it sounds like Justin has some AV issues. So I think we're gonna get started without him today we have two main topics to discuss there is metadata and there is changes to the Token interface I think we're just gonna jump right into it with metadata sit are you gonna take this yeah oh yeah. So you know broadly metadata is just a static data, that can be read by consumers without calling it without calling contract function and invoking a awesome VM. So there are two levels of contract metadata one is the code metadata right in sorbine we have this concept of these code entries, that have like the contain wasn't. And then we have instances instances, that are tied to specific contract IDs and those instances instances
00:01:00.000 --> 00:01:59.999 align:start position:0%
will also have some metadata tied to them. So for contract metadata our plan is to put them at it into a wasm custom section and just add support in the SDK to allow for this. So for example you can you know. When you build a contract you can the SK can put in like build related information the questions we still need to answer are more around instance metadata. So the easy option is to not add any explicit protocol support instead of instead have an ecosystem standard on how metadata should be stored in contract data. So you know whoever creates the contract can follow the standard and just put you know a certain information into the Sentry and you users will know where to look just based off of the standard on the SDK we can build tooling around in the SDK to allow for this there's the one question here is how would paying rent on this entry look. Because this entry is not expected to be
00:02:00.000 --> 00:02:59.999 align:start position:0%
accessed on chain so. If that. If you know for no access is Unchained. Then it would be very easy for it to expire. So so you know one solution to this is we can provide a mechanism to tie the contract instance to any contract data keys, that the contract developer wants. So whenever you pay rent for the instance it would also pay rent for those keys, that are attached to it, that's one option. And then another option for instance metadata is to include an explicit metadata field in the contract instance and the the contract developer can write into, that this is still only standardizes how like where metadata is stored not how it actually looks like in the protocol. But this would also. If we do this we can also allow contracts to access metadata for other contracts without calling it to a awesome VM like we could expose, that that information
00:03:00.000 --> 00:03:59.999 align:start position:0%
because right. Now contracts are not allowed to look at and look at data from other contracts without calling into a wazen VM like you have to go through or contract function. So you have to go through the interface of the contract we could instead allow contracts just load directly the metadata field from another contract instance allowing you to you know look at you know information like for their example in the token you can look at the decimals or the token name. If you want to without calling a contract function. So yeah, that's, that's like the, that's the one thing where we're still thinking about for metadata. But I think, that's, that once we figure, that out we should be able to move forward on this any questions what are some examples of scenarios in, which contracts need access to other contracts is metadata. So it's not a yeah this won't be like a common scenario but. If a contract wants say the
00:04:00.000 --> 00:04:59.999 align:start position:0%
token's decibel number for some reason right like we expose, that in the token interface right we have the name the decimal function and we did, that. Because there is no other way to get, that right we don't. Because we don't have metadata right. Now but. If a contract wants, that for some reason right this would be a way to get it I don't think this this I don't think we need to optimize for the scenario where where you know you want to call into metadata in a contract without calling through a contract function. Because it will be rare and. Because of, that you know it's fine to expose, that in the interface and call into a contract function. But yeah like, that's one example it yeah. But my like I'd love to learn about like concrete uses for this. Because it looks like all the metadata uses, that we've been discussing are mostly for Downstream systems it's not for other contracts to consume and. If if, that's the case. Then you know I definitely agree, that having just a standard metadata
00:05:00.000 --> 00:05:59.999 align:start position:0%
you know Ledger entry and a way to access it is kind of like makes the most sense for everyone the question is like are we losing like this important optimization here yeah I'm looking at the Oracle consumer interface precept let's try it in the store Dev I don't know. If everybody has seen it here it basically tries to come up with a standardized historical interface and you know it has a bunch of functions like base asset the list of supported assets decimals resolution, that I suspect may be useful. When you use the machine for the Oracle users correct me. If I'm running as into modes and OrbitLens here. So yeah let me know what what you think about contracts for example like it seems to me like this property seemed to be useful for some function
00:06:00.000 --> 00:06:59.999 align:start position:0%
operations and you know optimizing just cases would be generally beneficial. If you are talking about the Oracle contract interface in particular I think, that that we need to Define Define the validity of those values for example. If we expose decimals and other let's say static properties of the contract in the contract itself via methods in the interface all all other consumers can pretty easily fetch this data. But for all other options I don't see, that
00:07:00.000 --> 00:07:59.999 align:start position:0%
it will be as optimal for example. If I understand correctly contract code can be upgraded and in fact during the upgrade we can lose those values or they they can be replaced with some other values. So from what I'm seeing right. Now I don't like see any benefits from providing some external external access to this metadata in vasmo contractor entry or data laser entries entries and definitely it shouldn't be installed on. Because store Tom is bringing the logic outside of the system
00:08:00.000 --> 00:08:59.999 align:start position:0%
and it really has a lot of problems in terms of usage from the consumer perspective. If if a token, that store tomb is is one of the options on the table. Then we can just just expose the static values on the project website and, that's it. Because even in in, that way it will be probably more more reliable than using Stellar tool yeah I don't think store Thomas on the table. So my question is rather like what do you think as a user of an oracle contract for example as a contract user as it is would you be ever interested in calling functions like base asset or decimals or list of assets I say modes has posted on the CAD, that contracts are expected for example to fetch decimals from tokens
00:09:00.000 --> 00:09:59.999 align:start position:0%
which might be the case as well right I think it's probably like one time only calls. Because most of this methods functions you mentioned they are actually a static right. But anyways I think, that for consistency they should be there. If we can for example expose some some of this values in bathroom custom section Etc, that's good. But still I think the easiest way from the perspective of Downstream systems is to just pull or pull this information directly from the contract via the contract function call I think it's possible
00:10:00.000 --> 00:10:59.999 align:start position:0%
to come up with some special cases where this this where these functions will be called like much much more regularly for example. If the the. If there is some proxy contract, that Aggregates data from let's say a dozen of different Oracles. And then this functions can be called for example on every access to the underlying systems. But I don't really see whether or other like storage options for example control entry will be better than a control control in this regard. Because it's more flexible
00:11:00.000 --> 00:11:59.999 align:start position:0%
flexible I mean it's more flexible and less efficient rate you know you need to make n plus one or n plus two contract calls instead of n you are spending quite a bit of gas and, that. So against Thomas question was whether we ever meet this data machine it seems like yes this sometimes just like just explain where I'm coming from I just feel a bit of disconnected we like a lot of the contract interface isn't exposed a bunch of this meta data-ish functions and you know there are usable both on chain and off chain and it's not really efficient to use them either on chain or off chain, which I would consider a swipe slightly slightly yeah an argument towards like you know having this instead exposures static metadata, that is readable by anyone writable by the owner contract. But I
00:12:00.000 --> 00:12:59.999 align:start position:0%
have a strong opinion on this. But it just feels weird to me, that we like have a bunch of this static contract methods, that are kind of tied to the contract instance instance and you know they will always just fetch an entry from The Ledger like it seems like in his optimization for me. But you know I don't feel like it. So it sounds EMA like what you're suggesting is like a step towards you know basically like exposing kind of like API by shared memory, which I think for like non-meta-data use cases is is you know is a bit dangerous like maybe the the contract shouldn't actually expose you know data through like like a shared memory structure and and. If I look at the functions right. Now especially on like in the token contract they're mostly there for Downstream systems and I did want to
00:13:00.000 --> 00:13:59.999 align:start position:0%
ask moots can you give us examples of. When other contracts actually need the decimals, that sounds a bit idiosyncratic to me yeah yeah yeah I guess probably the best example I can think of is in any system, that has to attempt to Value some collection of tokens, that may or may not be like fully defined and or can change in the future an example of this would be Ave at any point in time in the future it can choose to add a new token they probably don't want to assume, that in the Ethereum case all tokens have 18 decimals for example they have usdc, which I think in Ethereum only has six. So in, that event. If you are trying to consume some common common price to compare all these Assets in you'd have to take the decimals into account otherwise your price would either be
00:14:00.000 --> 00:14:59.999 align:start position:0%
severely inflated or deflated based on whatever number of decimals you've been assuming so, that would be kind of like trying or I suppose trying to Value some set of tokens would be really the only case I can think of, that decimals would be needed Unchained. But it's a fairly common one and Ave actually does, that it calls the decimals function yeah you'll some people like for example balancer does something kind of interesting where they actually normalize all the decimal values and just assume they're 18. Which is an option too. If you want to avoid trying to call decimals. But just. Because oracles don't always list prices in normal like the same denomination you would need to use decimals to ensure, that you're actually getting the correct one got it. So it's mostly kind of like normalizing data coming from oracles
00:15:00.000 --> 00:15:59.999 align:start position:0%
correct yeah yeah it just feels a little bit weird to me, that well like the functions for example are metadata conceptually right and and you know it is urge, that we expose it as a function. But we are not going to use a tone chain whereas we are proposing and just you know hey let's use some standard like we have this Ledger entries is the metadata to use of chain. So actually what I mean here. So basically we have functions. But we don't use them on chain. And then for off chain we have standardized metadata entries. Then there is a question like why do we even expose this functions in the first place or maybe vice versa why we buzzer with defining the standard structure for metadata at all. If we provide functions for, that we say like hey just you know. If you want to
00:16:00.000 --> 00:16:59.999 align:start position:0%
expose any metadata exposure to this is a static function it's hopefully reasonably cheap to call off-chain anyway well I think the answer is the exposed functions today. Because we don't have the concept of metadata right. So the question is like. If we do have the concept of metadata. Then we will probably reduce the number of functions to those, that are actually usable on chain and you know things like you know the name of the token probably not usable on chain I don't see a reason to expose, that. So so like I you know I would error on on the side of like not introducing new mechanics. Then then introducing your mechanics mechanics and whatever we can do with with defining ecosystem standards is better than making you know protocol change, that we need to live in Forever yeah definitely I like I'm all for like you know letting more stuff to be resolved like of protocol of chain
00:17:00.000 --> 00:17:59.999 align:start position:0%
just, that it's a little bit weird, that we have two ways of doing the same thing. But you know. If our guidance is hey like. If you don't ever expect this to be accessed unchanged just use a ledger key to unplug the interface and things, that's probably good enough yeah and I do think it's an optimization for Downstream systems right like we don't want wallets to like constantly be calling you know running like wasn't code to determine like you know decimals and and asset names I think, that if. If we are going with any of the let's say with any static storage for this metadata metadata it should be read only. So it's like it's set for once and never changed. Because otherwise
00:18:00.000 --> 00:18:59.999 align:start position:0%
from the consumer perspective I don't really really don't really understand. When this data can be updated for example and and many ways. If it's stored not in the contract data. But in Contra closure entry or somewhere else I think, that in most cases consumers will have to call it like every time I understand, that it's cheaper. But still. If we are decoupling this from the standard standard contract storage. So it's probably makes sense to ensure, that these values are you know for example. If they're created in
00:19:00.000 --> 00:19:59.999 align:start position:0%
contractual entities and they should be created created well during creation and the never changed so, that's an interesting point. Because we we will allow for updating contract instances or sorry you updated contract instance to point to a different contract code entry, and now I think ideally you would update in a way where the metadata still holds true. But but yeah it's a completely coupled like no matter how metadata is stored with shouldn't touch it. When the source is being updated and to be clear the sort of metadata we've been talking about, that is attributed to the bathroom Source this is not like the data about like decimals or anything. Because it's not an instance it's more like this has been built this version of sdkx or this implements interface Y and not merging
00:20:00.000 --> 00:20:59.999 align:start position:0%
that. So you know. When we update it yes it will be updated. But like it is expected like. When we updated yes it will be updated. But like it is expected we give the implementation migrated to a new SDK version on you send it to interface I think this is what you want to observe you're talking about code metadata right I thought yeah yeah. But but I think yeah yeah there was a question about like hey what what. If he updates the contract implementation. So what I'm saying is, that you do not touch instance metadata and old metadata itself is expected to be updated. Because it just describes the code. So but. But do you allow for updating the instance metadata I get the contract the code metadata it depends on the approach right. If you go for the contract storage just the normal contract data Ledger entries it is updatable and the same is true for the current functions it exposes right click, that prevents you from changing the token
00:21:00.000 --> 00:21:59.999 align:start position:0%
name currently. If you go for yeah another approach we can make a trade only. If you want okay. Because I think, that's what orbit just brought up okay. So it doesn't sound like we've like decided on you know. If this information. So like you know we can actually yeah someone mentioned, that the metadata we don't have metadata at the moment. But technically you can still look at the token and figure out where the balance entry or sorry where the decimal entry is stored right and what we're saying is. If you do this all off protocol. Then you would just. figure out a set ecosystem standard for where the decimal entry will be stored. Because they'd already exists today we would ideally put the decimal name and token all into a single metadata entry, that that, that's like determined by the ecosystem not by the protocol right. So it's not like we're we're going to you know add Like A New Concept
00:22:00.000 --> 00:22:59.999 align:start position:0%
of like a new type of Entry or add information, that doesn't exist today it's more about where we put the information, that already exists on chain today and just in a way where we can where it would make where it's easier to retrieve right yeah and. If I try to paraphrase what Dima said earlier at, that point I think, that the the the argument here is is like not whether or not to add this to the contract entry itself itself. But assuming, that we're not like do we actually need to standardize this or you know do we just use what we have right now, which is functions. Because you know like more ways to access data is like more dangerous or it's it creates like a bifurcation there yeah and, that's specifically for the like your question is specifically about the cross-contract case right
00:23:00.000 --> 00:23:59.999 align:start position:0%
yeah to be clear I think the cross-contract case is actually like I recognize, that there are use cases for, that. But I think they're like fairly minimal and I think most metadata, that we've been talking about is never going to be consumed by another contract yeah I agree I think we need to consider the separation of security for this to Value. So let's say. If we talk about the value, that is stored and Modified by the contract itself. Then the security lies entirely in the field of the code written by the developer but. If if we
00:24:00.000 --> 00:24:59.999 align:start position:0%
introduce another way to store some metadata would be randomly or some other let's say editable metadata we need to think about security considerations here as well. So we need to provide information and strictly Define. When can will be changed and under, which conditions. Because again. If you are talking about oracle's price modify as decimals may have like disasters effects for all consumers orbit I didn't understand from, that what your perspective as you said. If we're introducing a new mechanism for accessing metadata do you think we should add we should introduce like a separate mechanism for Access I think we can introduce and it's okay. But we can
00:25:00.000 --> 00:25:59.999 align:start position:0%
we should Define very strictly under, which condition it changes. So there are like a few options described in the prairie dog and and I should probably focus on these options, that as I provide a reasonably access to this metadata or at least provide strict security guarantees, that this metadata won't be changed by someone in the runtime. Because contracts for example can have like other more Street security grantees. Then the deployer
00:26:00.000 --> 00:26:59.999 align:start position:0%
the deployer contract or deployer account for example it's something, that should be considered the like the more we talk about this the more I feel strongly, that we shouldn't introduce like a protocol feature specifically for this and I think, that the functions yeah the cross contract calls facilitate all of our anshay needs and an ecosystem standard for metadata can help Downstream systems just know where something is instead of calling for it. But but I don't think we should introduce new protocol mechanics here yeah and to add to the concerns, that Sid has mentioned at the very beginning regarding the rent payments for those entries, that are never going to be attached on genes supposedly I think
00:27:00.000 --> 00:27:59.999 align:start position:0%
that the current iteration of the Ring proposal kind of takes care of, that in less reasonable fashion. Because you can pump print and arbitrary entries. So you know. If you really care about your token contract you can just bump the rent on its metadata every once in a. While and the good thing is, that metadata is not like something, that has to be there to make your contract upgrade. So not critical to maintain rent a bit. But it should be possible. So it's not a concern as well well it does have to be a manual process, though. And so I'm wondering like. If it would be wise to maybe some outside the metadata to the contract instance itself. Because right. Now you currently have a rent bump whenever you access either read access or read write access. And so I can imagine a scenario where like the contract is used on chain a lot. But then you know. If you don't manually call
00:28:00.000 --> 00:28:59.999 align:start position:0%
this bump. Then even, though it's being used on chain the metadata can get archived and default on rent. So I'm wondering. If we should tie metadata somehow to the contract instance such, that. If the contract is actively being used the metadata won't get sent to the archive and you don't have to have this manual intervention. But Garen is isn't this problem relevant for any like Global state, that a contract has like this is not something unique for metadata even like you know like pool values and a liquidity pool will will you know we'll need similar mechanisms. Now this is true. But I feel like mad data is just somewhat unique. Because it's just never used on chain right and like. If I feel like for most contract data types. If they're being touched or. If they are like relevant for onshine operations. Then they'll be accessed and they'll have the rent bump. And so I feel like, that's like the one issue with the metadata is, that. Because it doesn't have an on-chain use it will never have this automatic bump. Because it should never be accessed by an on-chain
00:29:00.000 --> 00:29:59.999 align:start position:0%
contract, that's a good point it's like in the liquidity pool thing like it will be accessed. So it will have this automatic bomb. And so I'm just worried, that you know it's like a weird interface where we have like essentially you know especially in the new brand proposal where we have automatic rent payments payments it just feels weird, that rent is paid automatically for you know anything, that's relevant. But a very popular contract instance would still not automatically update the Mad data entries. And so it just feels like a poor user experience oh I mean in the current proposal right you still can Bounce Around manually rate for any Ledger entry you want, which is what I refer to by saying, that we have a solution for, that I'm not saying it is perfect. But you know since we say, that hey this sort of metadata is for the off-chain usage anyway I don't see this too offensive
00:30:00.000 --> 00:30:59.999 align:start position:0%
that you know you need to craft rent bumps of chain as well as opposed to the automated months I mean yeah it's probably not the best ux. But since like the cost of defaulting our rent is really low here not impossible to recreate this entry. If needed from the archive. So I feel like well it may be of a minor annoyance it doesn't seem like I'm super critical. But I mean you can also get creative and do the merging of the data, that is being accessed and chain and, that is purely metadata just by implementing it in a certain fashion in the contract like you can have a single entry, that mixes both used. And then use data. And then everything will get pumped together, which is good I guess
00:31:00.000 --> 00:31:59.999 align:start position:0%
we have a great like this can be developed developed off protocol. If needed yeah like my general sentiment is. If this you know. If this thing is still alive there would be at least one entity, that you know, that cares enough to put you know quarters in this meter okay. So it sounds like we where we are at the moment is, that we, that the the metadata won't be exposed directly on chain and, though we will say for now, that rent will just be manually bumped on these entries is, that right yes okay okay all right I don't think there are any other questions around this
00:32:00.000 --> 00:32:59.999 align:start position:0%
so we can. If no one else has any other questions we can move on to the next topic yeah. So this took an interface I don't have much do exposes. But basically it's a couple of things, that we haven't still done with the token things right across next and and some of these things are pretty and uncontroversial I think like for example all the admin interface doesn't require admin address anymore to be passed to it. Because we need to fetch admin from the storage anyway. So we can directly call request it the next thing, that is slightly more controversial I guess and interesting is this is next it is much easier to make
00:33:00.000 --> 00:33:59.999 align:start position:0%
outright subcontract course on behalf of someone. So you can the user can call a contract, that calls a token transfer for example and and it is a useful feature. But regular transfer transfer is quite Limited in the sense, that you can only send a preset amount and this is the exact amount, that you have signed so. If the example. If you have some trading contracts, that doesn't perform a full trade it will need to come up with a custom refund Logic for example like. If the price has dropped down compared to what you have authorized authorized and so, that cases we want to introduce a function like X for Max or maybe expert Contracting proposals welcome and this function would basically allow
00:34:00.000 --> 00:34:59.999 align:start position:0%
sign-in as maximum amount and signing the the address, that is all tries to transfer up to, that amount. But then the call itself accepts the actual recipient and the actual amount, that of course have to be not have to not exceed the amount, that has been signed by the user, that allows to do something like Xavier has signed transfer of 100 to XLM and during a trade we figure, that actually they need to spend just 95 XLM to perform the trade. So the contract can do just a single token call X4 Max with 100xl and authorized and 95 XLM sexual value. So I guess interesting question like the proposal like, that seems a
00:35:00.000 --> 00:35:59.999 align:start position:0%
reasonable at least from the previous discussions discussions I guess the question for this particular proposal is how many extra functions are we going to have. Because currently they already have week two x four and extra from this using allowance, which is like the next topic. But you know maybe we should try conversion conversion for example have the normal extra Behavior to be always like this extra Max I have described like you know you always sign the actual value of the transfer. But then like. If you are doing just a simple payment you can bypass Romanian arguments or duplicates and something. And then you know combination from contract you can decide or we can have two functions. So I guess, that is the question here I'm interested in some opinions. So I guess the trade-off here is either more complex interface or
00:36:00.000 --> 00:36:59.999 align:start position:0%
simpler interface with less functional. But this function itself is like more complex just to make sure we're all on the same page in in current semantics. If you want to do like a trade, that is a you know a strict send. Then the current expert expert function is enough right yes okay so. If you want to do like a strict receive in, which like the other side of the trade is guaranteed. Then the like the send amount can be flexible yes got it out of curiosity what is common in the world of you know popular a m's on on Ethereum for example do they work on like strict send or strict receive semantics, that's anyone or no it's not really either sadly you kind of
00:37:00.000 --> 00:37:59.999 align:start position:0%
put in a price and you put in a slippage tolerance tolerance. So it's likely more it's I guess yeah no it's definitely strict send with the slippage tolerance got it. But the amount you send is set yeah it's just the the amount you receive is is undefined up to some limit yeah yeah yeah I think this is function of requirements or is this a function of the you know for example token interface and Improvement and interface yes like I can see eyes relate. Because I know, that some things are definitely by product of the current design restrictions certain blockchains. So I wonder. If here this is a really business requirement or just something, that is a product of token Heaven only strict sense
00:38:00.000 --> 00:38:59.999 align:start position:0%
yeah I hear you and and it is difficult to know I this is anecdotal. But I can tell you, that throughout the the the beginning of Stellar we only had like strict receive semantics and, that was extremely confusing and. When we've added stricts and most people kind of like migrated to, that. Because it is and and this is an assumption I think it's it's it's a bit easier to perceive you know I'm gonna put this amount in and I recognize, that the amount coming out can be like dependent on market conditions the opposite and like the other side I think is a bit more confusing to people. So I don't necessarily think, that having only strict sense semantics is is, that bad I am concerned about having an interface, that is a bit convoluted and has you know too many expert functions by the way can we please stop saying expert and like move to transfer functions will, that happen soon
00:39:00.000 --> 00:39:59.999 align:start position:0%
yeah yeah actually as a pair of token in European discussion I think we should migrate to longer function names I know, that we allow up to 32 bytes we should collects for transfer and you know rename also terribly named functions, that they're trying to fit into, that character. So yeah I think this should happen yeah I think in the chat everyone is excited about this yes let's have more understandable longer function names please. So is there a proposal here is just not do it at all and live with only a strict send transfer. Because it is true, that it is not impossible to just like even. If you need restrict received behavior and even. If you don't use allowance you still can do it by for a transfer of the whole
00:40:00.000 --> 00:40:59.999 align:start position:0%
amount. And then refunding so, that that's an option as well and it keeps things simpler and you know you find this useful we can extend the token interface eventually yeah especially. Because this is you know we're not talking about just a standard token right this is the token interface right. So this is you know every implementer is going to have to implement this and I do think, that we need to to as much as possible keep it simple and you know say what you want about the erc20 interface it is fairly simple and I think there's something to learn from, that like this whole thing came up during those next discussions and things like a lot of people were interested like what. If I need to send a volatile amount of token token but. If that's really more of a hypothetical case and in reality it doesn't really matter much
00:41:00.000 --> 00:41:59.999 align:start position:0%
yeah I agree, that we can just keep interfaces important. So unless someone has a very strong use case for transfer Max what's profit for. Now now does everyone agree yeah any supporters of transfer Max want to speak. Now okay. And then the next topic is allowances and yeah I think there was some controversy about this. But basically what I like to have in the end, which we may not necessarily achieve. But or anything, that things like persistent and limited nuances are inherently dangerous and I mean the luxury some data about millions of
00:42:00.000 --> 00:42:59.999 align:start position:0%
dollars was a persistent limited alliances on other blockchains. So I think there is some evidence, that this is not the best pattern to use but, that said like series seemingly a pretty narrow slice of cases where it might be useful it is still dangerous. But it could be useful like the case of recurring payment or subscription for, that cases I think, that using account obstruction is the correct quote-unquote solution. Because it enforces the actual recordings like. When you are doing a recurring payment the actual requirement is not I allows this contract to spend as much token on my behalf of the font. But I allow this token to spend up to X token during the time period of and weeks or months or
00:43:00.000 --> 00:43:59.999 align:start position:0%
something right. So the question here is like. If we want to still have persistent allowances at all in the token interface given, that they count with certain risks and another thing is again another proposal I had is just temporary allowance, that exists only during the contract called execution and, that's mostly useful for the cases similar to like, which receive or maybe even something not converted than, that for you want to take the token from the user and it between several parties for example again I recognize, that's
00:44:00.000 --> 00:44:59.999 align:start position:0%
probably not the most useful use case necessarily and I have seen I have exact concerns about the need for the temp storage. Now but I feel like at least. If you are talking about all answers they will do much more comfortable with like temporary allowances. Because the main issue is persistent tolerances is, that well people just forget about them. And then you know it's in some way compromises and you would lose your token without much actions from you whereas like. When we are talking about something temporary it exists only business scope of a single transaction. So yeah basically two questions wait do you have any arguments for and against persistent allowances in token interface and. If you have something against or maybe for the temporary allowances at all and
00:45:00.000 --> 00:45:59.999 align:start position:0%
then we can decide like what do we do close close the Nema around this concept of like persistent using account abstraction instead of persistent allowances for things like subscriptions can you ex can you like further explain how this might work I don't fully understand, that yeah. So I kind of abstraction allows you to basically do signature OS transactions. So instead of making like like you know signing every operation done with your account what you can have is, that your account may have a function, that you need to all tray such as for example at subscription or add your current payment is whatever requirements, that seem useful right for example span token X up to certain amount is in certain 10th window. Then may have
00:46:00.000 --> 00:46:59.999 align:start position:0%
certain options right how this time window window it's been applied. So I guess this totally depends on the business requirements those opinions, which is why why like an alternative to, that would be to do some timed approvals for the token. But it seems really complicated for something as simple as token interface right. Because there may be different requirements for this and typically are like recurring payments is just one example like there are other examples where you can have a session or something. But anyway anyway. So you have a function, that says add a subscription right you authorize it and write an entry owned by your account to The Ledger. Then describes this subscription subscription and then. When someone tries to authorize something on behalf of your account depending likely to arguments maybe whatever your contract decides to do. But the point is, that instead of verifying
00:47:00.000 --> 00:47:59.999 align:start position:0%
some signature it would expect the code to have no signature at all. But instead it would expect a certain entry being present in. So edgers for example in case of the recurrent payment you would expect, that. If a contract tries to call a token transfer on your behalf without any signatures and it must have a subscription. And then it would fetch a subscription from The Ledger verifies, that the send amount does not exceed the remaining balance for the subscription and. If so it would allows it would it be fair to say the advantage of doing the account abstraction approach to subscriptions is it lets the code live in the actual wallet and be more complicated, that way versus just being implemented as like an approval mechanism in the token, which is a bit yeah yeah. So there's already a couple of NHS one is customization like you
00:48:00.000 --> 00:48:59.999 align:start position:0%
don't need to attach the token interface and you don't need to restrict yourself to tokens right you might also you know I'll try some text to trade your entities or something like like I'm making this happen it's a bad example. But you get the idea it's not limited to token and it's not yeah like like certain way of defining the time balance for example and another Advantage is, that you are the owner of the account, which again in case of persistent allowances for example the allowance is delegated to a third party you have no control over it and. If it's compromised you're in, that situation here you will be screwed only. If your account is compromised. But I mean, that's a general problem of any account. But at least you do not put any additional trust to the third party like you just Define rules, that for the third party to
00:49:00.000 --> 00:49:59.999 align:start position:0%
use your funds sorry go ahead like for this it sounds like you need special accounts, that can actually handle the logic for like understanding subscriptions. But also you're kind of like delegated you're moving the responsibility of like the subscription logic from the you know from the merchant to the account like what do we expect, that Merchants are going to program accounts for users to do this I'm a bit confused yeah, that's definitely a general issue issue. While account obstruction seems like a nice idea like in reality they have already a ton of Stellar accounts answer right, that you know I would imagine the apps would want to build for, which is why I'm not saying necessarily this is a Only Solution I'm just saying, that it is
00:50:00.000 --> 00:50:59.999 align:start position:0%
an architecturally good solution and it's good from the security standpoint and in order to kind of mitigate the issue of you know for example Quest extra account not supporting anything like, that I had another proposal here on this card code extensible accounts and what it comes down to is, that you basically kind of can add delegations for your account to delegate authorization from your main account to another account and think of it way. Because adding a module for example you can have a classic store account with a subscriptions module obviously someone needs to write this module account doesn't have to be Merchant it can be you know one library, that provides it. So it is an unzero amount of work obviously but. If shareable is one is there a some standards like hey it's
00:51:00.000 --> 00:51:59.999 align:start position:0%
module standards allows to do subscriptions for example. So anyone who can or who wants to do subscriptions just needs to make sure, that kind of has this module again this is just a proposal I had and I think it's also applicable to the more broad case of a I want to do something interesting with custom account contracts. But I'm worried about and working. So these extensions it is possible you know you don't require a user to just migrate to your account implementation necessarily. But you you just allows them to reuse their main account address. But benefit from some new features, which I think maybe generally useful thing to have or adoption of customer accounts the
00:52:00.000 --> 00:52:59.999 align:start position:0%
extensible accounts thing is super interesting interesting I think it ties in really closely with contract upgrades. Because accounts are generally you know really long-lived and you want to be able to upgrade like. If the subscription interface is a new thing or there's like subscription to V2 right you don't want to be stuck with your smart contract wallet being on a previous version yeah and I guess the good thing about it, that kind of allows for experimentation. Because I to be completely honest I have my doubts about like general adoption of account abstraction. If you just say hey you are the store account. But you can also build your own things it seems like a pretty daunting task and you know. If you can at least build things in a model or fashion hopefully there will be more use for, that that yeah, that's, that I realized like this might be a separate discussion week. If
00:53:00.000 --> 00:53:59.999 align:start position:0%
not everyone has read this proposal I would feel okay ish it's just leaving the persistent alone Soldier and adding a disclaimer about wait don't use this unless you after as a simplest solution. But you know my last tense is basically, that I really sooner or later we should just get rid of, that and provide on abstraction for, that yeah it's just it custom inexpensable accounts yeah it sounds like there's a tension here between like what is kind of like secure and has like you know proper architecture elegant and like extensible versus what is you know kind of like simple and generalizable, which is like what we have right. Now with the persistent allowances my my vote is to keep persistent allowances there. Because
00:54:00.000 --> 00:54:59.999 align:start position:0%
because. If we're going to you know rely on people implementing their own account abstraction or account abstraction like modules for subscriptions. Then I think, that's a bit of a high barrier of Entry I wonder how popular subscriptions are in general how comfortable I have people with them especially. When it's done in the form of I just given a limited allowance to this contract. So I'm not necessarily convinced, that this is like a super strong use case in general. But you know as I said like. If you add some disclaimers and say, that you know like this is us next and visits our us framework whatever you should be able to avoid this in like 95 of the cases hopefully, that's good enough. Because really the the kissing like why I started this topic at all is, that in reality you shouldn't need allowances at
00:55:00.000 --> 00:55:59.999 align:start position:0%
all like most of the time right yeah I would say, that subscriptions right. Now in crypto are definitely not there yet. But in the world of merchant payments they're huge and we can't ignore it. If if we do believe in kind of like you know wide adoption of yeah definitely. But but I guess the question is here rather like would you want a simple. But insecure solution or you know should be right let's try for providing proper secure support and and I don't think they're not they're necessarily like mutually exclusive right. If you know. If we do have persistent allowances and we come up with like a better mechanism through like like you know abstraction, that's great. But I think just having something, that is kind of like a simple catch-all mechanism is still worth having having yeah it just means we need to support
00:56:00.000 --> 00:56:59.999 align:start position:0%
persistent approvals forever and everyone implements a token does as well. Because it's part of the token interface yeah, which is you know For Better or For Worse is an established practice like across the ecosystem right yeah again coming back to the collection of requirements versus limitations and reasonably certain, that persistent allowances are a result of the limitations of experiment right Reliance on, that single subscribers single signer and a single call right they really are not needed most of the time. So my main concern would be really not about the subscriptions necessarily. But about just people music out of an art of habit again they are not needed most of the time I think
00:57:00.000 --> 00:57:59.999 align:start position:0%
that's, that's, that's an important point about sort of one knows right it shouldn't make balances and there generally. And so but I mean as long as you can make this clear clear hopefully, that's okay yeah I definitely agree and I think, that both in the documentation and in wallets, that Implement signing these there needs to be kind of like you know huge big red warnings whatever you sign you actually sign in allowance. Because users shouldn't be doing this on a regular basis yeah yeah as long as you say, that yeah it's reserved for some specific use cases I was gonna say yeah I agree the smart contract subscription model for, that is definitely better and it's nicer
00:58:00.000 --> 00:58:59.999 align:start position:0%
but it opens a huge can of worms in particular around like you've approved with the approval model you can say to the user you've approved this amount for these wallet transfers right, which is kind of easy to understand but. If you're getting into like more advanced logic within the smart contract well, that's a big ux challenge to explain, that to users in a way they can understand, which like we're not going to solve in the next six months months given everything else we have to do yeah I mean, that's definitely about a week week, that's the same right right there is some upfront cost before we get nice things things yeah yeah I'm sure people in the community are looking into, that could be a pretty nice to build on top of this account obstruction framework. But yeah I definitely recognize, that it is a pretty high entry cost right. Because I mean those wallet support and punching support. So yeah not
00:59:00.000 --> 00:59:59.999 align:start position:0%
sure how we will perseverance. So it sounds it looks like we're on time I would say I think for. Now it sounds like we're leaning towards keeping persistent approvals approvals Precision allowances and we probably need to further discuss the idea of temporary allowances. But but we'll push, that to next week cool well thank you so much have a great day y'all see you next week
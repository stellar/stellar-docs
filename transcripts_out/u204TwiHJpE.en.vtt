WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:59.999 align:start position:0%
I see some folks have come to the meeting already and we probably can get started first and pleas meain chat like. If you can hear me. Now okay great thank you right. So today we have two rather small CS to go through both cups are about adding some new host functions for turbon and both pretty simple. So
00:01:00.000 --> 00:01:59.999 align:start position:0%
just hopefully shouldn't take too long to to discuss the first okay maybe maybe let's wait for like 30 seconds more I see folks keep coming right hey can see no one has t some last even okay. So let's get started right we have tab 68 first and tab 68 proposes to add a new host function will be used to get at an
00:02:00.000 --> 00:02:59.999 align:start position:0%
executive for an address and depending on what the address is the EXA the executable value will be different depending on what the addresses more specifically. When the address corresponds to the classic account with technically no contract and executable for it, which is why we'll return Special Value Value, that that this is a classic account now. When the dra corresponds to a contract there are also two different cases one case is. When the contract is a to asset contract, which is our buildin contract and in, that case again you will get the flag, that says, that this is a tered contract and. When you're doing with a CL
00:03:00.000 --> 00:03:59.999 align:start position:0%
with a regular vasm contract we'll tell this vasm contract and provide the respective has this is actually both specification of the CAP and quick description of the CAP there isn't much to talk about here. But I guess there is quite a few things to tell about motivation for why would someone actually want this super Po and why this hasn't hasn't implemented initially in the protocol. So in general addresses are kind of abstract right You can for example call require o for any address and in the background we will figure out what exactly to call for it or you can save the address in the storage for example and you don't care exactly what B is suggest. But there are some more
00:04:00.000 --> 00:04:59.999 align:start position:0%
narrow use cases, which kind of came up during the time of Tran's existence and they're kind of different in their ways. But the common topic as well some information about the address is necessary to be retried specifically one of the cases, which has been brought up is about distinguishing the custom tokens and S asset contract tokens and the way this function will help is, that it will be actually able to tell on chain. If a given contract is a store asset contract. And then for example you can look up the contract name and see, which classic asset it corresponds to and you actually don't need to worry about like. If you know the executable is a s contract and you know
00:05:00.000 --> 00:05:59.999 align:start position:0%
that its name is for example native right. Then you actually are 100% sure on chain, that the contract you dealing this is actually xrm contract, which has the name native and executable ised contract and same goes basically for any asset and this use case has come up in the context of the AEL breaks, that does some FR chain token Ren and basically you know to deploy a token on a different chain they need to understand like. If it is a classic tokens they doing with and th they can create appropriate metadata for this event and there is no need to hurt code for example ID for all the contracts and I think the question of what is the address of the XLM contract or how how they figure out. If something is XLM has come up quite a bit before, and now we provide a way, that doesn't actually involve for in the hardcoded
00:06:00.000 --> 00:06:59.999 align:start position:0%
XLM value, which may be valuable in some cases another re case, that has come up here. But basically. When deing with a custom accounts there are maybe several actually quite different cases for why you would want to know specifically what is a hash of a particular wasm contract what is a wasm hash hash and this may come up both in the implementation of the custom account itself itself say I you want your customer account to only authorize token operations on some tracted token implementation right again for example to asset contract trusted custom token implementation or maybe in general you want to be able to verify the source of certain contracts you
00:07:00.000 --> 00:07:59.999 align:start position:0%
want to in right it is more of a customization SC and in another case, that T has brought up specifically is, that. If you wanted to build some modelized account, that have several contracts Implement in several different authorization policies, which kind of makes sense for the general customer account custom custom customization customization you basically may have some contracts, that would do us for you and you actually want to be confident, that this contracts will not be updated. So for example you trust certain contracts to do something on your behalf and you trust its current implementation. But you do not want this implementation to be ever seen and. If you know
00:08:00.000 --> 00:08:59.999 align:start position:0%
what is the current casat you can actually enforce, that and for the hasn't make sure, that the hash hasn't seen in the future location. So all and allers are like pretty narrow cases it probably doesn't come up for each and every contract. But I think they are interesting enough and in general functionality exist makes sense to provide it like other part of the deployer function right you you can deploy something. But you cannot know what exactly has been deployed. Now we kind of boot in another end of this and I think beyond what I've been talking about there are some other things, that people may come up to with this functioning bits it is not something you need to store for example example right I can try to speak louder is it better
00:09:00.000 --> 00:09:59.999 align:start position:0%
okay okay yeah I should have P me sooner yeah. So what I've been saying is, that the use case presented inen discussions are some this. Because it motivated this happen the first place. But I'm sure there are more things, that people may come up with and this functionality is not unique to s s. But for example EV EVM has functions for retrieving the actually they even have functions to retrieve the entire code, which I don't think is relevant to soran. But also like to retrieve the hash of the contract code, which is more or less what we are doing here. So I think all know it's pretty sensible idea
00:10:00.000 --> 00:10:59.999 align:start position:0%
to have and seemly some use cases where this is helpful. So this is pretty much it on the C presentation and I don't know. If there are any questions. But there was a a discussion in GitHub regarding the data structure to be used here. Because the initial CAP has n data structure structure proposed and Lee has suggested to use a flat data structure and I think I haven't replied on the discussion. But after looking at this again before this m I think it seems like a sensible suggestion. So I'll probably update the CAP and makes it ANM structure flat yeah. So it's like guess small implementation detail. But I
00:11:00.000 --> 00:11:59.999 align:start position:0%
think it probably makes sense to do, that yeah so, that's pretty much it on CAP 68 are there any questions e
00:12:00.000 --> 00:12:59.999 align:start position:0%
yeah regarding the fony yeah I agree, that even, though we kind of going to have two very similar data types I think it makes sense conceptually to have this FL I guess it's not too much of Maintenance Maintenance burden yeah not for performance reasons. But mostly for quity all right anyways. If anyone has any more questions please pause them in the discussion thread other, that that's pretty much it for CAP 68, and now CAP 69 it's an even simpler CAP and it simply adds two conversion functions one to com
00:13:00.000 --> 00:13:59.999 align:start position:0%
convert string object into bite object and another to convert bite object back into string object and the reason for this is basically, that spring object well well first thing is, that strings and byes and thran are exactly the same thing. So kind of makes sense for them to be convertible to each other. But the main reason for why this has actually come up is, that due to I guess bit of an oversight in in the design string has very restricted set of the host functions, that can do anything about it specifically you can get only stream lens today and copy it into memory. So people were trying to get
00:14:00.000 --> 00:14:59.999 align:start position:0%
for example a character of a string object and, that's not possible without actually copying the whole string back into guest memory and. If you don't know the lens of your string. Then you need to link aloc or do some weird ha where you would only Lo some swice or something. So basically it's all kind of hey and just adding the conversion functions is a very quick fix for, that. So you can convert string into bites on the host side perform any of the operations, that are already available for bites. And then maybe either converted back or I don't depending on your logic. So yeah I think it was mostly design I don't think say great reason to not have it
00:15:00.000 --> 00:15:59.999 align:start position:0%
and also this has come up actually about a year ago for the at least once before like recently and again people are just confused why there is no conversion between bites and strings and well you can just add it it's a very simple change. So I guess, that's all I have to say for this CAP yeah so. If there are any questions again please let me know or please pause them in the respective GitHub discussion right so, that's it for me I don't know
00:16:00.000 --> 00:16:59.999 align:start position:0%
if someone wants to use this time for CAP 67 or not I don't know. But yeah, that's pretty much it for for me and. If no one else has any to about. Then you can call it Med e
00:17:00.000 --> 00:17:59.999 align:start position:0%
e
00:18:00.000 --> 00:18:59.999 align:start position:0%
e e
00:19:00.000 --> 00:19:59.999 align:start position:0%
okay it seems like no moment discussion for today and I guess, that's it for this meeting thank you everyone for attention
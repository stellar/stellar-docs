Okay, I'll get started. , hi everyone. Okay, I'll get started. , hi everyone. Today, , we are going to be talking Today, , we are going to be talking Today, , we are going to be talking. About CAP 75, which is a proposal to add about CAP 75, which is a proposal to add. About CAP 75, which is a proposal to add two new host functions to support two new host functions to support. Two new host functions to support Poseidon and Poseidon 2 head functions. Poseidon and Poseidon 2 head functions. Poseidon and Poseidon 2 head functions. , so the cap itself is fairly , so the cap itself is fairly , so the cap itself is fairly. Straightforward. , two new host straightforward. , two new host straightforward. , two new host. Functions. it it's pretty standalone functions. it it's pretty standalone functions. it it's pretty standalone. Doesn't involve any of the previous doesn't involve any of the previous doesn't involve any of the previous. Protocols mostly except using the protocols mostly except using the protocols mostly except using the. BLS and BN field. but I want to spend BLS and BN field. but I want to spend. BLS and BN field. but I want to spend a little bit time on the approaches that. A little bit time on the approaches that a little bit time on the approaches that. We decided on and the rationale behind we decided on and the rationale behind we decided on and the rationale behind. This approach. So first of all just a this approach. So first of all just a. This approach. So first of all just a quick introduction on on the quick introduction on on the. Quick introduction on on the motivation why do we want the Poseidon motivation why do we want the Poseidon. Motivation why do we want the Poseidon and Poseidon 2 hatches. so so and Poseidon 2 hatches. so so. And Poseidon 2 hatches. so so the Poseidon and Poseidon 2 they are the Poseidon and Poseidon 2 they are. The Poseidon and Poseidon 2 they are I'll call them Poseidon family. So they I'll call them Poseidon family. So they. I'll call them Poseidon family. So they are they are family of hashes basically are they are family of hashes basically. Are they are family of hashes basically it accept a range of parameters and then it accept a range of parameters and then. It accept a range of parameters and then you can configure it to to compute you can configure it to to compute. you can configure it to to compute output. So what it what it is is it's a output. So what it what it is is it's a. Output. So what it what it is is it's a sponge based sponge based sponge based hash function which means it consists. hash function which means it consists hash function which means it consists. Of a sponge of a sponge of a sponge that absorbs input and fit output that absorbs input and fit output. that absorbs input and fit output which is a variable length input various which is a variable length input various. Which is a variable length input various variable length output function and variable length output function and. Variable length output function and internally there's a permutation which internally there's a permutation which. Internally there's a permutation which is fixed input fixed output and the the is fixed input fixed output and the the. Is fixed input fixed output and the the reason that u it is useful along with reason that u it is useful along with. Reason that u it is useful along with Other catches of similar design is Other catches of similar design is. Other catches of similar design is that it directly operate natively on that it directly operate natively on. That it directly operate natively on the on the prime field. And as you can the on the prime field. And as you can. The on the prime field. And as you can as you know most of the zero as you know most of the zero. As you know most of the zero knowledge applications are built off knowledge applications are built off. Knowledge applications are built off of the prime field such as BRS or of the prime field such as BRS or. Of the prime field such as BRS or BM254 BM254 BM254 which makes Poseidon natively work . Which makes Poseidon natively work which makes Poseidon natively work . With with this field and they are ideal with with this field and they are ideal with with this field and they are ideal. In DK application. Just to give a rough in DK application. Just to give a rough in DK application. Just to give a rough. Idea, it the amount of constraints idea, it the amount of constraints . Idea, it the amount of constraints to generate using a regular hash like a to generate using a regular hash like a. To generate using a regular hash like a SH 256 versus Poseidon is two order of SH 256 versus Poseidon is two order of. SH 256 versus Poseidon is two order of magnitude difference. So it's a lot of magnitude difference. So it's a lot of. Magnitude difference. So it's a lot of proof side less proof side complexity proof side less proof side complexity. Proof side less proof side complexity and time to use Poseidon. And time to use Poseidon. And time to use Poseidon. So for for contrast so proof So for for contrast so proof So for for contrast so proof. Allocation typically don't involve allocation typically don't involve allocation typically don't involve. Rehashing or anything. but for rehashing or anything. but for rehashing or anything. but for. Contract implementing logic such as a contract implementing logic such as a. Contract implementing logic such as a mer tree that you want to generate proof. Mer tree that you want to generate proof mer tree that you want to generate proof. Of you want to have the same hash of you want to have the same hash of you want to have the same hash. Implementation implementation implementation between your contract and what you. between your contract and what you between your contract and what you use when you generate the proof for that. Use when you generate the proof for that use when you generate the proof for that. Mole tree. I think that's quite obvious. Mole tree. I think that's quite obvious. Mole tree. I think that's quite obvious. and to have the Prooseidon and to have the Prooseidon and to have the Prooseidon. Implemented on the on the gas side or implemented on the on the gas side or. Implemented on the on the gas side or or contrast side is quite expensive. Or contrast side is quite expensive. Or contrast side is quite expensive. Even with the functions that we already Even with the functions that we already Even with the functions that we already. Provide for BLS field arithmetics, provide for BLS field arithmetics,. Provide for BLS field arithmetics, there's still a lot of round trips there's still a lot of round trips. There's still a lot of round trips between converting a few element to between converting a few element to. Between converting a few element to bytes and and things like that. So bytes and and things like that. So . Bytes and and things like that. So that's why we we want to support that's why we we want to support. That's why we we want to support Prooseidon as native host functions. Prooseidon as native host functions. Prooseidon as native host functions. So just a recap of where we were last So just a recap of where we were last So just a recap of where we were last. Time. Last time we proposed a few time. Last time we proposed a few time. Last time we proposed a few . Three possible approaches to this. three possible approaches to this. . Three possible approaches to this. first is just to provide the hash first is just to provide the hash. First is just to provide the hash functions plain and simple. you functions plain and simple. you. Functions plain and simple. you know for different field you know for know for different field you know for. Know for different field you know for for different field combination of B for different field combination of B. For different field combination of B and BLS combination of PID and PIN 2 and and BLS combination of PID and PIN 2 and. And BLS combination of PID and PIN 2 and a combination of number of hash a combination of number of hash. A combination of number of hash input. So this gives us what like input. So this gives us what like. Input. So this gives us what like eight different type of host functions eight different type of host functions. Eight different type of host functions that will cover a lot of use cases. that will cover a lot of use cases. . That will cover a lot of use cases. but this approach isn't good because but this approach isn't good because. But this approach isn't good because we've from the feedback and from the we've from the feedback and from the. We've from the feedback and from the evidence that a lot of these hashes they evidence that a lot of these hashes they. Evidence that a lot of these hashes they require particular parameters these require particular parameters these. Require particular parameters these parameters are not set in stone. So parameters are not set in stone. So. Parameters are not set in stone. So different implementations could choose different implementations could choose. Different implementations could choose them differently. So even if we specify them differently. So even if we specify. Them differently. So even if we specify them in in the host for example them in in the host for example. Them in in the host for example someone else might need a different way someone else might need a different way. Someone else might need a different way to provide a parameter. So this way to provide a parameter. So this way. To provide a parameter. So this way isn't just provide a hash function isn't isn't just provide a hash function isn't. Isn't just provide a hash function isn't the most maintainable way and what the most maintainable way and what. The most maintainable way and what about providing more host functions for about providing more host functions for. About providing more host functions for those field arithmetics and also it those field arithmetics and also it. Those field arithmetics and also it wouldn't solve the problem because even wouldn't solve the problem because even. Wouldn't solve the problem because even if we provide things like matrix if we provide things like matrix. If we provide things like matrix multiplication the pose hashing involves multiplication the pose hashing involves. Multiplication the pose hashing involves a lot of rounds of permutation each a lot of rounds of permutation each. A lot of rounds of permutation each round is doing this multip round is doing this multip. Round is doing this multip multiplication so we still end up with a multiplication so we still end up with a. Multiplication so we still end up with a lot of these cause and a all of these lot of these cause and a all of these. Lot of these cause and a all of these round trips. so one of the proposals round trips. so one of the proposals. Round trips. so one of the proposals ended up last time was can we provide ended up last time was can we provide. Ended up last time was can we provide a more generic interface for the for a more generic interface for the for. A more generic interface for the for the sponge hash namely the to the sponge hash namely the to. The sponge hash namely the to absorb some input doing permutations and absorb some input doing permutations and. Absorb some input doing permutations and spit out the output and then be and let spit out the output and then be and let. Spit out the output and then be and let it be parameterized. It be parameterized. It be parameterized. So yeah so that's what we settled on So yeah so that's what we settled on So yeah so that's what we settled on. On last time and and yeah so now to on last time and and yeah so now to on last time and and yeah so now to. Transition to this cap. So this cap transition to this cap. So this cap transition to this cap. So this cap. Proposes a slightly different approach proposes a slightly different approach proposes a slightly different approach. which which I call approach four which which I call approach four which which I call approach four . That from the discussion thread for for that from the discussion thread for for that from the discussion thread for for. Anyone who's following. So approach four anyone who's following. So approach four. Anyone who's following. So approach four is instead of providing the launch is instead of providing the launch. Is instead of providing the launch interface we provide the internal interface we provide the internal. Interface we provide the internal permutation functions that the launch permutation functions that the launch. Permutation functions that the launch hash uses. so why why why is that? So hash uses. so why why why is that? So. Hash uses. so why why why is that? So so the the sponge is the sponge is a so the the sponge is the sponge is a. So the the sponge is the sponge is a it's sort of its own animal. It's a it's sort of its own animal. It's a. It's sort of its own animal. It's a different animal than the permutation. Different animal than the permutation. Different animal than the permutation. , sponge design had many different , sponge design had many different , sponge design had many different. Considerations considerations considerations for different applications. For for different applications. For. for different applications. For example, not only for hatching but also example, not only for hatching but also. Example, not only for hatching but also for like generating like a random for like generating like a random. For like generating like a random stream of bytes or or for MAC stream of bytes or or for MAC . Stream of bytes or or for MAC method message authentication code or method message authentication code or. Method message authentication code or for for random like for receable for for random like for receable. For for random like for receable random value generator like these random value generator like these. Random value generator like these applications are all u designed applications are all u designed. Applications are all u designed scope of a sponge. So the sponge needs scope of a sponge. So the sponge needs. Scope of a sponge. So the sponge needs to be more flexible. It needs to to be more flexible. It needs to . To be more flexible. It needs to maintain a state. It needs to in some maintain a state. It needs to in some. Maintain a state. It needs to in some some cases it requires switching between. Some cases it requires switching between some cases it requires switching between. Absorbing and squeezing and then absorbing and squeezing and then absorbing and squeezing and then. Switching back. So the sponge interface switching back. So the sponge interface switching back. So the sponge interface. Itself isn't itself isn't itself isn't it isn't a single definition that we can it isn't a single definition that we can. It isn't a single definition that we can just just take because and just just take because and. just just take because and itself is also has some some complexity itself is also has some some complexity. Itself is also has some some complexity in it. however the internally all the in it. however the internally all the. In it. however the internally all the sponge function they call the same sponge function they call the same. Sponge function they call the same permutation function. So after so in permutation function. So after so in. Permutation function. So after so in both stun absorb and squeeze the the both stun absorb and squeeze the the. Both stun absorb and squeeze the the input and output before it was the input input and output before it was the input. Input and output before it was the input is passed and then the permutation is is passed and then the permutation is. Is passed and then the permutation is applied and and the permutation is applied and and the permutation is. Applied and and the permutation is applied and the output is squeezed. So applied and the output is squeezed. So. Applied and the output is squeezed. So so at the center of it is just this so at the center of it is just this. So at the center of it is just this permutation function that takes a fixed permutation function that takes a fixed. Permutation function that takes a fixed length input and a fixed length output. Length input and a fixed length output. Length input and a fixed length output. So this is much more maintainable and So this is much more maintainable and. So this is much more maintainable and it's much more easy to support in it's much more easy to support in. It's much more easy to support in solarong without ramifications because solarong without ramifications because. Solarong without ramifications because it's just a simple cryptographic it's just a simple cryptographic. It's just a simple cryptographic building block and the sorbound host building block and the sorbound host. Building block and the sorbound host doesn't need to maintain any any state. Doesn't need to maintain any any state. Doesn't need to maintain any any state. so there's no like state related so there's no like state related so there's no like state related. Issues for like what if you make a issues for like what if you make a issues for like what if you make a. Subcontract call do they you know subcontract call do they you know subcontract call do they you know. Reinitialize a sponge and how to do reinitialize a sponge and how to do reinitialize a sponge and how to do. That. So, so by by supporting Prooseidon that. So, so by by supporting Prooseidon. That. So, so by by supporting Prooseidon permutation instead of the full permutation instead of the full. Permutation instead of the full Prooseidon hash it gives us a lot of Prooseidon hash it gives us a lot of. Prooseidon hash it gives us a lot of flexibility flexibility flexibility maintaining sort of host. Maintaining sort of host maintaining sort of host and also sponge itself for for a h for a. And also sponge itself for for a h for a and also sponge itself for for a h for a. Simple hash algorithm that's like a simple hash algorithm that's like a simple hash algorithm that's like a. Binary hashing binary hashing binary hashing of of a Merkel node for example isn't. Of of a Merkel node for example isn't of of a Merkel node for example isn't that complicated. is just basically it's. That complicated. is just basically it's that complicated. is just basically it's. Just a single round of taking the input just a single round of taking the input just a single round of taking the input. And applying the permutation and and applying the permutation and and applying the permutation and. Spitting out the output. I've written spitting out the output. I've written spitting out the output. I've written. Down a little pseudo code that basically down a little pseudo code that basically. Down a little pseudo code that basically is what it is in the cap. So, so just to. Is what it is in the cap. So, so just to is what it is in the cap. So, so just to. Recap, the sponge interface is recap, the sponge interface is recap, the sponge interface is. Complicated. it the the sponge is complicated. it the the sponge is complicated. it the the sponge is. Designed for many different use cases, designed for many different use cases, designed for many different use cases,. Not just hash. Not just hash. Not just hash. Even though for hash the sponge is Even though for hash the sponge is Even though for hash the sponge is. Really simple we don't want to just really simple we don't want to just really simple we don't want to just. Baking a simple sponge implementation baking a simple sponge implementation baking a simple sponge implementation. Inside host while this is much easier to inside host while this is much easier to. Inside host while this is much easier to do it in the contract or in the guest or. Do it in the contract or in the guest or do it in the contract or in the guest or. In the SDK in the SDK in the SDK but it is makes much more sense to to but it is makes much more sense to to. but it is makes much more sense to to support the primitive that's mostly the support the primitive that's mostly the. Support the primitive that's mostly the most expensive operations happen most expensive operations happen. Most expensive operations happen which is the permutation function which is the permutation function . Which is the permutation function inside the sort of host So that's the high level motivation and. So that's the high level motivation and now I can go through the actual two now I can go through the actual two. now I can go through the actual two functions being proposed. one is a functions being proposed. one is a. Functions being proposed. one is a Prooseidon permutation and second one is Prooseidon permutation and second one is. Prooseidon permutation and second one is Prooseidon 2 permutation. the two Prooseidon 2 permutation. the two. Prooseidon 2 permutation. the two look fairly fairly similar. So so look fairly fairly similar. So so. Look fairly fairly similar. So so just a bit of background Prooseidon is just a bit of background Prooseidon is. Just a bit of background Prooseidon is the original version developed in 20 the original version developed in 20. The original version developed in 20 2019. Poseidon 2 is a a improved 2019. Poseidon 2 is a a improved. 2019. Poseidon 2 is a a improved version of that developed in 2023. version of that developed in 2023. . Version of that developed in 2023. internally they they work slightly internally they they work slightly. Internally they they work slightly different. Poseidon 2 has u improved the different. Poseidon 2 has u improved the. Different. Poseidon 2 has u improved the internal matrix shapes and then add internal matrix shapes and then add. Internal matrix shapes and then add pre relication add add a single pre relication add add a single. pre relication add add a single layer of pre-apply but overall it works layer of pre-apply but overall it works. Layer of pre-apply but overall it works fairly similar. so I'll just cover fairly similar. so I'll just cover. Fairly similar. so I'll just cover the Poseidon one. the Poseidon one. the Poseidon one. . So the process permutation takes the so the process permutation takes the so the process permutation takes the. Input which is a vector object that is input which is a vector object that is input which is a vector object that is. Your vector of field element and then your vector of field element and then. Your vector of field element and then the second thing is the field type. the second thing is the field type. . The second thing is the field type. so I think it probably makes sense to so I think it probably makes sense to. So I think it probably makes sense to have field type as a symbol but in the have field type as a symbol but in the. Have field type as a symbol but in the cap I I'm putting U32 should be cap I I'm putting U32 should be. Cap I I'm putting U32 should be equivalent but yeah field basically is a equivalent but yeah field basically is a. Equivalent but yeah field basically is a enum that specify which field you you. Enum that specify which field you you enum that specify which field you you. Want your permutation function to be want your permutation function to be want your permutation function to be. Defined on and of course your input will defined on and of course your input will. Defined on and of course your input will be passed in the same field as the be passed in the same field as the. Be passed in the same field as the permutation permutation permutation matrix and all that. , and the rest. matrix and all that. , and the rest matrix and all that. , and the rest. Of it is just internal parameters for of it is just internal parameters for of it is just internal parameters for. The for the hat functions. , so that's the for the hat functions. , so that's. The for the hat functions. , so that's pretty much it. , but I'll just spend pretty much it. , but I'll just spend. Pretty much it. , but I'll just spend maybe a few a couple minutes just maybe a few a couple minutes just. Maybe a few a couple minutes just explaining what these fields are. , t explaining what these fields are. , t. Explaining what these fields are. , t is the capacity parameter. So it's the is the capacity parameter. So it's the. Is the capacity parameter. So it's the capacity the internal sorry not the capacity the internal sorry not the. capacity the internal sorry not the capacity but the internal state size. Capacity but the internal state size. Capacity but the internal state size. The internal state side much must match The internal state side much must match The internal state side much must match. The input and also must match the the input and also must match the the input and also must match the. Size of internal matrix. It is size of internal matrix. It is size of internal matrix. It is. Decomposed of the rate which is number decomposed of the rate which is number decomposed of the rate which is number. Of you can think of as number of input of you can think of as number of input of you can think of as number of input. You need to hatch at once plus some you need to hatch at once plus some you need to hatch at once plus some. Capacity which gives you additional capacity which gives you additional capacity which gives you additional. Security parameters. d is the degree security parameters. d is the degree security parameters. d is the degree. Of the the fbark which is the of the the fbark which is the of the the fbark which is the . Internal internal internal one of the internal step in the one of the internal step in the. One of the internal step in the permutation before applying the matrix permutation before applying the matrix. Permutation before applying the matrix multiplication. So for bn and bs both multiplication. So for bn and bs both. Multiplication. So for bn and bs both both fields d is equal to five. So we both fields d is equal to five. So we. Both fields d is equal to five. So we may we may just only accept the equals 5. May we may just only accept the equals 5 may we may just only accept the equals 5. U but of course for other field in the u but of course for other field in the u but of course for other field in the. Future could be different. the round future could be different. the round future could be different. the round. F round t these are the internal partial f round t these are the internal partial. F round t these are the internal partial round and the for round these are the round and the for round these are the. Round and the for round these are the number of round the matrix number of round the matrix. Number of round the matrix multiplication happens so the yeah multiplication happens so the yeah. Multiplication happens so the yeah so the there's also a linear layer so the there's also a linear layer. so the there's also a linear layer which is u sorry the the linear layer is which is u sorry the the linear layer is. Which is u sorry the the linear layer is a run the mod matrix multiplication a run the mod matrix multiplication. A run the mod matrix multiplication but the nonlinearity is provided by the but the nonlinearity is provided by the. But the nonlinearity is provided by the run constants which is also matrix but run constants which is also matrix but. Run constants which is also matrix but specified for each run. So the so the MD specified for each run. So the so the MD. Specified for each run. So the so the MD MDS matrix for hash two function is MDS matrix for hash two function is. MDS matrix for hash two function is 3x3 run constant is a is another 3x3 run constant is a is another. 3x3 run constant is a is another matrix with dimension n by m where n is matrix with dimension n by m where n is. Matrix with dimension n by m where n is the number of run and m is three. The number of run and m is three. The number of run and m is three. So that's a high high level run through So that's a high high level run through So that's a high high level run through. Of the different parameters. the of the different parameters. the of the different parameters. the. Second one is fairly similar. The only second one is fairly similar. The only second one is fairly similar. The only. Difference is that the internal MDS difference is that the internal MDS difference is that the internal MDS. Matrix in the second version is a matrix in the second version is a matrix in the second version is a. Diagonal matrix because of the diagonal matrix because of the diagonal matrix because of the. Precision 2 improvement precision 2 improvement precision 2 improvement in terms of cost type. In terms of cost type. In terms of cost type. So we so we manage I think we we can So we so we manage I think we we can So we so we manage I think we we can. Manage to ship this as a native solar manage to ship this as a native solar. Manage to ship this as a native solar bond library which means that all of the. Bond library which means that all of the bond library which means that all of the. Operations they are already existing operations they are already existing operations they are already existing. And were defined. These include the and were defined. These include the and were defined. These include the. Field arithmetic for adding and the field arithmetic for adding and the field arithmetic for adding and the. Multiplication and things like that. So multiplication and things like that. So multiplication and things like that. So. There's no particular peridon specific there's no particular peridon specific there's no particular peridon specific. Metering parameters we need to support metering parameters we need to support metering parameters we need to support. But we do have to add these ban 254 but we do have to add these ban 254 but we do have to add these ban 254. Field u arithmetic cost types which field u arithmetic cost types which field u arithmetic cost types which. Is a very opportune timing because we is a very opportune timing because we is a very opportune timing because we. Have the cap 74 which has b24 have the cap 74 which has b24 have the cap 74 which has b24. scala field and pairing. scala field and pairing. scala field and pairing. So  I went through the parameters  I went through the parameters metering. Metering metering rationale. Yes. So that the rationale rationale. Yes. So that the rationale. Rationale. Yes. So that the rationale why hash function why we don't why hash function why we don't. Why hash function why we don't provide a hash function out of box provide a hash function out of box. Provide a hash function out of box rather than providing the permutation rather than providing the permutation. Rather than providing the permutation primitive. It is explained primitive. It is explained. Primitive. It is explained and yeah just to also mention these and yeah just to also mention these. And yeah just to also mention these parameters they are parameters they are parameters they are. So so so yeah so so some of them they are they yeah so so some of them they are they. Yeah so so some of them they are they are kind of defined based on the are kind of defined based on the. Are kind of defined based on the application like if you have a curve of application like if you have a curve of. Application like if you have a curve of if you want to do hashing with BN25 if you want to do hashing with BN25 . If you want to do hashing with BN25 254 then the degree is five you can 254 then the degree is five you can. 254 then the degree is five you can change that and then the sum of them is change that and then the sum of them is. Change that and then the sum of them is depend on the actual application depend on the actual application . Depend on the actual application which is how many inputs you want to which is how many inputs you want to. Which is how many inputs you want to hash at once and then based on the size hash at once and then based on the size. Hash at once and then based on the size of the input these parameters like t of the input these parameters like t. Of the input these parameters like t and then the number of runs they need to and then the number of runs they need to. And then the number of runs they need to be adjusted the original procidum be adjusted the original procidum. Be adjusted the original procidum paper provides scripts and guidelines paper provides scripts and guidelines. Paper provides scripts and guidelines for how to generate these parameters for how to generate these parameters . For how to generate these parameters in general I think most in general I think most. In general I think most applications have their own applications have their own. Applications have their own they they have they use a a set of they they have they use a a set of. they they have they use a a set of generated parameters like CIRCOM does generated parameters like CIRCOM does. Generated parameters like CIRCOM does and Noel does and to provide the maximum and Noel does and to provide the maximum. And Noel does and to provide the maximum like safetiness we would have like safetiness we would have. like safetiness we would have these as part of preset in the SDK. These as part of preset in the SDK. These as part of preset in the SDK. So like the SDK SDK interface will look So like the SDK SDK interface will look So like the SDK SDK interface will look. Exactly just like a hash two that takes exactly just like a hash two that takes exactly just like a hash two that takes. Two input and then internally you may be two input and then internally you may be. Two input and then internally you may be able to specify the set of parameter able to specify the set of parameter. Able to specify the set of parameter like a circum parameter or or neural like a circum parameter or or neural. Like a circum parameter or or neural parameter things like that and then we parameter things like that and then we. Parameter things like that and then we we also possibly expose these we also possibly expose these. We also possibly expose these Poseidon permutation as a as a more like Poseidon permutation as a as a more like. Poseidon permutation as a as a more like a hazmat interface something that a hazmat interface something that. A hazmat interface something that advanced users that know what they're advanced users that know what they're. Advanced users that know what they're doing can can call with their own doing can can call with their own. Doing can can call with their own parameters but we we will make them parameters but we we will make them . Parameters but we we will make them the distinction more clear. Yeah. In terms of testing there's a Yeah. In terms of testing there's a reference implementation for Prooseidon. Reference implementation for Prooseidon reference implementation for Prooseidon and so Horizon lab has a reference. And so Horizon lab has a reference and so Horizon lab has a reference imitation for Poseidon 2 and in the same. Imitation for Poseidon 2 and in the same imitation for Poseidon 2 and in the same. Repo has Poseidon one. That's the one we repo has Poseidon one. That's the one we. Repo has Poseidon one. That's the one we likely going to adopt. And it also likely going to adopt. And it also. Likely going to adopt. And it also provides test vectors for both one and provides test vectors for both one and. Provides test vectors for both one and two in different fields and parameter. Two in different fields and parameter. Two in different fields and parameter. And then there's also the original And then there's also the original And then there's also the original. Prooseidon paper that come with a a Prooseidon paper that come with a a Prooseidon paper that come with a a. Sage script implementation with some sage script implementation with some sage script implementation with some. Reference vectors which we will also reference vectors which we will also reference vectors which we will also. Match our implementation with in our match our implementation with in our match our implementation with in our. Tests. Tests. Tests. There's a draft implementation and I There's a draft implementation and I There's a draft implementation and I. Think that's it. Think that's it. Think that's it. Now four is open for questions. Yeah. So I did a very rough well I Yeah. So I did a very rough well I wouldn't say too rough but like the. Wouldn't say too rough but like the wouldn't say too rough but like the implementation is fairly. Implementation is fairly implementation is fairly mostly good and then the the field for. Mostly good and then the the field for mostly good and then the the field for BRS is already there. So I did a . BRS is already there. So I did a BRS is already there. So I did a number on on the on the reference test. Number on on the on the reference test number on on the on the reference test cases for BLS . Cases for BLS cases for BLS the 3x3 matrix case which is the hash the 3x3 matrix case which is the hash. The 3x3 matrix case which is the hash two operation that's about half a two operation that's about half a. Two operation that's about half a million CPU instruction. So it's a lot a million CPU instruction. So it's a lot a. Million CPU instruction. So it's a lot a lot better than what I projected last lot better than what I projected last. Lot better than what I projected last time. And then the 5x5 matrix case I time. And then the 5x5 matrix case I. Time. And then the 5x5 matrix case I believe that's like cache three input believe that's like cache three input. Believe that's like cache three input that's around 1 million CPU. That's around 1 million CPU. That's around 1 million CPU. So yeah that's well below our target So yeah that's well below our target So yeah that's well below our target. Ceiling which we want to support around ceiling which we want to support around ceiling which we want to support around. 20 hash cores in a single contract. Oh, okay. You want me to close it? Okay. Oh, okay. You want me to close it? Okay. Bye, everyone.

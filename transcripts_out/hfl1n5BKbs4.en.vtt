WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:59.999 align:start position:0%
Hello everyone and welcome to this week's Stellar Developer Meeting today we have the team from blend joining us for a code walkr in support of their exciting news security Initiative for the Stell ecosystem I'm Carson as usual from the SDF Dev team and and Alex will join us from script 3 and amen from Satur to set the stage here blend is getting ready to launch their blend V2 and in preparation for, that they're opening up, that code and for groundbreaking groundbreaking $125,000 in usdc competition focused on securing lend V2 through both a competitive auditing and a formal verification this is the first ever open competition competitive audit and formal verification competition within the
00:01:00.000 --> 00:01:59.999 align:start position:0%
Stellar ecosystem. So it's an amazing opportunity for Stellar devs to try their hand on competing to find bugs and write formal verification rules I just get more familiar with blend in general. So I'll post a link to how to sign up for the competition started this Monday. So it is open. But let me. Now introduce Alex hello thanks for having me welcome Alex do you just let me know. When I am ready to get running go ahead you are all right perfect your screen all right thank you so yeah I am Alex you might see me online as mots2 and I'm the lead developer at script 3 and we developed blend, which is a universal liquidity protocol primitive just a quick overview what we're going to run through we might go a wee bit fast. Because there's a lot of stuff to cover. But I'll give you guys a quick for those who aren't familiar just a quick
00:02:00.000 --> 00:02:59.999 align:start position:0%
breakdown of what blend is how the actual contracts all work together. And then I'll run into the code and kind of the main thing I'll try and focus on for those doing the auto competition is really going to be how we test blend and specifically. If there is some kind of bug or thing you found within blend V2 kind of some tips and tricks on how you it might be a bit easier to prove, that something is in fact wrong. So yeah blend is a universal liquidity protocol primitive and what does, that mean basically blend is a tool, that allows you know companies people who are crypto natives really any entity, that wants a lending Market to actually go ahead and have one. So lending markets the crypto are just places where people can land in BIO assets from each other and one thing, that blend does is blend basically comes with an automatic back stop module, which acts as Insurance bad debt protection and also scam protection and and these
00:03:00.000 --> 00:03:59.999 align:start position:0%
things these are funded by anyone and kind of the way this all works together is the pool will give some portion of the interest it generates out to the back stop module such, that it can provide, that that layer of insurance for the protocol, that's just a really brief intro as to what blend does I want to touch on first actually how the contracts all work together since been looking at this from a security perspective knowing how the main components of blend interact is pretty vitol. So kind of the really like Cornerstone part of blend is the emitter contract this doesn't have very many responsibilities it's core one is going to roughly Define the admin protocol token in this case is blend secondly it's responsible for defining the back stop module. is like I said earlier the contract, that basically holds all of the insurance funds for the blend pools insurance
00:04:00.000 --> 00:04:59.999 align:start position:0%
in this case are going to be blend usdc LP tokens. So there is a common AMM it's for those familiar with EVM it's basically balancer. But it's just an LP token for blend usdc its main responsibility is it actually controls the state of the pool so. If you have a lending market and there's a back stop module actually has the ability to turn the pool on and off. So for example. If something happens to a pool or it gets exploited some Oracle goes wrong the back stop module actually has the ability to disable borrowing for the pool secondly it's also the first less capital in the event of any bad debt and those, that might not know bad debt is basically the case where a user has liabilities and they have no collateral to cover it. So the protocol has to take a loss on, that debt secondly it also manages the blend emissions. So the protocol basically starting from the emitter blend tokens
00:05:00.000 --> 00:05:59.999 align:start position:0%
will get sent to the back stop module and it's the back stop module's responsibility to send it to all of the pools within the blend ecosystem within the backstop module it also defines a pool Factory this thing drops pretty simple it's a contract, that contains a pool wasum and for any pool, that's created this is the thing, that validates, that this is in fact a blend pool and it is the exact contract, that we expect to be deployed. And then the meat and potatoes of the protocol is going to be the actual pool this is kind of the sort of a part of the whole protocol it is the place where people can go and lend and borrow reserves. So there's tons of different ways you can set things up. But this is kind of the place where all the lending and borrowing occurs and kind of where most user interaction will end up taking place. So I know, that was really fast
00:06:00.000 --> 00:06:59.999 align:start position:0%
but hopefully is this is being recorded right Caren I think it is I'll take, that as a yes y it's recorded perfect. So yeah we can go probably go back and watch, that over. If anything was missed and I'm also available on Discord. If you want to ask further questions. But we will jump to the actual codes since, that's probably what a lot of you all are interested in. So I'll give a quick breakdown of how contracts actually exist in soron. And then we can start trying to dig through some of how this how our codes actually tested. So for those, that aren't familiar The Way We have set up our soron repository is you'll notice, that all of the core contracts, that I talked about earlier are located within their own folder. So for example all the code for the back stops within the back stop folder pool within the pool pool Factory Etc
00:07:00.000 --> 00:07:59.999 align:start position:0%
Etc each contract has a contract. RS file this is really the entry point and interaction point for the contract. So you'll you you'll notice, that in soran there are these macros contract contract client these are really the things, that defined how users actually can call into the contract. So anything, that's public facing is part of this trait and will be implemented for the back stop contract stru this is also the location where where we probably have all of the most user-facing documentation for each of the functions so. If you're ever curious about what's available on a contract what the arguments mean this file will be the place where they're documented. So yeah and there's also a contract implementation macro. So this will be the place where a a Constructor is defined. So this is basically called. When the contract's first deployed and can never be invoked again and there's also the
00:08:00.000 --> 00:08:59.999 align:start position:0%
back stop trait implementation for the contract and this is where all of our code is basically getting defined. So everything in here is exposed for anyone on the blockchain to interact with the way we structured things is we generally do all of the authentication, that's required to use the contract here. And then we actually perform all of the logic in a second helper function so, that we can better unit test the code as a whole. So you'll notice. If you're ever looking for authentication things you you'll notice, that all of the O actually takes place here. If you are from the EVM world o how Soroban does o is probably one of the largest differences between the two blockchains. So it is worth looking into it's it's incredibly well documented on sorond Sor bonds documentation. So I would highly recommend reading through how, that works. So you and
00:09:00.000 --> 00:09:59.999 align:start position:0%
then you'll also notice, that for example. If I go to where we actually Define the logic this is pretty common throughout all of our contracts. So we we we'll basically try and wrap all all of the logic, that's external to authentication and stuff within a function and we actually go through in write unit tests specifically for those functions. So this is a pretty good place to look. If you think something might be incorrect or wrong or a bug exists somewhere this is probably one of the easiest places to start testing, that and attempting to find whether or not something's wrong and you you'll often find, that this is like kind of where most of our unit tests actually occur secondly one thing, that we do include within this blend contracts repository is there's mock contracts and there's also a test Suites folder. So one thing, that's really nice about interacting with soron is as I'm using tests you'll notice I have rust analyzer installed on
00:10:00.000 --> 00:10:59.999 align:start position:0%
my fsco. But you you you have the ability to step through debug so. If you're ever curious about what actual values are within a function you're you can use all the rust internal tools to step through and actually debug it. If you're like most developers in the world you're just going to add a whole bunch of print lines. And then run the test, that also works fantastic too. But it's it's really nice for example. If you do think something's wrong make sure to use the rust tools and use use all the debugging tools to your advantage we've been able to find a lot of things internally using those those strategies. But one really important thing I wanted to touch on especially for L contracts is we have this giant test Suites folder we use a lot of this for all of the integration testing. So for example there is a test fixture this basically just contains a whole it's it's basically going to deploy from a fresh environment a whole bunch of contracts and things, that exist
00:11:00.000 --> 00:11:59.999 align:start position:0%
to basically support a pretty standard blend pool. So you'll notice it's going to make tokens it adds a whole bunch of users it deploys all the contracts out for you and you can basically. Then start from a really good starting point to actually write an integration level test one quick thing to note here is, that. If you ever see an our test the user Bombadil I'm a bit of a Lord of the Rings nerd. So he is the admin and ruler of everything. So he has the power to basically mint tokens at will he's kind of the admin the super key for roughly all of our tests as well. But how this is actually implemented you'll actually notice. If you look back at some of our older audits we've written integration tests after after basically fixing issues, that have been found one of these was an inflation attack, that I believe C Tor found in the first audit. But for example this kind of walks you through a really good way
00:12:00.000 --> 00:12:59.999 align:start position:0%
if you think something does exist, that might have an issue writing one of these level tests is a really really good way to actually prove whether or not it exists since this kind of is what at at this level of test this really is the place where you're going to have the same level of interaction, that someone using the blockchain would. Then yeah maybe the last thing to note before I switch over to the fev VA here is you'll notice on the test test fixture. When you cre the test picture there's a true false just. So it's clear you have the ability. When running rust integration tests to actually deploy the contracts and use WMS so. If you want to use the actual wasm files, that are being deployed, that's great we do, that in plenty of tests but. If you do, that rust itself won't actually be able to debug the code within the wasin packages so. If you're expecting some of the prit lines or line by line de debugging to
00:13:00.000 --> 00:13:59.999 align:start position:0%
work you will need to deploy all of the contracts as rust crates, that way you can use all the unit testing tools. So yeah, that's probably all I'm going to touch on here again within test Suites and test this is tons of really good examples on setting up all different kinds of environments. If you want to go through and attempt to prove, that something is incorrect lastly I'm going to also run through the Fe Vault contract this this is basically a add-on contract, that's aimed at wallets, that will allow users to specify either a fixed rate of return or excuse me a CAP rate of return. So for example. If a wallet wanted to offer say 10% on usdc deposits using blend they can deploy one of these Fe volts. If the blend pools returning more than 10% they would keep, that extra
00:14:00.000 --> 00:14:59.999 align:start position:0%
say it's returning 15% they would keep 5% 10% would go to the users or they can just take a fixed interest take off of all of the interest generated for deposits through this Fe volt. So it it works pretty similar similarly to any er ERC 4626 function or 4626 Vault token. So those, that are familiar or I've looked at those those kinds of protocols in the past this should feel somewhat familiar to you I did want to call out one thing you'll also notice some of the implementation patterns we use in blend also come over here. So the only thing, that's maybe a bit different is this contracts a bit simpler. So you you'll notice we've kind of there's probably one less layer of abstraction there for you to have to deal with most things are documented pretty well in code but. If you find anything please please feel free to call it out you'll notice, that in the test
00:15:00.000 --> 00:15:59.999 align:start position:0%
here it's set up a bit differently. So for example this is a very long test. But we we we mainly are testing the fee VA through integration testing since the contct is a bit similar simpler and it relies heavily on the blend contracts themselves. So you'll notice, that we we support a blend rust crate, that includes all of the blend contracts themselves this has been updated for the exact hash, that was pushed for the Auto competition. So you'll notice, that I believe yeah the version is here. But this comes with a very similar deployment script as the one we use within the blend contracts repository for their integration test. So let's see. If yeah there's a blend flixer deploy function, that will actually go ahead and create all of the
00:16:00.000 --> 00:16:59.999 align:start position:0%
blend contracts needed to interact with a very similar setup as to what blend view1 main it is so. If you do run into anything with the F VA this is kind of a great place to look to go ahead and try and prove, that something INF fact is missing or has a bug. So yeah, that's probably all I wanted to touch on I wanted to make sure I left a little bit of time for Sor to go through the formal verification portion of the auto competition. But I'll probably leave it there unless there's anything else you want me to touch on Carson great let's let's wait and see. If there's any questions at the end. But thank you for the presentation I'm going to invite Shandon Armen on the stage welcome both of you you hi Armen are you there okay yep hello you have my screen
00:17:00.000 --> 00:17:59.999 align:start position:0%
so this is the contest repo. So trra you can let me know yeah we should walk over sure yeah you can share and I'll I'll just go over it. So as Alex mentioned in his presentation before you know we are doing this audit and formal verification contest for blend and. While the audit itself you can you know all all of the prog the code bases in scope for the verification part we have a smaller scope. Because the the protocol is there's a lot of code. And so we decided, that it would be more tractable and manageable. If we tried to focus on one particular part and in particular we are looking at the back stop crate so. If you go up a little bit in this repository. So for what it's worth this is the repository where all the code is. So you can clone this repository. And then you can check out all the different crates and
00:18:00.000 --> 00:18:59.999 align:start position:0%
in particular the one, that we are talking about is the back stop as you can see Armen has it here and I want to show the Sora specific stuff. So first of all the the the properties, that you're going to be writing are going to be in the seras specs directory where Armen is right. Now I think I have a couple of little. So well. Now can you go maybe look at some of the other files there's a few, that I provided just for an example yeah. So here's a few examples of things, that you just to give you an idea for what these look like. And so you can notice here, that there is this thing called cvlr uncore assert in all the rules. And so the things, that are so, that's one thing I want to talk about a little bit so. If you look at line number five this is the we we call it Cavalier. So cavaliere is the specification language, that we've built it's just a rust Library. So you can import the library. And then you can use the various
00:19:00.000 --> 00:19:59.999 align:start position:0%
assertions and there, which are just macros, that we've defined. So assume assert and satisfy I think are probably the most common ones and the ones, that are I think we recommend using the most. If you need something more specific. Then you can always reach out and we can help you figure out how to do, that the other thing worth noting here is can you can Arman can you go down to the the cargo Tomo file at the bottom yes. So we are also relying on rust features. So for example here you can see on line 17 there's this feature called called Cur and the nice thing about this this mechanism is it actually lets you use this feature to selectively compile the code. So for example you can. If you go back Armen to let's
00:20:00.000 --> 00:20:59.999 align:start position:0%
see let's go in the back stop yeah and maybe in the withdrawal maybe go to deposit actually okay perfect so. If you look at the top of this file you'll see, that we are using this feature called sora and essentially what this is saying is, that. When the feature is enabled and I just showed you before, that in the cargo TL it is enabled. Then use this mock implementation of the token client and otherwise you can use the whatever default one, that blend was using and this is just for verification only right so. When you're compiling your code for other purposes. Then you shouldn't be using this but. When you're doing verification this is helpful. Because a lot of the times we want to modularize things. And so you may not need to include all the code for the token. When you're really just verifying the code for the back stop right so, that's an interesting feature, that I think you'll probably use quite a bit and you know always feel free to reach out on
00:21:00.000 --> 00:21:59.999 align:start position:0%
Discord. If you have any questions the other thing I also want to highlight is the con files. So on the left you will see, that there is this directory called conss and here we have provided some setup and some skeleton for some basic conss. So let's look at the one yeah the withdraw one is a good one. So what's happening here is we have this file, that has a a build script this is already provided you probably should not have to modify this at all it's just a python script, that does a bunch of stuff, that is necessary for making sure, that the reports look nice you know you have all the files uploaded there it calls the right build instruction in this case we're using this file called this build system called just. But other than you should not have to modify, that more or less. Then there's a few verification specific things. So for example there's this thing called we have this slide called optimistic Loop we we don't need to worry
00:22:00.000 --> 00:22:59.999 align:start position:0%
about what, that is I would leave, that there there's also this precise bitwise Ops flag, which is set to True what this is saying is, that. When you're doing the verification use bit vectors you may or may not want it it's you can. If you're facing like slow running times I recommend taking it out and seeing what happens and again. If you run into any issues. When you take it out you can reach out and we'll try to help you. And then really the main thing you will have to modify is this rules field. So whatever rules you write you just have to add them to this file. And then you just run this San with this configuration file I one thing I would recommend. So it is very common for users to run the prover with many ruls and, that is what you will do in the end but. When you're debugging and. When you're just you know trying to test things out it is often helpful to just
00:23:00.000 --> 00:23:59.999 align:start position:0%
run one rule at a time. So you know, which rule is problematic or you know, which has a Vu problem or all kinds of stuff right. So definitely keep, that in mind. When you're just getting started and you know writing these as as I can tell you there's a lot of excitement already on Discord lots of people have been asking lots of questions really good questions. So it's already really nice to see the the engagement from the the community so, that's, that's really cool. So I think let me just think what else I would like to show actually yes can you Armen. If you click on the documentation page, that you have open. So yeah here we have some documentation for using Sunbeam. So there's the installation guide, which I think you probably don't need to worry too much about. If you. If you have installed ctra CLI you should be good to go. So I don't think you need anything else. So the user guide is the main thing you know we have some examples of you know what the
00:24:00.000 --> 00:24:59.999 align:start position:0%
different components are. So for example here you know you see this like hash rule thing on top of these functions. So really what's Happening Here is you're just writing rust functions right. So Cura is like interpreting those functions separately especially for verification. But from your point of view you're just writing rust functions with special macros and special annotation so, that's one of the annotations is this rule attribute and I already mentioned the CVL assume assert macros from the Cavalier spec Library another thing, that is very useful is this notion of non-determinism. So oftentimes what happens is. When you're doing verification you might want to sort of summarize some piece of code. Because you know maybe, that's not super relevant for the property you're verifying and all you care about is, that that function returns some
00:25:00.000 --> 00:25:59.999 align:start position:0%
non-deterministic value right it could be a u64 it could be i1 128 whatever it could be a user defined type all kinds of Stu. So this nonb gives you a mechanism to do, that. So Cavalier actually already implements a bunch of non-ets for various primitive types blend has a lot of userdefined structs right. So for example there's the Q4 Q4 withdrawal struct you might want to implement, that trade for this this truck right. So you can do it this way. So right like as there's an example here. So essentially all you do is you know you assign non- debt to all the fields of the struct and you're good to go. So this is something, that's really helpful for for verification we often have to do it and I'm imagining other people will have to do this as well we have some very basic examples in the tutorial. So we have a Sunbeam tutorial over over here it gives an example of the token
00:26:00.000 --> 00:26:59.999 align:start position:0%
contract so. If you've never done verification I think this is a good way to start you can just do the exercises here and you know just try to understand like what what's really happening. When you run the tool. And so so on and other than, that. If you go back I think I already explained the scripts the build script stuff. If you scroll down a little bit more Armen yeah I think they these are already covered say. So I think the main other thing I would recommend looking at is what happens. When you do run Sunbeam. So as I mentioned before and it's actually also listed in the readme for the the repo all you do is you just run Cur San proofer and you pass this Con file and you you run it and all you get is a link to a run right and this link is going to look something like this right. So here you can see well. So here there is no violation. So you're fine. But
00:27:00.000 --> 00:27:59.999 align:start position:0%
if there is a violation you can see a call Trace the call Trace is not super easy to read so. If you are stuck with problems with the call Trace please post messages on Discord and we'll try to help you as much as possible you can also see the code right. So for example here on the left you have this files you can see all the files, that you used to run verification all the properties, that you ran all the code, that you changed or properties you wrote everything is here. So and I would always encourage you to. If you are having any problems you can just send me a link to a run. And then I can take a look at the run I can reproduce the Run locally and and help you debug your problems problems other than, that I'm not thinking what else would be useful I think about, that's, that might be all I have like oh actually I would like to mention one other thing. So we already saw the feature CRA
00:28:00.000 --> 00:28:59.999 align:start position:0%
feature of mechanism where you can selectively decide what functions to include. When you're compiling we also saw the non-dead macro another thing, that you may have to do is summarize various functions. So this is something, that you know for example here the way the best way to do this is the following right. So in the C specs directory you there is a directory called summaries and in there you can. So the mod is, that's where you just expose all the summaries, that you have written. So here there's you know this file called emissions and in emissions it's possible, that depending on the property you're proving you might have to summarize right. So for example you can say, that I don't really care what emissions does as long as it's returning a Nonet terministic value or you can, that well it should be a nondeterministic value. But maybe it should be in some range. So this kind of stuff right like it really depends on
00:29:00.000 --> 00:29:59.999 align:start position:0%
your understanding of protocol and like what you think is necessary for whoever is calling this function to know about this function Behavior right. So this is actually often very helpful. So you can put all your summaries here. And then wherever you're calling the function instead of calling the original function you just call this function and it would be really good. If you actually annotate it with this. Because then you know you're not really changing the semantics of the original program great I think we need to wrap it up here. But thank you so much for for this presentation I think this was very helpful for everyone who's going to participate in the competition to get to walk through both of the code and and the verification here. So thank you all for joining I didn't see any questions in the chat. But yeah feel free to reach out also in Discord. If there's anything I'll post the link again in Discord for the competition. So good luck to everyone
00:30:00.000 --> 00:30:59.999 align:start position:0%
the competition is running until March 17th. So still have plenty of time to to dig into it thank you everyone for joining thank you Shandra and Alex for for joining here us thank you everyone thanks everybody
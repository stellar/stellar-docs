hello everyone and welcome to the open
protocol meeting obviously it is the
first time we're doing it in this
discord channel but
most the conversation around Stellar
development has moved to discord and so
it makes sense to kind of put it all in
one place most of the jump cannon
work in fact all of it is really being
done in the open here on the jump cannon
channel and on the jump cannon dev
channel so anyone who's interested in
seeing us work to bring smart contracts
to Stellar can you know join in that in
that discussion so
today the these meetings these protocol
meetings are are here to discuss and
plan for actual changes to the Stellar
protocol and we are focused on project
jump cannon at this point and on which
will bring smart contracts to Stellar
and we're talking here about the
protocol changes that are necessary in
order to accommodate it
to tackle jump cannon we actually
decided to break up the suggested
protocol changes into a suite of core
advancement proposals and at this point
they're actually four different caps
that are linked to three of which are
linked to in the media invite one that
just came in under the wire but it's cap
49 so those caps are cap 46 the
webassembly smart contract runtime
environment which is what we discussed
last meeting and it's basically a
building block that establishes a
vocabulary that we can use to talk about
wasm-based smart contract environments

47 the smart contract life cycle defines
the structure of smart contracts on
Stellar and specifies how users can
create update and remove them
then cap 48 and cap 49
I think our two approaches to deal with
smart contract asset interoperability
and so this meeting is being
is like anyone can sort of watch it
now

i
believe david has a sdf role so
but we are also archiving this and and
posting it on youtube so that people who
can't be in the discord channel who want
to watch the protocol meeting can watch
it later
so with that said you know we're talking
about smart contracts I believe that the
first place the first set of issues that
is probably worth talking about relate
to
your caps john cap 48 and cat 49
deal with
interoperability
so I feel like there are some questions
that are that are open that we might
want to
it's probably useful to talk about now
but john do you want to sort of give an
overview of where we are with those two
caps and then we can take it from there
sorry first time
first I'm doing like a video call on
discard I'm still getting a little
oriented

let me pull up the relevant documents
give me one moment
and then I will give a little intro
okay I'm ready sorry about that
so basically
these two proposals

they
relate to just one very simple question
or simple sounding question which is
yes exactly but some error cuts on that
which is we have some classic assets
some of which have like you know
substantial value sitting beneath them
and we'd like to be able to use those
immediately as soon as you know we
deploy
jump can and smart contracts
on the public network without
and
the the kind of
framework here is like well ideally we
can use them
without anybody doing anything they just
kind of work like magic
so there's a couple
of things that go into that one thing
we'd like is for them to be pretty fast
tokens are kind of like the framework
on which blockchain lives
so
that to be really efficient in order to
make the whole thing efficient
the second thing is like there's no
reason to think that anchors
are going to instantly deploy new
software
to support interoperability between
their existing assets like classic
assets and smart contracts
and so ideally it just kind of we do it
for them in some sense they everybody
just gets it for free basically
and there's one other requirement
which I'm now not remembering

oh yeah and the third one is a security
kind of situation which is that like
when I sign for a Stellar account at
medium threshold I have like complete
control over all of that accounts
balances

meaning like
I might be saying that i'd like to make
a five dollar payment but if I have a
million dollars in my account and i
signed for a smart contract to control
my account at medium threshold it could
just make it a million dollar payment
ideally we should make it so that
that situation is completely impossible
you can't just sign for the account to
make payments basically
and so these two caps 48 and 49 are
two different perspectives on this
problem
cap 48 is kind of like
what if I did the thing that was the
most frictionless possible
but if you do that you inherit a bunch
of weird stuff left over from like the
fact that Stellar assets are not really
quite exactly like your z20 assets or
whatever other ethereum standard you'd
like I'm really focused on erc20 just
because I'm familiar with it and it's
classic and old
but like there are other standards that
could be relevant here
but I'm gonna keep saying here c20
and you should just interpret that to be
whatever standard you like

cap 49 on the other hand is more like
what if we introduce a little bit of
friction but we make it so that these
things really really really look like
erc20 assets
and avoid any of these like weird
questions like oh like what who did that
do there's no more ambiguity
so that's kind of my pitch for these two
proposals
ultimately is it about choosing one path
or the other
is this like a choice between 48 and 49
that that is something that we need to
contemplate and make or are they
they work together
or
you know given john given that cap 49 49
was just like dumped this morning on the
repo maybe you can give us like a high
level overview and like what are the
differences between cap 49 cap 48
yes and to answer justin's question
it is an either or but not like not
like an either or and no other options
exist it's like a these are two good
options and there could be other good
options I haven't thought of but I have
thought of a lot of options and these
two definitely stand out as like
probably the best given our requirements
so it's like either 48 or 49 or
something that none of us have thought
of yet

to go over what tomer was talking about
in terms of 49 because I did kind of
just drop it on you guys at like 11
o'clock this 11 o'clock in my time this
morning

basically

I went over the issues in cap 48
which are listed in the design
rationale there's there's four slash
five of them depending on how you think
of it
and I went through and kind of
designed a system that solves them
so what is the functionality of before i
go over how the issues are different or
work out differently
so in cap 48 basically the machinery is
like
the like asset adapter or contract that
like everybody gets for free actually
goes around and controls
the Stellar trust line
so you know like when you use the
erc20 function transfer it actually goes
and uses the payment operation to send a
payment from this trust line to that
trust line or from this account to that
account if it's needed
whereas in cap 49 that never happens
the the only thing that the only time
the contract will ever use your trust
line
is when you call these two functions
wrap and unwrap or like if you're used
to we would call them as deposit
withdraw but this was confusing to niko
so I'm sticking with rap and unwrap and
we can change choose whatever names we
like later but I think nobody will be
confused by the terms wrap and unwrap
and basically like what the wrap
function does is it effectively
it effectively takes some stuff from
your trust line puts it in some new type
of ledger entry for the smart contract
which I'm going to call a wrapable
balance
name stinks whatever we can change it
and then it basically mints the
corresponding erc20 and then all the
other erc20 transactions operate on this
you know erc20 type balance that's just
like a new thing completely

and the the opposite thing unwrap
just does all of that in reverse and so
like the erc20 stuff is like completely
working on new ledger entries it doesn't
use any of the old machinery at all
only the wrap and unwrap functions
actually interop with the old machinery
and then to make all this stuff work you
now have to add a few compliance
functions

like you have to add auth and clawback
to the erc20 side of it
but that's like super simple
machinery that like I mean it's super
easy to build
I looked at how people have
implemented it like I looked at I was
actually looking at the
usdc contracts to see how they
implemented
the auth and it's like exactly as simple
as I was thinking we would do so that
was kind of a perfect fit in that sense
in terms of how this solves the
problems but actually before I continue
anybody want to stop me and ask some
questions otherwise i'll just go over
how to solve the issues that I see
just for me to understand the
there's still this like canonical
one-to-one mapping between an asset and
a wrapped asset
yeah
okay it's like a native implementation
you do the same kind of thing where you
like say like hey like give me the
contract id for this asset
and this contract id is some kind of
like native thing there's no wildling
behind it it just runs it has some
interface that we prescribe

and there's exactly one of them for
every asset that you could ever make
that's it
and they can store data and I'm not
really talking about how the data is
being stored in the
cap because we don't know
what the fee model is yet
so like there will be some fee model
I don't know who's paying for it
I don't particularly care at this time
and whatever we decide later should just
retrofit onto that's
that's that basically

any other questions before I go on
okay
so why do I like the 49 version
better than the 48 version
so I'm just going to go like over these
the issues I noticed
so the first thing is like it's not
labeled as an issue in cat 48 but it is
one which is like ideally you should be
able to use a
Stellar erc20 like a wrap an erc20
wrapping a Stellar classic asset however
that interface works
ideally you should be able to use it
exactly the same way you would use an
erc20
that's not even possible in cat 48 even
ignoring some of the other weird quirks
that like we have to agree on some
design that makes sense some
implementation that makes sense
because just when you initialize a
contract like let's say you have a
liquidity pool contract
and you have like a factory for it that
takes two assets which are going to be
the two assets that you have reserves
for
well you'd have to actually check like
hey is one of these assets
and like a Stellar
classic asset even if it has an erc20
interface
because you would still need to create
the trust lines for it
that's a bummer but at least it only
happens one time in initialization

that doesn't happen cap 49 you don't
need to create the trust signs the the
contractor does all the magic and we
don't need to be backwards compatible
because it's all new machinery however
the fee model works I don't know

then
the next thing is like what is the issue
of balance like if I take the cap 48
version and I ask the concept like hey
like balance of the asset issuer
what should I return
if I return 0
should I return in 60 formats should i
return you at 256 max
I mean like I have no idea what number
to return there is no sensible answer
the balance of the issuer is infinite
and also zero
zero
sorry I think zero I think zero is a
good answer for that question but like
you can make a payment from the issuer
in account so surely the balance isn't
zero sure it can mint right but it does
it like the it's the balance of like the
currently minted you know the current
circulating supply
I don't know man it's not compelling to
me
at all
because like in this context like
the function transfer for what like the
function transfer when called on the
issuer
actually has to me
which is not how an erc20 normally works
and since it like if I can call transfer
I should have enough balance to make
that transfer you see if the function
transfer 100 would succeed
then I must have a balance of greater
than 100.
I mean should we be rethinking
how
trust lines work in the legacy model
like I think it might have been a
design mistake that like
payment is how you create assets

like I know like obviously a lot of
people expect that now but like maybe
that's something that we should
reconsider that like actually an issuer
can have a balance
I totally agree that I would love to
change that but it would be a lot of
work that I don't want to do in this
context time wise when like we could
just fix the interface on the erc20 side
of it so that this doesn't happen
anymore
and that's that if you want the same
behavior use smart contracts that's what
cap 49 proposes this problem doesn't
exist in cat49
the reason it doesn't exist in cap 49 is
because the issuer now can't hold a real
balance
and transfer doesn't mint anymore
because it's all operating on these
wrapped up tokens
tomer's making a lot of faces so I feel
like he's doubtful about my argument
here
no I'm not awful about your argument i
understand why like I think there's an
elegance to cap 49 which is like better
separation between classic and smart
but we are putting
a lot of
burden on you know downstream systems in
the user
to actually like
to wrap and unwrap tokens and like
present some sort of like a unified view
of the universe
that like across the across these
boundaries I agree about the unified
view of the universe I don't really
agree about the burden of wrapping and
unwrapping
there's a section about that but
obviously I dropped this on you guys
like two hours ago so I don't assume
you've all read it but basically my
argument is like well hey you have to go
and work through this whole allowances
thing anyway
and if you have to go and do that you
can wrap up your assets when you're
doing that at the same time
there's nothing stopping you from
doing them at the exact same time

so like since your wallet is gonna guide
you through the allowances anyway it
might as well guide you through the
wrapping

that's kind of my argument that might
not apply in the context of like the eip
20 2612 is that the one where you have
the permit function I have to go and
look at how that would work but I assume
we can do a similar thing for the
wrapping anyway so probably it would
still be fine

okay
any questions before I do another one am
I am I actually being helpful here
should I stop
you're being very helpful john
i'd love to hear nico's take I know
he's been having some technical
challenges
can anybody here
okay
john can you talk a bit about
about the various authorization models

author required author revocable while
backable and how they would
relate to the to both cap 48 and cup 49
yeah definitely so in cap 48
everything kind of just works the way it
used to

there's no magic to it at all
the only catch is that like you can't
do the auth stuff from smart we could
make it said you could but there's like
a wide variety of reasons why you should
not be able to
and that might be a problem
but the
in cap 49 the auth stuff works a little
differently
but they it works differently in a like
favorably good way
everything is simpler
and we can actually fix some things that
were broken or not broken perhaps but
less than ideal in cap
in classic
so the first thing that's better is like
in classic there are three authorization
states you can be unauthorized
authorized to maintain liabilities or
authorized
in cap 49
all of that still exists in classic but
in smart there's only check
you're either authorized you're an
officer because there are no liabilities
so authorized to maintain liability is
the same as unauthorized so we don't
even need to represent it at all
glorious

the the next thing is like we had to
do this like off clock sorry
trustline clawback
trustline flag fallback enabled
something like that I can't remember the
name of it anymore to preserve backwards
compatibility with trust lines that like
you didn't believe that they would ever
be clawbackable
but since clawback already exists before
smart
everybody anything that anybody ever
builds on smart should be aware of the
fact that clawback is possible so we
don't need that flag either sweet so
now we solve two problems already
and so now
basically the way that auth works is
it's just like a single bit on your
account
not on your account on your like stored
in the contract data I guess stored in
this like wrapable balance entry type of
thing
and all it does
is it says whether you're allowed to
use the contract or not
and it's more I'm like representing
it more in the like
completely not allowed to use the
contract sense
than
just what like Stellar classic would
allow for example if your account
is not
authorized on the contract then you
can't even use transfer from to transfer
from two other people
you can't even be you can never be the
sender basically
on this account
and that I didn't think of that
originally but that is what is
implemented in that usdc contract that i
was looking at and that approach makes a
lot of sense to me if I'm not authorized
to use it for my own balances I probably
shouldn't be authorized to use it for
anybody else's balances either sounds
dangerous
so
that's the only real difference
but basically like author revocable
clawback all of that stuff that can
happen on the contract side of it
it's just determined by whatever the
issuer flags
if the issue of flags are currently
revocable irrevocable if it's currently
clawbackable you're applaud backable
that's it
no other magic to it so it's a much
simpler implementation than exists on
classic basically
does that kind of answer your question
oh
I definitely have some other questions
obviously wrapping you can only do
from from like a classic Stellar asset
to a smart asset you won't be able
to go the other way around right so
we're essentially saying that
like there will be like a new universe
of like payments for example only for
smart contract
assets that are completely in jump can
like you won't be able to interoperate
from the
likes of the classic protocol
I want to make sure I understand
exactly what you're asking me
are you saying that there will be an
like
are you saying that basically like when
somebody
wants to use a classic asset it ends up
being only usable and smart until they
send it back or you're saying that this
is kind of a model where people will be
using like will be making like erc20
type assets on smart
I'm saying let's say let's say I'm
issuing a new asset on the on the jump
can inside
doesn't relate at all to these
wrapped assets or or to any adapter
whatsoever it's just like my own
you know tomer coin
tomercoin will not be accessible from
the classic protocol in any way like i
wouldn't be able to use like a classic
payment operation on this coin
I mean we should obviously we can't
prevent that but we should discourage it
right like it would be a bummer
if


you know at some point we want to have
like really cheap payments and trades
right and so
to the greatest extent possibly want
to encourage people to
use assets that can participate in
you know things like speed x right
I mean I suppose in this context like if
you wanted something that was you know
that could be converted to a classic
asset
what you would probably just do is
actually
make it a classic asset and use the
wrapper
right
that's what I'm saying that basically
like it will be
it will be
of course it's true you know we
will people can implement their own
assets but to the greatest extent
possible we hope that our classic assets
will actually
serve the needs of kind of ninety
percent of the kinds of assets people
want to issue
but one would hope
right otherwise yes no but if I want to
coin
to have features that are missing from
the current seller protocol then I have
no other choice right
so
I think
regardless of what we do we need to
acknowledge that we're basically
going into a world in which there are
two classes of assets
assets that are interoperable between
these two

runtimes and assets that are only in
jump cannon and like do not inter
operate
and it sounds like we're also saying
that classic assets that already exist
we wouldn't be able to add in like if
you any of those features tomorrow that
you want to add to tomocoin
if ustc wanted to add it had those
same features they wouldn't be able to
do that because they're it's a classic
asset is that right
you might migrate back into the native
protocol
I wouldn't actually rely on us building
any new features on the old protocol
I think that's

yeah
john is smiling that's all I needed
if that's if that's the case then like
we're actually by doing this we're not
really planning a way to bring new
features to existing classic assets so
is there going to be this slow overtime
movement of assets that just stop using
classic
and then
we lose the ability to have assets to
speed x and things like that
to be honest I think that somewhere coin
is a bit of a
of an edge case like if we look at like
it's not like assets on Stellar actually
have

very true
real features missing from them
like it look like we do have a good
coverage of like asset features
so I'm not offended by the idea of like
issuing them still on the classic side
and wrapping them
I i
i'd like to find a way from the the user
experience to make it the the wrapping
parts less
visible
and not have like multiple balances for
like the same hassle but we can
figure that out later because the you
know the the ewe experience is not

you know
when you're crypto native it makes sense
when you're like you know just just
you know arando trying to make their
first steps in defa it's not like the
best experience
yeah I totally acknowledge that
one thing that is kind of missing from
the wrapped contract proposal that i
wrote which I did think about this
morning was whether there should be mint
and burn operations
on the smart side
if there were mint and burn operations
on the smart side
it would be possible to effectively
issue a classic asset
and then always work on the smart side
and so like your users could unwrap them
and then use them on classic and re-wrap
them if we wanted to preserve that
interoperability but like in practice
everything would happen on smart
and people would never really be doing
the wrapping and unwrapping unless they
want to go back to classic
and so that in that world you avoid
the rap step like imagine if like
you have an anchor flow that instead of
issuing you the classic acid then you
have to wrap it up and send it smart
you just like they ask you like hey like
do you want this to be smart or classic
and if you want it to be smarter they
just issue it on the smart side
and then you don't have to do the
wrapping
or we could even do that by make that
the default at some point that might
make the ux better for some cases which
maybe would be a lot of cases actually i
don't know what do you think about that
summer slash lee
it's
yeah like it complicates things for the
issue and now they need to decide which
side belongs
on ideally there would be like one
especially with like these Stellar
assets that we expect to be the majority
we want to have like a very
straightforward best practice and i
think we might be just confusing the the
issue
with adding that functionality on the
smart contract
I also think we're asking the issuer to
make a decision really on versus
between scale and flexibility
so we want to be able to if we want like
what david said an issuer wants an asset
to be used on things like speed x or on
cheap payment operations they're going
to get they're going to be tempted to go
that scale route but then that might be
conflicting with flexibility like if
they want to have
I don't know some sort of sep 8 like
functionality that allows that's on
chain that you know maybe says
you can use my asset if you
have already been authorized to use some
other asset
you know as a sort of like a kyc
interface or something like that

like if they want to add something like
that later on or I don't know like
they have to decide at the point of
issuing am I going to be a smart asset
or a
an asset they can scale
maybe that well
i'd have to think about whether there's
a workaround for that
there might there might be one I'm
not really sure
so
I don't know I can't i'd have to think
about that more to answer what I think
just to clarify because I was going to
ask this question I think you just
answered it with that lee like
I'm an issuer and I'm ch and I'm and
there's a choice I can choose to issue a
classic or I can choose to issue on
smart
advantage for issuing on classic
is that
has better scalability
maybe true
I'm just thinking like if new issuers
come to me
the other advantages are choose to issue
unclassic
sorry can you say that one more time
justin I couldn't hear the whole thing
oh
this
this well basically when new issuers
joined the network why would they choose
to issue one classic
well presumably the idea of classic rate
is that your
your asset is very well defined right
there's just like you know four bits or
whatever that like
tell everybody exactly what to expect of
your asset
and so that lets you know the the the
the fact that it's
you know it's such a well-known quantity
also unless it be like you know
allows us to implement things more
scalably

and let's you know sort of guarantee
like things like auth immutable right
like guarantee that there won't be weird
surprises
I think the big thing is that classic
will be
cheaper and have more capacity
that's the main reason to do that on
classic
but like for example do we expect

exchanges to
offer both classic and smart assets or
just classic assets
like well you know
when when you're getting usdc or
whatever
will it be a smart usdc or will just be
like classic usdc
it'll be classic everything that
exchanges do exchanges move slow they
move very slow
and they're very resistant to
introducing changes so if you ever hope
for you
listed on you know kraken or wherever
like you'll want to make it classic
that's a good point yes
yeah
yeah generally speaking I think that
except for like extreme
use cases for with smart contracts
that have sophisticated
non-trivial logic I definitely think we
need to push everyone to issue on
classic
and use this
whatever interoperability scheme
we decide on
then I think it becomes pretty important
to make it as easy as possible to do
this
like those mint and burn operations i
was talking about they sound important
now
because like if we want people to get
like a unified smart user experience
but still have an underlying classic
asset
that you can like actually unwrap that
would be the easiest way to get that

so
we probably should do that
yeah we're
yeah we're about to make
horizon's life
a bit hellish
with like figuring out these things
and how to convey them to the wallets
wait
but isn't the whole point of if you
issue your asset as a classic asset then
horizon should just work right
that's another yes
yeah but the question is like if a user
wants to do something on the smart side
you know let's say I did something on
the smart side and now I have like part
of my USDC balance is on classic part of
the usdc thing
is on is on jump cannon
now verizon needs to give
you know give wallet some like unified
view
but then
why should horizon even touch the smart
side of things
I agree
george can you expand on on why you
agree I would also love to hear more i
was also like
it just doesn't seem like horizons place
to make those kinds of
to coalesce those separate things
like
if you're making them separate then they
should stay separate because we just
give an accurate reflection of
the core's state of the world
and so if you have them in two places
then we reflect them in two places right
well well a wallet uses horizon as
as it's kind of like
you know
just beta access layer into this into
the Stellar universe right
now if a wallet
classic wallet
well no a wallet a wallet wallet
not just a classic wallet
like I don't have any smart wallets
but I would imagine smart wallets maybe
wouldn't well like
Stellar wallets would want to add smart
functionality right it's not going to be
like two universes
that's the whole thing right you know if
I have a Stellar wallet and I want to be
able to participate in a d5
application
and
I need to have
access to all those information

and we need to find a way to present
that information you're going to need a
level of extensibility
that horizon just like it's not
it's just not the horizon way of doing
things like maybe I have some asset and
it like
keeps its own ledger and like some weird
you know
compressed state or something right
so like I'm actually there's actually
going to need to be like kind of
server-side logic
for for decoding that right and
that's not we don't want to be like
loading that stuff into horizon right we
want horizon to be stable and
predictable
let me let me rephrase maybe horizon is
a bit of a loaded term
but we need to provide
a
data access layer to Stellar that allows
wallets to reason about what's going on
on the smart side what's going on on the

dumb side sorry classic side and to
interoperate with these like wrap-on
wrap functions
so this might not be horizon this might
be
you know horizon ng or whatever
but something needs to provide that
functionality and that's something
is
you know like we're making its life a
bit difficult
well I mean I would argue that that
something is going to need to be
much more sort of modular and extensible
than horizon right it's just going to be
a
totally different architecture in fact
you might have
many instances of this and you have
would have would have some horizon ngs
that support some assets but not other
assets right and I mean it would just be
it's just going to be a much more
heterogeneous ecosystem right assuming
that people are taking advantage of the
smart contracts
all right camera can I try to get some
clarity on what you're actually saying
here
are you saying that you
that you want this
thing I'm going to use the word horizon
and we're all just going to pretend
we're talking about the same thing even
though we're not
but you want horizon this data access
layer
to be able to talk about both the
wrapped balances and the unwrapped
classic balances like the trust line
balances or are you saying that you want
it to be more generically useful for
exploring the state of the smart
contract universe outside of these asset
adapter rapper things
I think you're saying the first one
but I think david thinks you're saying
the second one
and maybe you're not saying either of
them
stuff right now like I'm trying to think
of by the way can you guys hear me i
don't know how long you were talking but
I wasn't able to hear you for a while at
least
okay can you guys hear me now yes yes
yes
okay awesome
so I'm talking about the wrapped assets
specifically like the this kind of
like dance between wrapped assets and
regular assets and I'm thinking about
if I'm if I'm trying to
you know just like top down design
from a user perspective like the wallet
experience
all the experience they very

they have like this universal view in
which a user doesn't have to think about
you know which side an asset is on right
so
either
the wallet needs to have these like
multiple services that it interacts with
or it has or needs to have like this
unified

you know service that it interacts with
that provides it with like a unified
view of the world
so
I think that regardless of this is
something that that needs to happen
and and it doesn't necessarily


actually
yeah I think cap 48 might be
more
friendly for downstream
so I mean maybe the problem here is i
didn't read these caps because I didn't
hear about them in time
so to the extent that the I guess that
there's a choice between
explicitly wrapping and unwrapping
versus like always having
assets be sort of both classic and
smart at the same time I would I would
you know strongly favor the unified
one but again I haven't read the the the
the rationales and stuff

you know assuming that we do that right
then we're gonna have sort of classic
assets which are also accessible in
smart contracts and we're gonna have
like smart contract only assets so the
for the classic assets
horizon should be sufficient right
because you can access those to the
classic interface for the new smart
assets
every asset is going to need its own
horizon modification potentially or like
a lot of assets are if they're if
they're if they're doing interesting
things and so we're going to need a kind
of modularity on the server side we're
like I might issue a new kind of asset
with like new properties I'm going to
need to like also present kind of like
horizon side logic to do that and I just
to me it feels like
danger like horizon doesn't feel like it
has the kind of modularity and
extensibility that we would want for
that
we should think about a more like
plug-in friendly architecture
there's another there's another angle to
this too and that is a horizon like
right now mostly horizon just provides
access to data
and if we just make sure that
if we make it such that horizon has
access to contract data technically
clients could still use that contract
data to display things like the balances
or whatever you know they can look up in
the contract data the same way the
contract does
there's some downsides to doing that
but that's one way for us to sort i
guess kick that can down the road a
little bit you know we can but they can
potentially be services that
show some specific balance format for
specific types of assets it doesn't have
to be a horizon though clients could
just use horizon to get like the raw
contract data
actually I think that's that's sort of
like the model that of the first demo
that paul had posted into the jump canon
channel
he posted a demo where
you could use this horizon like
service to just get the raw contract
data and then the client can interpret
it however it wants
john is the main difference in
terms of the interface between cap 48
and cap 49 like ignoring the wrapped
asset part but the other main difference
just being supporting having that total
supply

that's the other interface difference
and then there's a couple other like
ambiguity improvements
like it's very clear what the answer of
balance of is in all cases
even outside of just the issuer case in
cap 49 like is the balance the available
balance or the raw balance this is one
of the things that I like kept coming
back to when I was writing cap 48
and I don't think I was consistent
everywhere
but in cap 49 like there is no notion of
the available balance from the context
perspective it's just the balance
so like there's there's like some
interface improvements in that like you
get the total supply and cap 49 you
don't get in 48 but like the interface
is also just more logical in cap 49 like
I don't there's only one right answer
basically in cat 49 for every function
it just does the thing that you expect
it to do because there's no other thing
that it could possibly do
do we have to keep to the erc20
interface exactly though like I could
see it being if we can solve the other
problems so if we found a solution to
total supply for cap 48
we could say okay there's actually two
balance functions there's you know
the balance of and available our balance
of
in the Stellar ecosystem
is that fair
and we definitely could do that and then
we could basically say like hey like you
know when you implement a token on
Stellar what you should do is implement
both of these functions and probably
there you want them to be the same
function they just have the same
implementation
we definitely could go and do everything
in reverse

so
yeah
a little bit
ah it sucks okay maybe I need to shout
or something
it's good enough
okay now I was going to say like the
the
like the reason we have this on the
classic side is because of liabilities
right and actually liabilities we could
have implemented that differently like
in in smart the way you would do it is
actually you would move the actual
liquidity
outside of the account right so I think
like you know like an offer basically
would be
you would actually move
whatever you want to sell in the offer
like that's not the way we did it
whatever
but
that's right to me I don't know if we
need to expose those two concepts like
balance wise like the available I mean
the
usable balance is
is the thing you want to expose
like you know the fact that we
that whatever is locked in our office i
mean this is
not interesting I think from a smart
contract point of view
it's not a it's not usable like it's not
available right
I mean
the main downside of that though is like
things that should be true cease to be
true like you should expect that the
total supply is equal to the sum of all
the balances that just won't be true
this feels like a minor detail
to me like the distinction about how we
would expose these two values because we
could just choose one or we could just
expose both
and doing either doesn't really break
I don't think doing either would break a
contract's ability to

replicate what you know what's happening
on other chains is
is that not true
I I don't know if it's true
but like if your goal is to make it so
that these tokens interoperate perfectly
with what people are accustomed to using
which is my goal here like if I could i
would just like take the stuff that
people have been building on for five
years and just like build exactly that
stuff on seller because that's how we're
gonna get the fastest adoption
and any place where it's not exactly
obvious how it works exactly the same
that's friction that's going to start
with a slow adoption
and if it doesn't work exactly the same
then it's really going to slow adoption
so like the first step is like is it
obvious that it works exactly the same
if the answer is no you probably have a
problem and then if it doesn't work
exactly the same you have a second
problem
so that's how I feel about this it's
like anything we can do to make those
answers like
this is so obvious that you don't need
to think about it and it does exactly
what you're used to that should be our
goal
I don't know if people disagree with
that goal but I think it's a really
good goal like my goal would be to make
this so stupidly easy for people to use
because they're so familiar with it
that they want to build right now
immediately you know
and unless there are things about the
way that systems currently work that
people hate
there are and that that eip 2612
thing that I mentioned was something
that tomer pointed out that some people
found a big improvement about something
that people hate from erc20 so like
it can be better
but
all of these things work better than
classic Stellar assets I think at least
for like the needs of smart contracts
so I mean I guess we have about 12
minutes left in this meeting do we do we
want to keep like I know that there's a
few other sort of questions that came
up
outside the interoperability
questions do we want to take this time
to discuss those or should we stick with
interoperability there's contract
management questions that I know there's
cat 47 talks about
instance
stuff that we want to cover
especially because
the cap 48 49 discussion for now
I feel like there's a lot to think about
and discuss
it does feel like we got to a natural
lull
do you want to talk about the cap that
you've been working on
yeah I can start with the cat 47
so
all right cat47 just specifies how
contract management would work
actually creating update and removing
contracts so it's
know relatively simple compared to cap
46 and
48.49
lee had some questions related to
this
I think the most interesting one was
we we allow mutable contracts
and the cap doesn't specify any
versioning right now
so one of his questions was that
if you if you allow immutable contracts
how would you identify
which contract version was used for a
specific invocation currently there's
nothing in there that you would have to
you know replay history and go look at
which contract entry was used as
specific invocation


so yeah so the least question was around
you know auditing which contract was
used

I'm not sure if
this is something we should add lee do
you want to talk about this

yeah I mean you you basically you
basically set up like
I I just I think there's there's two
components to it identification and then
referencing
so

there should be some way I think for
someone to speak concretely around about
a specific version of a contract like
you should be out there are going to be
apis that expose information about
this is the transaction that executed
this is what it executed on
there should
it makes a lot of sense I think for
those apis to be able to point exactly
to the exact code and maybe that's just
a hash of the code

and if if so that's that's great we just
need to include that in the cap

maybe it doesn't even need to be stored
on the ledger I'm not sure if that's
important it could just be a hash
that's not actually stored and you have
to calculate it if you want to calculate
it
there just needs to be yeah and I i
guess
in terms of storing in the ledger
like the question I had was like you
know do we need to install that in the
transaction results or meta or something
like that so that there is something
more concrete or do you just have to
know this transaction executed on ledger
five and if you go and look at ledger
five
at the the state of the ledger you
can see that this is the contract that
was there
yeah and like if we have to do that that
just feels a bit ambiguous
okay
but I think nico
may have mentioned something around
you know there's a cost obviously to
storing
32 byte hashes for everything
and so maybe this is actually not
realistic to store like that everywhere
a contract gets used or something so
nico I don't know if you want to expand
on that
seems to be having on and off issues
connecting to this yeah
I can hear you right now tomorrow you
have been cutting in and out a bit
though from time to time
yeah

is this something that downstream
systems can do you know when they index
changes they can also index
what what version of the contract
caused these changes
I think so or at least maybe
george
might be able to shed some light on this
I I think one thing
we have had some issues with like
backfilling some of this data in the
past
so I think one example would be
you know claimable balances don't track
who created them
and it would actually seem simple for us
to say oh yeah downstream systems should
be able to just figure that out
but it was actually
really challenging I'm actually not sure
if we actually found a solution for that
maybe maybe there's going to be an ask
to the horizon team who are sort of
experts in this field
yeah I would say it's pretty hard to say
right now especially for me
I mostly joined as a listener so I'm not
super familiar with how these
caps
are
suggested to be implemented right now
but I do know that like we have the the
key value data access model that paul is
working on
which provides access I guess to
contracts but maybe not so much how
those contracts have been interacted
with so that's definitely tbd
from the horizon side
I will say that I felt a little bad in
retrospect about the not putting
who created a claimable balance on it
earlier drafts of the proposal had that
feature
and we convinced ourselves that it was a
that it was a waste to do it
which was basically just saying like
yo horizon y'all figure it out which
like maybe wasn't super nice in
retrospect but
I understand why we did it at the time
and I don't know if
I don't know if I would like even
knowing what I know now I'm not sure we
would have done something differently
for that particular case
but there definitely is some like
potential
risk for like
caveat
in the future
like
I could imagine people wanting to know
exactly what happened even on chain
like hey like this contract had a bug in
it
like let me write a contract that goes
and identifies all the bugged out data
like I could imagine doing that
or maybe you do it often I don't know
I'm not sure
but
I don't think I don't think we should
just assume that the only obvious thing
is to push the problem down downstream
yeah I think that's fair and
specifically because in this case
the identifier or the reference whatever
call it could be derived from the data
itself
so I think like the claim balance
created creator example

is more challenging because it wasn't
actually derivable from the immediate
data from the claimable balance itself
whereas in this case it is like if you
have the wasn't code you could hash it
and if we say the id is the hash then
it might not be the button
one thing I was talking to slightly
different topic but still related to
like code versioning stuff
that I was talking to darth about
yesterday afternoon

was about like
maybe the state of like and like start
had some reasons that this is like maybe
not a brilliant idea
and I don't claim it is but like
basically like
the idea that I kind of had which was
weird was that all contract code is
mutable there are no immutability flags
or anything for it
but it's only mutable from within that
own
smart contract so basically if you want
to be able to redeploy your smart
contract you need to write a function
that can redeploy your smart contract if
it is missing your contract is immutable

if it is there then you can redeploy
your smart contract using whatever
scheme you want for signatures and stuff
so the main advantage I see to this is
like
you get immutability for free and you
get mutability for free but if you want
me ability you just have to build
whatever readability scheme you want

but the the cash that's pointed out
that made me think that maybe this is
not so smart is he said that if you
accidentally bork your contract and
forget to deploy your redeploy function
you're dead
you're just straight dead
so
yeah that's that's your risk
basically
yeah like we I think we
concluded with the idea that maybe it
might be a good idea to allow both you
know you can update the the contract
with
update
manager or
update contract app or you can allow the
the contract code itself
up to upgrade the contract let me
obviously have to think about this
a bit more but
that might that might be like that might
be a good idea
if you update if you deploy your
contract

when is the new contract available like
the current ledger no it'd probably be
the next led you're right
yeah it'd be the next ledger it would i
guess the the operation would basically
be like hey at the end of this ledger
write the new code
kind of like the same thing as like
when we were working on speed x it's
like a speed x create offer operation
means like hey when you go into the
speed x phase
make this offer and try to trade it
so
there's some interesting applications of
that you know you could write a contract
that actually contains multiple versions
of itself and it could change which
version of itself is currently going to
be deployed based off some other inputs

yeah that's it's intriguing it's funny
you say that because I was thinking
about things like that too I was
thinking about deploying a client
that can write itself back to the chain
which I thought was just like
intriguingly weird but there's some
examples of like twines that can write
themselves back even under this case of
corruption
so like you could imagine a contract
that could have its data corrupted and
then write itself back to the contract
anyway which is pretty neat I have no
idea how that could possibly be useful
but like there probably are useful
versions of these kinds of machinery
it feels like a good thought to end on
since
especially since we're out of time

so we are going to be having these
meetings weekly I don't know if we're
having well we'll sort of deal with
scheduling in the background but so for
anyone who's watching you you can find
them in this channel
we're also going to be discussing
this stuff asynchronously in the
jump canon and jump canon dev channels
here on discord
thanks everybody
I will talk to you all soon
you

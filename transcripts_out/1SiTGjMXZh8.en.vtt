WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:59.999 align:start position:0%
So without further Ado we're going to keep talking about State expiration today and I think Garen dropped a bit of a bomb a couple of days ago. So I think we're gonna start with, that and again. If you can give us a quick overview of some of the suggested changes yeah sure. So up until this point the current Legacy expiration proposal has had this thing called a rent balance. So essentially what you would do is, that whenever you you know create an entry or want to do a rent bump you would put XLM into this rent balance. And then every Ledger a variable amount of a fee called the rent fee would be removed from this rent balance and the rent feed could either decrease or increase based on the size of the bucket list and network usage. So the reasoning behind this initially was, that we want to provide some sort of market equilibrium, that as The Bucket List gets larger and as the price of writing to the bucket list increases we
00:01:00.000 --> 00:01:59.999 align:start position:0%
also have increased pressure to evict and expire entries out of the bucket list. And so the thinking with this kind of variable rent fee is, that as the Buckle list grows you the rent fee also grows and so, that you deduct rent balance more aggressively. And so more entries will fall to zero or negative rent balances. And then be expired more frequently so, that's kind of the original thinking as to why we had this variable rent balance and this variable rent fee. Now the issue with, that is there's two primary issues the first is just the user experience story. So with run balance. Because the rent fee, that's deducted is variable from ledger to Ledger you can estimate how many ledgers you think your entry will be live on the network. But you can't know for certain. So for instance say. If you initially paid for 100 ledgers of rent. But you know there are a bunch of merges. So the bucket list size decreased a lot. Then your entry could live much longer conversely. If you paid for say 10 years of rent your entry might only lasts one year. If the network explodes in popularity and the Buckle of size
00:02:00.000 --> 00:02:59.999 align:start position:0%
increases. And so it's kind of weird user interface where the users expect an entry's lifetime to be measured in ledgers. But really you have like this rent balance and like this variable thing you really can't control it and so, that was issue number one is, that it was difficult for users to understand and it didn't have a great user Story the second issue is, that of Downstream systems and so. Because the rent fee is variable from ledger to Ledger you don't know. When or you can't predict what the Run fee will be. And so you cannot predict an entry's rent balance. Now in Stellar core we have like this bucket list data structure, which is like you know specially designed with this multiple levels and like this log scripted merge tree approach and we've designed the rent balance system to work very well with the bucket list such, that on bucket list DB you always know exactly how much rent balance your entry has and we can do this efficiently without iterating through every entry. And then you know decrementing its rent balance by the current letters rent fee we
00:03:00.000 --> 00:03:59.999 align:start position:0%
can like you know get around it using some optimizations of the bucket list structure. Now the issue for Downstream systems is, that Downstream systems don't have a copy of the bucket list you know they're running captive core. But the way, that a captive Quorum core is currently designed it's too expensive to query a captive core directly and so, that means, that in order for these Downstream systems primarily Horizon and sort of on RPC nodes in order for them to have accurate rent balance information what they would need is to essentially either maintain their own version of The Bucket List and apply rent via like a copy of the bucket list or do some like very inefficient operations with like SQL where you like essentially cache some amount of rent fees. And then lazily apply them in the background or something like, that. But in either case it's it's a lot of work for Downstream systems a lot of disk I o and things like, that. So those are these are the two main drawbacks and so. When thinking about this issue we thought from our first principles okay do we
00:04:00.000 --> 00:04:59.999 align:start position:0%
need this variable rent fee do we need a rent balance or can we use a definitive expiration Ledger and so, that's kind of what today's conversation about is rent balance versus expiration Ledger. Now how the expiration ledger works is instead of having The Ledger entry store a rent balance field, that is periodically deducted from instead all it stores is a single entry, which is expiration Ledger it's very simple essentially before the expiration Ledger the entry is live and accessible after the expiration Ledger the entry has run out of rent and is not accessible. And then once the entry is passed this expiration Ledger it can be expired, which is. When it's deleted from The Bucket List and then. If it's a temporary entry it could be permanently deleted or. If it's a restorable entry it's deleted. And then stay sent to a state restoration node or something like, that. Now the advantages to the expiration Ledger approach are, that it's significantly easier for Downstream systems. Because they don't have to periodically update entries with rent balance information The Meta, that's
00:05:00.000 --> 00:05:59.999 align:start position:0%
initially emitted whenever an entry is created or an entry receives a rent bump we'll tell Downstream systems exactly. When an entry should expire. And so it's pretty straightforward from the implementation standpoint it also makes a lot more sense for users who expect, that a lifetime is measured in kind of Ledger a discrete and predictable values. Now the drawback to this is, that we can't have this Dynamic eviction pressure feature, that we have in rent balance. So how the expiration Ledger implementation will work with respect to fees is what we would do is take whatever the current market rent fee rate is based on the size of The Blacklist. And then lock, that right in and charge, that rate for the entire lifetime of the object or of the entry. So for instance say you are creating a new entry, that has one year's worth of rent you would be charged one year's worth of rent at the current rent fee. Now the issue with this is suppose, that within, that year The Bucket List size increases significantly essentially what
00:06:00.000 --> 00:06:59.999 align:start position:0%
you would be doing is. Because you locked in, that rage. When the size was small you'd be paying an artificially low rate compared to other entries, that are being added onto the network later. And so you have this weird system where these entries can be kind of grandfathered in. So to speak such, that they pay low fees. Because it's gotten at the ground level. When the network is low. And so with rent balances you don't have this grandfather thing. Because even. If you create an entry on Day Zero answer up on launch day. When the buck list was at you know theoretical smallest size. Because every entry is subject to the same variable rent fee no matter. When they were created the old entries and new entries are charged the same rate however. Because you have to essentially lock in the rate on creation time around bump time with an expiration Ledger approach, that's not possible. And so I think what we want to think about. If we want to make expiration letters work. Because I think the two benefits to Downstream systems and to the user experience are very very significant benefits. And so we should
00:07:00.000 --> 00:07:59.999 align:start position:0%
think about expiration Ledges pretty seriously I think, that we need to make sure I think the thing we want to prevent most are kind of two scenarios first where you have a system where users or there's smart Contracting can essentially provide a storage interface for cheaper than the protocol can. If you can imagine say on day Zero. When the bucket list is small someone spins up a smart contract, that has public functions, that exactly mirror the storage functions of, that the protocol exposes. So you have like you know get you know create just the exact same interface. But instead of calling it directly through the Soroban SDK you would just make a call to a Smart contract for your storage needs. And so what this storage contract could do is it could just you know buy up say the maximum amount of Ledger entries possible on day Zero with say like 100 years of rent or some very large value and essentially permanently lock in those entries for 100 years at the lowest possible rent fee. And then say two or
00:08:00.000 --> 00:08:59.999 align:start position:0%
three years down the line you know. If the Stellar network explodes and huge the rent fee will be significantly higher. And so what this contract can do is essentially auction off this rent space at a artificially low rate. And so you can essentially use a middleman contract to get cheaper storage than you could. If you actually went to the protocol directly. And so this is really bad from a network Health perspective. Because essentially every storage call. Now has to pass this middleman. And so you have lots of additional overhead for serving storage just. Because essentially you have a bug and exploitability in the way, that you charge rent. And so I think to prevent against, that specific exploit where you have like these these storage contract interfaces what you would need is some sort of upper bound on the amount of Ledger or the lifetime of an entry at any given point essentially the thinking being, that you know. If you allow arbitrarily large amounts of rent purchases. Then you could say
00:09:00.000 --> 00:09:59.999 align:start position:0%
lock in an entry for 100 years, which is far too long. Because the price will probably significantly increase in, that lifetime but. If you have a maximum lifetime of say six months it's unlikely, that a storage contract interface could be profitable with only six months difference between the initial rent fee paid. And then the rent you they'd be providing their users. And so I think the plan is. If we do expiration ledgers is to have a network parameter, which is the maximum rent or the maximum lifetime of a given entry on The Ledger. And so this could be something like six months or one year and this would be a network parameter. And so what we can do is you want this value to be as large as possible from a user perspective just. So you can provide the most flexibility and usability. But you want to be small enough such, that you don't have these rent related exploits and so, that would be a number, that we can change by a network vote just so, that we can essentially tune this value up or down as we see exploits happening on the network or as we see, that no exploits are happening on the network
00:10:00.000 --> 00:10:59.999 align:start position:0%
in addition to this issue we also kind of like the middleman storage contract we also want to make sure, that we're not allowing a bunch of spam entries to lock in very low rates take up space on the network and essentially up the price for everyone else, that's doing legitimate work, that's not spam. And so you can imagine, that on Day Zero. When the you know buckless has a small you have a bunch of airdrops, that take whatever the maximum lifetime is say six months a year or whatever. And then essentially just mint spam airdrop tokens and tell the bucket list size increases such, that's no longer profitable. Now the issue with this is, that they can essentially even, though you know each additional spam token they put on the network raises the rent fees slightly for the next spam token they can still do this very fast and very quickly take up the cheapest rent options with all of this spam and unlike an event balance approach even, though the spam has caused the rent fees to be high for everyone else. Because the spam did it first they
00:11:00.000 --> 00:11:59.999 align:start position:0%
are not subject to those higher fees and you can't evict them, which means you can have like this essentially these events where. If for whatever reason the bucket list size decreases in the rent fee decreases rapidly you can have all these spam tokens kind of come in and fill the Gap in very quickly get the network up to, that you know high rent fee rate again at the cost of all of these spam entries taking up more time than they probably should. And so I think, that's probably where I want to get the conversation started and open up the floor of questions. But those are the biggest pros and cons of each the pros of rent balance being you know this eviction pressure and defining these exploits natively without like the need for like a maximum rent balance or something like, that the con being Downstream systems and usability Garand there was a question around the downstream systems can you just quickly outline the the difference or specifically with exploration Ledger what would be the downstream systems
00:12:00.000 --> 00:12:59.999 align:start position:0%
kind of like expectations yeah. So I think the the the issue with the rent balance versus expiration Ledger is just, that an expiration letter we can put in meta so, that the downstream systems can be directly told what the expiration Ledger is. But there's no way to emit meta for the variable rent balance bombs just. Because they're too frequent. So for instance with expiration Ledger just. Because it's set a single time on creation or whenever an entry has its is expiration or its lifetime extended what you can do is just emit meta, that says okay this key has this lifetime. And then they start in a SQL database. And then whenever you access, that entry you can just spit out the lifetime easy. And so you can contain all, that information in meta with rent balance the issue is the initial rep balance is in the meta sure. So say like this has a starting value of a thousand XLM. But the issue is every Ledger has a variable amount, that's deducted from, that thousand XLM and. Because every single Ledger entry is subject to this variable rent
00:13:00.000 --> 00:13:59.999 align:start position:0%
every single Ledger closed what we'd have to do is. If to contain this information in meta literally submit a meta entry for every single entry on The Ledger periodically with the updated rent information and, that's just not possible. And so essentially the downstream systems would have to manage this rent balance themselves and we could probably emit the variable rent fee as meta every Ledger close. But then it would be the responsibility of the downstream systems to implement essentially the rent balance bookkeeping themselves. If that makes sense foreign it does sound for the most part like a win-win. So I definitely want to un probably focus on like what are the pros of of the current Red Diamond system compared to exploration Ledger
00:14:00.000 --> 00:14:59.999 align:start position:0%
yes I think the it comes to to eviction pressure and kind of not being exploitable or being more game proof and so, that's the primary issue with locking in a essentially a rent fee at creation time is, that you open up these vulnerabilities for the kind of like a contract storage middleman and for a long life spam entries, that increase rent fees for everyone else. And so those are the two kind of I think exploits, that we want to prevent happening and so. If we can find essentially a suitable limitations on the expiration Ledger like one limitation being not allowing arbitrarily large lifetimes to defeat those two exploits. Then I think it would be a good decision there's also a couple of other drawbacks I think these are all solvable problems. But just something to think about is, that there's certain issues like. Because you're locking in an expiration Ledger there are questions about what to do whenever you resize an entry. So for
00:15:00.000 --> 00:15:59.999 align:start position:0%
instance say you create an entry, that's only one byte large and say okay I want it to have an expiration Ledger 10 years from now and. So you pay the rent fee for 10 years. But for only one byte. And then two ledgers later you say oh this entry is. Now 100 kilobytes. Then you essentially need to reconcile okay what do we do in this situation do we either a shorten the lifetime. Because the rent fee is. Now higher. Because it's you know a larger entry size just for reference the rent fee is charged per byte. And so you need to pay more rent in order to have the same expiration Ledger you did before. And so my current thinking for, that particular Edge case is, that the expiration Ledger should never decrease for instance a write or an update or changing the size of an entry should never decrease its lifetime it should only match or increase the lifetime, which means, that. If you have an entry, that has say 10 years worth of or, that has an expiration Ledger 10
00:16:00.000 --> 00:16:59.999 align:start position:0%
years in the future. If you resize, that entry. Then you what you need to do is you need to pay for essentially the difference. So you'd have to pay in this example. If you had a one byte entry, and now it's a you know 10 byte entry you'd have to pay for 10 bytes or for the nine additional bytes whenever you do, that update. And so I think there are like issues like, that. And then the two exploit exploitability cases, that rent balance solves really elegantly. Because rent balance you you know it's charged every Ledger and so. If you resize it. Then they'll the you know new additional fees will just be picked up on the next Ledger. And so it's handled automatically. And then these exploits are not possible just. Because your rent for your paying is always up to date. And so you can never game the system by locking in a rent fee early. And then using it later. When the rent fee is more expensive
00:17:00.000 --> 00:17:59.999 align:start position:0%
is there anyone on stage or in the audience, that want to speak in favor of rent balances okay. So yeah I just want to comment on this from a product perspective I definitely think, that this is a big win. Because the user experience of the previous proposal red balances is definitely kind of like requires a bit of a complex mental model of what rent actually means. Because when people you know pay rent they are used to kind of like locking a specific grade for a specific given of time a specific given amount of time. So I do think, that this new proposal kind of like sits better with like a mental model of of what rent actually is even, though we're not using the word rent here
00:18:00.000 --> 00:18:59.999 align:start position:0%
one question, that I also asked on Discord is around a the question of temporary entries and to the question of like Auto bumps and what is what are the implications for these yeah. So I think my current thinking is, that we should still have Auto bumps. But the auto bump should be optional and optional well let me explain what I mean by optional. And so I think in this system we still want an auto bump system such, that you know frequently used entries and shared entries such as contract instances and contract code wasm are paid for and so, that was envisioning is, that before we were like bumping by some you know amount of XLM now. Because we have this expiration Ledger interface we would just Bump by some modest amount like 10 ledgers per access automatically and some of, that would look like is, that you would pay at the current market rate whatever the current rent fee is for
00:19:00.000 --> 00:19:59.999 align:start position:0%
the extension. And so even. If the entries say had like three years worth of rent, that was paid for two years ago. So it was very cheap whenever you access it you would still need to pay for the additional 10 ledgers at the current market rate and so, that's for automatic bumps I think what we should do for auto bumps is especially for temporary entries there were use cases where other bumps are useful and so I think. When creating an entry what you should do is on the initial item creation you can set a flag and, that flag is either Auto bumps true false. And so what this allows you to do is, that the original developer. When you're creating the entry can choose. If this entry is something, that should be bumped or something, that is like you know short-lived. So it should expire. And then whenever you access, that entry, that flag is stored in The Ledger entry. And so the Access Auto bump is determined by, that initial create time flag. And so I think Auto bumps are optional. But they're not optional by The Entity, that's accessing the entry they're
00:20:00.000 --> 00:20:59.999 align:start position:0%
optional based on the entity, that's creating the entry. If that makes sense. And so I think, that makes the most sense. Now another thing for temporary entries is. Because we. Now have this expiration Ledger I know before we kind of went back and forth as to you know. If we should have expert or temporary entries with like firm or exact cut-offs or not or like, that expire on the exact Ledger entries. And so I think under this system now, that we don't use rent balances, that should be very possible and easy to do such, that you can. Now use temporary entries for security features such, that. If you want an entry, that lasts exactly 100 ledgers what you would do is just say make a temporary entry set the expiration ledger to you know or set the TTL to 100. And then set auto bump to false. Now I think we still need to actually I still need to think about, that a little bit more as to. If we can. Because right. Now we are allowing both temporary and
00:21:00.000 --> 00:21:59.999 align:start position:0%
restorable entries to be bumped by anyone anytime. And so I take back, that said they still might not be appropriate for security uses out of the box. But so what I'm kind of envisioning right. Now is the autobump flag. And then in addition to the automatic bumps on access, which both temporary and restorable entries have you can also still manually bump any entry both temporary and restorable via an operation and, that operation is similar to what was in rent balance. But now you just specify the new expiration Ledger. And then my thinking is, that whenever you bump or whenever you pay for more you can either there's two options here sorry October were you saying something no sorry oh. So I think there's whenever you do a manual bump operation to extend the expiration Ledger there are two ways we could think about it first you could either be credited for the amount you've already paid. And then view it as an
00:22:00.000 --> 00:22:59.999 align:start position:0%
extension. So for instance say you know I have a ledger, that's set to expire in a year and I want to expire it to expire in 18 months one potential solution would be the rent bump operation only charges you at the current market rate for six more months of rent it says hey there's already you know 12 months of rent here. So we're only going to charge you for the additional six. So the total comes out to 18 months, that's option one. Now the drawback to, that option is again for, that first 12 months you're locking in a lower rate in, that last six months is. Now at the market rate so, that's option one option two is, that whenever you do a manual bump you don't count the previous balance is burned what this would be is, that. If you know there's an entry, that you want to live 18 months. But it currently lives it currently has an expiration, that's only 12 months in the future you have to pay 18 months of rent at the current market
00:23:00.000 --> 00:23:59.999 align:start position:0%
price. And then the expiration Ledger is reset and, that in this way essentially the 12 months, that it was already there is burned and you're charged for the entire 18 months of the market rate. Now the advantage to this is again I think for a network Health perspective and to prevent capability we want to be charging as close to Market rates whenever we can. And so in this system you always can be charging you know the market rate. However it's kind of a poor ux. Because you're burning this amount it seems, that like in something like this should be probably strictly additive. And so I guess as far as the the two interfaces are concerned what are your thoughts as two manual rent bumps, that was a lot I just want to go back to a point you made earlier quickly about temporary entries so. If I understand correctly you are suggesting, that the temporary entries. If we do go for Ledger expert for expiration Ledger the
00:24:00.000 --> 00:24:59.999 align:start position:0%
the contract should be the same, that is we're kind of like letting go of the whole short medium long terms and making it the exact same interface as restorable Ledger entries yeah I think. So now the one thing, though is I initially said they were fit for security uses. But then I caught myself. Because right. Now any user can bump any entry, which means, that even. If you have say like a kyc entry, that's only supposed to last 128 ledgers and you initially set its expiration alleged to be 128 ledgers in the future a malicious user could bump, that using the manual operation. And so I think for security purposes we still need to, that still needs to be enforced at the contract level whereas like in this case the contract would need to embed their own like TTL inside the temporary entry just. Because you have this arbitrary bump I mean I guess we could have a flag, that's like no bump to
00:25:00.000 --> 00:25:59.999 align:start position:0%
Temporary entries but, that might be adding too many flags at this point. Because the current interfaces anyone can bump anything okay thanks for answering, that question going back to Auto bumps for a second I do think you know I've been thinking about the the wallet and dApp experience and what they need to think about in terms of State expiration and it does seem like autobump doesn't negate the need for wallets and dapps to actually be attentive to The Ledger expiration times and to act on, that either either by like suggesting the user to do like a manual bump or to initiate a manual bump. So it it does seem like Auto bump has this like implicit Behavior to it in, which we're like extending Ledger entry expression times. But it doesn't
00:26:00.000 --> 00:26:59.999 align:start position:0%
actually it like adds complexity to the system. But it doesn't actually remove complexity from the implementation of of like products it makes things a bit less expected and predictable. So I think yeah go ahead well I think the the auto bumps serve a very specific purpose or at least they were initially designed to serve a specific purpose and this is the shared state. So from your example like like a dApp or like a wallet right this is not a good example for auto bumps. Because you have a particular balance entry, that you care about and no one else really cares about. And so for a wallet perspective say you want your wallet to live for one year the correct answer is not just to keep you balancing it with via Smart contract. So you Auto bump it or rather just to do a manual operation. And then to bump, that by a year the use case for autobums is more for contract instances and contract wasm particularly wasm is a
00:27:00.000 --> 00:27:59.999 align:start position:0%
difficult one. Because you can have a single wazzin blob, that many different contract instances use and the question is who pays for, that was and blob. And so essentially by having like this Auto bump feature, that every user who touches it is required to pay a little bit and you can essentially like share the cost of you know this contract and this contract instance or this contract code in this contract instance among all the users who are using it. And so I think the other bump feature was specifically for these kind of shared resources, that there is no clear owner for instance like usdc it'd be kind of a crappy interface. If you know 10 000 people used it a day. But there was no Auto bump. And then the 10 000 in first person had to go pay rent. Because it got archived or something and he was just the or they were just the The Unlucky user, that drew the Short Straw. And so I think there definitely still is a pretty strong use case for auto bumps for these sort of different entry types. But I agree for something like a
00:28:00.000 --> 00:28:59.999 align:start position:0%
adapter a wallet you would still need you know this manual operation in addition to audit bumps oh would you recommend a ledger entry, that is a user specific like a balance or an LP position to be Auto bumpable or not Auto bumpable I mean I think it just depends on the contract implementation I don't think it needs to be Auto bumpable the same way, that contract instances and stuff do. But I don't see like a downside I think the general thinking is the the kind of design model I had in my head is, that extending a lifetime should never be negative, that like this is why it's not good for security cases. Because anyone can extend any lifetime such, that it should always be a positive action it cannot be a negative action. And so I think you know I think there was talks last
00:29:00.000 --> 00:29:59.999 align:start position:0%
time of exposing an Autobahn flag and I think this probably makes the most sense, that you know contract instances and contract wise in code you don't have this option whenever you deploy it it has it must be Auto bumped. But then for any other key you create I think you probably just give the option too or or should we just. Because there's also like I mean you could also say, that the contract instances and contract code are Auto bumped and nothing else is. But then you can kind of get into this sticky situation where there are still contract types, that have shared States. So for instance. If you can think like a a like a DEX right and there's like this asset pair, that start as an entry and many different people are like viewing or trading, that asset pair you wouldn't want one individual to be stuck with the bill. And so I think, that there are still I still think Auto bump is a powerful primitive and I think it should probably be enabled by default just. Because it's the safest route. But I think you know having a option to turn it off especially for personal State like balances is probably
00:30:00.000 --> 00:30:59.999 align:start position:0%
a good idea. And so now, that I've talked for a little bit I think the answer your question I would probably say for something like a token balance I would probably say no to the auto bump Behavior just. Because it's something, that will probably like the lifetime of, which will be explicitly managed by a wallet. Because I agree it's kind of needed the one thing, that maybe like I'm thinking about there is, that. So for the first version we can do you know something like, that right like I would imagine, that maybe in the future we would want to have like maybe something, that kind of Auto Tunes over time. Because like in the example of like the you have like a very you know active contract the wazam is basically going to be used multiple times per Ledger and you end up with really reaching your
00:31:00.000 --> 00:31:59.999 align:start position:0%
limit fairly quickly and then. When the limit is reach you actually are backed into, that situation where you know some users are going to bump some are not going to bump like basically the first one in The Ledger all right and the bumping. And then yeah and, that and also like the. If the what. If the blob is fairly large maybe, that auto bump on the ends up adding quite a bit of cost to each individual transaction. If it's you know bumping like for a good number of Legends let's say you know 100 ledgers or something to keep in mind Garen there is a question about the mechanics of Autobahn from Paul can you expand a bit on. When does Auto bump actually occur yeah. So the current strategy is, that autobump occurs on all access, which is
00:32:00.000 --> 00:32:59.999 align:start position:0%
both read and write access how this works under the hood is, that you know in addition to having the expiration Ledger stored in The Ledger entry we also have like this kind of shell entry type, that is used for read-only Access. So for instance like for your wasin blob they're only access read only and essentially to modify a ledger entry in The Bucket List you have to rewrite the entire entry at the top level bucket and so. If we were to modify the you know the entry or the the expiration Ledger directly in The Ledger entry you'd have to rewrite the entire wasin blob. And So to avoid this we have like this kind of shim entry type, which is just an expiration Ledger extension. And so this entry is very small it's literally just a key. And then the new expiration Ledger. And so we use this entry type whenever we want to bump a read-only entry. And so in the wasm use case even
00:33:00.000 --> 00:33:59.999 align:start position:0%
though you're only reading the wasm. Because we are Auto bumping you do have to do a small write but, that right is very small it's the minimal size right you can do. And so we are implicitly turning every read into a read write. But we're not rewriting the entire entry we're reading the entire entry. And then writing a very small entry with the new expiration Ledger. And so under the hood, that's how we implement it efficiently rent bumps for both reads and writes. So I do want to touch on something, that you mentioned before, which is the question of with should bumping like pumping in general should, that be a flag it does feel like you know last week we talked a bit about you know very various Oracle usage
00:34:00.000 --> 00:34:59.999 align:start position:0%
patterns and you know we got to inclusion where sometimes the contract developer would want to limit or give an upper boundary to. When a ledger entry should exist and making it non-bumpable is a very kind of like easy way to do, that the question is like does, that over complex the system well. So I guess we have two different questions here I think we have the question of do we want to does the entry Auto bump. And then does the entry allow bumps. And so I think from an implementation standpoint these would be very easy to implement we could just you know thrown a Flags field on The Ledger entry and Define a couple of flags I think the question is is this you know making the user experience too complex. And so what this would look like is I
00:35:00.000 --> 00:35:59.999 align:start position:0%
think this would only be explicable to Temporary entries I think or Okay. So let's talk about the Autobahn flag first I think the Autobahn flag whether or not this item is auto bumped on access it could be an optional flag for both temporary and restorable entries. But I think it should be strictly enforced for contract wasm and contract instances. Now for the should you allow bumps at all I think we could allow, that flag but, that flag could only be used for temporary entries. And so this would be the use case where you either have like a security use case where you want this to do exactly some number of ledgers or the Oracle use case where the thing is only valid for five minutes or whatever and then. If you set this flag. Then this entry would not receive Auto bumps and it would also not be bumpable by the manual operation and. If you tried to bump it it would just fail or Panic or something like, that. Now you would only want this black on temporary entries. Because restorable entries and unique entries should always be bumpable
00:36:00.000 --> 00:36:59.999 align:start position:0%
they they don't necessarily need to always have Auto bombs. But they should always be bumpable just. Because they are important information, that needs to be saved, which is why they are subject to being sent to the state expiration node. When they expired. And so just. Because the design parameter for this entry is, that it's supposed to be important live State there should be no use cases where you wouldn't want to bump or wouldn't want to allow a unique or restorable entry to be bumpable. And so I think, that is the the most technically complete kind of interface it's very you know feasible from a core perspective the only question is. If that's too much complexity at the end user foreign I think, that as you described this. If it creates more Divergence between temporary entries and restorable entries. Then probably for the sake of Simplicity I say we shouldn't include it especially. Because this is something, that the contract developer can program for in
00:37:00.000 --> 00:37:59.999 align:start position:0%
their contract I will say. If we go this route and say. If we I think. So so. If I'm understanding it correctly we don't want Divergence. And so we'd have an autobump flag true false. But we would not have the no bump flag I think. If we go this route we need to be very clear in our documentation, that the expiration Ledger is not absolute. Because if you know have like a temporary entry self-delink entry. And then there's a field called expiration Ledger it's a reasonable assumption, that The Ledger would be deleted immediately after, that ledger and. If we don't have this no bump flag, that's not the case. Because a malicious user could you know invoke the operation and bump any temporary entry even. If autobump is disabled. And so you know I think, that's a fine interface decision to make, that all entries are bumpable. But I think we need to make, that very clear just from a ux perspective so, that we don't have security issues with temporary entries being used improperly
00:38:00.000 --> 00:38:59.999 align:start position:0%
any questions or comments on this what do people think about should we have the bump bumpable flag I'm just going to type a big thing. But I could actually say it I think I would vote for having not having an Autobahn flag. If possible just having a fewer configuration options for the different types of storage like there's two different types of storage and they act differently I think, that's fine to explain and understand but. If you have to say okay there's restorable entries and they act in this way unless you enable auto bump on them. And then restore volunteers like you know what I mean there's like four different configurations. Now versus just two. So Paul are you talking about the bumpable flag or the auto bumpable flag sorry yes sorry pumpable okay
00:39:00.000 --> 00:39:59.999 align:start position:0%
yeah I think, that makes sense to me it's just not everything is bumped. But just. So I understand are we still interested in the Autobahn flag or do we also want to Nick say, that and just say everything I bumps as well I definitely don't think, that everything should be Auto bumpable by default yeah it does sound like for from a completeness perspective having both of these flags kind of like covers most use cases I mean one thing we can do is just like. If we don't want to expose the bumpable flag. Now we can just Define it in the XDR and defined in core just not exposing the SDK. And then turn, that on V2. If we want to you know have a more complicated ux Matrix for storage, that would at least give us future
00:40:00.000 --> 00:40:59.999 align:start position:0%
proofing or like I think actually. If we just. If if we were defining Auto bump anyway. Then we need to have a Flags field for the album flag. And so we can easily extend it later. And so I think you know the bumpable versus no bumpable, that could be a V2 feature. But I think unless there's like a strong strong one for it. Now we can just leave, that off for. Now and just have the autobump flag I'm not sure, that the Autobahn really benefit the network it might benefit the ease of use. But not necessarily the network itself right sure I guess the you are having more IO churn for sure I guess the there didn't seem to be a great solution for the contract instance and contract was in the case without Autobahn. So I think you know it for it
00:41:00.000 --> 00:41:59.999 align:start position:0%
might be useful to say maybe like I think those two entries need something like Auto bump or need some way of essentially like automatically or pooling rent together in some way. Because that was kind of the the the thing we were trying to think about with the contract wasm is okay you have like four or five different instances, that all have the same was and back end how do you equitably and equally share the load. When it comes to expiration ledgers I think, that my the direction, that I'm thinking about is, that. If someone was uploading a contract I want to see his hotels involvement in the future on maintaining, that and not. So much on leaving it and assuming, that it will be funded by
00:42:00.000 --> 00:42:59.999 align:start position:0%
someone else like I want to see like a activity right on, that contract from the owner and not by someone else, that might be inherently using it oh fishes, that contracts don't have an owner like who doesn't can be reported by anyone and you pay anyone. So you know. If you have a the creditable implementation, that people are using there is no clear owner yes someone might have written in the code. But anyone can deploy it and yeah it's kind of hard to track to anyone and demand you know maintenance from someone I mean you could expect it. But it's like the Canada universally demand this
00:43:00.000 --> 00:43:59.999 align:start position:0%
yeah I feel like there's kind of the the concept of like a library contract is definitely a big thing on Ethereum. And so it feels like an unfair expectation to write something like a dApp implementation, that has you know, that's, that's more of a library function and expect the library owner to be the sole payer for, that even, though other contract instances are using, that Wiseman making money off the wasm it just seems weird, that. If five you know different contract instances are using and profiting of wasm, that only the you know entity, that originally deployed the wasm should be on the hook for paying for it. So I would argue, that. If someone is using something for free. Then he shouldn't instead you should either pay the author right and generate money right out of, that right or basically copy it in from now on he would be the owner of, that
00:44:00.000 --> 00:44:59.999 align:start position:0%
piece what do you mean by copy, though I feel like, that's why it works for network perspective. Because now you have like five identical copies of the same ones yeah the current design is exclusively like encouraging sharing the code. Because we don't want to store it tens or hundreds of duplicate version drops. Because it's the biggest lecture entries by far. So you don't want to encourage code to paste and you know fragment system or anything and again wait I think I went around here. But in dth for all like a lot of the things I implemented by proxy patterns and Stuff Etc again a lot of instances are referring to say another single contract instance and you know you do not deploy your own like copy of unislove and you do not maintain it instead of it you can just refer to a proxied instance of unisol, that is yes
00:45:00.000 --> 00:45:59.999 align:start position:0%
getting updated by someone probably. But I don't think it's fair to say, that a Do Your Own Thing yeah I know I would be happy to see some incentive model Incorporated here in is part of, that. But you know maybe, that's something, that we need to you know like think separately of the countries do you have any thought about, that yeah I think we should allow contracts to be detached from a concept of an owner you know for for a lot of legal reasons this is better for some contracts you know like the uni swap contracts are not upgradable they don't have an owner
00:46:00.000 --> 00:46:59.999 align:start position:0%
and and, that's the way they want it like it exists like, that for a reason right. So I don't think we should kind of like own over emphasize this concept of an owner, that's a good argument Aaron do you think it would be reasonable to constrain Auto bump to these entries, which are the ones, which are going to benefit from the most. So not all ledger entry is not contract data. But just the contract code and the contract instances yeah I think contract code contract instances for sure. But I think there's also the reason why I wanted to Define autobump is I think there's also areas where contract data should be Auto bumped. So like for instance like. If you have a tax. And then there are like entries on the DEX, that many users of the DEX use the Audubon feature is kind of just so, that these entries are kind of like paid for by all users instead of you
00:47:00.000 --> 00:47:59.999 align:start position:0%
know one unlucky user. So I think there's still there are definitely use cases where you'd want something like an autobump primitive for contract data. However I could definitely see a use case where this is not the default as a flag where contract instances and contract wasm receive bumps by requirement. And then data defaults to false. But you can turn it on. If you want. Because I still think there are definitely use cases where you'd want something like this for contract data I don't know. If it's a common case. But there definitely are significant cases I think it's a very common case like effectively everything in a contract, that is like a global variable or Global state, that doesn't specifically adhere to to an account like you know like in a liquidity pool the actual like pool values are global and need to be bumped we have been discussing this for some
00:48:00.000 --> 00:48:59.999 align:start position:0%
time what about explicitly change the data to the contract instance like do we anticipate some short case where you know the data is kind of global. But it's not once per contract or something. If not. Then maybe we just for the small Global state of the contract in the instant century. And then you know it's subject to the same Ultra bomb obviously. Because if you think about it it's kind of a part of the contract, that's another consideration here I mean I guess the question is how monolithic do we want to be right. Because the issue with, that is, that the. So say the advantage is, that like. If you have like a a contract instance, that's like has a very large amount Global state every call must bump all, that state whereas like I said for instance where the liquid equals. So there's like a poor implementation, that has like 10
00:49:00.000 --> 00:49:59.999 align:start position:0%
different like asset swaps or something. And so even. If you only access one you have to bump the other nine implicitly whereas. If you don't title and you keep everything individual. Then you only have to bump the entries you actually touch. Now I don't know like in practice contracts might be small enough, that this isn't really a big issue it definitely does simplify some things and decreases our right amplification as well. Because you'd only need to write at most one bump per contract instance. So this effectively goes sorry go aheadly I think it's difficult to distinguish between Global and individual. Because like they're definitely going to be contracts, that have like nexuses like where it's not Global. But maybe it involves like multiple participants. So I don't know like where do we draw the line between something should be a shared cost versus
00:50:00.000 --> 00:50:59.999 align:start position:0%
being an individual cost seems too difficult to do, that yeah other than like the really General cases of contract code should definitely be a shared cost like in for contract data I don't think we can make, that call like I think the country developers do foreign ly think the safest option is just to default this to true. And then maybe expose a flag just. Because I feel like the benefit or the drawback to Auto bumping something where. When it shouldn't be Auto bumped is very minimal. Because the whole idea is, that for the bump to be a small bump such, that. If lots of users are accessing it over time it grows. But for instance right. If you have a balance it you know and you say view balance and you have to pay 10 extra ledgers of rent on the one entry I mean, that will literally like, that might be less than like an Excel I'd be measured in strips. And so I feel like the the drawback to not having autobombs can be high. If you
00:51:00.000 --> 00:51:59.999 align:start position:0%
have a shared you know Global Entry, that you forget to bump. And then for the entire lifetime of, that contract you have to manually bump it it's expensive I feel like, that's a much worse failure case than the other case where you sometimes have to pay a small additional fee to access some entries leaning into, that is there is a really a big downside to not requiring Auto bump like what's not having the option not making configurable oh yeah just like requiring it like universally yeah I personally think there's I think there's not a I think there maybe is one negative use case we have Oracle data, that should really only live for like five minutes or ten minutes it would be really annoying. If you know especially. If this data is accessed often in like a DEX sort of environment I think, that would be really annoying. If you access this thing. So much in a five minute lifetime such, that it always lives for like six hours or
00:52:00.000 --> 00:52:59.999 align:start position:0%
like two weeks after you know even, though you should only do five minutes. So I think for like very short-lived entries and like Oracle data there's a strong use case outside of, that I don't see a super strong use case for for not just repairing oil pumps everywhere see are you suggesting setting into true for every type of Entry or just for restorable entries. Because like for the Oracle use case, that you're describing Garand wouldn't they use temporary entries for, that yeah yes I think. So I think right. Now we are talking about a unified interface where both restorable and temporary have the same expiration Ledger interface and both have the same Auto buttons yeah I feel like contracts put in contracts avoid the issue, that you're describing you know where you accidentally continue to rebump a temporary entry by I guess like moving on to using like a
00:53:00.000 --> 00:53:59.999 align:start position:0%
contract, that uses a temporary for five minutes I guess how would people be referencing, that like an hour from now well no so, that's the issue right. So it's, that no one is referencing it. Now and for. Now but in, that five minutes enough people referenced it such, that it was aren't bumped. So much, that it will live significantly longer than five minutes. So the issue is no one will access it within an hour. But it will live you know an hour two hours or. However long. So this I think what you're just I guess. So what. If Auto bumping wasn't didn't bump it a fixed amount what. If it bumped up to some CAP I mean it does bump up to some cap. Because we have a a maximum rent balance for a maximum expiration Ledger due
00:54:00.000 --> 00:54:59.999 align:start position:0%
to you know issues we discussed earlier. And so there is a CAP it's just, that the issue is, that you know, that CAP will make sense for some entries. But doesn't make sense for others. So for instance like. If the CAP is six months and in the extreme case you have an oracle entry, That was supposed to last five minutes, that lasts up to the CAP of six months, that's a lot of wasted fees okay. So it sort of feels go ahead sorry it's sort of. So this is the last thing I'm going to say I think on this it sort of feels like Auto bump okay we could argue, that what Obama should be configurable per entry. But it also sounds like the amount of this thing should be Auto bumped before. If we're making a configurable it's not really a binary yes or no it's more like an amount
00:55:00.000 --> 00:55:59.999 align:start position:0%
like as a contract developer the contract developers really probably like the person who's gonna know best like how long. If this is going to get bumped it needs to be bumped for or I guess it's some combination of the contract developer and the user. But yeah just I'm a little skeptical of allowing contracts to Define you know like access fee amounts right. Because if a contract was like oh you know like even. If it's not malicious it's just like a stupid design it's like hey this should have six months and it's like a you know a thousand or it's like a you know 10 kilobyte entry, that you know requires a six-month bomb just to access, that's a pretty poor ux yeah I'm like this is just the slippery slope of configurability like the more I yeah in some ways maybe we need you know to Paul's Point around like the not making things configurable
00:56:00.000 --> 00:56:59.999 align:start position:0%
maybe this is the trade-off we make it okay like temporary entries might get bumped more than what they need to they might live around a little bit longer but, that's a trade-off for for all these other reasons okay. So we're at time it definitely sounds like everyone's on board with Ledger exploration moving on from rent balance there are the questions of, which flags we expose and there is the question, that Dima raised about revisit revisiting the the idea of contract attached state, which we decided against in the context of metadata but, that wasn't yeah it wasn't a landslide of
00:57:00.000 --> 00:57:59.999 align:start position:0%
opinions there. So maybe it's worth rethinking about, that. So again it does sound like you have a lot to work with right. Now in terms of Ledger exploration I would try to summarize this question about, which kind of Flags We've we've just debated and and starting a discussion around, that to give people some asynchronous time to think about, that and Dima. If you could kind of like resurface this idea of kind of like contract attached state and the the benefits of, that both in this context and in others I think, that could be beneficial Garen is there anything else you know, that sounds good okay Dima I saw you unmuted for a sec there yeah I just want to just say, that
00:58:00.000 --> 00:58:59.999 align:start position:0%
yeah. When I have some time oh right I guess is, that my nature with the contract data you said through the time yeah. So I don't know. If you have enough time to get it shipped into the one even everyone is on board. But yeah I need to think a bit more about this awesome okay thank you everyone it's been a great session see y'all next week
WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:59.999 align:start position:0%
All right I'll get started well welcome everyone today I'll be speaking about an update to CAP 67, which is the unified events cap. So so a recent change was made where with the goal of reaching feature parody with regards to Memos in seller classic and more specifically you know batch payments within a transaction with different mxed operation Source accounts are possible in classic and this is a way you can make batch payments to an exchange. So we wanted to make similar functionality possible in in sorun. So the the proposed solution is to add an extension function called transfer with memo to the Token standard. If if you want to support memos. So the function takes an optional optional memos for both the from and two addresses and will emit transfer event with a new topic, that is a vector of memos this this format does need to be discussed, though there's
00:01:00.000 --> 00:01:59.999 align:start position:0%
there's been a lot of discussion on this recently so. If we don't expect, that the memos to be filtered on. Then it should actually be in the data field. But putting putting this into the data field will be a breaking change, which is why I didn't initially update the proposal for, that. Because the data field is currently an integer instead of a map. But one of the options is is making, that breaking change and updating, that and the the other option is to split the. If you want do want the top memos to be filtered on is to split, that Vector two separate memo fields in the topic. So we leave the the memos in the topics and allow them to be filtered on there and instead of. So those are updates to the transfer event the other alternative is instead of emitting the transfer event we ALS we emit a we still we emit the transfer event as it exists today. And then we emit an additional transfer with memo
00:02:00.000 --> 00:02:59.999 align:start position:0%
event with the memo information so. If you care about the memo you consume, that event as well and there's also an alternative proposal in the thread I just linked from Dima to First Class the MOX count type, which is a a different proposal from the transfer with memo a methodology, that that the CAP defines. So yeah there I know there's a lot of opinions on what we should do here I don't know. If anyone wants to chime in maybe Lee or dimma yeah I guess I could quickly present my option option and recap some points I've made in the discussion Regarding why do I think, that my proposal might be a better option than an explicit operation code transfer with memo and the gist of The Proposal is, that
00:03:00.000 --> 00:03:59.999 align:start position:0%
we make it. So from the client standpoint the mark addresses do not look like do not require any special treatment meaning, that you can create an st Val, that represents for example Max classic account and pass it as out to the contract and and changes are only necessary on the contract side similar to to the transfer memo option right the changes are necessary on the contract side to support this. Because if you're are talking about the approach or we literally have a transfer with memo function we are kind of reinforcing the memo concept, that is really problematic. Because like we have two different identifiers
00:04:00.000 --> 00:04:59.999 align:start position:0%
identifiers, that the users need to care about and we put it deeper into the protocol into the token standards. And then we just expect down Downstream systems to handle it in a special way to and. If represented this singular address I am not sure. If this is going to apply like. If if this has worked for example I don't see why wouldn't like changes to the trade they constantly get issues with memers they could in theory build an M address and it back into memo and g account, that doesn't happen. Because that's very cumbersome and, that Reise on a lot of parties to do the right thing at the same time whereas in my proposal the only thing, that a v would need to do is well convert a Spring key into an address, which is like
00:05:00.000 --> 00:05:59.999 align:start position:0%
call library function. So there is no need to somehow specially handle this and we are kind of reinforcing a good pattern of using Max accounts and the the main benefit of Max accounts is, that they have a canonical single address representation and in general the user doesn't need to worry about what exactly it is only s it's they need to worry about is, that this is their address of their exchange account quote unquote and they need to deposit money to this account and this is the only thing, that they we need to worry about. So it's kind of the gist of the proposals there are definitely information details, that could be discussed. But I guess there was lot of position on the whole idea of doing doing this, which honestly I'm still not
00:06:00.000 --> 00:06:59.999 align:start position:0%
sure sure I understand the reasons behind. Because again again like the transfer M proposal is like doubling down on the memo hack, that has been existent in the protocol for a. While so yeah, that's kind of my side process here with your propos proposal to you you have a transfer function, that would take two different types right it would either it could either take the address object is exists today or among yeah address object Bally I'd say the main requirement is, that on the client side Al XDR should deal with SC addresses, that represent maxed accounts can introduce a concept of Max contracts as well, that's the main requirement. Then
00:07:00.000 --> 00:07:59.999 align:start position:0%
everything else is going into the realm of the implementation details and things may be adjusted for quity. If I think, that's needed like. But yeah in my original proposals area was, that since the contract types are they by the nature of our San design they're polymorphic right or they variant types basically right. So you can pass a general Val, that represents one of the about of types to the contract, which means, that the layer of the contract interfaces there shouldn't be an issue for a contract to be able to accept not only add dress object in a function. But either an address object or maxed address object. So is one way this can
00:08:00.000 --> 00:08:59.999 align:start position:0%
be implemented U on like the level of the Cross contract interraction there is of course definitely some stuff, that needs to be figured out how how exactly do this DEC how do we represent this interface at all. But I don't think it's impossible to achieve especially given, that it's kind of a narrow use case I think it could be a separate interface, that you implement. If you want to support MOS and this interface will be compatible with the interface of the Regional token contract. Because again protocol itself does not enforce any type restrictions Ty restrictions happen at the contract implementation layer. So I think yeah can do, that and the same goes for the event trade like we can do different things
00:09:00.000 --> 00:09:59.999 align:start position:0%
about the events like we can a transfer event we can like ex option and kind of in favor of, which is another benefit of this approach is, that since we have Max accounts in the protocol what we could do is we could have a an additional field in the event structure itself for through this mares I don't know. If it is too wasteful or not. But at least this is an option, that we have, that does not require imited additional EV and also does not mess up index and for those who don't care about M. So you could have a set Vector of the multiplex Tes addresses in the event, which would generate automatically. So yeah, that's kind kind of one of the options, that this opens up as well. So the the vent point you mentioned like, that's a, that's be done with either approach right where we
00:10:00.000 --> 00:10:59.999 align:start position:0%
separate the max ID well it depends on versus goes like in the transfer memo option it has to go through the normal EV data structure. So it will either belong to data or topics with a protocol based approach we have an option of putting it into a sort field, that is not data and not a topic Oh you mean the XDR yeah in the XDR yes so. If you don't care about this you will not see it at all and this event will quite a normal transfer event you interesting okay so, that that would require some Downstream like some work in RPC to expose, that additional information right. Because I don't think RPC currently exposes of course everything course I mean sure any option requires like some sort of additional work somewhere yeah and
00:11:00.000 --> 00:11:59.999 align:start position:0%
yeah it's not an argument Pro con it's not a pro con of any approach yeah sorry I Wasing wanted to say something yeah. So I think like we're discussing a few different small features, that all come together into sort of these two different ways, that we could implement this. And so I think the the four different features we're talking about is you know should the should it be an M address or should it be a g address plus a memo in the input. And then the same thing for the output the event. And then we're talking about should we reuse the transfer function the existing transfer function or should we separate the this use of M memers into a separate
00:12:00.000 --> 00:12:59.999 align:start position:0%
function. And then should we reuse the transfer event or should we separate them into the transfer with memo event like each of these these things are like separate decisions, that we can make I think some of what you've alluded to De about you know the SDK and you know what would this look like in the S Cas. So I understand I think. When we look at from the the host interface yes all values, that come into a contract are a Val. So it's a little bit like. If you're a Java programmer and you're familiar with like object you know you can make your parameter coming into a function as object or you can make it some type and map to different types. So you know we could add nstk type, that is I'm not sure what we' call it any address I'm just going to use the term any address right. Now and address could be this MX
00:13:00.000 --> 00:13:59.999 align:start position:0%
address or it could be the address we have today. So the MX address is an M address and the address we have today is a g or a c. And so we we could do, that. But we're sort of adding a lot more, that I think every token developer is going to be exposed to and going to have to learn about and, that's like, that's a barrier to entry, that's a a potential point of confusion. So why I think, that every token developer will be exposed to this is. Because we can't change we can't have, that token interface be something, that's extendable. So like right. Now the SDK has. If the function name is the same. So right. Now there's this token interface in the S an SDK and there's tooling built around, that by folks like. If you go and have a look at like the OpenZeppelin contracts and stuff. So there's like tooling being both buil bu up around
00:14:00.000 --> 00:14:59.999 align:start position:0%
being compatible with it and we can't have like another trait, that provides a different type of transfer function, that has the same name and has a different type as the input so, that means, that somebody, that goes and implements you know one of those traits their code might not be compatible with someon the other type of the trait. If we have two complete different traits there sort of like it's very difficult it's not really simple in Rust to you know rust doesn't have this concept of like overloading functions. So it's it's just yeah it's a little bit difficult to figure out how do we actually make, that work. So I think like the develop like a narrative around like what a developer experiences. So like on the surface I think like yeah this you know trying to build everything into one function overloading the type these are all nice engineering these all seem like nice engineering decisions. But the narrative, that actually results in for the
00:15:00.000 --> 00:15:59.999 align:start position:0%
user of the SDK is is reasonably complicated like they need to learn about more things whereas most custom token developers probably don't need to know about MX addresses they probably don't need to know about memos like a lot of what we're adding for like Marx address and memos is for yeah I guess some specific UK US cases where the token Developers for those specific U cases would need to be aware of them yeah I'm yeah I I've made a lot of like I've answered a lot of these questions in the discussion. But yeah I can answer again and I'd really like to challenge a lot of your points. Because well first thing is the developer complexity I think, that transfer memo option introduces developer complexity
00:16:00.000 --> 00:16:59.999 align:start position:0%
arguably more developer complexity just in different place and this place is St like wets or block explorers and I would argue, that complexity in these places is much worse. Because instead of you know doing this once or a few times in places like OpenZeppelin implementations for example right you actually ask every developer to to either resort to just present in this transfer with memo operation literally transfer with memo and you know we we kind of just repeat the mistake of building them into protocol and we'll have funds lost. Because people just forget to paste memo in the operation or you have a requirement for the downstream developers to have the same level of knowledge of what M must do. But the work around again. If we like in case of the SDK. If there is at least some
00:17:00.000 --> 00:17:59.999 align:start position:0%
possible way of building a samean solution for the developers, which we can discuss this rain firms options for the downstream it's basically up to them for the interpretation and I don't see a sane way of standardizing this and making sure, that you know every time address is an address but. If you encounter transfer res memo somewhere. Then this is not an address this is Max address and then. If you encounter an M address and user tries to make a transfer you actually need to resort to this different function and you need to break it down I think it's more complicated than messing a bit with r traes and the solutions, that are proc involve like what. If token interface accepted just a valve for examp example, which is
00:18:00.000 --> 00:18:59.999 align:start position:0%
that's type safe. But you know token implementation just makes a check. If it is address in one case Max address in the other case. Then like we don't even need separate traes or it just move the check out of SDK autom magical type conversion into into the contract project there just one option we we can think about more my point is, that like I feel like fundamentally this is just a better place to put complexity. Because it's higher upstream and ultimately not many people need to deal with it especially like you know. If it's always once and something like opens up implementations. But but also sorry one last thing I wanted wait like one last point I wanted to make I don't agree, that most of the token developers should not care about memos I think they do. Because because like they probably would hope their
00:19:00.000 --> 00:19:59.999 align:start position:0%
tokens being listed on the exchanges at some point sooner or later. So I think in either option they will kind of need to worry about this in one way or another either by implementing transfer B memo or Max Account Support. So yeah again I'm not sure. If we are saving something here specifically yeah yeah. So I think one thing I think was interesting you you talked about the you this this idea, that like we want to be able to encourage madress use and we we we don't want to go down, that past where you know the two were separated. Because that was you know a mistake it was easy to forget them I think we're conflating some of the layers here so. When esses were added there were actually two problems to solve. So the first problem was people not forgetting the the the memo and
00:20:00.000 --> 00:20:59.999 align:start position:0%
displaying, that information. So displaying, that combined information in just a single identify, that they could just copy and paste the wallet. Now the second problem, that had to be solved was how do we get, that information into the existing transaction XDR the way, that we settled on solving, that second piece is actually largely an implementation decision so, that first piece is like the actual problem the problem we were trying to solve the user problem the second piece was the implementation is just implementation details and the way we tried to solve, that at the time, which was largely led by just the existing structure of the XDR was was to put, that memo ID next to the account inside this moxed account structure. Because we could actually do, that in a way, that didn't break a lot of the existing XDR. But the goal was really just to get the memo alongside each of these places where where where we needed to basically you know attach to a destination or attach it to the source. So I think like, that
00:21:00.000 --> 00:21:59.999 align:start position:0%
last part is largely an implementation decision the Sol the problem, that was originally solved with MOX accounts is, that first part you user copy and pasting a single ID into their wallet and I don't like both of the solutions we're discussing here they both satisfy, that first problem, which I think is like you know. If we're going to continue to support MOX accounts, that's like, that's sort of the thing we have to make sure, that continues to get solved and otherwise like a lot of the those details about you know does the wallet split apart the M address wallets already need to know about M addresses. So like, that's not a big deal does the or you know they could potentially we could make the SDK easier at you know doing, that for them but, that's largely an implementation detail detail. So I guess I'm not really seeing like the connect with like how adding continuing to propagate passing
00:22:00.000 --> 00:22:59.999 align:start position:0%
those. Because I mean in the XTR like to be really clear like in the XTR an M address is still two parts the Melo is still separated from the you know the public here sure totally. But the thing is, that again this transfer with memo we have like two separate contract call arguments and yeah of course it is an implementation detail. But this is a detail, that will cause a lot of bad decisions Downstream wait again one decision can we talk specifically about what decisions are. Because because something I just want to highlight is, that Downstream systems will want to filter these events by the G address not by the no no I'm not talking about the events I'm talking about the C and again to make me Point Clear like I I'm not even insisting on any specific solution to the events I'm talking specific about how is this function
00:23:00.000 --> 00:23:59.999 align:start position:0%
being called I'm arguing, that transfer mem is harmful. Because well you have a functions, that has four arguments and downstream. When you're building this call and trying to get user input for it you basically have two options one option is do what you do every other time for every other function, which is like have a strict matin of a cous to input function arguments what we are proposing here with transfer memos is, that well in this particular case they will need to somehow somehow either take M address as user input and split it into two parts or I don't know I'm not sure how this is supposed to look like and then. When we are talking about R, which again kind of us with a function arguments we're in exactly the same position where we kind
00:24:00.000 --> 00:24:59.999 align:start position:0%
of need to in this particular case we need to do something about like this mapin of arguments, that is normally one to one and you know your code would be hey. If I say C address a render is a string key. But here is say no no no like you you cannot render this as a string key you actually need to render first and second argument as this m spring key. So you know I doubt this will work and this is honestly like how again I made this point before like we can say, that transaction memo is an implementation detail just renders destination as an M address of memo plus was a destination account like, that that works on paper. If you have a single payment. But we will don't do, that. Because it's like very unintuitive and error prone for
00:25:00.000 --> 00:25:59.999 align:start position:0%
were you there yep just I don't know. If George would like to George is typing some things in here it sounds like he has some perspective to share don't know. If he wants to join the stage
00:26:00.000 --> 00:26:59.999 align:start position:0%
sure yeah I mean I can just reiterate what I put in the chat, which is pretty similar to Demus points I think, which is, that having separate functions for this and separate parameters for this just reintroduces the problem at the user layer, that you mentioned Lee, which is, that people forget their memos right. So by by separating it out you're just reintroducing, that possible confusion it seems to me, that. If we want first class support for custodial wallets, which is like the main user of M addresses. Then you would want first class support and transfers right and you would want, that to also be present in custom tokens. If if a token doesn't support M addresses right. Then you can't use it in the exchanges, which you know might be fine and might be a decision, that the token makes. But I feel like we would want to encourage, that rather than make it this very distinct opt in thing, that you have to
00:27:00.000 --> 00:27:59.999 align:start position:0%
have a separate function to handle you mentioned, that people will forget the memo but. If an exchange is still displaying in M address and the wallet is receiving, that M address I mean. If the wallet doesn't know what to do with an M address it's going to failed there's going to be some sort of error but. If a wet knows what to do with an M address it's going to unpack it. So I'm I'm I'm trying to figure out where is the forgetting the memo paste coming in you're suggesting we would continue to use the M string key. But not actually propagate, that at anything. But the UI layer layer correct, that's the layer, that's like the input into creating a transaction, that's the layer where this the M address came about to solve the problem I see. And so the application developer would be responsible for
00:28:00.000 --> 00:28:59.999 align:start position:0%
dissecting the M address rather than just passing it along along yep now, that's, that's not without a cost I acknowledge. But I think the cost like this is we're discussing tradeoffs yeah and the cost in the solution I'm proposing is just using new version of spring key library. Because again it just Maps into address. But arguably things are a bit more complex on the con side, which yeah yeah I'm not sure. If it's necessarily significantly more complex could you elaborate on what you mean by an M address maps to C address SC address sorry SC. So so basically. When because like what I'm proposing like I
00:29:00.000 --> 00:29:59.999 align:start position:0%
want V to just wait do what they are likely doing. Now right it would paste the destination as a string key and you can just take this string key convert it into address SC well pass it to the co and this is like like this is what you have to do. Now to support sound transfers right and the only you will need to do to support Max transfers as well updates the libraries things will magically work it is a lot less work and a l a lot less chances of just doing something weird yeah what what typically happens in I think most SDKs George you can probably correct me. If I'm wrong about this or. If it's not most. But I think what most stks do is you give them a string. So you give them the M address or the G address. And then the SDK is the
00:30:00.000 --> 00:30:59.999 align:start position:0%
one, that builds the MOX account on the classic side yeah whatever the XDR types are. So most applications don't build the XDR types themselves. But right, that's the point right. But say like do we make contract codes with just like strings and even Z like you still know need to know, which contract code to make right. Because your safe default should probably be transfer. But then or maybe the saet default should be transferred with memo but, that's not always going to succeed. So there is definitely some L of projects, that needs to happen even like ticated build calls just from the strings. But I'm not even sure. If that's the case right. Because conversion and building actual call is different and here like we are mixing the conversion and building the call. Because
00:31:00.000 --> 00:31:59.999 align:start position:0%
currently again for each and every contract call the conversion is one to one you have like two string keys and an amount and this is argument to the transfer and here is say well here is like three two string keys and amount. But you need to M this to four arguments and sure, which where it should happen this is like how capsulated in it decay or V care about it or whatever client. So I don't know maybe there is some good Solutions there. But but I feel like it's kind of hacky and error prone. And then again as I pointed in the discussion like BL explorers may displays is differently as well so. If you were to check your transactions there you would be confused confused yeah. So I think we're I think like where these different ideas were optimizing for different things. So I think the proposal for transfer with
00:32:00.000 --> 00:32:59.999 align:start position:0%
memo is like very simple to add to the SDK and the experience or the knowledge about what you or what you need to know about, that extension of a token is really isolated. And so I think like there are benefits to developer onboarding for contract development in the Stellar e system. Because of, that. And then I think the the idea, that you're presenting is optimizing for there being one interface a single interface people need to learn with. So people need to know about this stuff. So there's more for them to maybe know up front as a contract developer. But once they know, that information it's a single interface. And then an added benefit of this is, that in things like stks or at, that client level you do still get like, that single view of the M address whereas with the First with the the first proposal we don't you don't get like the single view. Because clients
00:33:00.000 --> 00:33:59.999 align:start position:0%
need to unpack things. So I think like these two different approaches are optimizing for different things trading off different things I think something, that you mentioned before deer is like we don't we haven't really figured out exactly what the SDK would look like and what the experience would be there maybe we need you know assuming, that we have all the time in the world Maybe we need to actually do a spike there to make sure, that we don't have any unknowns and, that we have a Clear Vision for like what the contract developer experience is going to be yeah sure I agree, that prototype wouldn't hurt. Because yeah I want to make make sure this makes sense aswi
00:34:00.000 --> 00:34:59.999 align:start position:0%
I think maybe we could discuss the event portion of this. So like I earlier I listed out like there were like four micro decisions we sort of need to make within these decisions and one of those decisions or two of those decisions is around the event. So I think we've talked quite a lot about like the input the trans the transfer function versus the transfer M function. And then you know should it be G memo and M on the inputs for the outputs I don't think I saw in your proposal, that they would be an M address. So so is are both proposals consistent, that whatever the event is it would both the event would contain a g. And then a separate memo yeah say don't have a strong opinion we have options and the tradeoffs are are like much less clear to me. Because well we could easily
00:35:00.000 --> 00:35:59.999 align:start position:0%
put M addresses right there in the event and look the same. But the concern is, that it will confuse consumers, that don't care about htic rate, which is why we could do either separate field, that is protocal defined for this MOS, which has again a down set of B it's a protocal change and also it adds with four bites to the all the events events just kind of bad. But of course you can just do whatever you would do with transfer this memo by just you know providing ways of getting the mar from and. And then you can do basically anything you want to structure and I think U you know there is no difference between transfer this memo and my proposal the scenar we. If the all resarch to split Max address into two
00:36:00.000 --> 00:36:59.999 align:start position:0%
parts. Then they very can cze whatever events we think are the best trade of yeah the only distinctive thing about my proposal, that we had this yet another option of having M thiz as a parallel field to topics and data. But other than, that I don't have to strong opinion on what the event should look like yeah to's not here today. But I did run this by him yesterday like what u based off what he knows from a product perspective would it make more sense for exchangers to you know filter on or exchangers or anchors to filter on, that m versus a jress his opinion was a Gess I think we haven't I don't think we have like like a survey of how people typically filter
00:37:00.000 --> 00:37:59.999 align:start position:0%
but existing exchanges would be given, that historically there were just a separate G and a memo are probably filtering on G address oh yeah totally I kind of like we know status quo, that most exchanges use G+ memo MH. But they also don't use the events, which is what we're discussing here. So there may be honestly an opportunity here like to kind of. If people need to migrate anyway you can kind of try to promote well something maybe a bit. But I think for non- exchangers memos maybe kind of know to deal this. So right. But exchanges would be using Horizon and Horizon typically uhit imits in air quotes Things based on account. So I think, that's where like the the
00:38:00.000 --> 00:38:59.999 align:start position:0%
idea, that okay like exchangers they currently collect these events affects payments VI account. So we should probably just keep doing the same thing in a mid Advance buy account, which I think makes sense. Because like these topics are intended to be things, that you could filter on and so. If I'm running a system, that's catering for n number of events coming in to one g. But you know across like all those n number of moed IDs like it from a scaling perspective it's difficult how would you use an RPC to filter on all of those things you wouldn't you'd be just You' just have your system ingesting everything relating to the geod. And then splitting them out oh I see Nico he's on yes. So yeah I guess you guys were talking yeah there's the you know number
00:39:00.000 --> 00:39:59.999 align:start position:0%
two right, that is the do you want to expose the G Plus memo or the m in the output right as an event I think maybe we should maybe talk first about number four in your list right, that is is it a single transer event or is it multiple events. Because I think you know like they are like implications in this context like the the way I'm thinking about this is, that the tradeoff is, that so. If we have separate events the nice thing about it is, that we keep the transfer events for the standard token contract as a you know fairly clean like it's the same thing we don't you know mess with it the problem with, that approach where you have two events is, that you need to do some sort of
00:40:00.000 --> 00:40:59.999 align:start position:0%
reconciliation from The Exchange side. If people send. So assuming, that like the The Exchange requires memo. But for some reason somebody sends money and forgets to specify the memo they actually need to reconcile the those two event streams in some way basically to find the U the transfers, that happened, that don't have a you know transfer with memo equivalent and, that sounds a bit complicated to do I mean it's doable it's just like you have to to kind of you do this kind of reconciliation on a per transaction basis basis. So yeah. So like I don't know what you guys think about about this one. Because yeah. If if we can get one event, that's the the other ation I starting a discussion right, that was I think the
00:41:00.000 --> 00:41:59.999 align:start position:0%
the type of problem we we have in, that context is how does extensions to a standard on as an event right like how do they look look like right. Now like we're saying maybe we keep adding topics to the the event the problem I see with doing, that. If we're not like super careful on on on, that is you know as you add more extensions to like how does, that work like you you know to keep you know they are basically Index right in the in some arrays arrays so. If you only implementing one of those extension you know extension number 20 does, that mean you have to put a bunch of voids you know like in the you know up to 20 basically, that's, that the type of things, that happens in, that World and yeah who manages the the namespace I mean the name spacing
00:42:00.000 --> 00:42:59.999 align:start position:0%
here being you know just a number. But there's a bit of, that question, that kind of pops up in this case it probably makes sense I think you mentioned this it it would make sense for the topics to be in the data field not the topics and you would you. If you turn the data into a map. Then you only look look for what you care about I age extending topics definely the extensions would have their own name of sort like maybe here would say memos or something and then, that's a string and then, that's how you can. Then have a custom data attached to it yeah, that's the cleanest option Le is, that what you were is, that what you were thinking too yeah my point was just to move them out of the topics in general I mean I think in general the memo probably don't belong there like
00:43:00.000 --> 00:43:59.999 align:start position:0%
filtering on the memo IDs is is getting a little too granular like we these topics are meant to be like things, that you could filter on, that you know most people are going to want to filter on. Because I think maybe George you can confirm this like I think the RPC or different systems have to index these topics. So like we've already got four topics like once you start adding more topics it's like PE yeah yeah I agree I don't think the memo needs to be a topic. But the and for the the same reasons, that you know Nik is mentioning too like having to add in all these voids like. Now we got six topics. And then like you get to like 20 topics eventually. When there's even more extensions this doesn't really it doesn't create an interface, that's intuitive at all I think. But I think this is like one of the nice things about the separate event the transfer of memo event is it's it's
00:44:00.000 --> 00:44:59.999 align:start position:0%
very very explicit like you know. If you want to ingest. If you're looking at an operation and there's a transfer and a transfer of memo and you care about me. If you don't care about memos for starters you just don't care about, that other event and. If you do care about memos. Then you can adjust, that one instead for, that operation. But like I was saying, though Exchange is care about both. Because they need to to basically ingest those transfer with no MOS. Because that's basically how they can you know through tech support or whatever they can return the money to the the sender yeah. So for them like there is this other issue, that's I feel like this has come up like. So many times, that there's this other issue, that okay. Now we have two events. So then they have to figure out not double processing them and I think we shouldn't not do this for, that
00:45:00.000 --> 00:45:59.999 align:start position:0%
reason. Because we should solve, that problem or we should have a story for, that for how to solve, that problem it doesn't necessarily have to be solved today. But it's something we should solve whether, that be through like I think you know we've talked about ideas like an invocation ID. So then you just say like okay like this this memo and this other transfer they're in the same invocations I don't double count the other one or something like, that yeah unfortunately I feel like invocation w't help here like there was an unrated discussion, which is unrated. Now about like what. If a token wants to charge s during a transfer for example and you'll have an for example to transfer events, that are actually separate transfer events in
00:46:00.000 --> 00:46:59.999 align:start position:0%
general I feel like. If we were to come up with a good event linking mechanism it would be almost exactly the same thing as converting data into map like almost. Because what I think we could do is say like for the event we can say what is some special link in a and you know you can think of every event with assembly in caned is a part of the same event. But at this point honestly like why don't just make data map. Because I think, that's the only way really to prevent double counter is like you have unambiguous way to say like you know these two events are actually describing the same things, that has happened. So maybe map is really it's right way to go
00:47:00.000 --> 00:47:59.999 align:start position:0%
sure so, that's what it's I guess we can maybe discuss it offline we have maybe 10 minutes left. But the one of the questions to answer is do we either use a new event or make a breaking change to the data field and make it a map is, that right does, that sound good I guess have a question I don't know how like consumers of those things you know what they do. But like. If if it was an extra field at the end of the event, that is added would, that really like like be a much of a breaking in change basically like like people are just using the index zero whatever like
00:48:00.000 --> 00:48:59.999 align:start position:0%
you know the I mean it's already an array right. So like at theend you talk about the topic or the data data the data isn't an array right. Now it's a an integer, that's the breaking change like making yeah, that's a pretty big breaking change yeah I thought it was like we had a vector already originally it was a map. And then I think it got changed to a vector. And then I think got changed to an integer okay. So yeah we have, that question to answer and for the the transer memo prop like function
00:49:00.000 --> 00:49:59.999 align:start position:0%
versus Deus proposal I think the yeah, that what we want to do is prototype what, that looks like in the SDK to see what it looks like so, that that's the I'm guessing I think, that's the status of, that question, that is number three right go ahead, that's, that's a suggestion yeah I mean, that that's I think it's a good idea my suggestion is. If we're leaning towards, that approach we absolutely should spike out what the develop contract developer experiences. Because I don't think for something, that I suspect will be as intrusive to the developer experience on the contract developer side I don't think we should trade, that off for the benefit of clients not having to unpack an M address. Because I think both of these things obviously have a cost there's a cost saying to wallet clients you have to unpack an M address to put it into the to the SDK. But
00:50:00.000 --> 00:50:59.999 align:start position:0%
but, that's yeah I think I would prefer, that cost cost over over MX addresses and and Mos sort of intrusive intrusively entering every to implementation. But this is why to SP it I think just you know to see how bad, that that is and to see what surprises there are I think you know one thing, that came up in the the chat was in the past we've been concerned about M addresses accidentally being having balances stor against them and, that's one reason why we wouldn't want to add the M address to the main address type it it just be. So easy for a developer just to store balances against the M. But then, that that's not accessible to to use by the G address requiring or or something okay the I noticed, that even with this
00:51:00.000 --> 00:51:59.999 align:start position:0%
proposal, that problem could still occur. If I'm understanding correctly like this m address will be convertible with Val so, that it can be used as an input. And so in theory you'd be able to store it as well oh I mean same can be said about transfer like you can do whatever sorts of stupid things in your contract like nothing PR you from storing some inders in storage for no reason yeah. But there's like. If something's going to become a thing, that people shouldn't do we shouldn't set them up to fail. But but also yeah, that's what I wanted to say like. If you're concerned about this like you can just make it impossible to make this keep prevent people doing themselves you know I'm not sure we can with the existing the way the rust type system is. So I mean obviously
00:52:00.000 --> 00:52:59.999 align:start position:0%
we can do anything we want. If we Val implementation no no we can do this as the host level yeah I'm not saying it's SDK level can just make it it fail. But these types are just a contract type right is is MX address cont it is a c Val like we can say like. If your leer key SC contains a maxed address you just will not trate it right totally totally do we could do, that. If it's anywhere in the anywhere like. If it's inside a VC or. If it's inside like a nested type or something like, that is, that what I'm saying yeah yes we we have similar checks to what like we make sure, that you you know cannot create AAL or C out of non-representable types and stuff like this. So defin have validations like, that not in the St specifically. But you know they pretty
00:53:00.000 --> 00:53:59.999 align:start position:0%
flexible in host in terms of like restriction types. So really I was thinking about this as well like. If you're concerned, which is a valid concern like you know to not shoot yourself in a EG like you still will be able to probably extract an integer and. If you really want to you will be able to store like this for for some reason. But the same can be said about transfer Le you need to be very intentional about doing something bad and we can prevent the most obvious mistake, which is we just write in Mar address window storage this is preventable okay. So we, that that's question number, that's, that was the decision number three we still have to figure, that out
00:54:00.000 --> 00:54:59.999 align:start position:0%
like a lot of complexity it feels like we're discussing a lot of complexity just yeah yeah just to improve, that one little thing at the CL okay. Then for decision two I think we agreed, that we should, that the output should have G Plus memo right instead of just the mend mend and I guess one is tied to three right like the G Plus versus M for input. So I guess, that's something we still need to answer it are there any we're running out of time are there any other open questions sounds like we still have some stuff to discuss
00:55:00.000 --> 00:55:59.999 align:start position:0%
yes I guess the question on the yeah single event or not right, that's number four by going back to this right like this one is it could be a I mean it's a breaking change potentially right. If it's a for like the downstream you know like like like systems right, that are ingesting I don't necessarily think, that it's U like as a breaking change like, that it's not necessarily like insurmountable right like it's a basically it's like kind of like the type of thing you do in you know in in many situations we can allow like we have to allow in the token standard, that it's either a single amount or a or or some or something something else right. And then you have to dynamically Downstream. Then U do something different
00:56:00.000 --> 00:56:59.999 align:start position:0%
based on either the type or or or. If it's you know I guess it's the type yeah, that that tries this yeah you're talking about making the data field a map right. If it was a map or or a vector yeah yeah I yeah we we've discussed this a bit internally there doesn't seem it is a breaking change. But there doesn't seem to be much opposition to this we can bring this back up. If if it helps in this case yeah I think to like the way we would do this. If if this memo thing is a separate Set and an extension we'd make a change to set 41 as well as the extension. So like SE 40 ideally we'd change set 41 so, that it says, that the field could be an amount or or a map, that contains an amount yeah so, that. If folks are developing they they're not they don't feel like they need to use just the
00:57:00.000 --> 00:57:59.999 align:start position:0%
amount. If the for non-mo transfers yeah mount as an integer fi definitely has to be a part of the standard like we cannot decate it. Because the historical events have it already already yeah would remove it we just say, that both all right. Now we're out of time. So this there's are there any other questions or concerns right. Now continue adding them to the chat and we can address them and we'll continue continue any any open questions in the GitHub discussions all right thank you
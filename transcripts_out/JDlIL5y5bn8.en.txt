um the first is partial stay archival
um the first is partial stay archival
cap 62 and then in memory uh sorbon
cap 62 and then in memory uh sorbon
cap 62 and then in memory uh sorbon
state for cap 66 and no Tom I will never
state for cap 66 and no Tom I will never
state for cap 66 and no Tom I will never
stop using in Centric Linux distro cool
stop using in Centric Linux distro cool
stop using in Centric Linux distro cool
so I guess um before I get started guess
so I guess um before I get started guess
so I guess um before I get started guess
a little bit of background uh so
a little bit of background uh so
a little bit of background uh so
protocol 23 um is kind of where the
protocol 23 um is kind of where the
protocol 23 um is kind of where the
rubber is going to start hitting the
rubber is going to start hitting the
rubber is going to start hitting the
road uh as far as state archival is
road uh as far as state archival is
road uh as far as state archival is
concerned so um kind of some you know
concerned so um kind of some you know
concerned so um kind of some you know
background to you when soron launched we
background to you when soron launched we
background to you when soron launched we
of course had the interface for state
of course had the interface for state
of course had the interface for state
archival with rent um and all those sort
archival with rent um and all those sort
archival with rent um and all those sort
of stuff with the intention that
of stuff with the intention that
of stuff with the intention that
eventually entries that have run out of
eventually entries that have run out of
eventually entries that have run out of
rent will be archived and then removed
rent will be archived and then removed
rent will be archived and then removed
from validators uh in order to free up
from validators uh in order to free up
from validators uh in order to free up
space so you don't have you know the
space so you don't have you know the
space so you don't have you know the
issues um that come with large amounts
issues um that come with large amounts
issues um that come with large amounts
of state that have to be
of state that have to be
of state that have to be
maintained um and so um that's kind of
maintained um and so um that's kind of
maintained um and so um that's kind of
where we're going now today um the
where we're going now today um the
where we're going now today um the
interface is such that you still pay
interface is such that you still pay
interface is such that you still pay
rent you still have to issue restores
rent you still have to issue restores
rent you still have to issue restores
and all the sort of things things um but
and all the sort of things things um but
and all the sort of things things um but
the data is not actually yet removed
the data is not actually yet removed
the data is not actually yet removed
from
from
from
validators um and so that's where we're
validators um and so that's where we're
validators um and so that's where we're
going so initially uh the plan was for
going so initially uh the plan was for
going so initially uh the plan was for
protocol 23 was to have what we're
protocol 23 was to have what we're
protocol 23 was to have what we're
calling full State archival and in full
calling full State archival and in full
calling full State archival and in full
State archival what happens is uh
State archival what happens is uh
State archival what happens is uh
entries um once they have uh run out of
entries um once they have uh run out of
entries um once they have uh run out of
rent uh be removed from the live State
rent uh be removed from the live State
rent uh be removed from the live State
and then they are added to this
and then they are added to this
and then they are added to this
temporary data store called the hot
temporary data store called the hot
temporary data store called the hot
archive um and the hot archive is still
archive um and the hot archive is still
archive um and the hot archive is still
maintained by all validators but it's
maintained by all validators but it's
maintained by all validators but it's
just a separate database that just
just a separate database that just
just a separate database that just
maintains um entries that have been
maintains um entries that have been
maintains um entries that have been
recently archived uh the thinking being
recently archived uh the thinking being
recently archived uh the thinking being
was that eventually this hot archive
was that eventually this hot archive
was that eventually this hot archive
would become full and when the hot
would become full and when the hot
would become full and when the hot
archive is full what you would do is you
archive is full what you would do is you
archive is full what you would do is you
would create um a Merkle tree of that
would create um a Merkle tree of that
would create um a Merkle tree of that
data validators would maintain the
data validators would maintain the
data validators would maintain the
Merkel rout and then delete all the um
Merkel rout and then delete all the um
Merkel rout and then delete all the um
information in the hot archive and then
information in the hot archive and then
information in the hot archive and then
you just repeat this process iteratively
you just repeat this process iteratively
you just repeat this process iteratively
so essentially you um evict entries from
so essentially you um evict entries from
so essentially you um evict entries from
the live state to the hot archive state
the live state to the hot archive state
the live state to the hot archive state
eventually that hot archive cach will
eventually that hot archive cach will
eventually that hot archive cach will
become full and then you'll actually
become full and then you'll actually
become full and then you'll actually
delete and remove those entries from the
delete and remove those entries from the
delete and remove those entries from the
validator and then um the restoration
validator and then um the restoration
validator and then um the restoration
process once an entry has been archived
process once an entry has been archived
process once an entry has been archived
in this way if it no longer lives in the
in this way if it no longer lives in the
in this way if it no longer lives in the
validator there's like a Merkel style
validator there's like a Merkel style
validator there's like a Merkel style
proving scheme um to which you are able
proving scheme um to which you are able
proving scheme um to which you are able
to restore an entry back to the live ler
to restore an entry back to the live ler
to restore an entry back to the live ler
state so that's kind of what we consider
state so that's kind of what we consider
state so that's kind of what we consider
full state archival which is where
full state archival which is where
full state archival which is where
entries actually get deleted from
entries actually get deleted from
entries actually get deleted from
validators but um thinking about this
validators but um thinking about this
validators but um thinking about this
problem a little bit more and looking at
problem a little bit more and looking at
problem a little bit more and looking at
the current metrics of soron um it seems
the current metrics of soron um it seems
the current metrics of soron um it seems
that we're still a little too early for
that we're still a little too early for
that we're still a little too early for
this full C archival I think long term
this full C archival I think long term
this full C archival I think long term
if you look at um smart contract
if you look at um smart contract
if you look at um smart contract
platforms that have large amounts of
platforms that have large amounts of
platforms that have large amounts of
State there are significant issues with
State there are significant issues with
State there are significant issues with
maintaining all that state you have um
maintaining all that state you have um
maintaining all that state you have um
lots of um you know Hardware
lots of um you know Hardware
lots of um you know Hardware
requirements on a network like salana to
requirements on a network like salana to
requirements on a network like salana to
maintain large amounts of cashes and
maintain large amounts of cashes and
maintain large amounts of cashes and
then um you have a networks like
then um you have a networks like
then um you have a networks like
ethereum that don't have large hard
ethereum that don't have large hard
ethereum that don't have large hard
requirements but they're very slow just
requirements but they're very slow just
requirements but they're very slow just
due to maintaining these very large
due to maintaining these very large
due to maintaining these very large
databases so long term at scale I think
databases so long term at scale I think
databases so long term at scale I think
it's still very important to have the
it's still very important to have the
it's still very important to have the
full State archival solution where
full State archival solution where
full State archival solution where
entries are deleted from validators and
entries are deleted from validators and
entries are deleted from validators and
then restored VI proving schemes um but
then restored VI proving schemes um but
then restored VI proving schemes um but
the reality of the situation is we're
the reality of the situation is we're
the reality of the situation is we're
not quite there yet and I think that
not quite there yet and I think that
not quite there yet and I think that
currently there is less than a gigabyte
currently there is less than a gigabyte
currently there is less than a gigabyte
of soron state currently live stellar
of soron state currently live stellar
of soron state currently live stellar
and so going through all these um hoops
and so going through all these um hoops
and so going through all these um hoops
and adding all this complexity um for
and adding all this complexity um for
and adding all this complexity um for
this proving scheme just to delete a
this proving scheme just to delete a
this proving scheme just to delete a
small amount of data isn't really uh
small amount of data isn't really uh
small amount of data isn't really uh
worthwhile at this point and so that's
worthwhile at this point and so that's
worthwhile at this point and so that's
why for protocol 23 instead of going the
why for protocol 23 instead of going the
why for protocol 23 instead of going the
full cival route where we actually
full cival route where we actually
full cival route where we actually
delete entries we are doing something um
delete entries we are doing something um
delete entries we are doing something um
called or I'm proposing something called
called or I'm proposing something called
called or I'm proposing something called
partial SE archival and this is what cap
partial SE archival and this is what cap
partial SE archival and this is what cap
62 um kind of explains and so in partial
62 um kind of explains and so in partial
62 um kind of explains and so in partial
State archival what we do is we do kind
State archival what we do is we do kind
State archival what we do is we do kind
of the first half of the full state
of the first half of the full state
of the first half of the full state
archival so we still maintain uh two
archival so we still maintain uh two
archival so we still maintain uh two
different databases on the validator you
different databases on the validator you
different databases on the validator you
have the live bucket list which contains
have the live bucket list which contains
have the live bucket list which contains
all of your live state which is the um
all of your live state which is the um
all of your live state which is the um
The Ledger that exist today and then you
The Ledger that exist today and then you
The Ledger that exist today and then you
still have a um what's called the hot
still have a um what's called the hot
still have a um what's called the hot
archive which is a cache of recently
archive which is a cache of recently
archive which is a cache of recently
archived entries and so what you would
archived entries and so what you would
archived entries and so what you would
do is that whenever an entry runs out of
do is that whenever an entry runs out of
do is that whenever an entry runs out of
rent it would be evicted and removed
rent it would be evicted and removed
rent it would be evicted and removed
from the live State and added to this um
from the live State and added to this um
from the live State and added to this um
hot archive database now the key
hot archive database now the key
hot archive database now the key
distinction here with partial stay
distinction here with partial stay
distinction here with partial stay
archival is even though you still remove
archival is even though you still remove
archival is even though you still remove
things from the live bucket list and add
things from the live bucket list and add
things from the live bucket list and add
them to to the hot archive you never
them to to the hot archive you never
them to to the hot archive you never
actually delete the hot archive um the
actually delete the hot archive um the
actually delete the hot archive um the
hot archive never becomes full such that
hot archive never becomes full such that
hot archive never becomes full such that
uh the entries are never actually
uh the entries are never actually
uh the entries are never actually
removed from validators and so um it's
removed from validators and so um it's
removed from validators and so um it's
partial St archival because you are
partial St archival because you are
partial St archival because you are
still kind of storing live state in one
still kind of storing live state in one
still kind of storing live state in one
database and storing archive state in a
database and storing archive state in a
database and storing archive state in a
different database but you're not
different database but you're not
different database but you're not
actually removing any state from
actually removing any state from
actually removing any state from
validators and so I think my current
validators and so I think my current
validators and so I think my current
proposal would be in uh protocol 23 to
proposal would be in uh protocol 23 to
proposal would be in uh protocol 23 to
implement the partial state archival
implement the partial state archival
implement the partial state archival
with the intention of later on in the
with the intention of later on in the
with the intention of later on in the
future extending this to the full State
future extending this to the full State
future extending this to the full State
archival solution um the only reason is
archival solution um the only reason is
archival solution um the only reason is
is that I
is that I
is that I
think that um for the uh you can the the
think that um for the uh you can the the
think that um for the uh you can the the
size at which the um the hot archive
size at which the um the hot archive
size at which the um the hot archive
becomes full and becomes deleted is
becomes full and becomes deleted is
becomes full and becomes deleted is
configurable and so I think um we could
configurable and so I think um we could
configurable and so I think um we could
do something reasonable such as we could
do something reasonable such as we could
do something reasonable such as we could
Implement on this St archival solution
Implement on this St archival solution
Implement on this St archival solution
but uh we could set the the capacity of
but uh we could set the the capacity of
but uh we could set the the capacity of
the hot archive to something very high
the hot archive to something very high
the hot archive to something very high
like 50 GB such that it would take a
like 50 GB such that it would take a
like 50 GB such that it would take a
long time and a lot of network activity
long time and a lot of network activity
long time and a lot of network activity
uh to actually start deleting State and
uh to actually start deleting State and
uh to actually start deleting State and
then you know if the network was to grow
then you know if the network was to grow
then you know if the network was to grow
that much such that we had 50 gigabytes
that much such that we had 50 gigabytes
that much such that we had 50 gigabytes
of archived uh sorb on state then it
of archived uh sorb on state then it
of archived uh sorb on state then it
would actually make more sense to start
would actually make more sense to start
would actually make more sense to start
deleting State and requiring proofs for
deleting State and requiring proofs for
deleting State and requiring proofs for
all the operational benefit that we get
all the operational benefit that we get
all the operational benefit that we get
there um and so that's kind of um the
there um and so that's kind of um the
there um and so that's kind of um the
current proposal of 62 is we're going to
current proposal of 62 is we're going to
current proposal of 62 is we're going to
still maintain all information on the
still maintain all information on the
still maintain all information on the
validators but we're just going to move
validators but we're just going to move
validators but we're just going to move
archived information from one database
archived information from one database
archived information from one database
uh to a different database um now the
uh to a different database um now the
uh to a different database um now the
reason that we want to do this this
reason that we want to do this this
reason that we want to do this this
separation of archive State and um live
separation of archive State and um live
separation of archive State and um live
state is that it actually opens up a
state is that it actually opens up a
state is that it actually opens up a
large number of optimizations and so
large number of optimizations and so
large number of optimizations and so
that's what we get into in cap 66 which
that's what we get into in cap 66 which
that's what we get into in cap 66 which
is uh inmemory sorbon State and so uh we
is uh inmemory sorbon State and so uh we
is uh inmemory sorbon State and so uh we
can because we have the system where the
can because we have the system where the
can because we have the system where the
live State uh or the live bucket list
live State uh or the live bucket list
live State uh or the live bucket list
holds all classic information and all
holds all classic information and all
holds all classic information and all
live soron information and we have a
live soron information and we have a
live soron information and we have a
completely separate database that stores
completely separate database that stores
completely separate database that stores
all the archive State now because of the
all the archive State now because of the
all the archive State now because of the
rent system and because of the uh the
rent system and because of the uh the
rent system and because of the uh the
way that we do write fees you know where
way that we do write fees you know where
way that we do write fees you know where
a write fee is a function of the total
a write fee is a function of the total
a write fee is a function of the total
size of the bucket list we actually have
size of the bucket list we actually have
size of the bucket list we actually have
a way to put a soft limit on the amount
a way to put a soft limit on the amount
a way to put a soft limit on the amount
of live soron State at all times the
of live soron State at all times the
of live soron State at all times the
reason being is that you know with the
reason being is that you know with the
reason being is that you know with the
um the current bucketless size if you
um the current bucketless size if you
um the current bucketless size if you
were to add enough life State such that
were to add enough life State such that
were to add enough life State such that
you go beyond the target bucka size
you go beyond the target bucka size
you go beyond the target bucka size
rights become very very expensive such
rights become very very expensive such
rights become very very expensive such
that the network um users are
that the network um users are
that the network um users are
incentivized to allow entries to run out
incentivized to allow entries to run out
incentivized to allow entries to run out
of rent and become archived and so
of rent and become archived and so
of rent and become archived and so
because of the way our fee system works
because of the way our fee system works
because of the way our fee system works
uh we have a way to essentially have a
uh we have a way to essentially have a
uh we have a way to essentially have a
soft limit on the amount of State in the
soft limit on the amount of State in the
soft limit on the amount of State in the
light bucket list at all times um and so
light bucket list at all times um and so
light bucket list at all times um and so
what I'm proposing is to change that fee
what I'm proposing is to change that fee
what I'm proposing is to change that fee
slightly um such that instead of the
slightly um such that instead of the
slightly um such that instead of the
sorbon right fee um corresponding to the
sorbon right fee um corresponding to the
sorbon right fee um corresponding to the
size of the entire live leer of both
size of the entire live leer of both
size of the entire live leer of both
classic and sorbon entries it only
classic and sorbon entries it only
classic and sorbon entries it only
applies to the life soron entries and so
applies to the life soron entries and so
applies to the life soron entries and so
essentially the uh the buckus target
essentially the uh the buckus target
essentially the uh the buckus target
size instead of being a buckus size
size instead of being a buckus size
size instead of being a buckus size
would change to just be the uh the life
would change to just be the uh the life
would change to just be the uh the life
soron uh Target size and I think this is
soron uh Target size and I think this is
soron uh Target size and I think this is
much more fair uh given that classic
much more fair uh given that classic
much more fair uh given that classic
entries don't actually have to pay rent
entries don't actually have to pay rent
entries don't actually have to pay rent
yet and so it's a little unfair that
yet and so it's a little unfair that
yet and so it's a little unfair that
adding classic entries actually changes
adding classic entries actually changes
adding classic entries actually changes
the WR fees and the rent fees for sorban
the WR fees and the rent fees for sorban
the WR fees and the rent fees for sorban
um and especially as the network exists
um and especially as the network exists
um and especially as the network exists
today classic State dominates sorant
today classic State dominates sorant
today classic State dominates sorant
State size and so changes in sorant
State size and so changes in sorant
State size and so changes in sorant
usage don't actually really affect soron
usage don't actually really affect soron
usage don't actually really affect soron
right fees rather changes in classic
right fees rather changes in classic
right fees rather changes in classic
usage affect soron right fees and so by
usage affect soron right fees and so by
usage affect soron right fees and so by
changing the The Bucket List Target size
changing the The Bucket List Target size
changing the The Bucket List Target size
to a sorbon state instead of just all
to a sorbon state instead of just all
to a sorbon state instead of just all
total State um we have a much more fair
total State um we have a much more fair
total State um we have a much more fair
fee system but what that also allows us
fee system but what that also allows us
fee system but what that also allows us
to do is to prioritize live sorup on
to do is to prioritize live sorup on
to do is to prioritize live sorup on
state um above arive state so what do I
state um above arive state so what do I
state um above arive state so what do I
mean by that so if we change the uh the
mean by that so if we change the uh the
mean by that so if we change the uh the
way that we calculate fees to only look
way that we calculate fees to only look
way that we calculate fees to only look
at sbon size we can use the fee system
at sbon size we can use the fee system
at sbon size we can use the fee system
to enforce a maximum amount of Life
to enforce a maximum amount of Life
to enforce a maximum amount of Life
State at any time so for instance we
State at any time so for instance we
State at any time so for instance we
could set the target soron State size to
could set the target soron State size to
could set the target soron State size to
1 Gigabyte and then the fee system would
1 Gigabyte and then the fee system would
1 Gigabyte and then the fee system would
ensure that there's not much more than 1
ensure that there's not much more than 1
ensure that there's not much more than 1
gigabyte of Life Sor on state at a given
gigabyte of Life Sor on state at a given
gigabyte of Life Sor on state at a given
point now you could maybe you know go a
point now you could maybe you know go a
point now you could maybe you know go a
little bit above that if people are
little bit above that if people are
little bit above that if people are
willing to pay expensive fees
willing to pay expensive fees
willing to pay expensive fees
um but the way that the fee growth works
um but the way that the fee growth works
um but the way that the fee growth works
is that um you know you are reasonably
is that um you know you are reasonably
is that um you know you are reasonably
capped to a small amount of state and so
capped to a small amount of state and so
capped to a small amount of state and so
because we have the system where the
because we have the system where the
because we have the system where the
amount of live sorb on state at any
amount of live sorb on state at any
amount of live sorb on state at any
given time is fixed what we can actually
given time is fixed what we can actually
given time is fixed what we can actually
do is just store all sorbon state in
do is just store all sorbon state in
do is just store all sorbon state in
memory and not have disk access at all
memory and not have disk access at all
memory and not have disk access at all
and so that's the current proposal um in
and so that's the current proposal um in
and so that's the current proposal um in
cap 66 is to prioritize all live uh
cap 66 is to prioritize all live uh
cap 66 is to prioritize all live uh
soron state in memory uh and this is
soron state in memory uh and this is
soron state in memory uh and this is
made possible because we store live
made possible because we store live
made possible because we store live
soron state in one database and archived
soron state in one database and archived
soron state in one database and archived
state in a different database and so by
state in a different database and so by
state in a different database and so by
splitting the state into two separate
splitting the state into two separate
splitting the state into two separate
databases we can very easily just
databases we can very easily just
databases we can very easily just
iterate over the the live database and
iterate over the the live database and
iterate over the the live database and
store all that sorab on state in
store all that sorab on state in
store all that sorab on state in
memory and so that's kind of what's
memory and so that's kind of what's
memory and so that's kind of what's
Happening um behind the scenes um as to
Happening um behind the scenes um as to
Happening um behind the scenes um as to
what the uh the validator is doing um
what the uh the validator is doing um
what the uh the validator is doing um
now we're able to do this because of the
now we're able to do this because of the
now we're able to do this because of the
maximum soron State size if we didn't
maximum soron State size if we didn't
maximum soron State size if we didn't
have this and if
have this and if
have this and if
sorban uh LIF state was able to grow
sorban uh LIF state was able to grow
sorban uh LIF state was able to grow
unboundedly this would be a very
unboundedly this would be a very
unboundedly this would be a very
dangerous optimization because
dangerous optimization because
dangerous optimization because
validators might run out of ram um but
validators might run out of ram um but
validators might run out of ram um but
because of the St kival system we can
because of the St kival system we can
because of the St kival system we can
actually fix the amount of Life State
actually fix the amount of Life State
actually fix the amount of Life State
and so there's no runaway R risk and so
and so there's no runaway R risk and so
and so there's no runaway R risk and so
we can um very reasonably store all
we can um very reasonably store all
we can um very reasonably store all
soron state in memory um and so there
soron state in memory um and so there
soron state in memory um and so there
are some changes we need to make to the
are some changes we need to make to the
are some changes we need to make to the
uh developer experience um and the user
uh developer experience um and the user
uh developer experience um and the user
experience to make this possible um so
experience to make this possible um so
experience to make this possible um so
first we are going to to change uh some
first we are going to to change uh some
first we are going to to change uh some
of the resource types A little bit um So
of the resource types A little bit um So
of the resource types A little bit um So
currently today we only have one read
currently today we only have one read
currently today we only have one read
resource which is read bites and read
resource which is read bites and read
resource which is read bites and read
entries um and this assumes that all the
entries um and this assumes that all the
entries um and this assumes that all the
information you're reading is on disk
information you're reading is on disk
information you're reading is on disk
and so what we're going to do uh or what
and so what we're going to do uh or what
and so what we're going to do uh or what
cap 66 proposes is to split this into
cap 66 proposes is to split this into
cap 66 proposes is to split this into
two different resource types so they're
two different resource types so they're
two different resource types so they're
going to be an explicit inmemory read
going to be an explicit inmemory read
going to be an explicit inmemory read
resource and then an explicit um on disk
resource and then an explicit um on disk
resource and then an explicit um on disk
read resource now the reason we're doing
read resource now the reason we're doing
read resource now the reason we're doing
this is that even though all sorbon
this is that even though all sorbon
this is that even though all sorbon
state is or all life soron state is held
state is or all life soron state is held
state is or all life soron state is held
in memory sorbon contracts can still
in memory sorbon contracts can still
in memory sorbon contracts can still
access classic State and classic State
access classic State and classic State
access classic State and classic State
needs to be on disk now because classic
needs to be on disk now because classic
needs to be on disk now because classic
entries aren't subject to State archival
entries aren't subject to State archival
entries aren't subject to State archival
they have the runaway Ram uh risk and so
they have the runaway Ram uh risk and so
they have the runaway Ram uh risk and so
we can't store classic entries in memory
we can't store classic entries in memory
we can't store classic entries in memory
and so um sorbon uh contracts will still
and so um sorbon uh contracts will still
and so um sorbon uh contracts will still
have to pay disk fees for for classic
have to pay disk fees for for classic
have to pay disk fees for for classic
State that's exist additionally we're
State that's exist additionally we're
State that's exist additionally we're
only storing live state in memory and so
only storing live state in memory and so
only storing live state in memory and so
if you access archive state for example
if you access archive state for example
if you access archive state for example
a restore operation then you would still
a restore operation then you would still
a restore operation then you would still
have to do dis reads and so there's a
have to do dis reads and so there's a
have to do dis reads and so there's a
dis vew for that but essentially what
dis vew for that but essentially what
dis vew for that but essentially what
would be changed is that you would um uh
would be changed is that you would um uh
would be changed is that you would um uh
there would be a network limit for the
there would be a network limit for the
there would be a network limit for the
um maximum number of on disk read
um maximum number of on disk read
um maximum number of on disk read
entries as well as the maximum uh number
entries as well as the maximum uh number
entries as well as the maximum uh number
of inmemory read entries now that being
of inmemory read entries now that being
of inmemory read entries now that being
said because uh the inmemory reads are a
said because uh the inmemory reads are a
said because uh the inmemory reads are a
lot cheaper than the on disk reads we
lot cheaper than the on disk reads we
lot cheaper than the on disk reads we
can actually pass aot that savings down
can actually pass aot that savings down
can actually pass aot that savings down
to the user so um in this proposal uh
to the user so um in this proposal uh
to the user so um in this proposal uh
there would actually be no in memory uh
there would actually be no in memory uh
there would actually be no in memory uh
read bites limit um so essentially the
read bites limit um so essentially the
read bites limit um so essentially the
read limit for Life s on state would
read limit for Life s on state would
read limit for Life s on state would
just completely go away uh because in
just completely go away uh because in
just completely go away uh because in
memory reads are cheap and so there's no
memory reads are cheap and so there's no
memory reads are cheap and so there's no
reason to limit that um now we would
reason to limit that um now we would
reason to limit that um now we would
still limit the total number of entries
still limit the total number of entries
still limit the total number of entries
being read but the bytes being read
being read but the bytes being read
being read but the bytes being read
would not be limited additionally uh
would not be limited additionally uh
would not be limited additionally uh
because we're not doing dis access uh
because we're not doing dis access uh
because we're not doing dis access uh
there would no longer be a read fee
there would no longer be a read fee
there would no longer be a read fee
associated with accessing Sor on State
associated with accessing Sor on State
associated with accessing Sor on State
and so um because you you still have to
and so um because you you still have to
and so um because you you still have to
pay like a instruction um like CPU uh
pay like a instruction um like CPU uh
pay like a instruction um like CPU uh
count and things like that to actually
count and things like that to actually
count and things like that to actually
process large amounts of data but
process large amounts of data but
process large amounts of data but
because we're not going to disk there
because we're not going to disk there
because we're not going to disk there
doesn't need to be an explicit fee or
doesn't need to be an explicit fee or
doesn't need to be an explicit fee or
resource for that um and so essentially
resource for that um and so essentially
resource for that um and so essentially
uh for live SW on state you don't have
uh for live SW on state you don't have
uh for live SW on state you don't have
to pay for reads and you can read as
to pay for reads and you can read as
to pay for reads and you can read as
many bytes as you want um you still have
many bytes as you want um you still have
many bytes as you want um you still have
to pay for the CPU though so it's still
to pay for the CPU though so it's still
to pay for the CPU though so it's still
an implicit fee but there's no explicit
an implicit fee but there's no explicit
an implicit fee but there's no explicit
read fee and so that's kind of um the
read fee and so that's kind of um the
read fee and so that's kind of um the
First Advantage to the inmemory versus
First Advantage to the inmemory versus
First Advantage to the inmemory versus
on disk resource now the second thing
on disk resource now the second thing
on disk resource now the second thing
this allows us to do um is is also
this allows us to do um is is also
this allows us to do um is is also
Implement autor restore functionality
Implement autor restore functionality
Implement autor restore functionality
and so um previously when we first
and so um previously when we first
and so um previously when we first
launched sorbon we weren't sure what the
launched sorbon we weren't sure what the
launched sorbon we weren't sure what the
final State archival proof system was
final State archival proof system was
final State archival proof system was
going to look like and so while from a
going to look like and so while from a
going to look like and so while from a
technological or from a technical
technological or from a technical
technological or from a technical
standpoint there was no reason to
standpoint there was no reason to
standpoint there was no reason to
require um a separate restore operation
require um a separate restore operation
require um a separate restore operation
and a separate invoke host function
and a separate invoke host function
and a separate invoke host function
operation uh we did that just to give us
operation uh we did that just to give us
operation uh we did that just to give us
flexibility later on in case the proof
flexibility later on in case the proof
flexibility later on in case the proof
system turned out to be very involved um
system turned out to be very involved um
system turned out to be very involved um
but in cap 57 we've actually outlined a
but in cap 57 we've actually outlined a
but in cap 57 we've actually outlined a
pretty lightweight proof system that
pretty lightweight proof system that
pretty lightweight proof system that
works with invoke host function and so
works with invoke host function and so
works with invoke host function and so
what we're going to do uh in cap 66 is
what we're going to do uh in cap 66 is
what we're going to do uh in cap 66 is
we're going to allow automatic restore
we're going to allow automatic restore
we're going to allow automatic restore
and so what this means is that you no
and so what this means is that you no
and so what this means is that you no
longer will have to um issue a restore
longer will have to um issue a restore
longer will have to um issue a restore
operation prior to your invo host
operation prior to your invo host
operation prior to your invo host
function but actually your invo host
function but actually your invo host
function but actually your invo host
function operation will just
function operation will just
function operation will just
automatically restore any um archive
automatically restore any um archive
automatically restore any um archive
keys that are in the footprint and so uh
keys that are in the footprint and so uh
keys that are in the footprint and so uh
this you know reduces the transaction
this you know reduces the transaction
this you know reduces the transaction
count required reduces fees and should
count required reduces fees and should
count required reduces fees and should
just offer a much better user experience
just offer a much better user experience
just offer a much better user experience
now the the way this works in resources
now the the way this works in resources
now the the way this works in resources
though is that like I mentioned before
though is that like I mentioned before
though is that like I mentioned before
the um live sorbon state is all cached
the um live sorbon state is all cached
the um live sorbon state is all cached
in memory in one database and archive
in memory in one database and archive
in memory in one database and archive
state is uncached and on dis in a
state is uncached and on dis in a
state is uncached and on dis in a
separate database and so if you call
separate database and so if you call
separate database and so if you call
info Coast function and every entry
info Coast function and every entry
info Coast function and every entry
you're using um is currently uh live
you're using um is currently uh live
you're using um is currently uh live
then you would have the free inmemory
then you would have the free inmemory
then you would have the free inmemory
resource bites and you wouldn't have to
resource bites and you wouldn't have to
resource bites and you wouldn't have to
pay for dis that being said if you're
pay for dis that being said if you're
pay for dis that being said if you're
using automatic restore the entries
using automatic restore the entries
using automatic restore the entries
being restored would come out of the
being restored would come out of the
being restored would come out of the
disk read bytes and would be charged uh
disk read bytes and would be charged uh
disk read bytes and would be charged uh
disk fees because again for the the
disk fees because again for the the
disk fees because again for the the
entries that are archived and live in
entries that are archived and live in
entries that are archived and live in
the hot archive database those do have
the hot archive database those do have
the hot archive database those do have
to be read off a
to be read off a
to be read off a
disk um and so I think that's kind of a
disk um and so I think that's kind of a
disk um and so I think that's kind of a
um kind of at the high level of what
um kind of at the high level of what
um kind of at the high level of what
we're proposing kind of uh you know the
we're proposing kind of uh you know the
we're proposing kind of uh you know the
tldr uh except been talking for for a
tldr uh except been talking for for a
tldr uh except been talking for for a
little bit is that um you know C the
little bit is that um you know C the
little bit is that um you know C the
archived entries live in their own
archived entries live in their own
archived entries live in their own
database and live sbond State lives in
database and live sbond State lives in
database and live sbond State lives in
um the separate dat or a live database
um the separate dat or a live database
um the separate dat or a live database
um we are then going to Cache uh all the
um we are then going to Cache uh all the
um we are then going to Cache uh all the
sbond state in the live database um in
sbond state in the live database um in
sbond state in the live database um in
order to pass that savings on to you
order to pass that savings on to you
order to pass that savings on to you
there will be an inmemory rebite limit
there will be an inmemory rebite limit
there will be an inmemory rebite limit
and an on disk uh rebite limit in fee
and an on disk uh rebite limit in fee
and an on disk uh rebite limit in fee
and then um finally there will be
and then um finally there will be
and then um finally there will be
automatic restore um to um you know
automatic restore um to um you know
automatic restore um to um you know
essentially um remove the need for the
essentially um remove the need for the
essentially um remove the need for the
restore operation in most
cases so I guess um are there there any
cases so I guess um are there there any
questions or any uh conversation points
questions or any uh conversation points
questions or any uh conversation points
we'd like to touch on
more looks like uh there's a question in
more looks like uh there's a question in
in the uh this in the chat the chat box
in the uh this in the chat the chat box
in the uh this in the chat the chat box
but uh I think a lot of daps and uh
but uh I think a lot of daps and uh
but uh I think a lot of daps and uh
extend TTL by default will that still be
extend TTL by default will that still be
extend TTL by default will that still be
necessary
necessary
necessary
ah yeah so I think um so just because we
ah yeah so I think um so just because we
ah yeah so I think um so just because we
have automatic restore doesn't mean that
have automatic restore doesn't mean that
have automatic restore doesn't mean that
you don't want to still manage your TTL
you don't want to still manage your TTL
you don't want to still manage your TTL
and so like I managed before if all the
and so like I managed before if all the
and so like I managed before if all the
entries um that you're using are
entries um that you're using are
entries um that you're using are
currently live then um what're or then
currently live then um what're or then
currently live then um what're or then
you don't have to pay read fees um and
you don't have to pay read fees um and
you don't have to pay read fees um and
you have much larger uh read
you have much larger uh read
you have much larger uh read
limits and so um you are still
limits and so um you are still
limits and so um you are still
incentivized to pay rent um also so but
incentivized to pay rent um also so but
incentivized to pay rent um also so but
the issue is when you restore when you
the issue is when you restore when you
the issue is when you restore when you
restore something you have to pay right
restore something you have to pay right
restore something you have to pay right
fees for the restoration and you also
fees for the restoration and you also
fees for the restoration and you also
have to pay discre fees for the
have to pay discre fees for the
have to pay discre fees for the
restoration and so I think from a um
restoration and so I think from a um
restoration and so I think from a um
from a fees perspective if you're using
from a fees perspective if you're using
from a fees perspective if you're using
an entry a lot it's still in your best
an entry a lot it's still in your best
an entry a lot it's still in your best
interest to extend the TTL um to save
interest to extend the TTL um to save
interest to extend the TTL um to save
money um as you know even BEC just
money um as you know even BEC just
money um as you know even BEC just
because the restore is automatic do not
because the restore is automatic do not
because the restore is automatic do not
make mean it's free and so you still
make mean it's free and so you still
make mean it's free and so you still
have to pay uh for that restore and even
have to pay uh for that restore and even
have to pay uh for that restore and even
if it's the same invo Coast function an
if it's the same invo Coast function an
if it's the same invo Coast function an
invo Coast function um invoking a
invo Coast function um invoking a
invo Coast function um invoking a
function that uh only accesses live
function that uh only accesses live
function that uh only accesses live
state is significantly less expensive
state is significantly less expensive
state is significantly less expensive
than invoking a host function that has a
than invoking a host function that has a
than invoking a host function that has a
automatic restore on the front end of
automatic restore on the front end of
automatic restore on the front end of
that um so we still definitely want to
that um so we still definitely want to
that um so we still definitely want to
extent
extent
extent
TL
um yeah uh let's
um yeah uh let's
see uh oh so for orbit lens will it be
see uh oh so for orbit lens will it be
see uh oh so for orbit lens will it be
possible to tell in advance whether the
possible to tell in advance whether the
possible to tell in advance whether the
entry will be automatically restored
entry will be automatically restored
entry will be automatically restored
during the simulation uh yes and so this
during the simulation uh yes and so this
during the simulation uh yes and so this
is um kind of more of the implement
is um kind of more of the implement
is um kind of more of the implement
details which are included in the cap um
details which are included in the cap um
details which are included in the cap um
but what we're doing is captive core has
but what we're doing is captive core has
but what we're doing is captive core has
recently added a couple of um HTTP n
recently added a couple of um HTTP n
recently added a couple of um HTTP n
points for querying Ledger State um that
points for querying Ledger State um that
points for querying Ledger State um that
will be used um uh by RPC in order to
will be used um uh by RPC in order to
will be used um uh by RPC in order to
simulate transactions correctly and so
simulate transactions correctly and so
simulate transactions correctly and so
essentially this endpoint is a high
essentially this endpoint is a high
essentially this endpoint is a high
performance you know multi-thread HTTP
performance you know multi-thread HTTP
performance you know multi-thread HTTP
endpoint um that uh has a similar
endpoint um that uh has a similar
endpoint um that uh has a similar
performance to a SQL uh table queries
performance to a SQL uh table queries
performance to a SQL uh table queries
and so it should be appropriate for for
and so it should be appropriate for for
and so it should be appropriate for for
production use cases and what this
production use cases and what this
production use cases and what this
endpoint will do is it's a key value
endpoint will do is it's a key value
endpoint will do is it's a key value
search where for every key you provide
search where for every key you provide
search where for every key you provide
it it will tell you um if that key
it it will tell you um if that key
it it will tell you um if that key
exists and then if it exists it'll give
exists and then if it exists it'll give
exists and then if it exists it'll give
you the value um and then it will also
you the value um and then it will also
you the value um and then it will also
give you meta information about that key
give you meta information about that key
give you meta information about that key
and so it will give you the Ledger entry
and so it will give you the Ledger entry
and so it will give you the Ledger entry
it will tell you if it's live or
it will tell you if it's live or
it will tell you if it's live or
archived um and then it will also tell
archived um and then it will also tell
archived um and then it will also tell
you um you know what its current TTL
you um you know what its current TTL
you um you know what its current TTL
value is and if it's in memory or on
value is and if it's in memory or on
value is and if it's in memory or on
disk and so the captive core endpoint um
disk and so the captive core endpoint um
disk and so the captive core endpoint um
is kind of Ed to be the new kind of
is kind of Ed to be the new kind of
is kind of Ed to be the new kind of
entry point for this information um and
entry point for this information um and
entry point for this information um and
so uh you should be able to query the
so uh you should be able to query the
so uh you should be able to query the
current archival state and the current
current archival state and the current
current archival state and the current
in memory versus on dis state of any
in memory versus on dis state of any
in memory versus on dis state of any
entry directly via captive core um again
entry directly via captive core um again
entry directly via captive core um again
there's also meta that we're emitting
there's also meta that we're emitting
there's also meta that we're emitting
for all these events so if you wanted to
for all these events so if you wanted to
for all these events so if you wanted to
it's theoretically possible to injust
it's theoretically possible to injust
it's theoretically possible to injust
meta and maintain the state of sorbon um
meta and maintain the state of sorbon um
meta and maintain the state of sorbon um
entries that way uh but if you don't
entries that way uh but if you don't
entries that way uh but if you don't
want to do that and create your own SQL
want to do that and create your own SQL
want to do that and create your own SQL
table and Pipeline and pipeline you can
table and Pipeline and pipeline you can
table and Pipeline and pipeline you can
just use the the captive core htpn
points uh so will automatic restore
points uh so will automatic restore
become automatically available for
become automatically available for
become automatically available for
existing contracts uh yes so the this is
existing contracts uh yes so the this is
existing contracts uh yes so the this is
all handled um at the RPC level and so
all handled um at the RPC level and so
all handled um at the RPC level and so
the essentially what's changing is that
the essentially what's changing is that
the essentially what's changing is that
with protocol 23 um and this is detailed
with protocol 23 um and this is detailed
with protocol 23 um and this is detailed
in cap 66 specifically
in cap 66 specifically
in cap 66 specifically
is that we are changing the footprint to
is that we are changing the footprint to
is that we are changing the footprint to
um have this field where you distinguish
um have this field where you distinguish
um have this field where you distinguish
in the footprint if a sorond key is
in the footprint if a sorond key is
in the footprint if a sorond key is
either in memory or on disk and so
either in memory or on disk and so
either in memory or on disk and so
essentially uh what the validators will
essentially uh what the validators will
essentially uh what the validators will
do is that for um whenever they receive
do is that for um whenever they receive
do is that for um whenever they receive
and apply an info Coast function they
and apply an info Coast function they
and apply an info Coast function they
will look at the footprint and for every
will look at the footprint and for every
will look at the footprint and for every
sore Bond entry uh that is marked as
sore Bond entry uh that is marked as
sore Bond entry uh that is marked as
being on disk AKA marked as being Arch
being on disk AKA marked as being Arch
being on disk AKA marked as being Arch
um before running that transaction um
um before running that transaction um
um before running that transaction um
the validator will essentially restore
the validator will essentially restore
the validator will essentially restore
those entries automatically um and so
those entries automatically um and so
those entries automatically um and so
the actual contract and the contract
the actual contract and the contract
the actual contract and the contract
logic will not change which means that
logic will not change which means that
logic will not change which means that
all deployed contracts are automatically
all deployed contracts are automatically
all deployed contracts are automatically
um compatible with this uh now the
um compatible with this uh now the
um compatible with this uh now the
invocations to those contracts will
invocations to those contracts will
invocations to those contracts will
change slightly because of the footprint
change slightly because of the footprint
change slightly because of the footprint
changes but again this will all be
changes but again this will all be
changes but again this will all be
handled by RPC and so pre-flight will uh
handled by RPC and so pre-flight will uh
handled by RPC and so pre-flight will uh
will do all this automatically
uh let's see other
uh let's see other
questions oh so ler streaming mode um
questions oh so ler streaming mode um
questions oh so ler streaming mode um
I'm I'm not sure about the context um
I'm I'm not sure about the context um
I'm I'm not sure about the context um
but
but
but
behind um enabling or disallowing um
behind um enabling or disallowing um
behind um enabling or disallowing um
metast streams um on validators versus
metast streams um on validators versus
metast streams um on validators versus
captive core instances I imagine um it
captive core instances I imagine um it
captive core instances I imagine um it
has to do with performance reasons where
has to do with performance reasons where
has to do with performance reasons where
you don't want ingestion to make a
you don't want ingestion to make a
you don't want ingestion to make a
validator fall out of sync um and
validator fall out of sync um and
validator fall out of sync um and
essentially that config setting is uh an
essentially that config setting is uh an
essentially that config setting is uh an
opinionated way of saying that validator
opinionated way of saying that validator
opinionated way of saying that validator
should be high performance um and never
should be high performance um and never
should be high performance um and never
get blocked whereas like a watcher node
get blocked whereas like a watcher node
get blocked whereas like a watcher node
that's not participating in validation
that's not participating in validation
that's not participating in validation
um would be more appropriate for
um would be more appropriate for
um would be more appropriate for
observing and adjusting the meta because
observing and adjusting the meta because
observing and adjusting the meta because
there's not um it doesn't depend on a
there's not um it doesn't depend on a
there's not um it doesn't depend on a
downstream system where if the meta
downstream system where if the meta
downstream system where if the meta
stream gets clogged because the
stream gets clogged because the
stream gets clogged because the
downstream system isn't adjusting fast
downstream system isn't adjusting fast
downstream system isn't adjusting fast
enough you wouldn't want to uh lose sync
enough you wouldn't want to uh lose sync
enough you wouldn't want to uh lose sync
and have a validating node fall off the
and have a validating node fall off the
and have a validating node fall off the
network because of a um a downst stream
network because of a um a downst stream
network because of a um a downst stream
issue
cool so I guess
cool so I guess
um
um
um
I'll from George about the cap mentioned
I'll from George about the cap mentioned
I'll from George about the cap mentioned
somewhere that autor restore won't
somewhere that autor restore won't
somewhere that autor restore won't
always be possible can you elaborate on
always be possible can you elaborate on
always be possible can you elaborate on
these scenarios ah yes okay uh thank you
these scenarios ah yes okay uh thank you
these scenarios ah yes okay uh thank you
for pointing this out um so there are a
for pointing this out um so there are a
for pointing this out um so there are a
couple of edge
couple of edge
couple of edge
cases where um an invocation will still
cases where um an invocation will still
cases where um an invocation will still
require an explicit R operation
um uh sorry uh and so essentially
um uh sorry uh and so essentially
um because the inmemory reads are so
um because the inmemory reads are so
um because the inmemory reads are so
much cheaper um they don't have uh
much cheaper um they don't have uh
much cheaper um they don't have uh
limits um like the on desk read uh the
limits um like the on desk read uh the
limits um like the on desk read uh the
on just do um while there there is no
on just do um while there there is no
on just do um while there there is no
read byit limit at all um and while
read byit limit at all um and while
read byit limit at all um and while
there is an entry read limit the
there is an entry read limit the
there is an entry read limit the
expectation is that this limit will be
expectation is that this limit will be
expectation is that this limit will be
significantly higher than the dis limits
significantly higher than the dis limits
significantly higher than the dis limits
and so uh just for um you know example
and so uh just for um you know example
and so uh just for um you know example
suppose that a uh in protocol 23 um the
suppose that a uh in protocol 23 um the
suppose that a uh in protocol 23 um the
transaction in memory read limit is 40
transaction in memory read limit is 40
transaction in memory read limit is 40
entries and the on disk read limit is 20
entries and the on disk read limit is 20
entries and the on disk read limit is 20
entries and so say you have like this
entries and so say you have like this
entries and so say you have like this
Dex um you know trade that will access
Dex um you know trade that will access
Dex um you know trade that will access
40 soron entries now if all of those
40 soron entries now if all of those
40 soron entries now if all of those
entries are Al then um you know the uh
entries are Al then um you know the uh
entries are Al then um you know the uh
it's within the limits the invocation
it's within the limits the invocation
it's within the limits the invocation
Works no problem but say that all 40 of
Works no problem but say that all 40 of
Works no problem but say that all 40 of
those entries are archived now even
those entries are archived now even
those entries are archived now even
though the inmemory limits are large
though the inmemory limits are large
though the inmemory limits are large
enough for that transaction to succeed
enough for that transaction to succeed
enough for that transaction to succeed
um you can only the the automatic
um you can only the the automatic
um you can only the the automatic
Restorations will come from the on disk
Restorations will come from the on disk
Restorations will come from the on disk
uh limits and so because you have to pay
uh limits and so because you have to pay
uh limits and so because you have to pay
um disk fees and are subject to the dis
um disk fees and are subject to the dis
um disk fees and are subject to the dis
limits for the restore operation you can
limits for the restore operation you can
limits for the restore operation you can
only restore um in this example 20
only restore um in this example 20
only restore um in this example 20
entries um automatically even though you
entries um automatically even though you
entries um automatically even though you
need to um have authority to be live to
need to um have authority to be live to
need to um have authority to be live to
complete this Dex trate operation and so
complete this Dex trate operation and so
complete this Dex trate operation and so
in this scenario you would need to to uh
in this scenario you would need to to uh
in this scenario you would need to to uh
still um manually submit a restore
still um manually submit a restore
still um manually submit a restore
operation um just because uh the way
operation um just because uh the way
operation um just because uh the way
that the limits are set you can't fit
that the limits are set you can't fit
that the limits are set you can't fit
that many restores in a single uh
that many restores in a single uh
that many restores in a single uh
transaction um now that being said uh
transaction um now that being said uh
transaction um now that being said uh
especially uh given some other exciting
especially uh given some other exciting
especially uh given some other exciting
work that's happening in 23 um we expect
work that's happening in 23 um we expect
work that's happening in 23 um we expect
to raise limits pretty significantly
to raise limits pretty significantly
to raise limits pretty significantly
across the board and so I suspect that
across the board and so I suspect that
across the board and so I suspect that
this Edge case will not affect most
this Edge case will not affect most
this Edge case will not affect most
transactions it will only affect um very
transactions it will only affect um very
transactions it will only affect um very
expensive transactions that are doing
expensive transactions that are doing
expensive transactions that are doing
stuff and so for instance um if you have
stuff and so for instance um if you have
stuff and so for instance um if you have
a DEX trade and it's trading um assets
a DEX trade and it's trading um assets
a DEX trade and it's trading um assets
that are mostly live you won't be
that are mostly live you won't be
that are mostly live you won't be
affected really you're only going to be
affected really you're only going to be
affected really you're only going to be
affected um if you have like a DEX trade
affected um if you have like a DEX trade
affected um if you have like a DEX trade
that's crossing a ton of orders and for
that's crossing a ton of orders and for
that's crossing a ton of orders and for
some reason all those orders were
archived so you mentioned that uh the
archived so you mentioned that uh the
restore op could be deprecated uh
restore op could be deprecated uh
restore op could be deprecated uh
because of the automatic restore but
because of the automatic restore but
because of the automatic restore but
this Ed Case requires you to keep
this Ed Case requires you to keep
this Ed Case requires you to keep
something something like that around
something something like that around
something something like that around
right yeah so I think um I I mentioned
right yeah so I think um I I mentioned
right yeah so I think um I I mentioned
the cap that we met deprecate the
the cap that we met deprecate the
the cap that we met deprecate the
restore op um and that's just because
restore op um and that's just because
restore op um and that's just because
that if the footprint is automatically
that if the footprint is automatically
that if the footprint is automatically
restored um then having both the restore
restored um then having both the restore
restored um then having both the restore
op and the extend TTL op is kind of
op and the extend TTL op is kind of
op and the extend TTL op is kind of
redundant um because for instance uh say
redundant um because for instance uh say
redundant um because for instance uh say
that you just want to restore something
that you just want to restore something
that you just want to restore something
you don't actually need two um operation
you don't actually need two um operation
you don't actually need two um operation
types you could just essentially use the
types you could just essentially use the
types you could just essentially use the
extend TTL put all the keys you want to
extend TTL put all the keys you want to
extend TTL put all the keys you want to
restore in the footprint and then just
restore in the footprint and then just
restore in the footprint and then just
set the TTL extension to zero and this
set the TTL extension to zero and this
set the TTL extension to zero and this
is functionally equivalent to the
is functionally equivalent to the
is functionally equivalent to the
restore up and so when I uh mentioned um
restore up and so when I uh mentioned um
restore up and so when I uh mentioned um
deprecating the restore op I don't mean
deprecating the restore op I don't mean
deprecating the restore op I don't mean
deprecating the ability to restore
deprecating the ability to restore
deprecating the ability to restore
transaction or to restore entries via an
transaction or to restore entries via an
transaction or to restore entries via an
explicit transaction but just mean like
explicit transaction but just mean like
explicit transaction but just mean like
you know mechanically do we need both
you know mechanically do we need both
you know mechanically do we need both
the restore op and the extend TTL op
the restore op and the extend TTL op
the restore op and the extend TTL op
where the extend TTL up could now um you
where the extend TTL up could now um you
where the extend TTL up could now um you
know in theory at least both do a
know in theory at least both do a
know in theory at least both do a
restoration as well as
extend okay yeah that makes sense Nico
extend okay yeah that makes sense Nico
had a question about how the sorbon
had a question about how the sorbon
had a question about how the sorbon
state size is initialized at upgrade
state size is initialized at upgrade
state size is initialized at upgrade
time it's it's not specified in the cap
time it's it's not specified in the cap
time it's it's not specified in the cap
yeah I I think I need to expand on this
yeah I I think I need to expand on this
yeah I I think I need to expand on this
a little bit more um so I think um part
a little bit more um so I think um part
a little bit more um so I think um part
of this cap is that we are changing uh
of this cap is that we are changing uh
of this cap is that we are changing uh
the semantic meaning of a network config
the semantic meaning of a network config
the semantic meaning of a network config
setting um so so in particular The
setting um so so in particular The
setting um so so in particular The
Bucket List Target size will become the
Bucket List Target size will become the
Bucket List Target size will become the
sorbon state size now the issue is
sorbon state size now the issue is
sorbon state size now the issue is
currently the bucket list is like 11 or
currently the bucket list is like 11 or
currently the bucket list is like 11 or
12 gigabytes and so we uh all of our
12 gigabytes and so we uh all of our
12 gigabytes and so we uh all of our
network settings are assuming um that
network settings are assuming um that
network settings are assuming um that
the your target size is like 13 gigs uh
the your target size is like 13 gigs uh
the your target size is like 13 gigs uh
but now the issue is um if we you know
but now the issue is um if we you know
but now the issue is um if we you know
do a protocol upgrade uh protocol
do a protocol upgrade uh protocol
do a protocol upgrade uh protocol
upgrades previously have never actually
upgrades previously have never actually
upgrades previously have never actually
changed config settings and so if you
changed config settings and so if you
changed config settings and so if you
just do the protocol upgrade all of a
just do the protocol upgrade all of a
just do the protocol upgrade all of a
sudden um instead of your Baseline uh
sudden um instead of your Baseline uh
sudden um instead of your Baseline uh
for fees being 12 gigs with a target for
for fees being 12 gigs with a target for
for fees being 12 gigs with a target for
13 gigs because we're only tracking
13 gigs because we're only tracking
13 gigs because we're only tracking
sorbon State your target is still 13
sorbon State your target is still 13
sorbon State your target is still 13
gigs but now your Baseline is like 400
gigs but now your Baseline is like 400
gigs but now your Baseline is like 400
megabytes uh because there's like a lot
megabytes uh because there's like a lot
megabytes uh because there's like a lot
less soron State compared to life State
less soron State compared to life State
less soron State compared to life State
and then you have this dos attack where
and then you have this dos attack where
and then you have this dos attack where
until you upgrade the network confix
until you upgrade the network confix
until you upgrade the network confix
settings you essentially have no read or
settings you essentially have no read or
settings you essentially have no read or
write fees um for both uh in memory and
write fees um for both uh in memory and
write fees um for both uh in memory and
on dis State and so you could have like
on dis State and so you could have like
on dis State and so you could have like
a Doss attack where someone writes like
a Doss attack where someone writes like
a Doss attack where someone writes like
tons and tons and tons of temp entries
tons and tons and tons of temp entries
tons and tons and tons of temp entries
and like you know spams The Ledger for
and like you know spams The Ledger for
and like you know spams The Ledger for
essentially zero fees um and so I think
essentially zero fees um and so I think
essentially zero fees um and so I think
what I'm proposing is that you know
what I'm proposing is that you know
what I'm proposing is that you know
currently there's like an operational
currently there's like an operational
currently there's like an operational
lag between upgrades because core
lag between upgrades because core
lag between upgrades because core
validators can only cue uh one upgrade
validators can only cue uh one upgrade
validators can only cue uh one upgrade
at a time and so we'd have to get all of
at a time and so we'd have to get all of
at a time and so we'd have to get all of
tier one to arm for the protocol 23
tier one to arm for the protocol 23
tier one to arm for the protocol 23
upgrade and then after that goes through
upgrade and then after that goes through
upgrade and then after that goes through
have them all arm for the network config
have them all arm for the network config
have them all arm for the network config
setting upgrade and in between that time
setting upgrade and in between that time
setting upgrade and in between that time
um you have free free reads and free wrs
um you have free free reads and free wrs
um you have free free reads and free wrs
which is a huge security risk and so
which is a huge security risk and so
which is a huge security risk and so
what I'm proposing is that because
what I'm proposing is that because
what I'm proposing is that because
protocol 23 is semantically changing uh
protocol 23 is semantically changing uh
protocol 23 is semantically changing uh
what this config setting means the
what this config setting means the
what this config setting means the
protocol upgrade itself should also
protocol upgrade itself should also
protocol upgrade itself should also
change the value and so you know this is
change the value and so you know this is
change the value and so you know this is
slightly different implementation wise
slightly different implementation wise
slightly different implementation wise
than what we've done previously but I
than what we've done previously but I
than what we've done previously but I
think it should be relatively
think it should be relatively
think it should be relatively
straightforward implementation um
straightforward implementation um
straightforward implementation um
whereas like the protocol 23 upgrade um
whereas like the protocol 23 upgrade um
whereas like the protocol 23 upgrade um
both semantically changes what the Buist
both semantically changes what the Buist
both semantically changes what the Buist
Target size means as well as it resets
Target size means as well as it resets
Target size means as well as it resets
it to a initial starting value that's
it to a initial starting value that's
it to a initial starting value that's
more reasonable uh given this new
more reasonable uh given this new
more reasonable uh given this new
interpretation of the data
Okay so we've actually uh updated
Okay so we've actually uh updated
settings on protocol upgrades before
settings on protocol upgrades before
settings on protocol upgrades before
that I think we we know that works cool
that I think we we know that works cool
that I think we we know that works cool
okay great um let's see a couple other
okay great um let's see a couple other
okay great um let's see a couple other
[Music]
questions okay so for orbit lens uh the
questions okay so for orbit lens uh the
storage for the hot archive uh yes so um
storage for the hot archive uh yes so um
storage for the hot archive uh yes so um
the hot archive and the live Buck list
the hot archive and the live Buck list
the hot archive and the live Buck list
are both part of ensus um so we need the
are both part of ensus um so we need the
are both part of ensus um so we need the
hash of that state and so for that
hash of that state and so for that
hash of that state and so for that
reason um both of the the live database
reason um both of the the live database
reason um both of the the live database
and the hot archive database are both um
and the hot archive database are both um
and the hot archive database are both um
bucket list DB
bucket list DB
bucket list DB
implementations um and that's just
implementations um and that's just
implementations um and that's just
because they we have to meriz those
because they we have to meriz those
because they we have to meriz those
structures then Buck list DB is pretty
structures then Buck list DB is pretty
structures then Buck list DB is pretty
fast these days um now uh with respect
fast these days um now uh with respect
fast these days um now uh with respect
to offering tables to buckless DB um we
to offering tables to buckless DB um we
to offering tables to buckless DB um we
we don't really have any plans to do
we don't really have any plans to do
we don't really have any plans to do
that um and the reason is it's a very
that um and the reason is it's a very
that um and the reason is it's a very
difficult structure to add tables to um
difficult structure to add tables to um
difficult structure to add tables to um
so it's a it's a log structured merge
so it's a it's a log structured merge
so it's a it's a log structured merge
tree um which is kind of a a variant of
tree um which is kind of a a variant of
tree um which is kind of a a variant of
like database used by like rock CB or
like database used by like rock CB or
like database used by like rock CB or
level DB um and it's also completely
level DB um and it's also completely
level DB um and it's also completely
made inhouse like we didn't Fork levels
made inhouse like we didn't Fork levels
made inhouse like we didn't Fork levels
we didn't Fork rocks or anything like
we didn't Fork rocks or anything like
we didn't Fork rocks or anything like
that um and so kind of um we we have it
that um and so kind of um we we have it
that um and so kind of um we we have it
it works very well for um query types
it works very well for um query types
it works very well for um query types
that the valers require and it's very
that the valers require and it's very
that the valers require and it's very
efficient at those but we have to
efficient at those but we have to
efficient at those but we have to
essentially like hand write C++
essentially like hand write C++
essentially like hand write C++
optimized code for those specific
optimized code for those specific
optimized code for those specific
queries and and so it would be both a
queries and and so it would be both a
queries and and so it would be both a
very significant undertaking to allow
very significant undertaking to allow
very significant undertaking to allow
like you know arbitrary index types um
like you know arbitrary index types um
like you know arbitrary index types um
for Downstream um and it would also
for Downstream um and it would also
for Downstream um and it would also
probably not be a very efficient
probably not be a very efficient
probably not be a very efficient
database just because it's a lock
database just because it's a lock
database just because it's a lock
structured merge treat and so a SQL
structured merge treat and so a SQL
structured merge treat and so a SQL
style uh index query would not work very
style uh index query would not work very
style uh index query would not work very
well on it and so I think what I'd like
well on it and so I think what I'd like
well on it and so I think what I'd like
to do with this is um you know we've
to do with this is um you know we've
to do with this is um you know we've
we've uh for arbitrary key value lookups
we've uh for arbitrary key value lookups
we've uh for arbitrary key value lookups
we have exposed um end points that are
we have exposed um end points that are
we have exposed um end points that are
on the same scale as SQL queres but
on the same scale as SQL queres but
on the same scale as SQL queres but
again they're just raw key value stores
again they're just raw key value stores
again they're just raw key value stores
they're not like you know indexes or you
they're not like you know indexes or you
they're not like you know indexes or you
know really tables um and I think uh
know really tables um and I think uh
know really tables um and I think uh
there's been a lot of work done um by
there's been a lot of work done um by
there's been a lot of work done um by
the platform folks on like the um the
the platform folks on like the um the
the platform folks on like the um the
CDP um and things like that and so I
CDP um and things like that and so I
CDP um and things like that and so I
think um given that the complexity of
think um given that the complexity of
think um given that the complexity of
the database of uh Stellar core is
the database of uh Stellar core is
the database of uh Stellar core is
increasing a lot um and for a variety of
increasing a lot um and for a variety of
increasing a lot um and for a variety of
reasons we uh only support Buist DB now
reasons we uh only support Buist DB now
reasons we uh only support Buist DB now
and no longer support SQL um I think
and no longer support SQL um I think
and no longer support SQL um I think
that uh any sort of uh raw database
that uh any sort of uh raw database
that uh any sort of uh raw database
access needs to move more in the
access needs to move more in the
access needs to move more in the
direction of utilizing Downstream
direction of utilizing Downstream
direction of utilizing Downstream
utilizing met ingestion using CDP and
utilizing met ingestion using CDP and
utilizing met ingestion using CDP and
not rely on direct access to course
not rely on direct access to course
not rely on direct access to course
databases just because you know nowadays
databases just because you know nowadays
databases just because you know nowadays
with buck DB the core database is very
with buck DB the core database is very
with buck DB the core database is very
specialized and is not suitable for
specialized and is not suitable for
specialized and is not suitable for
generic queries
cool I
cool I
think there's a couple people typing so
think there's a couple people typing so
think there's a couple people typing so
I'll let them finish or if anyone else
I'll let them finish or if anyone else
I'll let them finish or if anyone else
has any other questions if not I have a
has any other questions if not I have a
has any other questions if not I have a
third cap that I'd like to introduce
third cap that I'd like to introduce
third cap that I'd like to introduce
um I'll give it a second and then we can
um I'll give it a second and then we can
um I'll give it a second and then we can
move
on all right I feel like that's we've
on all right I feel like that's we've
had enough time oh uh answer about
had enough time oh uh answer about
had enough time oh uh answer about
slp1
um dial would you mind linking that
um dial would you mind linking that
question again I'm not quite sure what
question again I'm not quite sure what
question again I'm not quite sure what
the slp1 question is
oh yeah the new limits sorry
oh yeah the new limits sorry
yeah cool um so I guess uh now I'd like
yeah cool um so I guess uh now I'd like
yeah cool um so I guess uh now I'd like
to uh move on to cap 65 the reusable
to uh move on to cap 65 the reusable
to uh move on to cap 65 the reusable
module cache and so um like I mentioned
module cache and so um like I mentioned
module cache and so um like I mentioned
before we were doing all this
before we were doing all this
before we were doing all this
optimization stuff um for a memory State
optimization stuff um for a memory State
optimization stuff um for a memory State
um and essentially uh in addition to uh
um and essentially uh in addition to uh
um and essentially uh in addition to uh
saving all the contract data in memory
saving all the contract data in memory
saving all the contract data in memory
uh we can also save all the contract
uh we can also save all the contract
uh we can also save all the contract
code um and by extension all the
code um and by extension all the
code um and by extension all the
contract modules in memory um because
contract modules in memory um because
contract modules in memory um because
you know we have a way of EX of
you know we have a way of EX of
you know we have a way of EX of
archiving um contract instances and
archiving um contract instances and
archiving um contract instances and
contract code that uh hasn't paid rep
contract code that uh hasn't paid rep
contract code that uh hasn't paid rep
recently and so um with that I think
recently and so um with that I think
recently and so um with that I think
gr's on the call if you want come up and
gr's on the call if you want come up and
gr's on the call if you want come up and
talk about cap 65
I don't think uh gr's on the call I I
I don't think uh gr's on the call I I
believe we were going to speak about CFE
believe we were going to speak about CFE
believe we were going to speak about CFE
65 next week right oh sorry I guess I
65 next week right oh sorry I guess I
65 next week right oh sorry I guess I
got a I gave youall a little teaser for
got a I gave youall a little teaser for
got a I gave youall a little teaser for
next week then my apologies got a
next week then my apologies got a
next week then my apologies got a
littlee of the gun but so yeah so
um I I don't want to steal grain thunder
um I I don't want to steal grain thunder
so I'll just you know leave you with a
so I'll just you know leave you with a
so I'll just you know leave you with a
teaser that we can you know have lots of
teaser that we can you know have lots of
teaser that we can you know have lots of
um this not only helps optimize the the
um this not only helps optimize the the
um this not only helps optimize the the
um read limits but also optimize CPU
um read limits but also optimize CPU
um read limits but also optimize CPU
utilization as well but we'll talk about
utilization as well but we'll talk about
utilization as well but we'll talk about
that more later
all right uh unless there are any other
all right uh unless there are any other
questions
questions
questions
uh we can conclude this
uh we can conclude this
uh we can conclude this
meeting thanks great uh Garen it was a
meeting thanks great uh Garen it was a
meeting thanks great uh Garen it was a
great
talk all right thank you and you know
talk all right thank you and you know
the dis uh if youall have any more
the dis uh if youall have any more
the dis uh if youall have any more
questions or concerns you know there's a
questions or concerns you know there's a
questions or concerns you know there's a
couple of discussion tabs on the Caps or
couple of discussion tabs on the Caps or
couple of discussion tabs on the Caps or
just ping me on Discord

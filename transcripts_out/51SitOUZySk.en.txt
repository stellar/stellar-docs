hello everyone and welcome to the the
hello everyone and welcome to the the
last Stellar developer meeting uh this
last Stellar developer meeting uh this
last Stellar developer meeting uh this
year and um on the agenda for today we
year and um on the agenda for today we
year and um on the agenda for today we
have two things uh we have Jay from the
have two things uh we have Jay from the
have two things uh we have Jay from the
the core engineering team they'll talk
the core engineering team they'll talk
the core engineering team they'll talk
about some new additions uh in protocol
about some new additions uh in protocol
about some new additions uh in protocol
22 and then he is going to give some
22 and then he is going to give some
22 and then he is going to give some
demos so uh I will
demos so uh I will
demos so uh I will
invite Jay to join me here on stage
invite Jay to join me here on stage
invite Jay to join me here on stage
hello hello can you hear me yeah I can
hello hello can you hear me yeah I can
hello hello can you hear me yeah I can
hear you okay great um hi everyone uh
hear you okay great um hi everyone uh
hear you okay great um hi everyone uh
I'm I'm Jay core developer uh today I'm
I'm I'm Jay core developer uh today I'm
I'm I'm Jay core developer uh today I'm
going to uh walk you through the
going to uh walk you through the
going to uh walk you through the
building blocks that we introduced uh in
building blocks that we introduced uh in
building blocks that we introduced uh in
protocal 22 which went live U this month
protocal 22 which went live U this month
protocal 22 which went live U this month
a couple weeks ago um uh specifically
a couple weeks ago um uh specifically
a couple weeks ago um uh specifically
around uh the The cryptographic
around uh the The cryptographic
around uh the The cryptographic
Primitives uh namely bs2 381
Primitives uh namely bs2 381
Primitives uh namely bs2 381
um
um
um
so yeah so the cap for bs2
so yeah so the cap for bs2
so yeah so the cap for bs2
3d1 is uh cap 59 which was introduced um
3d1 is uh cap 59 which was introduced um
3d1 is uh cap 59 which was introduced um
I would say three or four months ago um
I would say three or four months ago um
I would say three or four months ago um
but today I'm going to focus on just
but today I'm going to focus on just
but today I'm going to focus on just
like a high level overview of what you
like a high level overview of what you
like a high level overview of what you
can do with uh different uh types of
can do with uh different uh types of
can do with uh different uh types of
functions introduce as well as the the
functions introduce as well as the the
functions introduce as well as the the
SDK interface and I'm also going to show
SDK interface and I'm also going to show
SDK interface and I'm also going to show
a couple examples uh simple ones to
a couple examples uh simple ones to
a couple examples uh simple ones to
illustrate how you can make use of these
illustrate how you can make use of these
illustrate how you can make use of these
core functionality today to build useful
core functionality today to build useful
core functionality today to build useful
applications so uh let's get
applications so uh let's get
applications so uh let's get
started first let me share my
started first let me share my
started first let me share my
[Music]
screen okay so um
screen okay so um
yeah yeah walking through u a few things
yeah yeah walking through u a few things
yeah yeah walking through u a few things
um so first just briefly uh uh take you
um so first just briefly uh uh take you
um so first just briefly uh uh take you
through the cap uh since this is not a
through the cap uh since this is not a
through the cap uh since this is not a
protocol meeting I'll just be really
protocol meeting I'll just be really
protocol meeting I'll just be really
brief and not spend uh any time
brief and not spend uh any time
brief and not spend uh any time
explaining the details and nuances you
explaining the details and nuances you
explaining the details and nuances you
can read more about them um
can read more about them um
can read more about them um
so yes so this cap cap 59 uh is about uh
so yes so this cap cap 59 uh is about uh
so yes so this cap cap 59 uh is about uh
bs12
bs12
bs12
381 so the brs1 123 3d1 is a is a new uh
381 so the brs1 123 3d1 is a is a new uh
381 so the brs1 123 3d1 is a is a new uh
curve that that's added um so
curve that that's added um so
curve that that's added um so
the well it's not a new it's not one
the well it's not a new it's not one
the well it's not a new it's not one
curve it's rather like a family of
curve it's rather like a family of
curve it's rather like a family of
Curves U there's namely the the G1 which
Curves U there's namely the the G1 which
Curves U there's namely the the G1 which
is the base field and then the G2 which
is the base field and then the G2 which
is the base field and then the G2 which
is the extension field and what's what's
is the extension field and what's what's
is the extension field and what's what's
what's useful about uh this curve
what's useful about uh this curve
what's useful about uh this curve
specifically is that you can you can
specifically is that you can you can
specifically is that you can you can
compute uh pairings uh which is taking a
compute uh pairings uh which is taking a
compute uh pairings uh which is taking a
point in G1 uh pointing G2 repair them
point in G1 uh pointing G2 repair them
point in G1 uh pointing G2 repair them
and then it Maps into a different point
and then it Maps into a different point
and then it Maps into a different point
in a in a higher higher degree uh space
in a in a higher higher degree uh space
in a in a higher higher degree uh space
um so at a high level what why is this
um so at a high level what why is this
um so at a high level what why is this
useful you might ask so just like
useful you might ask so just like
useful you might ask so just like
cryptography we wanted to uh compute uh
cryptography we wanted to uh compute uh
cryptography we wanted to uh compute uh
like we want to do computations and we
like we want to do computations and we
like we want to do computations and we
want we don't want to do them in a a
want we don't want to do them in a a
want we don't want to do them in a a
plain manners right um just like ecdsa
plain manners right um just like ecdsa
plain manners right um just like ecdsa
you you utilize the
you you utilize the
you you utilize the
um properties of eliptic curve and then
um properties of eliptic curve and then
um properties of eliptic curve and then
uh and then the particularly the uh
uh and then the particularly the uh
uh and then the particularly the uh
discrete logarithmic problem is is hard
discrete logarithmic problem is is hard
discrete logarithmic problem is is hard
to solve meaning that if you multiply a
to solve meaning that if you multiply a
to solve meaning that if you multiply a
point a certain times um on the curve
point a certain times um on the curve
point a certain times um on the curve
and get a different curve it's really
and get a different curve it's really
and get a different curve it's really
hard to invert that process to get the
hard to invert that process to get the
hard to invert that process to get the
number that you multiplied with which
number that you multiplied with which
number that you multiplied with which
makes it useful for private key and
makes it useful for private key and
makes it useful for private key and
public key so same principle here um B2
public key so same principle here um B2
public key so same principle here um B2
C1 is just eliptic curve um and it can
C1 is just eliptic curve um and it can
C1 is just eliptic curve um and it can
it can used it can be used for
it can used it can be used for
it can used it can be used for
signatures which I we show in our first
signatures which I we show in our first
signatures which I we show in our first
example first example later on but it's
example first example later on but it's
example first example later on but it's
also it can do a lot more um so yeah so
also it can do a lot more um so yeah so
also it can do a lot more um so yeah so
the so the high level G of this is that
the so the high level G of this is that
the so the high level G of this is that
uh using the new the new curve you can
uh using the new the new curve you can
uh using the new the new curve you can
do encrypted computation that follows
do encrypted computation that follows
do encrypted computation that follows
certain rules and these are the basic
certain rules and these are the basic
certain rules and these are the basic
building blocks which uh people use to
building blocks which uh people use to
building blocks which uh people use to
build um more advanced and interesting
build um more advanced and interesting
build um more advanced and interesting
applications such as CK
applications such as CK
applications such as CK
knock all right so yeah so here are the
knock all right so yeah so here are the
knock all right so yeah so here are the
new host functions introduced uh I think
new host functions introduced uh I think
new host functions introduced uh I think
the total is like 12 if I remember
the total is like 12 if I remember
the total is like 12 if I remember
correctly um there's a yeah the basic
correctly um there's a yeah the basic
correctly um there's a yeah the basic
ones uh Point addition uh
ones uh Point addition uh
ones uh Point addition uh
G1 um Point uh Point multip
G1 um Point uh Point multip
G1 um Point uh Point multip
multiplication with a constant um MSM
multiplication with a constant um MSM
multiplication with a constant um MSM
which is basically a scaler like a
which is basically a scaler like a
which is basically a scaler like a
vector multiplication which is yeah just
vector multiplication which is yeah just
vector multiplication which is yeah just
multiplying a vector of number by a
multiplying a vector of number by a
multiplying a vector of number by a
vector of points and then add them
up so and then uh so these ones uh the
up so and then uh so these ones uh the
hash to curve in map to curve uh these
hash to curve in map to curve uh these
hash to curve in map to curve uh these
ones are if you use if you want to uh
ones are if you use if you want to uh
ones are if you use if you want to uh
use a digital signature scheme like if
use a digital signature scheme like if
use a digital signature scheme like if
you want to map a random message onto
you want to map a random message onto
you want to map a random message onto
the curve and and and uh map to a point
the curve and and and uh map to a point
the curve and and and uh map to a point
perform the uh cryptographic functions
perform the uh cryptographic functions
perform the uh cryptographic functions
on it you first have to take that
on it you first have to take that
on it you first have to take that
message and you have to Hash it onto the
message and you have to Hash it onto the
message and you have to Hash it onto the
curve um internally how it works uh very
curve um internally how it works uh very
curve um internally how it works uh very
briefly is that it there's a h this hash
briefly is that it there's a h this hash
briefly is that it there's a h this hash
function sh 256 and then you also
function sh 256 and then you also
function sh 256 and then you also
provide something called a DST which is
provide something called a DST which is
provide something called a DST which is
the domain separate uh Separation The
the domain separate uh Separation The
the domain separate uh Separation The
Domain separation tag which is just a
Domain separation tag which is just a
Domain separation tag which is just a
tag that you append to every message
tag that you append to every message
tag that you append to every message
such that your applications domain
such that your applications domain
such that your applications domain
separate from say like ethereum's
separate from say like ethereum's
separate from say like ethereum's
application like um so it's always good
application like um so it's always good
application like um so it's always good
to have a unique uh DST for every
to have a unique uh DST for every
to have a unique uh DST for every
application to avoid some kind of
application to avoid some kind of
application to avoid some kind of
intricate attack um so the basically how
intricate attack um so the basically how
intricate attack um so the basically how
it works is that it just hashes like
it works is that it just hashes like
it works is that it just hashes like
repeatedly hashes that message uh into
repeatedly hashes that message uh into
repeatedly hashes that message uh into
um a certain lens which corresponds to
um a certain lens which corresponds to
um a certain lens which corresponds to
the uh the length of the the point on
the uh the length of the the point on
the uh the length of the the point on
the curve and then it checks if that
the curve and then it checks if that
the curve and then it checks if that
point is on the Curve um and then if not
point is on the Curve um and then if not
point is on the Curve um and then if not
it it add one and repeat and then um
it it add one and repeat and then um
it it add one and repeat and then um
once it is on the curve then it
once it is on the curve then it
once it is on the curve then it
multiplies by some co-actor to send this
multiplies by some co-actor to send this
multiplies by some co-actor to send this
curve to the correct subgroup um
curve to the correct subgroup um
curve to the correct subgroup um
so this is just getting a little bit
so this is just getting a little bit
so this is just getting a little bit
into more detail is that these curves
into more detail is that these curves
into more detail is that these curves
obviously they are uh Prime uh like they
obviously they are uh Prime uh like they
obviously they are uh Prime uh like they
Prime field so the the it's the numbers
Prime field so the the it's the numbers
Prime field so the the it's the numbers
on this curve are are modulus of a of a
on this curve are are modulus of a of a
on this curve are are modulus of a of a
large Prime in this case um the prime
large Prime in this case um the prime
large Prime in this case um the prime
number is
number is
number is
381 bits long thus the name U BR is 12
381 bits long thus the name U BR is 12
381 bits long thus the name U BR is 12
381 and the subgroup is is different
381 and the subgroup is is different
381 and the subgroup is is different
subgroup is the number of points
subgroup is the number of points
subgroup is the number of points
that we pick or like the the definition
that we pick or like the the definition
that we pick or like the the definition
of the curve pick such that these uh
of the curve pick such that these uh
of the curve pick such that these uh
operations are defined so the subgroup
operations are defined so the subgroup
operations are defined so the subgroup
is a subset of all available points on
is a subset of all available points on
is a subset of all available points on
the BS 81 curve and then the for this
the BS 81 curve and then the for this
the BS 81 curve and then the for this
particular case the subgroup size is 256
particular case the subgroup size is 256
particular case the subgroup size is 256
bit uh so which is very convenient to be
bit uh so which is very convenient to be
bit uh so which is very convenient to be
represented as a big U
represented as a big U
represented as a big U
256 and so uh yeah some of the uh host
256 and so uh yeah some of the uh host
256 and so uh yeah some of the uh host
functions here actually uh if you look
functions here actually uh if you look
functions here actually uh if you look
at they're called f which basically
at they're called f which basically
at they're called f which basically
takes some U 256 vales and then like add
takes some U 256 vales and then like add
takes some U 256 vales and then like add
them together like these numbers
them together like these numbers
them together like these numbers
represent the the scalar in the
represent the the scalar in the
represent the the scalar in the
definition of of this particular curve
definition of of this particular curve
definition of of this particular curve
where the the modulus of the scaler
where the the modulus of the scaler
where the the modulus of the scaler
equals the subgroup size so this is
equals the subgroup size so this is
equals the subgroup size so this is
useful um for um manipulating the points
useful um for um manipulating the points
useful um for um manipulating the points
like multiplying them and then making
like multiplying them and then making
like multiplying them and then making
sure that this scaler is actually like
sure that this scaler is actually like
sure that this scaler is actually like
represented by the points on the curve
represented by the points on the curve
represented by the points on the curve
like yeah
so we just covered uh hash to curve and
so we just covered uh hash to curve and
then um yeah then we repeat for G2 which
then um yeah then we repeat for G2 which
then um yeah then we repeat for G2 which
is which is different uh group of points
is which is different uh group of points
is which is different uh group of points
um same thing here map to G uh map map
um same thing here map to G uh map map
um same thing here map to G uh map map
to G2 hash to G2 and then the important
to G2 hash to G2 and then the important
to G2 hash to G2 and then the important
one or I guess uh the most interesting
one or I guess uh the most interesting
one or I guess uh the most interesting
one that um the applications built off
one that um the applications built off
one that um the applications built off
of is the pairing so
of is the pairing so
of is the pairing so
so what the parent does is uh I'm I'm
so what the parent does is uh I'm I'm
so what the parent does is uh I'm I'm
going to borrow some other uh slides
going to borrow some other uh slides
going to borrow some other uh slides
here so this is
here so this is
here so this is
a this is just like a onepage uh
a this is just like a onepage uh
a this is just like a onepage uh
explanation for BL signature which will
explanation for BL signature which will
explanation for BL signature which will
cover in a bit in our example and here
cover in a bit in our example and here
cover in a bit in our example and here
is just the definition of a pairing
is just the definition of a pairing
is just the definition of a pairing
which takes a point in the first group
which takes a point in the first group
which takes a point in the first group
um point on the second group pair them
um point on the second group pair them
um point on the second group pair them
up and send it to a different group
up and send it to a different group
up and send it to a different group
uh the interesting about the paing is
uh the interesting about the paing is
uh the interesting about the paing is
that it is bilinear which means that it
that it is bilinear which means that it
that it is bilinear which means that it
is linear with respect to both the
is linear with respect to both the
is linear with respect to both the
first U term as well as the second term
first U term as well as the second term
first U term as well as the second term
so uh so here you see pairing of uh P
so uh so here you see pairing of uh P
so uh so here you see pairing of uh P
plus s um is equal to pairing of P times
plus s um is equal to pairing of P times
plus s um is equal to pairing of P times
pairing of s and same same here on the
pairing of s and same same here on the
pairing of s and same same here on the
second term Q Plus R you can um pair
second term Q Plus R you can um pair
second term Q Plus R you can um pair
them separately and multiply together so
them separately and multiply together so
them separately and multiply together so
the reason here is a multiplication
the reason here is a multiplication
the reason here is a multiplication
uh again this is just some details is
uh again this is just some details is
uh again this is just some details is
that because uh the paing result is sent
that because uh the paing result is sent
that because uh the paing result is sent
to like a higher degree um the 12th
to like a higher degree um the 12th
to like a higher degree um the 12th
degree uh that's part of the name BR is
degree uh that's part of the name BR is
degree uh that's part of the name BR is
12 so we need to get to the 12th uh
12 so we need to get to the 12th uh
12 so we need to get to the 12th uh
degree extension field uh which is a
degree extension field uh which is a
degree extension field uh which is a
multiplic multiplicative Group which
multiplic multiplicative Group which
multiplic multiplicative Group which
means you can perform like
means you can perform like
means you can perform like
multiplications um instead of a additive
multiplications um instead of a additive
multiplications um instead of a additive
Group which is our G1 and G2 so just
Group which is our G1 and G2 so just
Group which is our G1 and G2 so just
some details but important fact is that
some details but important fact is that
some details but important fact is that
you can uh these relationships can hold
you can uh these relationships can hold
you can uh these relationships can hold
and then by the extension of it uh if
and then by the extension of it uh if
and then by the extension of it uh if
you have a u on the left side if you
you have a u on the left side if you
you have a u on the left side if you
have a p repeated uh eight times uh this
have a p repeated uh eight times uh this
have a p repeated uh eight times uh this
is essentially multiplying the result
is essentially multiplying the result
is essentially multiplying the result
eight times and then which is equivalent
eight times and then which is equivalent
eight times and then which is equivalent
to taking the uh this paring result the
to taking the uh this paring result the
to taking the uh this paring result the
plain par result of p and Q and exponent
plain par result of p and Q and exponent
plain par result of p and Q and exponent
take the exponent a and then you can
take the exponent a and then you can
take the exponent a and then you can
move this a either you know on the left
move this a either you know on the left
move this a either you know on the left
side or on the right side or move it out
side or on the right side or move it out
side or on the right side or move it out
it doesn't it doesn't matter so the
it doesn't it doesn't matter so the
it doesn't it doesn't matter so the
pairing uh this pair relationship can be
pairing uh this pair relationship can be
pairing uh this pair relationship can be
quite useful um as we see in the example
quite useful um as we see in the example
quite useful um as we see in the example
of uh both signature as well as a uh SN
verification okay so I think that goes
verification okay so I think that goes
over well we just covered the FR which
over well we just covered the FR which
over well we just covered the FR which
is the field this is just a this is just
is the field this is just a this is just
is the field this is just a this is just
a very simple uh um like modular
a very simple uh um like modular
a very simple uh um like modular
arithmetics but with a very uh specific
arithmetics but with a very uh specific
arithmetics but with a very uh specific
module like addition uh
module like addition uh
module like addition uh
subtraction
subtraction
subtraction
multiplication uh power inversion and
multiplication uh power inversion and
multiplication uh power inversion and
that's
that's
that's
all so now let's look at the SDK so how
all so now let's look at the SDK so how
all so now let's look at the SDK so how
does this look uh inside the SDK which
does this look uh inside the SDK which
does this look uh inside the SDK which
is which is what you'll be um
is which is what you'll be um
is which is what you'll be um
interfacing with is so if you look at
interfacing with is so if you look at
interfacing with is so if you look at
the SD there's a it sits inside the
the SD there's a it sits inside the
the SD there's a it sits inside the
crypto library and then there's a brst
crypto library and then there's a brst
crypto library and then there's a brst
381 um module so the all the functions
381 um module so the all the functions
381 um module so the all the functions
are exposed inside the BRS 12 381 module
are exposed inside the BRS 12 381 module
are exposed inside the BRS 12 381 module
um so the few additional functions like
um so the few additional functions like
um so the few additional functions like
checking if a if a point is in the
checking if a if a point is in the
checking if a if a point is in the
subgroup um but overall there is a
subgroup um but overall there is a
subgroup um but overall there is a
pretty much one to one correspondence
pretty much one to one correspondence
pretty much one to one correspondence
between the host function and the SDK
between the host function and the SDK
between the host function and the SDK
function oh and also uh one interesting
function oh and also uh one interesting
function oh and also uh one interesting
to notice is there's a two addition
to notice is there's a two addition
to notice is there's a two addition
method um one is just a plain addition
method um one is just a plain addition
method um one is just a plain addition
and then the other one is the checked
and then the other one is the checked
and then the other one is the checked
Edition so so the reason for that is uh
Edition so so the reason for that is uh
Edition so so the reason for that is uh
so remember what I said earlier was uh
so remember what I said earlier was uh
so remember what I said earlier was uh
the BL 12 381 points are defined over a
the BL 12 381 points are defined over a
the BL 12 381 points are defined over a
particular subgroup um but
particular subgroup um but
particular subgroup um but
but but just the the addition operation
but but just the the addition operation
but but just the the addition operation
can perform on any point on the curve
can perform on any point on the curve
can perform on any point on the curve
doesn't have to belong to the subgroup
doesn't have to belong to the subgroup
doesn't have to belong to the subgroup
but in order for that addition to be
but in order for that addition to be
but in order for that addition to be
useful for our pairings and for our um
useful for our pairings and for our um
useful for our pairings and for our um
other uh like a SN operation like they
other uh like a SN operation like they
other uh like a SN operation like they
have to be in the subgroup but the
have to be in the subgroup but the
have to be in the subgroup but the
subgroup check is is is kind of
subgroup check is is is kind of
subgroup check is is is kind of
expensive so if you have a contract
expensive so if you have a contract
expensive so if you have a contract
which does like a number of these
which does like a number of these
which does like a number of these
additions and only you want to make sure
additions and only you want to make sure
additions and only you want to make sure
the end result is on the subgroup then
the end result is on the subgroup then
the end result is on the subgroup then
you can use uh the plain add function
you can use uh the plain add function
you can use uh the plain add function
which is not taking
which is not taking
which is not taking
um yeah which is not taking the uh the
um yeah which is not taking the uh the
um yeah which is not taking the uh the
the check it's just it's just point
the check it's just it's just point
the check it's just it's just point
doing the addition whereas if you wanted
doing the addition whereas if you wanted
doing the addition whereas if you wanted
to be safe and then you wanted to use
to be safe and then you wanted to use
to be safe and then you wanted to use
the the checked ad which performs the uh
the the checked ad which performs the uh
the the checked ad which performs the uh
the the subgroup check uh in in the end
modifcation yeah these are all very
modifcation yeah these are all very
standard yeah repeat for
G2 parent
G2 parent
check oh yeah okay uh one thing about
check oh yeah okay uh one thing about
check oh yeah okay uh one thing about
the parent check here um like I uh
the parent check here um like I uh
the parent check here um like I uh
mentioned earlier uh in this equation uh
mentioned earlier uh in this equation uh
mentioned earlier uh in this equation uh
this is a parent check it's check
this is a parent check it's check
this is a parent check it's check
checking a pairing of two points equals
checking a pairing of two points equals
checking a pairing of two points equals
some relationship of pairing like with a
some relationship of pairing like with a
some relationship of pairing like with a
uh either like a a result of a pairing
uh either like a a result of a pairing
uh either like a a result of a pairing
multiplied by each other or like
multiplied by each other or like
multiplied by each other or like
additional terms but the the pairing
additional terms but the the pairing
additional terms but the the pairing
result itself uh is is a point on a
result itself uh is is a point on a
result itself uh is is a point on a
higher degree uh in a higher degree um
higher degree uh in a higher degree um
higher degree uh in a higher degree um
extension F12 and then to compute that
extension F12 and then to compute that
extension F12 and then to compute that
F12 is very expensive so the parent
F12 is very expensive so the parent
F12 is very expensive so the parent
check is intended such that we we can uh
check is intended such that we we can uh
check is intended such that we we can uh
perform multiple pairings uh together
perform multiple pairings uh together
perform multiple pairings uh together
and then check that this the end result
and then check that this the end result
and then check that this the end result
uh equals to one which means this
uh equals to one which means this
uh equals to one which means this
pairing uh returns true or false if it
pairing uh returns true or false if it
pairing uh returns true or false if it
satisfies true otherwise it's false uh
satisfies true otherwise it's false uh
satisfies true otherwise it's false uh
the the benefit of that is that these
the the benefit of that is that these
the the benefit of that is that these
intermediate result they can be they can
intermediate result they can be they can
intermediate result they can be they can
be performed on a a much lower degree
be performed on a a much lower degree
be performed on a a much lower degree
which is much more efficient and only at
which is much more efficient and only at
which is much more efficient and only at
the very end do you have to or you don't
the very end do you have to or you don't
the very end do you have to or you don't
have to but like internally the
have to but like internally the
have to but like internally the
algorithm will send that to the uh uh
algorithm will send that to the uh uh
algorithm will send that to the uh uh
the 12's order and then do the
the 12's order and then do the
the 12's order and then do the
comparison check with uh the the U the
comparison check with uh the the U the
comparison check with uh the the U the
number one in 12 extension so so the
number one in 12 extension so so the
number one in 12 extension so so the
reason for that is uh in most of the
reason for that is uh in most of the
reason for that is uh in most of the
applications either in signature
applications either in signature
applications either in signature
checking or in in SN verification um you
checking or in in SN verification um you
checking or in in SN verification um you
only need to do pairing to to check
only need to do pairing to to check
only need to do pairing to to check
certain relation hold like in a SN for
certain relation hold like in a SN for
certain relation hold like in a SN for
example uh you are checking that your
example uh you are checking that your
example uh you are checking that your
polinomial uh contains a certain
polinomial uh contains a certain
polinomial uh contains a certain
structure uh by that you are Computing
structure uh by that you are Computing
structure uh by that you are Computing
uh some
uh some
uh some
polinomial uh relations and then you're
polinomial uh relations and then you're
polinomial uh relations and then you're
checking that the left side equals right
checking that the left side equals right
checking that the left side equals right
right right hand side uh this relation
right right hand side uh this relation
right right hand side uh this relation
hold so you you in in now the point you
hold so you you in in now the point you
hold so you you in in now the point you
actually need that 12 degree extension
actually need that 12 degree extension
actually need that 12 degree extension
Point all you have to do is to make sure
Point all you have to do is to make sure
Point all you have to do is to make sure
the left side equal right side so so far
the left side equal right side so so far
the left side equal right side so so far
I haven't uh heard of any application
I haven't uh heard of any application
I haven't uh heard of any application
that specifically needs the result of
that specifically needs the result of
that specifically needs the result of
the pairing so that's why we went with
the pairing so that's why we went with
the pairing so that's why we went with
this design of just passing a vector of
this design of just passing a vector of
this design of just passing a vector of
G1 Vector of G2 uh perform pairwise Che
G1 Vector of G2 uh perform pairwise Che
G1 Vector of G2 uh perform pairwise Che
pairing and then check the result in the
pairing and then check the result in the
pairing and then check the result in the
end if it's equal than uh equal to one
end if it's equal than uh equal to one
end if it's equal than uh equal to one
then return true otherwise return false
then return true otherwise return false
then return true otherwise return false
so it's just a
so it's just a
so it's just a
it's other line mass is the same but
it's other line mass is the same but
it's other line mass is the same but
just uh you know something to be be
just uh you know something to be be
just uh you know something to be be
aware like it's it's not taking a single
aware like it's it's not taking a single
aware like it's it's not taking a single
point pair with a single point but
point pair with a single point but
point pair with a single point but
taking a vector of pair with a vector
taking a vector of pair with a vector
taking a vector of pair with a vector
um and then these ones we covered okay
um and then these ones we covered okay
um and then these ones we covered okay
so I think that's it for the building
so I think that's it for the building
so I think that's it for the building
block oh it took 20 minutes it's
block oh it took 20 minutes it's
block oh it took 20 minutes it's
probably should probably speed up a
probably should probably speed up a
probably should probably speed up a
little huh
little huh
little huh
okay so let's talk about the the useful
okay so let's talk about the the useful
okay so let's talk about the the useful
applications U first first of all the
applications U first first of all the
applications U first first of all the
BRS signatures uh so I think I went
BRS signatures uh so I think I went
BRS signatures uh so I think I went
through this in one of the protocol
through this in one of the protocol
through this in one of the protocol
meeting earlier so I just keep it a
meeting earlier so I just keep it a
meeting earlier so I just keep it a
little more brief uh because the other
little more brief uh because the other
little more brief uh because the other
ones I think more interesting uh so the
ones I think more interesting uh so the
ones I think more interesting uh so the
BR signature uh the way it works I'm
BR signature uh the way it works I'm
BR signature uh the way it works I'm
trying to find the paragraph that does
trying to find the paragraph that does
trying to find the paragraph that does
explanation so yeah so so here there's a
explanation so yeah so so here there's a
explanation so yeah so so here there's a
there's some some kind of secret key and
there's some some kind of secret key and
there's some some kind of secret key and
then oh sorry this is a public key
uh okay so the the public key is some
uh okay so the the public key is some
number times the point uh the generator
number times the point uh the generator
number times the point uh the generator
point and then the the signature is uh
point and then the the signature is uh
point and then the the signature is uh
the public key times hash of the message
the public key times hash of the message
the public key times hash of the message
and by the parent property if you just
and by the parent property if you just
and by the parent property if you just
if you do the uh the public key and the
if you do the uh the public key and the
if you do the uh the public key and the
hash of the message and then you move
hash of the message and then you move
hash of the message and then you move
the uh the Scala part uh around in the
the uh the Scala part uh around in the
the uh the Scala part uh around in the
end you just you get a you get a a check
end you just you get a you get a a check
end you just you get a you get a a check
which is the uh the generator so the the
which is the uh the generator so the the
which is the uh the generator so the the
pairing of the of the public key and the
pairing of the of the public key and the
pairing of the of the public key and the
hash of message equals the the pairing
hash of message equals the the pairing
hash of message equals the the pairing
of the the generator and then the the
of the the generator and then the the
of the the generator and then the the
the signature so yeah if you it's fairly
the signature so yeah if you it's fairly
the signature so yeah if you it's fairly
straightforward the public key here
straightforward the public key here
straightforward the public key here
sorry I don't know why you call PK it's
sorry I don't know why you call PK it's
sorry I don't know why you call PK it's
actually just a secret key here uh you
actually just a secret key here uh you
actually just a secret key here uh you
can move it
can move it
can move it
it appears on the left in the beginning
it appears on the left in the beginning
it appears on the left in the beginning
but you can move it on the right and
but you can move it on the right and
but you can move it on the right and
then this becomes the the the signature
then this becomes the the the signature
then this becomes the the the signature
so the left and right must hold if this
so the left and right must hold if this
so the left and right must hold if this
signature is valid and the good thing
signature is valid and the good thing
signature is valid and the good thing
about it is that uh if you have the same
about it is that uh if you have the same
about it is that uh if you have the same
message and then multiple public Keys
message and then multiple public Keys
message and then multiple public Keys
signing the message then you can
signing the message then you can
signing the message then you can
essentially just aggregate all the
essentially just aggregate all the
essentially just aggregate all the
signatures together and aggregate all
signatures together and aggregate all
signatures together and aggregate all
the Public Public Keys together uh do
the Public Public Keys together uh do
the Public Public Keys together uh do
this off chain and all you have to do is
this off chain and all you have to do is
this off chain and all you have to do is
just to verify one pairing um then you
just to verify one pairing um then you
just to verify one pairing um then you
can you know verify potentially hundreds
can you know verify potentially hundreds
can you know verify potentially hundreds
of signatures all at once um and this is
of signatures all at once um and this is
of signatures all at once um and this is
only this is uh um if the messages are
only this is uh um if the messages are
only this is uh um if the messages are
same but if the message are unique then
same but if the message are unique then
same but if the message are unique then
for every message like M number message
for every message like M number message
for every message like M number message
there will be like M plus one parent
there will be like M plus one parent
there will be like M plus one parent
checks um so that's the general idea of
checks um so that's the general idea of
checks um so that's the general idea of
um
um
um
the UHS signature so let's see the
the UHS signature so let's see the
the UHS signature so let's see the
example uh so
example uh so
example uh so
so we have
so we have
so we have
uh
uh
uh
here hope you can see the code here uh
here hope you can see the code here uh
here hope you can see the code here uh
so this one example is already in the s
so this one example is already in the s
so this one example is already in the s
bomb uh example repo uh you can look at
bomb uh example repo uh you can look at
bomb uh example repo uh you can look at
it today uh I try to keep it documented
it today uh I try to keep it documented
it today uh I try to keep it documented
um I think it's fairly straightforward
um I think it's fairly straightforward
um I think it's fairly straightforward
uh in the it's a pretty much as
uh in the it's a pretty much as
uh in the it's a pretty much as
increment contract but the increment is
increment contract but the increment is
increment contract but the increment is
uh requires an O which is a uh for every
uh requires an O which is a uh for every
uh requires an O which is a uh for every
time you increment it will check called
time you increment it will check called
time you increment it will check called
check or and then check some the
check or and then check some the
check or and then check some the
signature payload and the uh and then
signature payload and the uh and then
signature payload and the uh and then
the public key so inside here is
the public key so inside here is
the public key so inside here is
basically just loading loading the
basically just loading loading the
basically just loading loading the
aggregate public key uh loading your uh
aggregate public key uh loading your uh
aggregate public key uh loading your uh
uh domain separation tag um and then
uh domain separation tag um and then
uh domain separation tag um and then
construct the vector and call pairing
construct the vector and call pairing
construct the vector and call pairing
that's all that is and then you can look
that's all that is and then you can look
that's all that is and then you can look
at the test which is doing most of the
at the test which is doing most of the
at the test which is doing most of the
uh setups um
uh setups um
uh setups um
here it contains 10 pairs of signatures
here it contains 10 pairs of signatures
here it contains 10 pairs of signatures
um applying the aggregation and
um applying the aggregation and
um applying the aggregation and
signature aggregation and then here just
signature aggregation and then here just
signature aggregation and then here just
runs the test which invokes the check
runs the test which invokes the check
runs the test which invokes the check
all with some random
all with some random
all with some random
payload um if I run
payload um if I run
payload um if I run
that yeah the
that yeah the
that yeah the
signature uh signature passes and then
signature uh signature passes and then
signature uh signature passes and then
it dumps out the the budget and then
it dumps out the the budget and then
it dumps out the the budget and then
yeah so this simple operation is like 31
yeah so this simple operation is like 31
yeah so this simple operation is like 31
uh 31 million CPU instructions um so
uh 31 million CPU instructions um so
uh 31 million CPU instructions um so
yeah remember this is 10 10 different
yeah remember this is 10 10 different
yeah remember this is 10 10 different
signatures on the same payload um so 31
signatures on the same payload um so 31
signatures on the same payload um so 31
31 million to verify 10 signature you
31 million to verify 10 signature you
31 million to verify 10 signature you
can do also more if they
can do also more if they
can do also more if they
more so that's a very brief uh walk
more so that's a very brief uh walk
more so that's a very brief uh walk
through of the uh the V signature so uh
through of the uh the V signature so uh
through of the uh the V signature so uh
now I want to go go and uh do something
now I want to go go and uh do something
now I want to go go and uh do something
uh new and the potentially interesting
uh new and the potentially interesting
uh new and the potentially interesting
which is the the cross 16 verifier so in
which is the the cross 16 verifier so in
which is the the cross 16 verifier so in
order to show that we have the building
order to show that we have the building
order to show that we have the building
block to build real ZK applications um I
block to build real ZK applications um I
block to build real ZK applications um I
went and uh generated a very simple
went and uh generated a very simple
went and uh generated a very simple
simple proof and then uh Ed a very uh
simple proof and then uh Ed a very uh
simple proof and then uh Ed a very uh
simple impementation of the grass 16 uh
simple impementation of the grass 16 uh
simple impementation of the grass 16 uh
verifier to verify that proof and uh I
verifier to verify that proof and uh I
verifier to verify that proof and uh I
want to uh walk you through it
want to uh walk you through it
want to uh walk you through it
so I don't know if we have enough time
so I don't know if we have enough time
so I don't know if we have enough time
for me to
for me to
for me to
actually
actually
actually
uh so do do we do we have time how much
uh so do do we do we have time how much
uh so do do we do we have time how much
time we have yeah yeah yeah take the
time we have yeah yeah yeah take the
time we have yeah yeah yeah take the
time you need yeah okay yeah because I I
time you need yeah okay yeah because I I
time you need yeah okay yeah because I I
do want to just walk you through the
do want to just walk you through the
do want to just walk you through the
steps that that's required to um to
steps that that's required to um to
steps that that's required to um to
generate the the proof and and and see
generate the the proof and and and see
generate the the proof and and and see
see it in action because a lot of a lot
see it in action because a lot of a lot
see it in action because a lot of a lot
of this is is looks like magic when you
of this is is looks like magic when you
of this is is looks like magic when you
first run it like just dump dumped a
first run it like just dump dumped a
first run it like just dump dumped a
bunch of things so okay
bunch of things so okay
bunch of things so okay
so here um don't know if you can see the
so here um don't know if you can see the
so here um don't know if you can see the
link here but I'm basically using uh
link here but I'm basically using uh
link here but I'm basically using uh
circum U circum doio uh if you just
circum U circum doio uh if you just
circum U circum doio uh if you just
search for it at the installation the
search for it at the installation the
search for it at the installation the
getting started guy um so circum is a is
getting started guy um so circum is a is
getting started guy um so circum is a is
a tool so
a tool so
a tool so
circum uh and snjs is a pair of tools
circum uh and snjs is a pair of tools
circum uh and snjs is a pair of tools
one is for defining the circuit which is
one is for defining the circuit which is
one is for defining the circuit which is
a arithmetic relation of what you're
a arithmetic relation of what you're
a arithmetic relation of what you're
trying to compute and then snjs is a is
trying to compute and then snjs is a is
trying to compute and then snjs is a is
a tool that allows you to take in the
a tool that allows you to take in the
a tool that allows you to take in the
circuit and and do all kinds of
circuit and and do all kinds of
circuit and and do all kinds of
computations and generate the proof and
computations and generate the proof and
computations and generate the proof and
also verify the proof so what we're
also verify the proof so what we're
also verify the proof so what we're
doing is uh we're going to just follow
doing is uh we're going to just follow
doing is uh we're going to just follow
this exact guide here uh
this exact guide here uh
this exact guide here uh
generate Define the circuit uh do all
generate Define the circuit uh do all
generate Define the circuit uh do all
the setup necessary generate the proof
the setup necessary generate the proof
the setup necessary generate the proof
and then once we have the proof we will
and then once we have the proof we will
and then once we have the proof we will
write our own contract uh to verify it
write our own contract uh to verify it
write our own contract uh to verify it
in soron instead of verified in
in soron instead of verified in
in soron instead of verified in
snjs okay so let's
screen all right hope you can see
screen all right hope you can see
my both of my
my both of my
my both of my
screens so so I did little bit of
screens so so I did little bit of
screens so so I did little bit of
preparation so uh here's a brand new
preparation so uh here's a brand new
preparation so uh here's a brand new
folder I have these two files uh these
folder I have these two files uh these
folder I have these two files uh these
are the exact instructions here it tells
are the exact instructions here it tells
are the exact instructions here it tells
you to copy the input copy the circle I
you to copy the input copy the circle I
you to copy the input copy the circle I
just did in advents so we don't have to
just did in advents so we don't have to
just did in advents so we don't have to
go through that so the first thing um it
go through that so the first thing um it
go through that so the first thing um it
wants you to do is to install these
wants you to do is to install these
wants you to do is to install these
dependencies which I already did so we
dependencies which I already did so we
dependencies which I already did so we
can skip that and the second one is that
can skip that and the second one is that
can skip that and the second one is that
uh it tells you to uh Define the circuit
uh it tells you to uh Define the circuit
uh it tells you to uh Define the circuit
in the circum language the the circle is
in the circum language the the circle is
in the circum language the the circle is
really uh simple it's the simplest you
really uh simple it's the simplest you
really uh simple it's the simplest you
can get basically multiplying two
can get basically multiplying two
can get basically multiplying two
numbers and then and then output the the
numbers and then and then output the the
numbers and then and then output the the
result of the
result of the
result of the
multiplication um however the the uh
multiplication um however the the uh
multiplication um however the the uh
interesting part is that these inputs A
interesting part is that these inputs A
interesting part is that these inputs A
and B are uh private inputs so in the
and B are uh private inputs so in the
and B are uh private inputs so in the
end uh your proof will prove that this
end uh your proof will prove that this
end uh your proof will prove that this
computation was done correctly uh uh
computation was done correctly uh uh
computation was done correctly uh uh
without revealing What A and B is so
without revealing What A and B is so
without revealing What A and B is so
only the only public output will be C uh
only the only public output will be C uh
only the only public output will be C uh
the um the number the result of the
the um the number the result of the
the um the number the result of the
multiplication so what we what we did
multiplication so what we what we did
multiplication so what we what we did
here is just copy this exact program uh
here is just copy this exact program uh
here is just copy this exact program uh
into this multiplier
file and then the next
file and then the next
one uh compiling the circuit so yeah so
one uh compiling the circuit so yeah so
one uh compiling the circuit so yeah so
scales gives you the the Circ
scales gives you the the Circ
scales gives you the the Circ
instructions um how to do that so this
instructions um how to do that so this
instructions um how to do that so this
is basically just writing this circuit
is basically just writing this circuit
is basically just writing this circuit
in in in some formats and uh so that it
in in in some formats and uh so that it
in in in some formats and uh so that it
can can be understood by um the other
can can be understood by um the other
can can be understood by um the other
tools
tools
tools
um but there's one thing we have to
um but there's one thing we have to
um but there's one thing we have to
change on this
command which is BRS
command which is BRS
12381 um so the reason that we need to
12381 um so the reason that we need to
12381 um so the reason that we need to
specify this is the the circuit
specify this is the the circuit
specify this is the the circuit
compilation uh needs to know the range
compilation uh needs to know the range
compilation uh needs to know the range
of like the the the range of uh prime
of like the the the range of uh prime
of like the the the range of uh prime
number so it needs to take the prime the
number so it needs to take the prime the
number so it needs to take the prime the
prime number the 3 381 uh one bit number
prime number the 3 381 uh one bit number
prime number the 3 381 uh one bit number
associated with with our curve right
associated with with our curve right
associated with with our curve right
this B 12 31 and use that as a as as a
this B 12 31 and use that as a as as a
this B 12 31 and use that as a as as a
curve to generate this circuit otherwise
curve to generate this circuit otherwise
curve to generate this circuit otherwise
it I don't know what happens although I
it I don't know what happens although I
it I don't know what happens although I
haven't tried but you should you should
haven't tried but you should you should
haven't tried but you should you should
do that so once you do that um it will
do that so once you do that um it will
do that so once you do that um it will
generate the multiplier in this R1 CS
generate the multiplier in this R1 CS
generate the multiplier in this R1 CS
format and then some other stuff so the
format and then some other stuff so the
format and then some other stuff so the
R1 CS is a rank one constraint system um
R1 CS is a rank one constraint system um
R1 CS is a rank one constraint system um
why is it called so so think of any
why is it called so so think of any
why is it called so so think of any
complex computation like a a know a squ
complex computation like a a know a squ
complex computation like a a know a squ
* Bal C something like that um you can
* Bal C something like that um you can
* Bal C something like that um you can
always break it down into simpler
always break it down into simpler
always break it down into simpler
computation by creating intermediate
computation by creating intermediate
computation by creating intermediate
Gates and then assigning intermediate
Gates and then assigning intermediate
Gates and then assigning intermediate
gates to you know more intermediate and
gates to you know more intermediate and
gates to you know more intermediate and
then like in the end you you just
then like in the end you you just
then like in the end you you just
compute two things to an output
compute two things to an output
compute two things to an output
so so the the the process of R1 CS is
so so the the the process of R1 CS is
so so the the the process of R1 CS is
just uh comp uh deconstruct a complex
just uh comp uh deconstruct a complex
just uh comp uh deconstruct a complex
computation in something into something
computation in something into something
computation in something into something
simple as a left left hand side times
simple as a left left hand side times
simple as a left left hand side times
right hand side equals an output whereas
right hand side equals an output whereas
right hand side equals an output whereas
both left hand side right hand side and
both left hand side right hand side and
both left hand side right hand side and
output are rank one which means the
output are rank one which means the
output are rank one which means the
highest polinomial degree is one so you
highest polinomial degree is one so you
highest polinomial degree is one so you
can have like a plus b but not a
can have like a plus b but not a
can have like a plus b but not a
square so that's what it
is okay once you do that um the next
is okay once you do that um the next
step is to compute the witness so so at
step is to compute the witness so so at
step is to compute the witness so so at
this point we have the circuit which is
this point we have the circuit which is
this point we have the circuit which is
our structure of our computation but in
our structure of our computation but in
our structure of our computation but in
order to to compute it like in order to
order to to compute it like in order to
order to to compute it like in order to
to be verifiable we have to comput it
to be verifiable we have to comput it
to be verifiable we have to comput it
with some inputs and then generate uh
with some inputs and then generate uh
with some inputs and then generate uh
the proofs and all that so here is just
the proofs and all that so here is just
the proofs and all that so here is just
defining the the input I I did did here
defining the the input I I did did here
defining the the input I I did did here
which is exactly what it's using so it
which is exactly what it's using so it
which is exactly what it's using so it
Tak
Tak
Tak
3 * 11 so the output will be uh 33 um
3 * 11 so the output will be uh 33 um
3 * 11 so the output will be uh 33 um
but we don't we won't know about this
but we don't we won't know about this
but we don't we won't know about this
three and
three and
three and
11 so once we have that uh we will enter
11 so once we have that uh we will enter
11 so once we have that uh we will enter
the uh the JS
the uh the JS
the uh the JS
Library okay it's empty right uh it's
Library okay it's empty right uh it's
Library okay it's empty right uh it's
generate yeah some other AO generated uh
generate yeah some other AO generated uh
generate yeah some other AO generated uh
code to compute uh stuff so what we do
code to compute uh stuff so what we do
code to compute uh stuff so what we do
here is
here is
here is
uh actually copy this one but I'll input
uh actually copy this one but I'll input
uh actually copy this one but I'll input
this
some okay so this one is just generating
some okay so this one is just generating
uh the the witnesses
uh and then you can also do this with
uh and then you can also do this with
C++ and then once you do that you have
C++ and then once you do that you have
C++ and then once you do that you have
the uh the witness file I don't think we
the uh the witness file I don't think we
the uh the witness file I don't think we
can load it yet but it's just a
can load it yet but it's just a
can load it yet but it's just a
um yeah the the witness uh is just the
um yeah the the witness uh is just the
um yeah the the witness uh is just the
input basically um
input basically um
input basically um
like I think the witness is it private
like I think the witness is it private
like I think the witness is it private
or just probably I I don't I forgot the
or just probably I I don't I forgot the
or just probably I I don't I forgot the
exact terminology but it's possible that
exact terminology but it's possible that
exact terminology but it's possible that
the witness is just a public output U so
the witness is just a public output U so
the witness is just a public output U so
so so only the C part 33 is contained in
so so only the C part 33 is contained in
so so only the C part 33 is contained in
the
witness okay now comes to the proving
witness okay now comes to the proving
part so yeah so so here here there's a
part so yeah so so here here there's a
part so yeah so so here here there's a
bunch of commands if you do it for the
bunch of commands if you do it for the
bunch of commands if you do it for the
first time it will look fairly weird
first time it will look fairly weird
first time it will look fairly weird
because it's telling you to generate uh
because it's telling you to generate uh
because it's telling you to generate uh
a power to ceremony um so what what it
a power to ceremony um so what what it
a power to ceremony um so what what it
what it really is is um so in order to
what it really is is um so in order to
what it really is is um so in order to
yeah so in order to compute uh the proof
yeah so in order to compute uh the proof
yeah so in order to compute uh the proof
so okay so remember we have the R1 CS
so okay so remember we have the R1 CS
so okay so remember we have the R1 CS
file and then the R1 CS is just a system
file and then the R1 CS is just a system
file and then the R1 CS is just a system
with equations of different uh nodes and
with equations of different uh nodes and
with equations of different uh nodes and
then every equation is just a simple
then every equation is just a simple
then every equation is just a simple
rank one left right equals output uh
rank one left right equals output uh
rank one left right equals output uh
multiplication and and and so the the
multiplication and and and so the the
multiplication and and and so the the
next step in order to uh make that into
next step in order to uh make that into
next step in order to uh make that into
some kind of provable structure is to uh
some kind of provable structure is to uh
some kind of provable structure is to uh
convert this into a qap which is a uh qu
convert this into a qap which is a uh qu
convert this into a qap which is a uh qu
quadratic arithmetic program what it
quadratic arithmetic program what it
quadratic arithmetic program what it
does is to on each side the left right
does is to on each side the left right
does is to on each side the left right
and output it uh fits uh a number of
and output it uh fits uh a number of
and output it uh fits uh a number of
polinomial that evaluate to uh at
polinomial that evaluate to uh at
polinomial that evaluate to uh at
certain points so the number of
certain points so the number of
certain points so the number of
equations is is a number of constraints
equations is is a number of constraints
equations is is a number of constraints
and at each constraint the polinomial
and at each constraint the polinomial
and at each constraint the polinomial
will evaluate at a different points so
will evaluate at a different points so
will evaluate at a different points so
to keep them separate and then a pol
to keep them separate and then a pol
to keep them separate and then a pol
polinomial is the aggregation of smaller
polinomial is the aggregation of smaller
polinomial is the aggregation of smaller
Pol polinomial defined over each unique
Pol polinomial defined over each unique
Pol polinomial defined over each unique
node so um what you what you think in
node so um what you what you think in
node so um what you what you think in
the and is just
the and is just
the and is just
a instead of left left times right
a instead of left left times right
a instead of left left times right
equals output you have a left side
equals output you have a left side
equals output you have a left side
polinomial uh of some degree degree
polinomial uh of some degree degree
polinomial uh of some degree degree
which which matches the number of
which which matches the number of
which which matches the number of
constraints and same for right hand side
constraints and same for right hand side
constraints and same for right hand side
and the opposite side um
and the opposite side um
and the opposite side um
and and in order to to verify this
and and in order to to verify this
and and in order to to verify this
polinomial computed correctly uh we so
polinomial computed correctly uh we so
polinomial computed correctly uh we so
here here's a key here's a key uh
here here's a key here's a key uh
here here's a key here's a key uh
concept U is in order to verify the
concept U is in order to verify the
concept U is in order to verify the
computational polinomial all you have to
computational polinomial all you have to
computational polinomial all you have to
do is to verify the computation of a
do is to verify the computation of a
do is to verify the computation of a
polinomial at a single random Point um
polinomial at a single random Point um
polinomial at a single random Point um
so this may sound little you know
so this may sound little you know
so this may sound little you know
counterintuitive in the beginning but if
counterintuitive in the beginning but if
counterintuitive in the beginning but if
you if you have polinomial of degree two
you if you have polinomial of degree two
you if you have polinomial of degree two
then there can be only two roots and
then there can be only two roots and
then there can be only two roots and
then if you have two polinomial of
then if you have two polinomial of
then if you have two polinomial of
degree two you you subtract them
degree two you you subtract them
degree two you you subtract them
together it can still only have two
together it can still only have two
together it can still only have two
Roots so which means that it can the two
Roots so which means that it can the two
Roots so which means that it can the two
polinomial can only be identical at n
polinomial can only be identical at n
polinomial can only be identical at n
number of points where n being the
number of points where n being the
number of points where n being the
degree of the polinomial so even if we
degree of the polinomial so even if we
degree of the polinomial so even if we
have you know hundreds thousands of
have you know hundreds thousands of
have you know hundreds thousands of
constraints in our circuit the space the
constraints in our circuit the space the
constraints in our circuit the space the
total space of our uh uh of our SN the
total space of our uh uh of our SN the
total space of our uh uh of our SN the
the prime modulus or rather the subgroup
the prime modulus or rather the subgroup
the prime modulus or rather the subgroup
is 200 200 56 bits long so it is
is 200 200 56 bits long so it is
is 200 200 56 bits long so it is
impossible for any uh Collision to
impossible for any uh Collision to
impossible for any uh Collision to
happen in in real chance so this this a
happen in in real chance so this this a
happen in in real chance so this this a
key concept of how to like how to
key concept of how to like how to
key concept of how to like how to
convert this polinomial into a u into a
convert this polinomial into a u into a
convert this polinomial into a u into a
non interactive check which is you just
non interactive check which is you just
non interactive check which is you just
need to make sure that it's evaluated at
need to make sure that it's evaluated at
need to make sure that it's evaluated at
a truly random uh value and then this
a truly random uh value and then this
a truly random uh value and then this
the verifier or anyone can just take the
the verifier or anyone can just take the
the verifier or anyone can just take the
output of that and then make sure and
output of that and then make sure and
output of that and then make sure and
then check the verification that uh the
then check the verification that uh the
then check the verification that uh the
the polinomial equality holds with
the polinomial equality holds with
the polinomial equality holds with
pairing uh what we introduce here so
pairing uh what we introduce here so
pairing uh what we introduce here so
this is what it does so so the power of
this is what it does so so the power of
this is what it does so so the power of
to here the the long story short is just
to here the the long story short is just
to here the the long story short is just
the the steps necessary to generate that
the the steps necessary to generate that
the the steps necessary to generate that
random point at which the polinomial are
random point at which the polinomial are
random point at which the polinomial are
evaluated that's really what it is um so
evaluated that's really what it is um so
evaluated that's really what it is um so
I'm going to spe speed around through
I'm going to spe speed around through
I'm going to spe speed around through
these steps here um it's not really that
these steps here um it's not really that
these steps here um it's not really that
interesting there's a lot of output you
interesting there's a lot of output you
interesting there's a lot of output you
can look at it later
sorry B 12
sorry B 12
31 that's the first step contribute to
31 that's the first step contribute to
31 that's the first step contribute to
ceremony some random
text it's going to compute set up some
text it's going to compute set up some
um
um
um
ceremony and then um the gr 16 requires
ceremony and then um the gr 16 requires
ceremony and then um the gr 16 requires
a a public uh a Universal setup which is
a a public uh a Universal setup which is
a a public uh a Universal setup which is
for the whole like you have to do once
for the whole like you have to do once
for the whole like you have to do once
and then the per Circle specific setup
and then the per Circle specific setup
and then the per Circle specific setup
so that's the second step here
so this was the last command prepare
so this was the last command prepare
phase two and then yeah
phase two and then yeah
phase two and then yeah
just set up the circle specific
stuff okay and then
stuff okay and then
uh and then contribute to
uh and then contribute to
uh and then contribute to
the another text okay so now we have the
the another text okay so now we have the
the another text okay so now we have the
the um the proving key and the
the um the proving key and the
the um the proving key and the
verification key set up for this circuit
verification key set up for this circuit
verification key set up for this circuit
and the next step is to generate the
proof okay so in the end we have uh this
proof okay so in the end we have uh this
proof
yeah which which uh contains uh ter
yeah which which uh contains uh ter
terms which is like encrypted evaluation
terms which is like encrypted evaluation
terms which is like encrypted evaluation
of polinomial at some
public public. Json do we get
public public. Json do we get
that oh um I think I sent it to the
that oh um I think I sent it to the
that oh um I think I sent it to the
previous folder but yeah the
previous folder but yeah the
previous folder but yeah the
public should just have one value here
public should just have one value here
public should just have one value here
um which is 33 so uh to verify uh verify
um which is 33 so uh to verify uh verify
um which is 33 so uh to verify uh verify
a proof to so what what we need to do is
a proof to so what what we need to do is
a proof to so what what we need to do is
to write a uh a
to write a uh a
to write a uh a
contract um this here it makes really
contract um this here it makes really
contract um this here it makes really
easy for you to do so there's a step
easy for you to do so there's a step
easy for you to do so there's a step
where you can um call to generate a
where you can um call to generate a
where you can um call to generate a
ethereum u solidity contract for
ethereum u solidity contract for
ethereum u solidity contract for
verifying
verifying
verifying
and then uh
and then uh
and then uh
four yeah
here yeah so the cont itself is um it's
here yeah so the cont itself is um it's
not that interesting um I'm not familiar
not that interesting um I'm not familiar
not that interesting um I'm not familiar
too much with solidity but most of the
too much with solidity but most of the
too much with solidity but most of the
logic here is just packing bits into
logic here is just packing bits into
logic here is just packing bits into
memories and then in the end it's called
memories and then in the end it's called
memories and then in the end it's called
this caring on you know a bunch of terms
this caring on you know a bunch of terms
this caring on you know a bunch of terms
so we can easily convert that into a Sor
so we can easily convert that into a Sor
so we can easily convert that into a Sor
Bond and the output of you know our
Bond and the output of you know our
Bond and the output of you know our
contract is just this much it it
contract is just this much it it
contract is just this much it it
verifies the proof takes a verification
verifies the proof takes a verification
verifies the proof takes a verification
key which is some um like G1 G2 points
key which is some um like G1 G2 points
key which is some um like G1 G2 points
uh and then approve which contains also
uh and then approve which contains also
uh and then approve which contains also
points in G1 G2 public signal in this
points in G1 G2 public signal in this
points in G1 G2 public signal in this
case just one which is 33 encoded into
case just one which is 33 encoded into
case just one which is 33 encoded into
the scale a field
the scale a field
the scale a field
number um and then aggregate the input
number um and then aggregate the input
number um and then aggregate the input
and then uh yeah construct the back to
and then uh yeah construct the back to
and then uh yeah construct the back to
check paing and that's really it and
check paing and that's really it and
check paing and that's really it and
then I did uh I copied all of the the
then I did uh I copied all of the the
then I did uh I copied all of the the
outputs um it's a it will be a different
outputs um it's a it will be a different
outputs um it's a it will be a different
one than what we gener earlier because
one than what we gener earlier because
one than what we gener earlier because
there an entropy I I because of the
there an entropy I I because of the
there an entropy I I because of the
random randomness um but but I did this
random randomness um but but I did this
random randomness um but but I did this
earlier I just copied all these uh the
earlier I just copied all these uh the
earlier I just copied all these uh the
the pro the proof part and the ver if
the pro the proof part and the ver if
the pro the proof part and the ver if
ification key part this is proof and
ification key part this is proof and
ification key part this is proof and
then this is the VK and then construct
then this is the VK and then construct
then this is the VK and then construct
the the key construct the proof and then
the the key construct the proof and then
the the key construct the proof and then
just call uh the verify proof and assert
just call uh the verify proof and assert
just call uh the verify proof and assert
that this result uh must be true because
that this result uh must be true because
that this result uh must be true because
the we've putting uh you know the output
the we've putting uh you know the output
the we've putting uh you know the output
at 33 so which is matches our public
at 33 so which is matches our public
at 33 so which is matches our public
output so let's run this
output so let's run this
output so let's run this
test okay so it finished and you can see
test okay so it finished and you can see
test okay so it finished and you can see
that this verifying the ZK proof uh
that this verifying the ZK proof uh
that this verifying the ZK proof uh
takes around 30 like 41 million CPU
takes around 30 like 41 million CPU
takes around 30 like 41 million CPU
instructions it performs uh four parent
instructions it performs uh four parent
instructions it performs uh four parent
checks per some addition multiplication
checks per some addition multiplication
checks per some addition multiplication
in G1 space so if you have more public
in G1 space so if you have more public
in G1 space so if you have more public
input then there will be more
input then there will be more
input then there will be more
multiplication and additions here but
multiplication and additions here but
multiplication and additions here but
the pairing is only there's only four
the pairing is only there's only four
the pairing is only there's only four
pairing so the so the total CPU is
pairing so the so the total CPU is
pairing so the so the total CPU is
roughly this this amount um yeah I think
roughly this this amount um yeah I think
roughly this this amount um yeah I think
that's it uh sorry for taking uh longer
that's it uh sorry for taking uh longer
that's it uh sorry for taking uh longer
than expected but uh this is it and
than expected but uh this is it and
than expected but uh this is it and
hopefully that you can see that this is
hopefully that you can see that this is
hopefully that you can see that this is
um this is uh you know exciting stuff
um this is uh you know exciting stuff
um this is uh you know exciting stuff
that you can use to build uh DK
that you can use to build uh DK
that you can use to build uh DK
application today you may ask what's the
application today you may ask what's the
application today you may ask what's the
use of it um you know the real
use of it um you know the real
use of it um you know the real
interesting part is is in the circuit
interesting part is is in the circuit
interesting part is is in the circuit
part um so instead of proving you know a
part um so instead of proving you know a
part um so instead of proving you know a
b and c you can write a much uh
b and c you can write a much uh
b and c you can write a much uh
interesting one like you know proving
interesting one like you know proving
interesting one like you know proving
hash like comput computation of a hash
hash like comput computation of a hash
hash like comput computation of a hash
or or knowing a pass in a Merle tree
or or knowing a pass in a Merle tree
or or knowing a pass in a Merle tree
which is like proof of possession or
which is like proof of possession or
which is like proof of possession or
something like that so all the
something like that so all the
something like that so all the
Innovations you know a lot of it can can
Innovations you know a lot of it can can
Innovations you know a lot of it can can
happen on the Contra side which is what
happen on the Contra side which is what
happen on the Contra side which is what
you guys uh you know are that that stuff
you guys uh you know are that that stuff
you guys uh you know are that that stuff
so yeah really looking forward to uh
so yeah really looking forward to uh
so yeah really looking forward to uh
seeing what comes out of it and yeah uh
seeing what comes out of it and yeah uh
seeing what comes out of it and yeah uh
let me know if you have questions we
let me know if you have questions we
let me know if you have questions we
also have a Discord threat feel free to
also have a Discord threat feel free to
also have a Discord threat feel free to
post it there and I'll hand it over to
post it there and I'll hand it over to
post it there and I'll hand it over to
cin great thank you so much this was uh
cin great thank you so much this was uh
cin great thank you so much this was uh
this was really good I think the
this was really good I think the
this was really good I think the
examples and and walking through the
examples and and walking through the
examples and and walking through the
code really made it U easier to
code really made it U easier to
code really made it U easier to
understand and and see see potential
understand and and see see potential
understand and and see see potential
with so I know we have one question uh
with so I know we have one question uh
with so I know we have one question uh
let me see Elliot was asking a question
let me see Elliot was asking a question
let me see Elliot was asking a question
earlier about if the host functions are
earlier about if the host functions are
earlier about if the host functions are
all that's needed for CK snarks on
all that's needed for CK snarks on
all that's needed for CK snarks on
Stellar or if there's still additional
Stellar or if there's still additional
Stellar or if there's still additional
functionality that's missing I don't
functionality that's missing I don't
functionality that's missing I don't
know if you have an answer for that yeah
know if you have an answer for that yeah
know if you have an answer for that yeah
to to verify the SN it's all we need um
to to verify the SN it's all we need um
to to verify the SN it's all we need um
okay so there there are some some quoes
okay so there there are some some quoes
okay so there there are some some quoes
in SDK which we we we build it like in
in SDK which we we we build it like in
in SDK which we we we build it like in
the um like we provide the the the most
the um like we provide the the the most
the um like we provide the the the most
generic like interface to expose this
generic like interface to expose this
generic like interface to expose this
for but there's a little bit corks like
for but there's a little bit corks like
for but there's a little bit corks like
you like for example ear U see in order
you like for example ear U see in order
you like for example ear U see in order
to try to store that um I have to store
to try to store that um I have to store
to try to store that um I have to store
the Bice instead of the G1 G2 but that's
the Bice instead of the G1 G2 but that's
the Bice instead of the G1 G2 but that's
the fix and also to compute the uh
the fix and also to compute the uh
the fix and also to compute the uh
negation of a point uh you have to do it
negation of a point uh you have to do it
negation of a point uh you have to do it
on the contract side but yeah uh in
on the contract side but yeah uh in
on the contract side but yeah uh in
terms of verification all the tools are
terms of verification all the tools are
terms of verification all the tools are
there um but there may be some ux gap
there um but there may be some ux gap
there um but there may be some ux gap
which I'm discovering and should be
which I'm discovering and should be
which I'm discovering and should be
fixing soon and also with your guys help
fixing soon and also with your guys help
fixing soon and also with your guys help
we will be able to make it better yeah
we will be able to make it better yeah
we will be able to make it better yeah
but in terms of verification that's it
but in terms of verification that's it
but in terms of verification that's it
but in terms of pro proving um so as you
but in terms of pro proving um so as you
but in terms of pro proving um so as you
see proving has to happen offchain and
see proving has to happen offchain and
see proving has to happen offchain and
then that's quite elaborate uh toour set
then that's quite elaborate uh toour set
then that's quite elaborate uh toour set
and also like different um Suites of uh
and also like different um Suites of uh
and also like different um Suites of uh
you know there's different Frameworks of
you know there's different Frameworks of
you know there's different Frameworks of
U like Marin uh you know gr 16 Plank and
U like Marin uh you know gr 16 Plank and
U like Marin uh you know gr 16 Plank and
and all the other other tools that you
and all the other other tools that you
and all the other other tools that you
can use so we haven't provide any of
can use so we haven't provide any of
can use so we haven't provide any of
that and we don't uh endorse any of it I
that and we don't uh endorse any of it I
that and we don't uh endorse any of it I
was just using the snjs as a example
was just using the snjs as a example
was just using the snjs as a example
because that's one of the you know most
because that's one of the you know most
because that's one of the you know most
well known um and then yeah that also
well known um and then yeah that also
well known um and then yeah that also
the the public ceremony aspect uh yeah
the the public ceremony aspect uh yeah
the the public ceremony aspect uh yeah
we don't have it on chain so but yeah
we don't have it on chain so but yeah
we don't have it on chain so but yeah
you can verify it but not there's no
you can verify it but not there's no
you can verify it but not there's no
proving um uh tour CH available at the
proving um uh tour CH available at the
proving um uh tour CH available at the
moment okay great any any other
moment okay great any any other
moment okay great any any other
questions feel free to put them in the
chat I don't
chat I don't
think that's the case
think that's the case
think that's the case
uh we are kind of running out of time so
uh we are kind of running out of time so
uh we are kind of running out of time so
I
I
I
will save the the uh walk through of
will save the the uh walk through of
will save the the uh walk through of
quick start for the next meeting um but
quick start for the next meeting um but
quick start for the next meeting um but
yeah if there's no other questions then
yeah if there's no other questions then
yeah if there's no other questions then
I think
I think
I think
U we will stop it right here let's
see
see
yeah
yeah
yeah
okay well thank you Jay thank you for
okay well thank you Jay thank you for
okay well thank you Jay thank you for
for for for your presentation it was
for for for your presentation it was
for for for your presentation it was
really good I think uh I think going
really good I think uh I think going
really good I think uh I think going
forward when we when we add new
forward when we when we add new
forward when we when we add new
functionality in in protocol when we uh
functionality in in protocol when we uh
functionality in in protocol when we uh
upgrade the network I think it's it's
upgrade the network I think it's it's
upgrade the network I think it's it's
relevant to to maybe spend some time in
relevant to to maybe spend some time in
relevant to to maybe spend some time in
in these meetings to to go over some of
in these meetings to to go over some of
in these meetings to to go over some of
the new new functionality and some of
the new new functionality and some of
the new new functionality and some of
the the things we can do as a developer
the the things we can do as a developer
the the things we can do as a developer
um so yeah um look forward to to more of
um so yeah um look forward to to more of
um so yeah um look forward to to more of
this kind of presentations but thank you
this kind of presentations but thank you
this kind of presentations but thank you
J Jay and thank you for everyone who
J Jay and thank you for everyone who
J Jay and thank you for everyone who
joined have a good holiday thank you you
joined have a good holiday thank you you
joined have a good holiday thank you you
guys happy holiday bye

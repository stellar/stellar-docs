---
title: Ejemplo
sidebar_position: 40
---

La integración con la plataforma de anclaje abarca tres áreas clave:

- Construir una experiencia de usuario basada en la web que se pueda abrir en una vista de web móvil
- Proporcionando actualizaciones de estado de la transacción a la plataforma de anclaje
- Obteniendo actualizaciones de estado de la transacción desde la plataforma de anclaje

## Construir una experiencia de usuario basada en la web

La Plataforma de Anclaje no ofrece una IU de etiqueta blanca que su empresa pueda utilizar, y en su lugar espera que el negocio construya su propio sistema de interfaz de usuario y backend. No construiremos una experiencia de usuario completa en & off-ramp en esta guía, pero cubrirá las formas en que su producto existente debe ser actualizado para ser compatible con la Plataforma Anchor.

### Autenticación

Si su negocio tiene un producto existente en & off-ramp, es probable que tenga un sistema existente para autenticación de usuario. Sin embargo, debido a que la Plataforma de Anchor autentifica al usuario antes de proporcionar la URL del negocio, exigir al usuario que pase por otra forma de autenticación es realmente innecesario. De este modo, se puede pensar que la Plataforma de Anchor proporciona una forma alternativa de autenticación.

El negocio es libre de seguir exigiendo que los usuarios se autentifiquen usando su sistema existente, pero la experiencia ideal del usuario saltaría este paso y crearía una sesión autenticada para el usuario si ya se hubiera autenticado usando su cuenta Stellar.

La Plataforma de Anchor añade un parámetro de consulta JWT `token` a la URL del negocio dada a la aplicación de cartera. Este token está firmado por el valor `SECRET_SEP24_INTERACTIVE_URL_JWT_SECRET` configurado anteriormente, e incluye la información que necesita para identificar al usuario. El proceso debería ser algo así:

1. Pasar el `token` añadido a la URL de tu sistema backend
2. Verifique la firma en el `token` y compruebe su expiración
3. Crear una sesión autenticada para el usuario identificado por `token.sub`

El contenido decodificado del `token` se verá algo así:

<CodeExample>

```json
{
  "jti": "e26cf292-814f-4918-9b40-b4f76a300f98",
  "sub": "GB244654NC6YPEFU3AY7L25COGES445P3Q63W6Q76JHR3UBJMLT2XBOB:1234567",
  "exp": 1516239022,
  "data": {
    "first_name": "John",
    "last_name": "Doe",
    "email": "johndoe@example. om"
  }
}
```

</CodeExample>

Tenga en cuenta que el valor `sub` identifica al usuario usando una cuenta Stellar y un entero. Este es el valor que tendrá cuando las aplicaciones custodial que utilizan una cuenta omnibus se autentifiquen con su servicio. Cuando las billeteras no custodial se autentican, el token puede parecer ligeramente diferente.

<CodeExample>

```json
{
  "jti": "e26cf292-814f-4918-9b40-b4f76a300f98",
  "sub": "GB244654NC6YPEFU3AY7L25COGES445P3Q63W6Q76JHR3UBJMLT2XBOB",
  "exp": 1516239022,
  "data": {
    "client_domain": "api. ibrantapp.com",
    "first_name": "John",
    "last_name": "Doe",
    "email": "johndoe@example. om"
  }
}
```

</CodeExample>

El valor `sub` aquí solo contiene una clave pública para identificar al usuario, y el campo `data.client_domain` identifica la aplicación de cartera utilizada para autenticar.

En ambos casos, toda la información en el objeto `data` es opcional, y sólo estará presente si la cartera proporciona esa información.

Vamos a añadir un servidor de backend a nuestro archivo de composición que se utilizará para verificar el token y crear sesiones web autenticadas para los usuarios que inicien transacciones.

<CodeExample>

```yaml
# docker-compose.yaml
---
business-server:
  build: .
  ports:
    - "8081:8081"
  env_file:
    - ./dev.env
  depends_on:
    - platform-server
```

</CodeExample>

Vamos a crear un simple contenedor Docker para nuestra aplicación.

<CodeExample>

```docker
FROM node:19

WORKDIR /home
COPY .
RUN npm install

CMD ["node", "server.js"]
```

</CodeExample>

Ahora vamos a crear una aplicación mínima de NodeJS.

<CodeExample>

```bash
yarn init -y
yarn add express jsonwebtoken
touch server.js
```

</CodeExample>

A continuación se muestra un ejemplo de un servidor de backend que autentifica a un usuario usando NodeJS.

<CodeExample>

```js
# server.js
const express = require("express");
const jwt = require("jsonwebtoken");
const app = express();
const port = process.env.BUSINESS_SERVER_PORT;

app.use(express.json());

/*
 * We'll store user session data in memory, but production systems
 * should store this data somewhere more persistent.
 */
const sessions = {};

/*
 * Create an authenticated session for the user.
 *
 * Return a session token to be used in future requests as well as the
 * user data. Note that you may not have a user for the stellar account
 * provided, in which case the user should go through your onboarding
 * process.
 */
app.post("/session", async (req, res) => {
  let decodedPlatformToken;
  try {
    decodedPlatformToken = validatePlatformToken(req.body.platformToken);
  } catch (err) {
    res.status = 400;
    res.send({ "error": err });
    return;
  }
  let user = getUser(decodedPlatformToken.sub);
  let sessionToken = jwt.sign(
    { "jti": decodedPlatformToken.jti },
    process.env.SESSION_JWT_SECRET
  );
  sessions[sessionToken] = user;
  res.send({
    "token": sessionToken,
    "user": user
  });
});

/*
 * Validate the signature and contents of the platform's token
 */
function validatePlatformToken(token) {
  if (!token) {
    throw "missing 'platformToken'";
  }
  let decodedToken;
  try {
    decodedToken = jwt.verify(token, process.env.SECRET_SEP10_JWT_SECRET);
  } catch {
    throw "invalid 'platformToken'";
  }
  if (!decodedToken.jti) {
    throw "invalid 'platformToken': missing 'jti'";
  }
  return decodedToken;
}

/*
 * Query your own database for the user based on account:memo string parameter
 */
function getUser(sub) {
  return null;
}

app.listen(port, () => {
    console.log(`business server listening on port ${port}`);
});
```

</CodeExample>

Ejecute esto con el servidor de plataforma y la base de datos e inicie una nueva transacción con el [monedero de demostración][stellar-demo-wallet]. Luego, enviaremos el token a nuestro servidor.

<CodeExample>

```bash
curl \
  -X POST \
  -H 'Content-Type: application/json' \
  -d '{"platformToken": "<paste the token from the URL here>"}' \
  http://localhost:8081/session | jq
```

</CodeExample>

## Proporcionando actualizaciones a la plataforma

Vamos a crear un punto final para nuestro servidor de negocios que acepte la información recogida en nuestra interfaz de usuario.

<CodeExample>

```js
# server.js

// Production systems should either let the Anchor Platform generate its own memos
// or have your custodial service generate a memo for each transaction.
const transactionMemos = {};

app.post("/transaction", async (req, res) => {
  let sessionToken;
  try {
    sessionToken = validateSessionToken(req.headers.get("authorization"));
  } catch (err) {
    res.status = 400;
    res.send({ "error": err })
    return;
  }
  // assuming this is a withdrawal transaction, we'll provide a memo, which is
  // required by our third-party custodian to credit us the payment. When the
  // payment is made with this memo, we can match the on-chain payment with the
  // transaction in the Anchor Platform's database.
  transactionMemos[req.body.transaction.id] = parseInt(Math.random() * 100000);
  let rpcRequestBody = [
    {
      "id": 1,
      "jsonrpc": "2.0",
      "method": "request_onchain_funds",
      "params": {
        "transaction_id": req.body.transaction.id,,
        "message": "waiting for the user to provide off-chain funds.",
        "amount_in": {
          "amount": req.body.amount_in.amount,
          "asset": "stellar:USDC:GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5"
        },
        "amount_out": {
          "amount": req.body.amount_out.amount,
          "asset": "iso4217:USD"
        },
        "amount_fee": {
          "amount": req.body.amount_fee.amount,
          "asset": "stellar:USDC:GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5"
        },
        "destination_account": "GD...G",
        "memo": transactionMemos[req.body.transaction.id],
        "memo_type": "id"
      }
    }
  ];
  let platformResponse;
  try {
    platformResponse = await updatePlatformTransaction(rpcRequestBody);
  } catch (err) {
    res.status = 500;
    res.send({ "error": err })
    return;
  }
  res.send({
    "transaction": platformResponse.records[0]
  });
});

function validateSessionToken(authorizationHeader) {
    let parts = authorizationHeader.split(" ");
    if (parts.length != 2 || parts[0] != "Bearer") {
        throw "invalid authorization header format";
    }
    let sessionToken = parts[1];
    try {
        jwt.verify(sessionToken, process.env.SESSION_JWT_SECRET);
    } catch {
        throw "invalid session token";
    }
    if (!sessions[sessionToken]) {
        throw "expired session";
    }
    return sessionToken;
}

async function updatePlatformTransaction(requestBody) {
  let response = await fetch(
    `${process.env.PLATFORM_SERVER}`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(requestBody)
    }
  );
  if (response.status != 200) {
    throw `unexpected status code: ${response.status}`;
  }
  return await response.json();
}
```

</CodeExample>

Esto actualizará la base de datos de la Plataforma de Anclaje con la información proporcionada y permitirá a las aplicaciones de cartera obtener esta información actualizada para que pueda retransmitirla al usuario. Usted debería haber informado al usuario de las cantidades de la transacción y que su negocio está esperando que llegue el pago en cadena pero proporcionar estas actualizaciones permite a los usuarios ver los estados de sus transacciones a través de su aplicación móvil sin abrir de nuevo la interfaz de usuario del negocio.

:::note

En este momento, la Plataforma de Anclaje no envía notificaciones a la aplicación de cartera cuando los estados de transacción cambian, sin embargo, está en nuestro mapa de ruta para añadir estas notificaciones o "solicitudes de devolución de llamada" para que las aplicaciones de cartera no tengan que consultar la Plataforma de ancla para actualizaciones.

:::

## Obteniendo actualizaciones desde la plataforma

Si sólo utiliza la Plataforma de Anclaje para exponer las APIs SEP a aplicaciones de cartera, entonces no tendrás una razón sólida para obtener actualizaciones del estado de la transacción desde la plataforma Anchor, principalmente porque no actualizará el estado de la transacción hasta que haga peticiones `JSON-RPC API`.

Sin embargo, si usas la Plataforma de Ancla para monitorear la red estelar para pagos entrantes (asociados con transacciones de retiro), la Plataforma de Anchor actualizará los estados de transacción cuando se reciban los pagos.

Hay dos maneras de obtener actualizaciones desde la plataforma Anchor,

- Encuesta de la plataforma API `GET /transactions/:id` para las transacciones que estás esperando un pago
- Transmitiendo eventos de cambio de estado de transacción desde un clúster de Kafka

Mientras que el estado de las transacciones de streaming cambia desde un clúster de Kafka puede ser un enfoque más robusto y escalable. vamos a utilizar el método de votación en esta guía. La configuración y el uso de un clúster Kafka serán objeto de una sección diferente de los documentos.

Primero, configuremos la Plataforma de Anclaje para observar la red Estelar para los pagos entrantes.

<CodeExample>

```yaml
# docker-compose. ml
---
stellar-observer:
  image: stellar/anchor-platform:latest
  command: --stellar-observer
  env_file:
    - . dev.env
  volumes:
    - ./config:/home
  depends_on:
    - db
```

</CodeExample>

El comando `--stellar-observer` inicia un proceso que monitoriza las cuentas de distribución configuradas en tu archivo `config.yaml` para pagos de retiro.

Si un pago es enviado a una de estas cuentas y el memo adjunto a la transacción coincide con un valor `memo` proporcionado o generado por la Plataforma de Anchor, la Plataforma de Anchor considerará la transacción con la que memo está asociado como recibida y actualizará el estado de la transacción a 'pending_anchor'. Hace esto haciendo una petición `JSON-RPC API`, así que necesitamos configurar la URL que debería usar.

<CodeExample>

```bash
# dev.env
PLATFORM_API_BASE_URL=http://platform-server:8085
```

</CodeExample>

Vamos a hacer algunas adiciones al archivo `server.js` para que podamos sondear la Plataforma de Anchor para nuestros pagos esperados.

<CodeExample>

```js
// server.js
... Rformat@@1 /*
 * Obtener los datos de transacción de la API de Plataforma
 *
 * Los sistemas de producción deben tener mecanismos de reintento adecuados.
 */
async function getPlatformTransaction(transactionId) {
  let response = await fetch(`${process.env.PLATFORM_SERVER}/transactions/${transactionId}`)
  if (respuesta. tatus ! 200) {
    tiro `código de estado inesperado: ${response.status}`;
  }
  return espera respuesta. son();
}

(async () => {
  while (true) {
    await new Promise(r => setTimeout(r, 2000));
    let requestPromises;
    for (const transactionId in transactionMemos) {
      requestPromises. ush(getPlatformTransaction(transactionId))
    }
    let transactions = await new Promise. ll(requestPromises);
    for (const transaction in transactions) {
      // asumiendo que todas las solicitudes fueron exitosas
      if (transacción. tatus == "pending_anchor") {
        // iniciar la entrega de fondos fuera de la cadena
        consola. og(`pago recibido para la transacción ${transaction.id}`);
      }
    }
  }
})()
```

</CodeExample>

## Ejemplo completo de implementación

Stellar proporciona un ejemplo de implementación de servidor empresarial para SEP-24. Se divide en dos partes: 1) una interfaz web, accesible para el usuario final; y 2) una implementación de back-end, usada para obtener y empujar actualizaciones de/a la plataforma Anchor.

El código para la interfaz web se puede encontrar [here][sep-24-ref-ui]

El código para el backend es parte de la Plataforma de Ancor, y está disponible como una [submodule][sep-24-ref].

[sep-1]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0001.md
[sep-9]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0009.md
[sep-24]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0024.md
[sep-38]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0038.md
[sep24-get-info]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0024.md#info
[imagen de la plataforma ancladora]: https://hub.docker.com/r/stellar/anchor-platform
[composición-docker]: https://docs.docker.com/compose/
[minikube]: https://minikube.sigs.k8s.io/docs/
[kubernetes]: https://kubernetes.io/
[nginx]: https://www.nginx.com/
[ap-default-values]: https://github.com/stellar/java-stellar-anchor-sdk/blob/develop/platform/src/main/resources/config/anchor-config-default-values.yaml
[monedero stellar-demo-]: https://demo-wallet.stellar.org
[laboratorio estelar]: https://laboratory.stellar.org/
[postgresql]: https://www.postgresql.org/
[aurora-postgresql]: https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.AuroraPostgreSQL.html
[h2]: https://www.h2database.com/html/main.html
[sqlite]: https://www.sqlite.org/index.html
[volante]: https://documentation.red-gate.com/fd/welcome-to-flyway-184127914.html
[sep-24 ref-ui]: https://github.com/stellar/sep24-reference-ui
[sep-24-ref]: https://github.com/stellar/java-stellar-anchor-sdk/tree/develop/kotlin-reference-server

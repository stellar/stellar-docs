---
title: Ejemplo
sidebar_position: 40
---

Integrarse con la Anchor Platform implica tres áreas clave:

- Crear una experiencia de usuario basada en la web que se pueda abrir en una vista web móvil
- Proporcionar actualizaciones del estado de las transacciones a la Anchor Platform
- Recuperar actualizaciones del estado de las transacciones desde la Anchor Platform

## Crear una Experiencia de Usuario Basada en la Web

La Anchor Platform no ofrece una interfaz de usuario de etiqueta blanca que tu negocio pueda usar, y en su lugar espera que el negocio construya su propia interfaz de usuario y sistema backend. No construiremos toda una experiencia de usuario de entrada y salida en esta guía, pero cubriremos las formas en que tu producto existente debería actualizarse para ser compatible con la Anchor Platform.

### Autenticación

Si tu negocio tiene un producto de entrada y salida existente, es probable que ya tengas un sistema para la autenticación de usuarios. Sin embargo, dado que la Anchor Platform autentica al usuario antes de proporcionar la URL del negocio, requerir que el usuario pase por otra forma de autenticación es en realidad innecesario. De esta manera, la Anchor Platform puede considerarse como que proporciona una forma alternativa de autenticación.

El negocio es libre de continuar requiriendo que los usuarios se autentiquen usando su sistema existente, pero la experiencia de usuario ideal omitiría este paso y crearía una sesión autenticada para el usuario si ya se ha autenticado usando su cuenta de Stellar.

La Anchor Platform agrega un parámetro de consulta `token` a la URL del negocio proporcionada a la aplicación de billetera. Este token está firmado por el valor `SECRET_SEP24_INTERACTIVE_URL_JWT_SECRET` previamente configurado, e incluye la información que necesitas para identificar al usuario. El proceso debería verse algo así:

1. Pasa el `token` agregado a la URL de tu sistema backend
2. Verifica la firma en el `token` y comprueba su caducidad
3. Crea una sesión autenticada para el usuario identificado por `token.sub`

Los contenidos decodificados del `token` se verán algo así:

<CodeExample>

```json
{
  "jti": "e26cf292-814f-4918-9b40-b4f76a300f98",
  "sub": "GB244654NC6YPEFU3AY7L25COGES445P3Q63W6Q76JHR3UBJMLT2XBOB:1234567",
  "exp": 1516239022,
  "data": {
    "first_name": "John",
    "last_name": "Doe",
    "email": "johndoe@example.com"
  }
}
```

</CodeExample>

Nota que el valor de `sub` identifica al usuario usando una cuenta de Stellar y un entero. Este es el valor que tendrá cuando las aplicaciones de custodia que utilizan una cuenta de conjunto se autentiquen con tu servicio. Cuando las billeteras no custodiales se autentican, el token puede verse ligeramente diferente.

<CodeExample>

```json
{
  "jti": "e26cf292-814f-4918-9b40-b4f76a300f98",
  "sub": "GB244654NC6YPEFU3AY7L25COGES445P3Q63W6Q76JHR3UBJMLT2XBOB",
  "exp": 1516239022,
  "data": {
    "client_domain": "api.vibrantapp.com",
    "first_name": "John",
    "last_name": "Doe",
    "email": "johndoe@example.com"
  }
}
```

</CodeExample>

El valor `sub` aquí solo contiene una clave pública para identificar al usuario, y el campo `data.client_domain` identifica la aplicación de billetera utilizada para autenticar.

En ambos casos, toda la información en el objeto `data` es opcional y solo estará presente si la billetera proporciona esa información.

Vamos a agregar un servidor backend a nuestro archivo de composición que se utilizará para verificar el token y crear sesiones web autenticadas para los usuarios que inicien transacciones.

<CodeExample>

```yaml
# docker-compose.yaml
---
business-server:
  build: .
  ports:
    - "8081:8081"
  env_file:
    - ./dev.env
  depends_on:
    - platform-server
```

</CodeExample>

Vamos a crear un contenedor de Docker simple para nuestra aplicación.

<CodeExample>

```docker
FROM node:19

WORKDIR /home
COPY . .
RUN npm install

CMD ["node", "server.js"]
```

</CodeExample>

Ahora vamos a crear una aplicación mínima de NodeJS.

<CodeExample>

```bash
yarn init -y
yarn add express jsonwebtoken
touch server.js
```

</CodeExample>

A continuación se muestra un ejemplo de un servidor backend que autentica a un usuario usando NodeJS.

<CodeExample>

```js
# server.js
const express = require("express");
const jwt = require("jsonwebtoken");
const app = express();
const port = process.env.BUSINESS_SERVER_PORT;

app.use(express.json());

/*
 * We'll store user session data in memory, but production systems
 * should store this data somewhere more persistent.
 */
const sessions = {};

/*
 * Create an authenticated session for the user.
 *
 * Return a session token to be used in future requests as well as the
 * user data. Note that you may not have a user for the stellar account
 * provided, in which case the user should go through your onboarding
 * process.
 */
app.post("/session", async (req, res) => {
  let decodedPlatformToken;
  try {
    decodedPlatformToken = validatePlatformToken(req.body.platformToken);
  } catch (err) {
    res.status = 400;
    res.send({ "error": err });
    return;
  }
  let user = getUser(decodedPlatformToken.sub);
  let sessionToken = jwt.sign(
    { "jti": decodedPlatformToken.jti },
    process.env.SESSION_JWT_SECRET
  );
  sessions[sessionToken] = user;
  res.send({
    "token": sessionToken,
    "user": user
  });
});

/*
 * Validate the signature and contents of the platform's token
 */
function validatePlatformToken(token) {
  if (!token) {
    throw "missing 'platformToken'";
  }
  let decodedToken;
  try {
    decodedToken = jwt.verify(token, process.env.SECRET_SEP10_JWT_SECRET);
  } catch {
    throw "invalid 'platformToken'";
  }
  if (!decodedToken.jti) {
    throw "invalid 'platformToken': missing 'jti'";
  }
  return decodedToken;
}

/*
 * Query your own database for the user based on account:memo string parameter
 */
function getUser(sub) {
  return null;
}

app.listen(port, () => {
    console.log(`business server listening on port ${port}`);
});
```

</CodeExample>

Ejecuta esto con el servidor de plataforma y la base de datos e inicia una nueva transacción con la [billetera de demostración][stellar-demo-wallet]. Luego, enviaremos el token a nuestro servidor.

<CodeExample>

```bash
curl \
  -X POST \
  -H 'Content-Type: application/json' \
  -d '{"platformToken": "<paste the token from the URL here>"}' \
  http://localhost:8081/session | jq
```

</CodeExample>

## Proporcionando Actualizaciones a la Plataforma

Vamos a crear un endpoint para nuestro servidor de negocios que acepte la información recopilada en nuestra interfaz de usuario.

<CodeExample>

```js
# server.js

// Production systems should either let the Anchor Platform generate its own memos
// or have your custodial service generate a memo for each transaction.
const transactionMemos = {};

app.post("/transaction", async (req, res) => {
  let sessionToken;
  try {
    sessionToken = validateSessionToken(req.headers.get("authorization"));
  } catch (err) {
    res.status = 400;
    res.send({ "error": err })
    return;
  }
  // assuming this is a withdrawal transaction, we'll provide a memo, which is
  // required by our third-party custodian to credit us the payment. When the
  // payment is made with this memo, we can match the on-chain payment with the
  // transaction in the Anchor Platform's database.
  transactionMemos[req.body.transaction.id] = parseInt(Math.random() * 100000);
  let rpcRequestBody = [
    {
      "id": 1,
      "jsonrpc": "2.0",
      "method": "request_onchain_funds",
      "params": {
        "transaction_id": req.body.transaction.id,,
        "message": "waiting for the user to provide off-chain funds.",
        "amount_in": {
          "amount": req.body.amount_in.amount,
          "asset": "stellar:USDC:GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5"
        },
        "amount_out": {
          "amount": req.body.amount_out.amount,
          "asset": "iso4217:USD"
        },
        "fee_details": {
          "total": req.body.fee_details.total,
          "asset": "stellar:USDC:GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5"
        },
        "destination_account": "GD...G",
        "memo": transactionMemos[req.body.transaction.id],
        "memo_type": "id"
      }
    }
  ];
  let platformResponse;
  try {
    platformResponse = await updatePlatformTransaction(rpcRequestBody);
  } catch (err) {
    res.status = 500;
    res.send({ "error": err })
    return;
  }
  res.send({
    "transaction": platformResponse.records[0]
  });
});

function validateSessionToken(authorizationHeader) {
    let parts = authorizationHeader.split(" ");
    if (parts.length != 2 || parts[0] != "Bearer") {
        throw "invalid authorization header format";
    }
    let sessionToken = parts[1];
    try {
        jwt.verify(sessionToken, process.env.SESSION_JWT_SECRET);
    } catch {
        throw "invalid session token";
    }
    if (!sessions[sessionToken]) {
        throw "expired session";
    }
    return sessionToken;
}

async function updatePlatformTransaction(requestBody) {
  let response = await fetch(
    `${process.env.PLATFORM_SERVER}`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(requestBody)
    }
  );
  if (response.status != 200) {
    throw `unexpected status code: ${response.status}`;
  }
  return await response.json();
}
```

</CodeExample>

Esto actualizará la base de datos de la Anchor Platform con la información proporcionada y permitirá que las aplicaciones de billetera recuperen esta información actualizada para poder retransmitirla al usuario. Ya deberías haber informado al usuario sobre los montos de la transacción y que tu negocio está esperando que llegue el pago on-chain, pero proporcionar estas actualizaciones permite a los usuarios ver el estado de sus transacciones a través de su aplicación móvil sin tener que abrir la interfaz de usuario del negocio nuevamente.

:::note

En este momento, la Anchor Platform no envía notificaciones a la aplicación de billetera cuando cambian los estados de las transacciones, sin embargo, está en nuestra hoja de ruta agregar estas notificaciones o "solicitudes de retorno" para que las aplicaciones de billetera no tengan que consultar a la Anchor Platform por actualizaciones.

:::

## Recuperando Actualizaciones de la Plataforma

Si solo utilizas la Anchor Platform para exponer las API SEP a las aplicaciones de billetera, entonces no tendrás una razón sólida para recuperar actualizaciones del estado de las transacciones de la Anchor Platform, principalmente porque no actualizará el estado de la transacción hasta que realices solicitudes `JSON-RPC API`.

Sin embargo, si utilizas la Anchor Platform para monitorizar la red Stellar en busca de pagos entrantes (asociados con transacciones de retirada de fondos), la Anchor Platform actualizará los estados de las transacciones cuando se reciban los pagos.

Hay dos formas de recuperar actualizaciones de la Anchor Platform,

- Consultar la API de la plataforma en el endpoint `GET /transactions/:id` para las transacciones que esperas un pago
- Transmitir eventos de cambio de estado de la transacción desde un clúster de Kafka

Si bien transmitir cambios de estado de la transacción desde un clúster de Kafka puede ser un enfoque más robusto y escalable, vamos a utilizar el método de sondeo en esta guía. Configurar y utilizar un clúster de Kafka será el tema de una sección diferente de la documentación.

Primero, configuremos la Anchor Platform para observar la red Stellar en busca de pagos entrantes.

<CodeExample>

```yaml
# docker-compose.yml
---
stellar-observer:
  image: stellar/anchor-platform:latest
  command: --stellar-observer
  env_file:
    - ./dev.env
  volumes:
    - ./config:/home
  depends_on:
    - db
```

</CodeExample>

El comando `--stellar-observer` inicia un proceso que monitorea las cuentas de distribución configuradas en tu archivo `config.yaml` para pagos de retirada de fondos.

Si se envía un pago a una de estas cuentas y el memo adjunto a la transacción coincide con un valor `memo` proporcionado o generado por la Anchor Platform, la Anchor Platform considerará la transacción asociada con ese memo como recibida y actualizará el estado de la transacción a `pending_anchor`. Esto lo hace mediante una solicitud `JSON-RPC API`, así que necesitamos configurar la URL que debería utilizar.

<CodeExample>

```bash
# dev.env
PLATFORM_API_BASE_URL=http://platform-server:8085
```

</CodeExample>

Vamos a hacer algunas adiciones al archivo `server.js` para que podamos consultar a la Anchor Platform por nuestros pagos esperados.

<CodeExample>

```js
// server.js
...
/*
 * Fetch the transaction data from the Platform API
 *
 * Production systems should have proper retry mechanisms.
 */
async function getPlatformTransaction(transactionId) {
  let response = await fetch(`${process.env.PLATFORM_SERVER}/transactions/${transactionId}`)
  if (response.status != 200) {
    throw `unexpected status code: ${response.status}`;
  }
  return await response.json();
}

(async () => {
  while (true) {
    await new Promise(r => setTimeout(r, 2000));
    let requestPromises;
    for (const transactionId in transactionMemos) {
      requestPromises.push(getPlatformTransaction(transactionId))
    }
    let transactions = await new Promise.all(requestPromises);
    for (const transaction in transactions) {
      // assuming all requests were successful
      if (transaction.status == "pending_anchor") {
        // initiate off-chain delivery of funds
        console.log(`received payment for transaction ${transaction.id}`);
      }
    }
  }
})()
```

</CodeExample>

## Implementación Completa de Ejemplo

Stellar proporciona una implementación de ejemplo de servidor de negocios para SEP-24. Se divide en dos partes: 1) una interfaz de usuario web, accesible para el usuario final; y 2) una implementación de backend, utilizada para obtener y enviar actualizaciones desde/hacia la Anchor Platform.

El código para la interfaz de usuario web se puede encontrar [aquí][sep-24-ref-ui]

El código para el backend es parte de la Anchor Platform, y está disponible como un [submódulo][sep-24-ref].

[sep-1]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0001.md
[sep-9]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0009.md
[sep-24]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0024.md
[sep-38]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0038.md
[sep24-get-info]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0024.md#info
[anchor-platform-image]: https://hub.docker.com/r/stellar/anchor-platform
[docker-compose]: https://docs.docker.com/compose/
[minikube]: https://minikube.sigs.k8s.io/docs/
[kubernetes]: https://kubernetes.io/
[nginx]: https://www.nginx.com/
[ap-default-values]: https://github.com/stellar/java-stellar-anchor-sdk/blob/develop/platform/src/main/resources/config/anchor-config-default-values.yaml
[stellar-demo-wallet]: https://demo-wallet.stellar.org
[stellar-lab]: https://lab.stellar.org/
[postgresql]: https://www.postgresql.org/
[aurora-postgresql]: https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.AuroraPostgreSQL.html
[h2]: https://www.h2database.com/html/main.html
[sqlite]: https://www.sqlite.org/index.html
[flyway]: https://documentation.red-gate.com/fd/welcome-to-flyway-184127914.html
[sep-24-ref-ui]: https://github.com/stellar/sep24-reference-ui
[sep-24-ref]: https://github.com/stellar/java-stellar-anchor-sdk/tree/develop/kotlin-reference-server

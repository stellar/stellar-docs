---
title: Ejemplo
sidebar_position: 40
---

Integrar con la Anchor Platform implica tres áreas clave:

- Crear una experiencia de usuario basada en la web que se pueda abrir en una vista web móvil
- Proporcionar actualizaciones del estado de las transacciones a la Anchor Platform
- Recuperar actualizaciones del estado de las transacciones desde la Anchor Platform

## Crear una Experiencia de Usuario Basada en la Web

La Anchor Platform no ofrece una interfaz de usuario de marca blanca que tu negocio pueda utilizar, y en su lugar espera que el negocio cree su propia interfaz de usuario y sistema backend. No vamos a crear toda una experiencia de usuario para el on & off-ramp en esta guía, pero cubriremos las formas en que tu producto existente debe actualizarse para ser compatible con la Anchor Platform.

### Autenticación

Si tu negocio tiene un producto existente de on & off-ramp, es probable que ya tengas un sistema existente para la autenticación de usuarios. Sin embargo, dado que la Anchor Platform autentica al usuario antes de proporcionar la URL del negocio, requerir que el usuario pase por otra forma de autenticación es en realidad innecesario. De esta manera, la Anchor Platform se puede considerar como una forma alternativa de autenticación.

El negocio es libre de continuar exigiendo a los usuarios que se autentiquen usando su sistema existente, pero la experiencia de usuario ideal omitiría este paso y crearía una sesión autenticada para el usuario si ya se han autenticado usando su cuenta de Stellar.

La Anchor Platform agrega un parámetro de consulta `token` a la URL del negocio proporcionada a la aplicación de billetera. Este token está firmado por el valor previamente configurado `SECRET_SEP24_INTERACTIVE_URL_JWT_SECRET`, e incluye la información que necesitas para identificar al usuario. El proceso debería verse algo así:

1. Pasa el `token` agregado a la URL de tu sistema backend
2. Verifica la firma en el `token` y verifica su caducidad
3. Crea una sesión autenticada para el usuario identificado por `token.sub`

El contenido decodificado del `token` se verá algo así:

<CodeExample>

```json
{
  "jti": "e26cf292-814f-4918-9b40-b4f76a300f98",
  "sub": "GB244654NC6YPEFU3AY7L25COGES445P3Q63W6Q76JHR3UBJMLT2XBOB:1234567",
  "exp": 1516239022,
  "data": {
    "first_name": "John",
    "last_name": "Doe",
    "email": "johndoe@example.com"
  }
}
```

</CodeExample>

Ten en cuenta que el valor `sub` identifica al usuario usando una cuenta de Stellar y un número entero. Este es el valor que tendrá cuando aplicaciones custodiales que utilizan una cuenta omnibus se autentiquen con tu servicio. Cuando las billeteras no custodiales se autentican, el token puede verse ligeramente diferente.

<CodeExample>

```json
{
  "jti": "e26cf292-814f-4918-9b40-b4f76a300f98",
  "sub": "GB244654NC6YPEFU3AY7L25COGES445P3Q63W6Q76JHR3UBJMLT2XBOB",
  "exp": 1516239022,
  "data": {
    "client_domain": "api.vibrantapp.com",
    "first_name": "John",
    "last_name": "Doe",
    "email": "johndoe@example.com"
  }
}
```

</CodeExample>

El valor `sub` aquí solo contiene una clave pública para identificar al usuario, y el campo `data.client_domain` identifica la aplicación de billetera utilizada para autenticar.

En ambos casos, toda la información en el objeto `data` es opcional y solo estará presente si la billetera proporciona esa información.

Agreguemos un servidor backend a nuestro archivo compose que se utilizará para verificar el token y crear sesiones web autenticadas para usuarios que inicien transacciones.

<CodeExample>

```yaml
# docker-compose.yaml
---
business-server:
  build: .
  ports:
    - "8081:8081"
  env_file:
    - ./dev.env
  depends_on:
    - platform-server
```

</CodeExample>

Creamos un contenedor Docker simple para nuestra aplicación.

<CodeExample>

```docker
FROM node:19

WORKDIR /home
COPY . .
RUN npm install

CMD ["node", "server.js"]
```

</CodeExample>

Ahora, creemos una aplicación NodeJS mínima.

<CodeExample>

```bash
yarn init -y
yarn add express jsonwebtoken
touch server.js
```

</CodeExample>

A continuación se muestra un ejemplo de un servidor backend autenticando a un usuario usando NodeJS.

<CodeExample>

```js
# server.js
const express = require("express");
const jwt = require("jsonwebtoken");
const app = express();
const port = process.env.BUSINESS_SERVER_PORT;

app.use(express.json());

/*
 * We'll store user session data in memory, but production systems
 * should store this data somewhere more persistent.
 */
const sessions = {};

/*
 * Create an authenticated session for the user.
 *
 * Return a session token to be used in future requests as well as the
 * user data. Note that you may not have a user for the stellar account
 * provided, in which case the user should go through your onboarding
 * process.
 */
app.post("/session", async (req, res) => {
  let decodedPlatformToken;
  try {
    decodedPlatformToken = validatePlatformToken(req.body.platformToken);
  } catch (err) {
    res.status = 400;
    res.send({ "error": err });
    return;
  }
  let user = getUser(decodedPlatformToken.sub);
  let sessionToken = jwt.sign(
    { "jti": decodedPlatformToken.jti },
    process.env.SESSION_JWT_SECRET
  );
  sessions[sessionToken] = user;
  res.send({
    "token": sessionToken,
    "user": user
  });
});

/*
 * Validate the signature and contents of the platform's token
 */
function validatePlatformToken(token) {
  if (!token) {
    throw "missing 'platformToken'";
  }
  let decodedToken;
  try {
    decodedToken = jwt.verify(token, process.env.SECRET_SEP10_JWT_SECRET);
  } catch {
    throw "invalid 'platformToken'";
  }
  if (!decodedToken.jti) {
    throw "invalid 'platformToken': missing 'jti'";
  }
  return decodedToken;
}

/*
 * Query your own database for the user based on account:memo string parameter
 */
function getUser(sub) {
  return null;
}

app.listen(port, () => {
    console.log(`business server listening on port ${port}`);
});
```

</CodeExample>

Ejecuta esto con el servidor de la plataforma y la base de datos e inicia una nueva transacción con la [billetera de demostración][stellar-demo-wallet]. Luego, enviamos el token a nuestro servidor.

<CodeExample>

```bash
curl \
  -X POST \
  -H 'Content-Type: application/json' \
  -d '{"platformToken": "<paste the token from the URL here>"}' \
  http://localhost:8081/session | jq
```

</CodeExample>

## Proporcionar Actualizaciones a la Plataforma

Creemos un endpoint para nuestro servidor de negocio que acepte la información recopilada en nuestra interfaz de usuario.

<CodeExample>

```js
# server.js

// Production systems should either let the Anchor Platform generate its own memos
// or have your custodial service generate a memo for each transaction.
const transactionMemos = {};

app.post("/transaction", async (req, res) => {
  let sessionToken;
  try {
    sessionToken = validateSessionToken(req.headers.get("authorization"));
  } catch (err) {
    res.status = 400;
    res.send({ "error": err })
    return;
  }
  // assuming this is a withdrawal transaction, we'll provide a memo, which is
  // required by our third-party custodian to credit us the payment. When the
  // payment is made with this memo, we can match the on-chain payment with the
  // transaction in the Anchor Platform's database.
  transactionMemos[req.body.transaction.id] = parseInt(Math.random() * 100000);
  let rpcRequestBody = [
    {
      "id": 1,
      "jsonrpc": "2.0",
      "method": "request_onchain_funds",
      "params": {
        "transaction_id": req.body.transaction.id,,
        "message": "waiting for the user to provide off-chain funds.",
        "amount_in": {
          "amount": req.body.amount_in.amount,
          "asset": "stellar:USDC:GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5"
        },
        "amount_out": {
          "amount": req.body.amount_out.amount,
          "asset": "iso4217:USD"
        },
        "fee_details": {
          "total": req.body.fee_details.total,
          "asset": "stellar:USDC:GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5"
        },
        "destination_account": "GD...G",
        "memo": transactionMemos[req.body.transaction.id],
        "memo_type": "id"
      }
    }
  ];
  let platformResponse;
  try {
    platformResponse = await updatePlatformTransaction(rpcRequestBody);
  } catch (err) {
    res.status = 500;
    res.send({ "error": err })
    return;
  }
  res.send({
    "transaction": platformResponse.records[0]
  });
});

function validateSessionToken(authorizationHeader) {
    let parts = authorizationHeader.split(" ");
    if (parts.length != 2 || parts[0] != "Bearer") {
        throw "invalid authorization header format";
    }
    let sessionToken = parts[1];
    try {
        jwt.verify(sessionToken, process.env.SESSION_JWT_SECRET);
    } catch {
        throw "invalid session token";
    }
    if (!sessions[sessionToken]) {
        throw "expired session";
    }
    return sessionToken;
}

async function updatePlatformTransaction(requestBody) {
  let response = await fetch(
    `${process.env.PLATFORM_SERVER}`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(requestBody)
    }
  );
  if (response.status != 200) {
    throw `unexpected status code: ${response.status}`;
  }
  return await response.json();
}
```

</CodeExample>

Esto actualizará la base de datos de la Anchor Platform con la información proporcionada y permitirá a las aplicaciones de billetera recuperar esta información actualizada para que puedan relatarla al usuario. Ya deberías haber informado al usuario de los montos de las transacciones y que tu negocio está esperando que el pago on-chain llegue, pero proporcionar estas actualizaciones permite a los usuarios ver los estados de sus transacciones a través de su aplicación móvil sin necesidad de abrir de nuevo la interfaz de usuario del negocio.

:::note

En este momento, la Anchor Platform no envía notificaciones a la aplicación de billetera cuando los estados de las transacciones cambian, sin embargo, está en nuestra hoja de ruta agregar estas notificaciones o "solicitudes de retorno" para que las aplicaciones de billetera no tengan que sondear la Anchor Platform para actualizaciones.

:::

## Recuperando Actualizaciones de la Plataforma

Si solo usas la Anchor Platform para exponer las SEP APIs a las aplicaciones de billetera, entonces no tendrás una razón fuerte para recuperar actualizaciones del estado de las transacciones desde la Anchor Platform, principalmente porque no actualizará el estado de la transacción hasta que hagas solicitudes a la `JSON-RPC API`.

Sin embargo, si usas la Anchor Platform para monitorear la red Stellar en busca de pagos entrantes (asociados con transacciones de retirada de fondos), la Anchor Platform actualizará los estados de las transacciones cuando se reciban los pagos.

Hay dos maneras de recuperar actualizaciones desde la Anchor Platform,

- Sondear el endpoint `GET /transactions/:id` de la API de la Plataforma para las transacciones que esperas recibir un pago
- Transmitir eventos de cambio de estado de transacción desde un clúster de Kafka

Mientras que transmitir cambios de estado de transacciones desde un clúster de Kafka puede ser un enfoque más robusto y escalable, vamos a usar el método de sondeo en esta guía. Configurar y usar un clúster de Kafka será el tema de una sección diferente de la documentación.

Primero, configuremos la Anchor Platform para observar la red Stellar en busca de pagos entrantes.

<CodeExample>

```yaml
# docker-compose.yml
---
stellar-observer:
  image: stellar/anchor-platform:3.0.4
  command: --stellar-observer
  env_file:
    - ./dev.env
  volumes:
    - ./config:/home
  depends_on:
    - db
```

</CodeExample>

El comando `--stellar-observer` inicia un proceso que monitorea las cuentas de distribución configuradas en tu archivo `config.yaml` para pagos de retirada de fondos.

Si un pago se envía a una de estas cuentas y el memo adjunto a la transacción coincide con un valor de `memo` proporcionado o generado por la Anchor Platform, la Anchor Platform considerará la transacción asociada a ese memo como recibida y actualizará el estado de la transacción a `pending_anchor`. Esto lo hace realizando una solicitud a la `JSON-RPC API`, así que necesitamos configurar la URL que debe usar.

<CodeExample>

```bash
# dev.env
PLATFORM_API_BASE_URL=http://platform-server:8085
```

</CodeExample>

Hagamos algunas adiciones al archivo `server.js` para que podamos sondear la Anchor Platform por nuestros pagos esperados.

<CodeExample>

```js
// server.js
...
/*
 * Fetch the transaction data from the Platform API
 *
 * Production systems should have proper retry mechanisms.
 */
async function getPlatformTransaction(transactionId) {
  let response = await fetch(`${process.env.PLATFORM_SERVER}/transactions/${transactionId}`)
  if (response.status != 200) {
    throw `unexpected status code: ${response.status}`;
  }
  return await response.json();
}

(async () => {
  while (true) {
    await new Promise(r => setTimeout(r, 2000));
    let requestPromises;
    for (const transactionId in transactionMemos) {
      requestPromises.push(getPlatformTransaction(transactionId))
    }
    let transactions = await new Promise.all(requestPromises);
    for (const transaction in transactions) {
      // assuming all requests were successful
      if (transaction.status == "pending_anchor") {
        // initiate off-chain delivery of funds
        console.log(`received payment for transaction ${transaction.id}`);
      }
    }
  }
})()
```

</CodeExample>

## Implementación de Ejemplo Completo

Stellar proporciona una implementación de ejemplo de servidor de negocio para SEP-24. Se divide en dos partes: 1) una interfaz de usuario web, accesible para el usuario final; y 2) una implementación backend, utilizada para obtener y enviar actualizaciones a/desde la Anchor Platform.

El código para la interfaz de usuario web se puede encontrar [aquí][sep-24-ref-ui]

El código para el backend es parte de la Anchor Platform, y está disponible como un [submódulo][sep-24-ref].

[sep-1]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0001.md
[sep-9]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0009.md
[sep-24]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0024.md
[sep-38]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0038.md
[sep24-get-info]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0024.md#info
[anchor-platform-image]: https://hub.docker.com/r/stellar/anchor-platform
[docker-compose]: https://docs.docker.com/compose/
[minikube]: https://minikube.sigs.k8s.io/docs/
[kubernetes]: https://kubernetes.io/
[nginx]: https://www.nginx.com/
[ap-default-values]: https://github.com/stellar/java-stellar-anchor-sdk/blob/develop/platform/src/main/resources/config/anchor-config-default-values.yaml
[stellar-demo-wallet]: https://demo-wallet.stellar.org
[stellar-lab]: https://lab.stellar.org/
[postgresql]: https://www.postgresql.org/
[aurora-postgresql]: https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.AuroraPostgreSQL.html
[h2]: https://www.h2database.com/html/main.html
[sqlite]: https://www.sqlite.org/index.html
[flyway]: https://documentation.red-gate.com/fd/redgate-flyway-documentation-138346877.html
[sep-24-ref-ui]: https://github.com/stellar/sep24-reference-ui
[sep-24-ref]: https://github.com/stellar/java-stellar-anchor-sdk/tree/develop/kotlin-reference-server

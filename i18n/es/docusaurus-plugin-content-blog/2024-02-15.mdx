---
title: 2024-02-15
authors: naman
tags:
  - protocol
---

<iframe
  src="https://drive.google.com/file/d/1oBuYg_LvGRGnKpjezok6PQGVN8ZpqVvy/preview"
  width="640"
  height="360"
  allow="autoplay"
></iframe>

[Hilo de la agenda de Discord](https://discord.com/channels/897514728459468821/1207385360116490360)

1. La reunión se centró en el proceso de agregar funciones de host, usando WebAuthN como ejemplo de uso caso; continuó desde la reunión anterior.
2. Discusión de las preocupaciones pendientes con la adición de la función de host de verificación secp256r1 de la reunión anterior.
   - ¿Qué significa que secp256r1 sea añadida como una función host vs. como un tipo de signer?
     - Como función de host, el usuario puede firmar entradas de autenticación de soroban. Necesita otra cuenta estelar para financiar y someter tx a la cadena. Esto último se puede hacer mediante una cuenta estelar que puede ser operada por una cartera o un contrato.
     - \_\_check_auth se invoca cuando el contrato se interactúa con las llamadas require_auth
3. CAP-52 fue redactado para introducir funciones de codificación/decodificación para Base64, que es necesario para WebAuthN. Consideraciones discutidas en la reunión:
   - Rendimiento: 1066 bytes que cuestan 1M instr para codificar un hash de 32bytes; por lo que el costo es muy pequeño y es cuestionable si se requiere una función de anfitrión.
   - Interfaz requiere dos funciones (codificar/decodificar)
   - Implementación sabiamente, WebAuthN requiere alfabeto y relleno de url, que decodificador probablemente necesita soportar. ¿Deberíamos usar símbolos o puntos? ¿Necesitamos alfabetos personalizados?
   - ¿Realmente necesitamos más esquemas de codificación? ¿No es suficiente el XDR? 
   - Los costosos mecanismos de autor, es decir, webauthn, no pueden ir acompañados de contratos con una lógica de negocio pesada (que podría ser un montón de contratos), lo que hace que la adopción sea problemática.
   - Probablemente deberíamos añadir bloques de construcción para permitir que el ecosistema añada nuevos casos de uso.
4. CAP-53 fue redactado para introducir funciones de codificación/decodificación para JSON, que es necesario para WebAuthN. Consideraciones discutidas en la reunión:
   - Rendimiento: 3.9Kb, 2.5M CPU.
   - Si se desconoce el tamaño del blob de entrada, el tiempo de ejecución aumentará.
   - Valorable por tener una función tan ligera que se utilizará en varios lugares.
   - Interfaz: 11 funciones
     - ¿Qué hacer con los números y decimales? ¿Añadir decimales y flotantes?
     - Sólo tenemos que extraer un campo para WebAuthN, pero ¿qué hay del caso general?
   - El tipo de número en JSON es decimal pero soroban no lo soporta. ¿Cómo debería tratarse esto?
   - Discusión sobre interfaces e implementaciones alternativas.
5. Afectaciones del núcleo
   - Mantenimiento: si añade una función de host, tiene que mantenerla para siempre. Si hay más versiones, tenemos que mantenerlo.
   - Superficie expandida para errores de seguridad.
   - Debe definir una ruta donde el núcleo dev no está en el bucle de implementación, ya que sus programas están llenos de trabajo de estabilidad. Cómo priorizar el trabajo de estabilidad, que puede descarrilarse debido a nuevas funcionalidades como lo que se está discutiendo actualmente.
   - Siguientes pasos:
     - Equipo central para crear un plan para añadir Base64. Se trata de un ejercicio importante que ayuda a determinar aún más retos al hacerlo. El resultado de este ejercicio puede ser que base64 _debería_ de hecho no ser implementado en este punto.
     - La discusión alrededor de la interfaz JSON debe continuar.

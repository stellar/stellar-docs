---
sidebar_position: 1
title: Sintaxis de solidez y oxidación, tipos de datos y construcciones básicas
description: Explore los fundamentos de la sintaxis de solidez y óxido, tipos de datos y Construcciones Básicas.
---

# Comenzando con el polvo y la solidez

En este tutorial exploraremos Rust and Solidity, dos potentes lenguajes de programación. Rust, un lenguaje de programación de sistemas, es famoso por sus características de seguridad, concurrencia y rendimiento, que pueden ser ventajosas al construir contratos inteligentes. Por otro lado, Solidity es un lenguaje de alto nivel especialmente diseñado para crear contratos inteligentes en la máquina virtual de Ethereum. Esta sección pretende ofrecer una visión general de alto nivel de las similitudes y diferencias entre las dos lenguas.

## Tabla de contenidos

1. [Sintaxis de solidez, tipos de datos y Construcciones Básicas](#solidity-syntax)
2. [Sintaxis de óxido, tipos de datos y modelo de propiedad](#rust-syntax)
3. [Escribir e interactuar con contratos inteligentes simples](#writing-and-interacting-with-simple-smart-contracts)

### Síntesis de solidez

Solidity es un lenguaje de programación diseñado específicamente para crear contratos inteligentes en la máquina virtual de Ethereum (EVM). Tiene una sintaxis similar a JavaScript y soporta una variedad de tipos de datos y construcciones.

```solidity
Solidez pragmática ^0.8.0;

contrato HelloWorld {
  function sayHello() public pure returns (string memory) {
    return "Hola, World!";
  }
}
```

### Tipos de datos

La solidez soporta varios tipos de datos, como:

- Boolean: `bool`
- Entero: `int` (firmado) y `uint` (sin firma)
- Dirección: `dirección`
- Cadena: `string`
- Bytes: `bytes` (tamaño dinámico) y `bytes32` (tamaño fijo)
- Arrayos: tamaño dinámico o de tamaño fijo y puede declararse con varios tipos.
- Estructuras: `struct`
- Números: `enum`
- Mapeo: `mapeo`

Aquí hay ejemplos de implementaciones para cada tipo de datos:

```solidity
Solidez pragmática ^0.8. ;

contract DataTypesExample {
    // Boolean
    bool public isCompleted = false;

    // Integer (firmado y sin firmar)
    int256 public signedInteger = -10;
    uint256 public unsignedInteger = 10;

    // Dirección
    dirección pública userAddress = 0x742d35Cc6634C0532925a3b844Bc454e4438f44e;

    // String
    string public greeting = "Hola, Mundo! ;

    // Bytes (dynamic-size and fixed-size)
    bytes public dynamicBytes = "hello, solidity";
    bytes32 public fixedBytes = "hola, solididad";

    // Arrays (dynamic-size and fixed-size)
    uint[] public dynamicArray = [1, 2, 3];
    uint[5] public fixedArray = [1, 2, 3, 4, 5];

    dirección[] public dynamicAddressArray = [0xd41d1744871f42Bb724D777A2d0Bf53FB43a0040, 0x1f514ae9834aEAF6c2c3eb6D20E27e865F419010];
    dirección[3] public fixedAddressArray = [0xC90cd0D820D6dc447B3cD9545185B046873786A6, 0x401997E856CE51e0D4A8f26ce64952313BEA0E25, 0x221d3b9821f3Cc49B42E7dd487E2a6d1b3ed0E05];

    bool[] public dynamicBoolArray = [true, false, true];
    bool[2] public fixedBoolArray = [true, false];

    // Estructurar
    struct Person {
        string name;
        años de ubicación;
    }
    Persona pública = Persona ("Alice", 30);

    // Enums
    esum Status { Open, Closed, Pending }
    Status public currentStatus = Status. pen;
    Status public nextStatus = Status.Closed;
    Status public previousStatus = Status. ending;

    // Mapeo
    mapeo(address => uint) saldos públicos;

    constructor() {
        balances[msg.sender] = 100;
    }
}
```

### Construcciones Básicas

Algunas de las construcciones básicas en Solidez incluyen:

1. `Variables`: Declarado con un tipo de datos y un identificador.
2. `Funciones`: Definido con la palabra clave `function`.
3. `Modificadores`: Se utiliza para modificar el comportamiento de las funciones.
4. `Eventos`: Utilizado para registrar cambios en el estado del contrato.
5. `Herencia`: La solidez soporta una herencia única y múltiple.

Exploraremos algunas de estas construcciones con más detalle en el siguiente artículo, [Conceptos avanzados de solidez](./solidity-and-rust-advanced-concepts.mdx#advanced-solidity-concepts).

### Sintáctica de óxido

Rust es un lenguaje de programación adecuado para la construcción de contratos inteligentes debido a su énfasis en la seguridad, la concurrencia y el rendimiento. Implementa estrictas reglas de propiedad y préstamo para prevenir razas de datos y otros errores comunes.

```rust
fn main() {
    println!("Hola, mundo!");
}
```

### Tipos de datos

El [Soroban Rust SDK](https://docs.rs/soroban-sdk/latest/soroban_sdk/index.html) soporta una variedad de [Tipos construidos](../../encyclopedia/contract-development/types/built-in-types.mdx) que consisten en ambos tipos Primitivos y [Tipos Personalizados](../../encyclopedia/contract-development/types/custom-types.mdx), tales como:

#### Tipos de datos primitivos

- Integers de 32-bits: signed (`i32`) and unsigned (`u32`)
- Enteros de 64-bits: con signo (`i64`) y sin signo (`u64`)
- Enteros de 128-bits: firmados (`i128`) y sin signo (`u128`)
- Librería (`bool`)
- Bytes, Strings (`Bytes`, `BytesN`): byte arrays y cadenas que pueden pasarse a contratos y almacenes
- Vec (`Vec`): tipo de colección secuencial e indexable
- Mapa (`Map`): diccionario ordenado clave-valor
- Dirección (`Dirección`): identificador opaco universal usado en contratos
- String (`String`): un tipo de matriz cultivable contiguo que contiene u8s y requiere que se pase un env en
- Símbolo:

  - (`Symbol::new`): pequeñas cadenas eficientes de hasta 32 caracteres de longitud y requieren que se pase un env en

  - (`symbol_short!`) pequeñas cadenas eficientes de hasta 9 caracteres de longitud

  Ambos están limitados a los caracteres `a-zA-Z0-9_` y están codificados en enteros de 64 bits.

#### Tipos de datos personalizados

- `Estructuras` (con nombres de campos): Un tipo personalizado que consiste en campos nombrados almacenados en el libro de valores como un `map` de pares clave-valor.
- `Estructuras` (con campos sin nombre): Un tipo personalizado que consiste en campos sin nombre almacenados en el libro de valores como vector de valores.
- `Enum` (Unidad y Tuple Variants): Un tipo personalizado que consiste en variantes de unidad y tuple almacenadas en el libro de rienda como un vector de dos elementos, con el primer elemento siendo el nombre de la variante y el segundo el valor.
- `Enum` (Integer Variants): Un tipo personalizado que consiste en variantes de enteros almacenadas en el libro como el valor `u32`.

Los siguientes son ejemplos de implementaciones para cada tipo de datos:

```rust
// Entero (firmado y sin firmar)
let unsigned_32_bit: u32 = 42;
let signed_32_bit: i32 = -42;
let unsigned_64_bit: u64 = 42;
let signed_64_bit: i64 = -42;
let unsigned_128_bit: u128 = 42;
let signed_128_bit: i128 = -42;

// Boolean
let boolean: bool = true;

// String
let msg: &str = "Hello";
String::from_slice(&env, msg)

// Symbols (corto y nuevo)
let symbol_short = symbol_short! "Sample"); // hasta 9 caracteres
// env is &Env
let symbol_new = Symbol::new(env, "SampleSymbolExpression");

// Bytes (Bytes and BytesN)
let bytes = Bytes::from_slice(&env, &[1; 32]);
let bytes_n = BytesN::from_array(&env, &[0; 32]);

// Vec
let vec = vec! &env, 0, 1, 2, 3];

// Mapa
let map = map! &env, (2, 20), (1, 10)];

// Dirección
let address = Address::new([0u8; 32]);

// Estructurar (nombres de campos)
pub struct State {
    pub count: u32,
    pub last_incr: u32,
}

struct Tuple(u32, String);

// Estructurar (campos sin nombre)
estructura de pub State(pub u32, pub u32);

// Enum (unit and tuple variants)
pub enum Enum {
    A,
    B(u32),
}

// Enum (variantes enteras)
pub enum Enum {
    A = 0,
    B = 1,
}
```

### Una breve introducción a los módulos, macros, estructuras, rasgos y atributos de macros

En esta sección, proporcionaremos una introducción concisa a algunos conceptos fundamentales en Rust: `Modules`, `Macros`, `Estructurales`, `Traits`, y `Attribute Macros`.

Estos conceptos son esenciales para entender y escribir código Rust eficiente, y le ayudarán en su viaje como desarrollador de contratos inteligentes.

#### 1. Módulos

Los módulos en Rust se utilizan para organizar y separar código en diferentes espacios de nombres. Permiten una mejor organización de código, reutilizabilidad y encapsulación. Para definir un módulo, utilice la palabra clave `mod` seguida de un bloque que contenga el contenido del módulo.

```rust
mod my_module {
    pub fn my_function() {
        println!("Hola desde my_module!");
    }
}
```

#### 2. Macros

[Macros](https://doc.rust-lang.org/book/ch19-06-macros.html) en Rust son herramientas poderosas que te permiten hacer metaprogramación, permitiéndote construir fragmentos de código reutilizable en tiempo de compilación.

Hay dos tipos básicos: [declarative](https://doc.rust-lang.org/book/ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming) y [procedural](https://doc.rust-lang.org/book/ch19-06-macros.html#httpsal-macros-for-generating-code-from-attributes) macros. El más común es la macro declarativa, o "macro", que se define con `macro_rules!`

```rust
macro_rules! my_macro {
    () => {
        println!("Hola de my_macro!");
    };
}

fn main() {
    my_macro!();
}
```

#### 3. Estructuras

Las estructuras son tipos de datos personalizados en Rust que te permiten agrupar datos juntos. Proporcionan una forma de definir y crear estructuras de datos más complejas.

```rust
struct MyStructural {
    field1: i32,
    field2: String,
}

fn main() {
    let my_instance = MyStructural {
        field1: 42,
        campo: String::from("Hola"),
    };
}
```

#### 4. Rasgos

Los rasgos de Rust definen un conjunto compartido de comportamientos que los tipos pueden entonces usar como es (implementaciones predeterminadas) o implementarse ellos mismos. Pueden ser pensadas como interfaces en otros idiomas. Los rasgos se definen con la palabra clave 'trait', y sus métodos se pueden implementar para diferentes tipos usando la palabra clave 'implícita'.

```rust
trait MyTrait {
    fn my_method(&self);
}

struct MyEstructurt;

impl MyTrait para MyStructural {
    fn my_method(&self) {
        println! "Hola desde el mi_método de MyTrait!");
    }
}
```

#### 5. Macros de atributo

Las macros de atributos en Rust son una forma de macros procedimentales que permiten definir atributos personalizados para varios elementos de idioma, como funciones, estructuras, y enums. Pueden modificar o generar código basado en los elementos anotados.

```rust
// Para usar una macro de atributos, primero importarla con `use`
use my_attribute_macro::my_attribute;

// Luego aplica el atributo a un elemento en tu código
#[my_attribute]
fn my_function() {
    println! "Hola de mi_function!");
}
```

Durante el viaje de tu desarrollador de contrato inteligente, encontrarás frecuentemente la macro [`#[contractimpl]`](https://docs.rs/soroban-sdk/latest/soroban_sdk/index.html) que exporta funciones de acceso público al entorno Soroban.

Las funciones que son accesibles públicamente en la implementación son invocables por otros contratos, o directamente por transacciones, cuando se despliegan.

```rust
#[contractimpl]
impl HelloContract {
    pub fn hola(env: Env, to: Symbol) -> Vec<Symbol> {
        vec![&env, symbol_short!("Hola"), a]
    }
}
```

### Modelo de propietarios

Rust impone [**reglas de propiedad estrictas**](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html) para administrar memoria y recursos:

- Cada valor tiene un único propietario.
- Cuando el propietario sale del ámbito de aplicación, el valor se distribuye automáticamente.
- [`Borrowing`](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html): Los valores pueden ser tomados como referencias inmutables o mutables.
- [`Lifetimes`](https://doc.rust-lang.org/rust-by-example/scope/lifetime.html): Utilizado para asegurar que las referencias permanezcan válidas.

### Dialecto de Contrato Inteligente

El desarrollo de contratos en Rust implica ciertas restricciones debido a características no disponibles en el entorno de implementación o altos costes de ejecución. Por lo tanto, el código escrito para contratos puede ser visto como un _dialect_ distinto de Rust, centrándose en el comportamiento determinista y el tamaño minimizado del código.

Para saber más sobre el Dialecto de Contratos de Rust, revisa la [Página de Dialecto de Contrato de Rust](../../encyclopedia/contract-development/rust-dialect.mdx).

## Escribir e interactuar con contratos inteligentes simples

En esta sección, aprenderemos a escribir e interactuar con contratos inteligentes simples en Solididad y Rust.

### Escribir un contador inteligente en solidez

He aquí un ejemplo de un contrato inteligente de solidez simple para un contador:

```solidity
// SPDX-License-Identifier: DESCENSADO
solidez pragmática ^0.8. ;

contract Counter {
    uint256 private _count;

    función getCount() public devuelve (uint256) {
        return _count;
    }

    function increment() public {
        _count += 1;
    }
}
```

Vamos a desglosar la disposición del código línea por línea:

```solidity
// SPDX-License-Identifier: UNLICENSED
```

Este es un comentario que identifica la [license](https://docs.soliditylang.org/en/v0.8.19/layout-of-source-files.html#spdx-license-identifier) para el código. No es necesario para ejecutar el código, pero es una buena práctica incluir información de licencia.

```solidity
solidez pragmática ^0.8.0;
```

Esto especifica la versión de Solididad para la que se ha escrito este código. En este caso, es la versión `0.8.0` o superior.

```solidity
contratar contador {}
```

Esto define un nuevo contrato de solidez llamado `Counter`.

```solidity
uint256 private _count;
```

Esta es una [`variable privada`](https://docs.soliditylang.org/en/v0.8.19/cheatsheet.html#function-visibility-specifiers) llamada `_count` de tipo `uint256` (entero sin signo). Esta variable se utilizará para almacenar el valor actual del contador. Está marcado como «privado», lo que significa que sólo se puede acceder desde dentro del contrato.

```solidity
function getCount() public devuelve (uint256) {
    return _count;
}
```

Esta es una función llamada `getCount()` que devuelve el valor actual del contador. La función está marcada como `public`, lo que significa que puede ser llamada desde fuera del contrato. La palabra clave `view` indica que esta función no modifica el estado del contrato. La palabra clave `returns` especifica el tipo de retorno de la función.

```solidity
function increment() public {
    _count += 1;
}
```

Esta es una función llamada `increment()` que incrementa el contador por 1. No devuelve nada, pero modifica el estado del contrato. Como `getCount()`, está marcado como `public`, lo que significa que puede ser llamado tanto desde dentro como desde fuera del contrato.

### Interactuando con el contador inteligente de solidez

Podemos interactuar con el contrato inteligente utilizando el `Remix IDE`. Para ello, siga estos pasos:

1. Haga clic en el siguiente enlace para [abrir Gist in Remix](https://remix.ethereum.org/#version=soljson-v0.8.18+commit.87f61d96.js&optimize=false&runs=200&gist=416ab15a6beed9d91cf2f615625ffe48&lang=en&evmVersion=null).

2. Navega al archivo `Counter.sol` en el explorador de archivos.

![Counter](/img/counter.png)

3. Pulsa `Ctrl/Cmd + s` para compilar el contrato.
4. Navega a la pestaña `Desplegar y ejecutar transacciones` y haz clic en el botón `Desplegar`.

![Deploy](/img/deploy-counter.png)

El contrato debe aparecer en la pestaña 'Contratos Desplegados:

![Deployed](/img/deployed-contracts.png)

5. Haz clic en el botón 'incrementar' para incrementar el contador.
6. Haz clic en el botón `getCount` para obtener el recuento actual.

![Increment](/img/increment.png)

Hasta este punto, hemos cubierto los fundamentos de la escritura, el despliegue en una máquina virtual sandbox e interactuando con un simple contrato inteligente usando Solidity. En la siguiente sección, ampliaremos nuestro conocimiento aprendiendo cómo lograr los mismos resultados usando Rust.

### Escribir un contador inteligente en roble

En esta sección, crearemos un programa Rust que simula la funcionalidad del contracto Inteligente. He aquí un ejemplo de un contador simple en Rust:

```rust
#![no_std]
use soroban_sdk::{contractimpl, log, Env, Symbol};

const COUNTER: ¡Símbolo = symbol_short! "COUNTER");

#[contract]
pub struct IncrementContract;

#[contractimpl]
impl IncrementContract {
    /// Incrementar incrementa un contador interno y devuelve el valor.
    pub fn increment(env: Env) -> u32 {
        // Obtener el recuento actual.
        let mut count: u32 = env.storage().instance().get(&COUNTER).unwrap_or(0); // Si no se establece ningún valor, asuma 0. ¡
        registros! &env, "count: {}", count);

        // Incrementar el conteo.
        count += 1;

        // Guardar el conteo.
        env.storage().instance(). et(&COUNTER, &count);

        // Devuelve el recuento al llamante.
        count
    }

    /// get_count devuelve el valor actual del contador.
    pub fn get_count(env: Env) -> u32 {
        env. torage().instance().get(&COUNTER).unwrap_or(0)
    }
}
```

Este código es una implementación de un contrato inteligente escrito en Rust usando el [`Soroban Rust SDK`](../../../tools/sdks/library. dx#soroban-rust-sdk), un kit de desarrollo de contratos inteligentes basado en Rust desarrollado por [Stellar Development Foundation (SDF)](https://stellar.org/foundation). El Soroban Rust SDK proporciona un poderoso conjunto de herramientas para escribir contratos inteligentes que funcionan en la máquina virtual Soroban.

Aquí hay una explicación línea por línea de lo que está haciendo el código:

```rust
#![no_std]
```

Este es un atributo Rust que le dice al compilador de Rust que no vincule la [biblioteca estándar de Rust](https://doc.rust-lang.org/std/). La biblioteca estándar es extensa, y al implementar aplicaciones Soroban, queremos estirar el proceso tanto como sea posible. Usando `no_std`, establecemos un punto de partida más leanero, "barebones" para proyectos, encompasando sólo el núcleo de Rust y algunos otros componentes esenciales, en lugar de la entera extensión de la biblioteca estándar.

```rust
usar soroban_sdk::{contractimpl, log, Env, Symbol};
```

Este código importa elementos necesarios del Soroban Rust SDK para escribir un contrato inteligente. El `contractimpl` [macro](https://doc.rust-lang.org/book/ch19-06-macros.html) se utiliza para implementar el contrato inteligente, mientras que la macro `log` se utiliza para registrar mensajes. La estructura `Env` representa el entorno en el que se está ejecutando el contrato, y el tipo `Symbol` es un tipo de cadena pequeño y eficiente.

```rust
const COUNTER: Symbol = symbol_short!("COUNTER");
```

Esto crea un nuevo valor `Symbol` con la cadena "COUNTER". El constante `COUNTER` se utiliza entonces como una clave para identificar el valor contable almacenado en el contrato `storage`.

```rust
#[contract]
pub struct IncrementContract;
```

Esto define una estructura pública, `IncrementContract`, que contendrá la implementación del contrato inteligente.

```rust
#[contractimpl]
Incrementar contrato {}
```

Esta es una macro que implementa la estructura 'IncrementContract' como un contrato inteligente.

Como se ha señalado anteriormente, el atributo `#[contractimpl]` exporta funciones públicas al entorno Soroban. Estas funciones son accesibles dentro de la implementación y pueden ser invocadas por otros contratos o directamente por las transacciones en el momento de su despliegue.

```rust
pub fn increment(env: Env) -> u32 {}
```

Esta es una función pública llamada `increment` que toma una estructura `Env` como argumento y devuelve un `u32`. `Env` es el entorno en el que se está ejecutando el contrato, y `u32` es el tipo de valor devuelto por la función.

```rust
let mut count: u32 = env.storage().instance().get(&COUNTER).unwrap_or(0)); // Si no se establece ningún valor, asuma 0.
```

En esta línea de código, se está creando una variable mutable llamada `count` de tipo unsigned 32-bit integer (`u32`). Se accede al entorno de almacenamiento usando `env.storage()`, y el valor asociado con la clave `COUNTER` es recuperado usando el método `get`. Si no hay ningún valor establecido para la clave `COUNTER`, se usa un valor por defecto de 0.

```rust
log!(&env, "contar: {}", contar);
```

Esto registra el recuento actual usando la macro `log` proporcionada por el Soroban Rust SDK.

```rust
cuenta += 1;
```

Esto incrementa el recuento en 1.

```rust
env.storage().instance().set(&COUNTER, &count);
```

Esto guarda el recuento actualizado al almacenamiento por contrato usando el método `set` en el objeto de almacenamiento.

```rust
contador
```

Esto devuelve el recuento actualizado a la persona que llama a la función.

```rust
pub fn get_count(env: Env) -> u32 {}
```

Esta es una función pública llamada `get_count` que toma una estructura `Env` como argumento y devuelve un `u32`. Una vez más vemos el 'Env' que es el entorno en el que se ejecuta el contrato, y `u32` como el tipo del valor devuelto por la función.

```rust
env.storage().instance().get(&COUNTER).unwrap_or(0)
```

Esto es una repetición del código que vimos anteriormente, que recupera el valor asociado con la clave `COUNTER` del almacenamiento del contrato. Si no hay ningún valor establecido para la clave `COUNTER`, se usa un valor por defecto de 0. Finalmente, se llama al método `unwrap()` para extraer el valor real del envoltorio `Ok`, que luego se devuelve al que llama la función.

Ahora que hemos escrito nuestro contrato inteligente, es hora de explorar cómo podemos interactuar con él usando la [CLI Stellar](../../.. tools/developer-tools/README.mdx#cli), una de muchas [Herramientas de desarrollador](../../../tools/developer-tools/README.mdx) robustas. Esta potente herramienta de línea de comandos nos permite interactuar con la máquina virtual Soroban de una máquina local, proporcionándonos una forma eficiente y flexible de gestionar nuestro contrato inteligente.

### Interactuando con el Contador Inteligente de Rust

Para interactuar con el contador de Polvo, crea una nueva biblioteca de Rust usando el nuevo comando de carga.

```bash
nuevo incremento de carga --lib
```

Una vez creado el proyecto, reemplaza el archivo `src/lib.rs` con el [ejemplo de código anterior](#writing-a-smart-counter-in-rust).

```rust
// Remember to replace your lib.rs file with the code example above.
// This is just a reference to point you in the right direction.
#[contractimpl]
impl IncrementContract {...}
```

Luego, añade las siguientes dependencias al archivo `Cargo.toml`:

```toml
[package]
name = "increment"
versión = "0.1. "
edition = "2021"

[lib]
crate-type = ["cdylib"]

[features]
testutils = ["soroban-sdk/testutils"]

[dependencies]
soroban-sdk = "20. .0"

[dev_dependencies]
soroban-sdk = { versión = "20.0. ", features = ["testutils"] }

[profile.release]
opt-level = "z"
overflow-checks = true
debug = 0
strip = "símbolos"
debug-assertions = false
(0)[video] = "abort"
unidades de código = 1
lto = true

[profile.release-with-logs]
heredados = "lanzar"
debug-assertions = true
```

> _Note_: Para una explicación detallada de la configuración de `Cargo.toml` usada en este tutorial, revisa el [Hola Ejemplo Mundo](../../build/smart-contracts/getting-started/hello-world.mdx).

A continuación, construir el proyecto usando el comando `stellar contract build`.

```bash
cd increment
stellar contrato build
```

El contrato compilado se ubicará en el directorio `target/wasm32-unknown-unknown/release`.

Para interactuar con el contrato, podemos utilizar el comando `stellar contract invoke` de la herramienta `stellar-cli`. He aquí un ejemplo de invocar la función 'incremento' en un contrato con ID 1:

```bash
contrato estelar invoca \
    --wasm target/wasm32-unknown-unknown/release/increment.wasm \
    --id 1 \
    -- \
    incremento
```

La salida debe ser el valor actual del contador, que en este caso es:

```bash
1
```

Puedes usar el mismo comando 'invoca un contrato estelar' para incrementar el contador varias veces.

Para obtener el valor actual del contador, puedes usar el siguiente comando:

```bash
contrato estelar invoca \
    --wasm target/wasm32-unknown-unknown/release/increment.wasm \
    --id 1 \
    -- \
    get_count
```

La salida debe ser el valor actual del contador, asumiendo que el contador se ha incrementado 3 veces, la salida será:

```bash
3
```

¡Y eso es todo! Usted ha aprendido a escribir e interactuar con contratos inteligentes simples en Solididad y Rust. En las próximas secciones, aprenderemos sobre conceptos avanzados de contrato inteligente, las similitudes y diferencias entre Solididad y Rust, y cómo desarrollar e implementar contratos inteligentes con Soroban.

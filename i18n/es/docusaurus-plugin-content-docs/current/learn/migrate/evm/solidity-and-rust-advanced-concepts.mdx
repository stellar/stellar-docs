---
sidebar_position: 2
title: Conceptos Inteligentes Avanzados con Solidez y Rust
description: Aprenda conceptos avanzados de Solidez y Rust y escriba contratos inteligentes seguros y eficientes.
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Conceptos Inteligentes Avanzados con Solidez y Rust

En este tutorial cubriremos conceptos avanzados de Solidez y Rust como herencia, interfaces, bibliotecas y modificadores. Adicionalmente, aprenderemos a escribir código Rust seguro y eficiente para contratos inteligentes. Por último, aprenderemos a convertir conceptos comunes de solidez a Rust.

## Tabla de contenidos

1. [Conceptos avanzados de solidez](#advanced-solidity-concepts)
2. [Conceptos de óxido avanzados](#advanced-rust-concepts)
3. [Escribiendo Código de Rust Seguro y Eficiente para Contratos Inteligentes](#writing-safe-and-efficient-rust-code-for-smart-contracts)
4. [Solidez para Soroban: Conceptos comunes y mejores prácticas](#solidity-to-soroban-common-concepts-and-best practices)

## Conceptos avanzados de solidez

### Herencia

En Solidez, los contratos inteligentes pueden heredar propiedades y funciones de otros contratos. Esto se consigue usando la palabra clave 'is'.

Aquí hay un ejemplo de un contrato padre que define una función llamada `messageFromParent` que devuelve una cadena:

```solidity
contrato Parent {
    function messageFromParent() public pure returns (string memory) {
        return "Hola de Parent";
    }
}
contract Child is Parent {
    function messageFromChild(string memory newMessage) public pure returns (string memory) {
        string memory messageFromParent = messageFromParent();
        devolver cadena(abi. ncodePacked(messageFromParent,', ', newMessage));
    }
}
```

En este ejemplo, el contrato `Child` hereda la función `messageFromParent` del contrato `Parent`. El contrato `Child` puede entonces llamar directamente a la función `messageFromParent`.

### Interfaces

Las interfaces son similares a los contratos, pero no pueden tener ninguna implementación de función. Sólo contienen firmas de funciones. Los contratos pueden implementar interfaces usando la palabra clave `is`, similar a la herencia.

Aquí hay un ejemplo de una interfaz que define una función llamada `doSomething` que devuelve un `uint256`:

```solidity
interface SomeInterface {
    function doSomething() external devuelve (uint256);
}

contrato SomeContract es SomeInterface {
    contador privado uint256;

    function doSomething() external override returns (uint256) {
        counter += 1;
        contador de retorno;
    }
}
```

En este ejemplo, el contrato `SomeContract` implementa la interfaz `SomeInterface`. Su implementación devuelve un `u256` que se incrementa cada vez que se llama a la función `doSomething`.

### Bibliotecas

Las bibliotecas son similares a los contratos, pero no pueden tener ninguna variable de estado. Se utilizan para almacenar código reutilizable que puede ser utilizado por otros contratos. Las bibliotecas son desplegadas una vez y pueden ser utilizadas por múltiples contratos. Se definen usando la palabra clave `library`. Se invocan usando la palabra clave `usando`.

```solidity
library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "Addition overflow");

        return c;
    }
}

contract MyContract {
    using SafeMath for uint256;

    uint256 public value;

    function increment(uint256 amount) public {
        value = value.add(amount);
    }
}
```

En este ejemplo, la librería `SafeMath` se utiliza en la función `increment`. La función `increment` utiliza la función `add` de la librería `SafeMath` para incrementar la variable `value`.

### Modificadores

Los modificadores se utilizan para cambiar el comportamiento de las funciones de una manera declarativa. Se definen usando la palabra clave `modifier`. Los modificadores pueden utilizarse para realizar comprobaciones comunes tales como validar entradas, comprobar permisos y más.

```solidity
contrato Ownable {
    dirección a propietario público;

    constructor() {
        owner = msg. ender;
    }

    modificador onlyOwner() {
        require(msg. ender == propietario, "Las llamadas no son propietarias");
        _;
    }
}

contrato MyContract es Ownable {
    function doSomething() public onlyOwner {
        // Esta función sólo puede ser llamada por el propietario del contrato
    }
}
```

En este ejemplo, el modificador `onlyOwner` se utiliza para restringir el acceso a la función `doSomething`. La función `doSomething` sólo puede ser llamada por el `propietario` del contrato que fue definido durante la implementación como `msg.sender`.

## Conceptos de óxido avanzados

### Cajas

Una caja en Rust es una colección de programas, scripts o rutinas precompilados que pueden ser fácilmente reutilizados por los programadores al escribir código. Esto les permite evitar reinventar la rueda al no tener que implementar la misma lógica o programar múltiples veces. Hay dos tipos de cajas en Rust: [cajas binarias y cajas de la biblioteca](https://doc.rust-lang.org/book/ch07-01-packages-and-crates.html).

Las cajas binarias son cajas que se pueden ejecutar como programas independientes. Las cajas de la biblioteca son cajas destinadas a ser utilizadas por otros programas. Las cajas de la biblioteca pueden importarse a otros programas usando la palabra clave `use`.

Aquí hay un ejemplo de un flujo de trabajo que implementa lógica de asignación (`alloc`) dentro de un contrato inteligente:

Primero un usuario incluiría la caja `alloc` en su archivo `Cargo.toml`:

```toml
[dependencies]
soroban-sdk = { espacio de trabajo = true, features = ["alloc"] }

[dev_dependencies]
soroban-sdk = { workspace = true, features = ["testutils", "alloc"] }
```

Entonces importarían la caja `asignar` en su contrato inteligente:

```rust
// Importa
#![no_std]
use soroban_sdk::{contractimpl, Env};

caja externa alloc;

#[contract]
pub struct AllocContract;

#[contractimpl]
impl AllocContract {
    /// Aloca un valor temporal de almacenamiento vectorial (0. cuenta), luego calcula y devuelve su suma.
    pub fn sum(_env: Env, cuenta: u32) -> u32 {
        let mut v1 = alloc::vec! ];
        (0. count).for_each(|i| v1. ush(i));

        let mut sum = 0;
        for i in v1 {
            sum += i;
        }

        suma
    }
}
```

En este ejemplo, la caja `alloc` se importa en el contrato inteligente usando la declaración `asignación de cajas externas;`. La caja `alloc` se utiliza entonces para crear un vector temporal que contiene valores de 0 a `count`. Los valores en el vector son luego sumados y devueltos.

Para más detalles sobre cómo usar la caja `asignar`, incluyendo un ejercicio práctico práctico, visita el [contrato de ejemplo de alloc](../../../build/smart-contracts/example-contracts/alloc.mdx#how-it-works).

#### Heredar Funcionalidad de Otros Clientes

Podemos ilustrar otro ejemplo de herencia importando funcionalidad en una caja de otras cajas del mismo proyecto en el siguiente ejemplo:

A continuación hay una función del archivo [`event.rs`](https://github.com/stellar/soroban-examples/tree/main/events/src) de nuestro ejemplo [Token](https://github.com/stellar/soroban-examples/tree/main/token).

```rust
usar soroban_sdk::{Address, Env, Symbol};
...
pub(cris) fn mint(e: &Env, admin: Dirección, a: Dirección, cantidad: i128) {
    let topics = (symbol_short! "mint"), admin, a);
    e. vents().publish(temas, cantidad);
}
```

Esta función publicará un evento de la menta en el blockchain con la siguiente salida:

```
Emitir evento con temas = ["mint", admin: Dirección, a: Dirección], datos = [cantidad: i128]
```

También usaremos una función de nuestro archivo [`admin.rs`](https://github.com/stellar/soroban-examples/blob/main/token/src/admin.rs).

```rust
// Metering: cubierto por componentes
pub fn read_administrator(e: &Host) -> Result<Address, HostError> {
    let key = DataKey::Admin;
    let rv = e. et_contract_data(key.try_into_val(e)?)?;
    Ok(rv.try_into_val(e)?)
}
```

Esta función devuelve un objeto `Result` que contiene la dirección del administrador.

Por último, implementaremos una función de nuestro archivo [`balance.rs`](https://github.com/stellar/soroban-examples/blob/main/token/src/balance.rs).

```rust
pub fn receive_balance(e: &Env, addr: Dirección, monto: i128) {
    let balance = read_balance(e, addr. lone());
    if !is_authorized(e, addr. lone()) {
        pánico! "no se puede recibir cuando está desautorizado");
    }
    write_balance(e, addr, balance + monto);
}
```

Esta función escribe una cantidad al saldo de una dirección.

El `event.rs` es importado en el archivo [`contract.rs`](https://github.com/stellar/soroban-examples/blob/main/token/src/contract.rs) que contiene la lógica de nuestro contrato de token.

```rust
//contrato. s

//import
use crate::event;
use caja::admin::{read_administrator};
use caja::balance::{receive_balance};

// trait logic
pub trait TokenTrait {
fn mint(e: Env, to: Dirección, cantidad: i128);
}

// estructura lógica
#[contract]
pub struct Token;

// Impl logic

#[contractimpl]
impl TokenTrait for Token {
fn mint(e: Env, a: Dirección, monto: i128) {
        check_nonnegative_amount(monto);
        let admin = read_administrator(&e);
        admin. equire_auth();
        receive_balance(&e, a. sola(), monto);
        event::mint(&e, admin, to, monto);
    }
}
```

Como puedes ver, los archivos `event.rs`, `admin.rs` y `balance.rs` se importan en el archivo `contract.rs` usando la palabra clave `use`. Esto nos permite usar las funciones de esos archivos en la función `mint` de nuestro archivo `contract.rs`.

#### Heredar funcionalidad usando `contractimport!`

El Soroban Rust SDK proporciona una macro poderosa, [`contractimport`](https://docs.rs/soroban-sdk/latest/soroban_sdk/macro.contractimport. tml), que permite al usuario importar un contrato desde su archivo Wasm, generando un cliente, tipos y constante sosteniendo el archivo de contrato.

Aquí hay un ejemplo de cómo usar la macro `contractimport` tomada de la [token.rs](https://github.com/stellar/soroban-examples/blob/main/liquidity_pool/src/token.rs) del archivo [ejemplo de Liquidity Pool ](https://github.com/stellar/soroban-examples/blob/main/liquidity_pool):

Primero, vemos que el archivo wasm del [ejemplo de token previamente construido](https://github.com/stellar/soroban-examples/blob/main/token) es importado en el archivo `token.rs` usando la macro `contractimport`:

```rust
//token.rs
soroban_sdk::contractimport!(
    file = "../token/target/wasm32-unknown-unknown/release/soroban_token_contract.wasm"
);
```

Entonces vemos que nuestro contrato de token es importado en nuestro [`lib.rs`](https://github.com/stellar/soroban-examples/blob/main/liquidity_pool/src/lib. s) y un `Client` es generado para que accedamos a la funcionalidad desde el contrato de tokens:

```rust
//lib.rs
token de mod;

fn get_balance(e: &Env, contract_id: BytesN<32>) -> i128 {
    token::Client::new(e, &contract_id).balance(&e. urrent_contract_address())
}

fn transfer(e: &Env, contract_id: BytesN<32>, to: Dirección, cantidad: i128) {
    token::Client::new(e, &contract_id). ransfer(&e. urrent_contract_address(), &to, &amount);
}

struct LiquidityPool;

#[contractimpl]
impl LiquidityPoolTrait for LiquidityPool {
    let token_a_client = token::Client::new(&e, &get_token_a(&e));
}
```

En el ejemplo anterior, usamos `contractimport` para interactuar con el archivo de token a través de un `Client` que fue generado para el módulo `token`. Este `Client` fue creado usando un rasgo de contrato que coincide con la interfaz del contrato, una estructura de ContractClient que contiene funciones para cada función en el contrato, y tipos para todos los tipos de contrato definidos en el contrato.

#### Una nota sobre herencia y composición

Mientras que hemos estado usando el término "herencia" para ayudar a hacer la transición de la Solidez más suave, aclaremos un aspecto importante de Rust: no apoya la herencia como la entendemos tradicionalmente. En su lugar, Rust practica la "composabilidad", lo que significa que utiliza funciones de diferentes cajas, que son similares a los paquetes, de una manera modular. Así que, cuando discutimos sobre `contractimport!`, realmente estamos observando la composabilidad en acción, no la "herencia". Rust no fomenta la relación "es a" inherente a los idiomas OOP. En su lugar, nos permite reutilizar y ensamblar el código de forma efectiva a través de diferentes ámbitos. Esta es una verdad técnica que es importante entender; Sin embargo, vale la pena señalar que este hecho no afecta al uso práctico de Soroban a través de esta guía.

### Módulos

En Rust, los módulos consisten en un conjunto cohesivo de funciones y tipos relacionados que a menudo se organizan juntos para una mejor organización y reutilizabilidad. Estos módulos pueden ser reutilizados a través de múltiples proyectos publicándolos como cajas.

Aquí hay un ejemplo de un módulo que implementa la lógica `SafeMath` con una función `add`:

```rust
#![no_std]

mod safe_math

// mod safe_math {
// pub fn add(a: u32, b: u32) -> Result<u32, &'static str> {
// a. hecked_add(b). k_or("Addition overflow")
// }
// }


// Importa
use soroban_sdk::{contractimpl, Env};
use safe_math::add;

rasgo de pub MathContract {
    fn add(&self, env: Env, a: u32, b: u32) -> u32;
}

#[contract]
pub struct Adder;

impl MathContract for Adder {
    fn add(&self, _env: Env, a: u32, b: u32) -> u32 {
        add(a, b). nwrap()
    }
}

#[contractimpl]
impl Adder {}

// módulo de prueba
#[cfg(test)]
mod test;
```

Tenga en cuenta que usamos la función `checked_add` de la biblioteca estándar para asegurarse de que la adición no se desborda. Esto es importante porque si la adición se desborda, podría conducir a un comportamiento inesperado en el contrato.

Incluso cuando el código Rust es compilado con el `#![no_std]`, todavía es posible usar algunas de las características de la biblioteca estándar, como la función `checked_add`. Esto se debe a que Rust proporciona la opción de importar módulos y funciones selectivamente desde la biblioteca estándar, permitiendo a los desarrolladores utilizar sólo las características específicas que necesitan.

### Rasgos

Rust no tiene un sistema modificador integrado como Solididad. Sin embargo, puedes lograr una funcionalidad similar usando 'traits' y sus implementaciones.

En el ejemplo siguiente, se ilustra la herencia de los rasgos usando el rasgo 'Ownable'.

```rust
#![no_std]

// Imports
use soroban_sdk::{contracttype, Address};

// Define the `Ownable` trait
trait Ownable {
    fn is_owner(&self, owner: &Address) -> bool;
}

// Implement the `Ownable` trait for the `OwnableContract` struct
impl Ownable for OwnableContract {
    fn is_owner(&self, owner: &Address) -> bool {
        self.owner == *owner
    }
}

// Define a modifier that requires the caller to be the owner of the contract
fn only_owner(contract: &OwnableContract, owner: &Address) -> bool {
    contract.is_owner(owner)
}

// Implement the contract for the `OwnableContract` struct
#[contracttype]

// Define the `OwnableContract` struct
pub struct OwnableContract {
    owner: Address,
    number: u32,
}

impl OwnableContract {
    // Define a public method that requires the caller to be the owner of the contract
    pub fn change_number(&mut self, new_number: u32) {
        if only_owner(self, &self.owner) {
            self.number = new_number;
        }
    }
}

#[cfg(test)]
mod test;
```

Aquí hay un desglose del código de arriba:

- Primero, definimos el trait `Ownable`, que define un único método llamado `is_owner`. Este método toma una 'Dirección' como argumento y devuelve un valor booleano indicando si la dirección es o no el propietario del contrato.
- A continuación, implementamos el trait `Ownable` para la estructura `OwnableContract`. Esto nos permite usar el método `is_owner` en instancias de la estructura `OwnableContract`.
- Luego, definimos un "modificador" llamado `only_owner` que toma una instancia de la estructura `OwnableContract` y una `Address` como argumentos. Este "modificador" devuelve un valor booleano indicando si la dirección es o no el propietario del contrato.
- Finalmente, implementamos el contrato para la estructura `OwnableContract`. Esto permite que sólo el `propietario` del contrato utilice el método `change_number` en las instancias de la estructura `OwnableContract`.

Vale la pena mencionar que el Soroban Rust SDK viene con varios requisitos incorporados que los desarrolladores pueden usar, como el [`require_auth`](https://docs. s/soroban-sdk/latest/soroban_sdk/struct.Address.html#method.require_auth) método proporcionado por la estructura `Address`.

### Interfaces

Las interfaces son una parte esencial de la construcción de contratos inteligentes con Soroban.

Hay muchos tipos de interfaces de contratos inteligentes, y cada uno tiene un propósito específico. Un ejemplo de una interfaz construida con Soroban es la [interfaz de Token (Token Interface](../../../tokens/token-interface.mdx). Esta interfaz asegura que los tokens desplegados en Soroban sean interoperables con los tokens incorporados de Soroban (como el Contrato de Activos Estelares). La interfaz de Token consta de tres requisitos de compatibilidad:

- `interfaz de función`
- `autorización`
- `eventos`

Para más información sobre interfaces de contrato inteligentes construidas con Soroban, incluyendo la interfaz de tokens, visite la [sección de tokens](../../../tokens/README.mdx) de la documentación.

## Escribir código seguro y eficiente de robusto para contratos inteligentes

Al escribir código Rust para contratos inteligentes, es importante centrarse en la seguridad y la eficiencia. Algunos consejos incluyen:

- Usa el tipo [`Result`](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html) para manejar errores de una manera segura y predecible. En los contratos inteligentes, es importante evitar el pánico, ya que esto puede conducir a un comportamiento impredecible. En su lugar, el resultado se puede utilizar para manejar errores y asegurar que el contrato se comporta como se esperaba.

En el siguiente ejemplo, la función `add` devuelve un tipo `Result`, que puede ser `Ok` o `Err`. Si la adición no se desborda, la función devuelve `Ok`, de lo contrario devuelve `Err`.

```rust
pub fn add(a: u32, b: u32) -> Result<u32, &'static str> {
    a.checked_add(b).ok_or("Adicional desbordamiento")
}
```

- Usa la familia de funciones `checked_` como `checked_add`, `checked_sub`, etc., para realizar operaciones aritméticas de una manera segura y eficiente. Estas funciones comprueban si hay desbordamientos y subflujos y devuelven un error si ocurre.

En el siguiente ejemplo, la función `add` utiliza la función `checked_add` para realizar la adición. Si la adición se desborda, la función devuelve un error.

```rust
pub fn add(a: u32, b: u32) -> u32 {
    a.checked_add(b).expect("Adicional desbordado")
}
```

- Usa `cargo` y `clippy` para hacer cumplir la calidad, el estilo y la eficiencia del código en Rust. `cargo` es el gestor de paquetes de Rust y proporciona una serie de herramientas para construir y probar código de Rust. `clippy` es un linter que puede ayudar a identificar posibles problemas en el código, tales como variables no utilizadas o funciones que podrían ser optimizadas.

Para usar clippy con carga, primero tendrás que instalarlo. Puede hacer esto ejecutando el siguiente comando en su terminal:

```bash
carga instalar clippy
```

Una vez que clippy está instalado, puedes ejecutarlo ejecutando el siguiente comando en tu terminal:

```bash
clippy de carga
```

Esto se ejecutará en todo su proyecto, comprobando si hay problemas potenciales y proporcionando sugerencias para mejorar. Clippy mostrará cualquier problema que encuentre, junto con sugerencias sobre cómo solucionarlos.

- Usa `cargo` y `rustfmt` para imponer el estilo de código. `rustfmt` es una herramienta que puede formatear automáticamente el código de Rust de acuerdo a la guía de estilo Rust. Esto puede ayudar a asegurar que el código sea consistente y fácil de leer.

Para usar rustfmt con carga, primero tendrá que instalarlo. Puede hacer esto ejecutando el siguiente comando en su terminal:

```bash
carga instalar rustfmt
```

Una vez que rustfmt esté instalado, puede ejecutarlo ejecutando el siguiente comando en su terminal:

```bash
fmt de carga
```

Before:

```rust
fn main()
{
let x=5;
if x==5 {
println!("Hola, mundo!");
}
}
```

Después:

```rust
fn main() {
    let x = 5;
    if x == 5 {
        println!("¡Hola, mundo!");
    }
}
```

## Solidez a Soroban: Conceptos comunes y mejores prácticas

En esta sección exploraremos conceptos clave de solidez y proporcionaremos sus equivalentes sorobanes. Discutiremos los siguientes temas:

- Propiedades del mensaje
- Manejo de errores
- Función relacionada con la dirección
- Especificadores de visibilidad de la función
- Variables basadas en tiempo

### Propiedades del mensaje

El Soroban Rust SDK y Solidity proporcionan una serie de propiedades de mensaje que pueden ser utilizadas para acceder a la información sobre la transacción actual. Estas propiedades incluyen:

#### Solidez

- `msg.sender`: La dirección de la cuenta que envió la transacción.
- `msg.value`: La cantidad de Ether enviada con la transacción.
- `msg.data`: Los datos enviados con la transacción.

Aquí hay un ejemplo simple de un contrato inteligente que demuestra el uso de cada uno

```solidity
pragma solidity ^0.8.0;

contract SimpleContract {
    address public sender;
    uint public value;
    bytes public data;

    // Caller must send Ether and data to this function.
    // This function will store the sender, value, and data.
    function sendData(bytes calldata _data) external payable {
        sender = msg.sender;
        value = msg.value;
        data = _data;
    }
}
```

Estas son parte de las variables globales de Solidity, a las que se puede acceder desde cualquier función del contrato.

#### Sorobán

A diferencia de las variables globales de Solidity, Soroban se basa en pasar un [`Env`](https://docs.rs/soroban-sdk/latest/soroban_sdk/struct. argumento nv.html) para todas las funciones que proporcionan acceso al entorno en el que el contrato se está ejecutando en su interior.

El `Env` proporciona acceso a la información sobre el contrato actualmente en ejecución, quien lo invocó, datos del contrato, funciones para firmar, hashing, etc.

Por ejemplo, usarías `env.storage().persistent().get(key)` para acceder a un valor de destino `persistent` desde la [storage]del contrato (https://docs.rs/soroban-sdk/latest/soroban_sdk/struct.Env.html). Lea más sobre los diferentes tipos de almacenamiento [here](../../encyclopedia/storage/persisting-data.mdx).

- `env.storage()` se utiliza para obtener una estructura para acceder y actualizar los datos del contrato almacenados.
- Utilizado como `env.storage().persistent().get()` o `env.persistent().storage().set()`.
- Adicionalmente, utilizamos el método `clone()`, un rasgo prevalente en Rust que permite la duplicación explícita de un objeto.

Vea el siguiente ejemplo para implementaciones de `env.storage()` y `clone()`

- `env.storage().persistent().set()`

```rust
use soroban_sdk::{Env, Symbol};

    pub fn set_storage(env: Env) {
        let key = symbol_short!("key");
        let value = symbol_short!("value");
        env.storage().persistent().set(&key, &value);
}
```

- `env.storage().persistent().get()`

```rust
use soroban_sdk::{Env};

    pub fn get_storage(env: Env) -> value {
        env.storage().persistent().get(&key);
}
```

- `clone()`

```rust
use soroban_sdk::{Env, Address};

    pub fn return_user(user: Address) -> Address {
        let user_address: Address = user.clone();
        user_address
}
```

### Manejo de errores

El Soroban Rust SDK y Solidity proporcionan una serie de maneras de manejar errores. Estos incluyen:

#### Solidez

La solidez proporciona una función `require` que puede ser usada para comprobar ciertas condiciones y revertir la transacción si no se cumplen. Por ejemplo, el siguiente código establece un valor mínimo para la cantidad de Ether enviada con la transacción:

```solidity

function deposit() public payable {
    require(msg.value >= 1 ether, "Not enough Ether sent");
    // ...
}
```

#### Sorobán

El macro [¡pánico!](https://doc.rust-lang.org/book/ch09-00-error-handling.html) sirve como mecanismo de manejo de errores de Rust, que se asemeja estrechamente a la función `require` en Solididad.

```rust
pub fn simple_deposit(amount: u32) {
    if amount < 1_000_000 {
        panic!("amount too low");
    }
        // ...
}
```

### Funcionalidad relacionada con la dirección

Tanto Soroban como Solididad proporcionan una serie de funciones para trabajar con direcciones. Estas funciones incluyen:

#### Solidez

- `address(this)`: Devuelve la dirección del contrato actual.
- `address payable(this)`: Devuelve la dirección del contrato actual como una dirección pagable.
- `address(address)`: Devuelve la dirección de la cuenta especificada.
- `address payable(address)`: Devuelve la dirección de la cuenta especificada como una dirección pagable.

A continuación hay un ejemplo de un contrato inteligente que ilustra cómo se pueden recuperar los contratos

```solidity
Solidez pragmática ^0.8. ;

contrato SimpleContract {
    address public contractAddress = address(this);
    address public randomAddress = 0x123456789012345678901234567890123456789012345678901234567890;

    dirección pública payableAddress = payable(address(this));
    dirección pública payableRandomAddress = payable(0x12345678901234567890123456789012345678901234567890);
}
```

No habría diferencia en la apariencia entre una dirección regular y una dirección pagadera en Solididad.

#### Sorobán

- `e.current_contract_address()`: Devuelve el objeto Dirección correspondiente al contrato de ejecución actual.

El `Env` no sólo proporciona información esencial sobre el contrato de ejecución actual y su invoker, pero también ofrece acceso a los datos y funciones del contrato para firmar, hashing, y más. La construcción o conversión de la mayoría de tipos en Soroban requiere acceso a una instancia de `Env`.

He aquí un ejemplo de un contrato inteligente que ilustra cómo se pueden recuperar los contratos:

```rust
#![no_std]
use soroban_sdk::{contractimpl, log, Dirección, Env, Symbol};

#[contract]
pub struct SimpleContract;

#[contractimpl]
impl SimpleContract {
    //Example contrato para devolver un contrato de dirección.
    pub fn return_address(env: Env) -> Dirección {
        let current_contract_address = env. urrent_contract_address();
        dirección_contract_actual
    }
}
```

#### Por qué Soroban Difiere

Soroban tiene algunas diferencias con Solididad en términos de direcciones y otras funcionalidades. Estas diferencias se deben a los principios y objetivos de diseño de Soroban.

Una diferencia significativa es el uso del objeto 'Env' en Soroban. El objeto Env\` encapsula varias funcionalidades relacionadas con la ejecución de contratos, el acceso a datos y más. Proporciona una interfaz unificada para interactuar con el entorno Soroban en el contexto de un contrato. Utilizando el objeto 'Env', Soroban permite un enfoque más modular y flexible del desarrollo de contratos.

Para explicarlo, el tipo 'Env' ofrece una puerta de entrada al entorno donde opera el contrato. Proporciona información sobre el contrato en curso, la entidad que lo invoca, los datos del contrato y las funciones para firmar, hacer hashing, etc. La mayoría de los tipos requieren acceso a un 'Env' para su construcción o conversión.

Mientras tanto, el objeto `Address` sirve como una potente herramienta para la autenticación y [authorization](#autorización). Por ejemplo, puede ser usado para autorizar transferencias de tokens, actuando como un guardián de seguridad dentro del sistema. Esta característica amplía la funcionalidad de las direcciones en Soroban, haciéndolas no sólo un medio de identificación o almacenamiento, pero también un actor clave en la verificación y autorización de las transacciones.

### Especificadores de Visibilidad de Funciones

El Soroban Rust SDK y Solidity proporcionan una serie de especificadores de visibilidad de funciones que pueden ser usados para controlar quién puede llamar a una función. Estos especificadores incluyen:

#### Solidez

- `public`: Cualquiera puede llamar a la función.
- `external`: Sólo otros contratos pueden llamar a la función.
- `internal`: Sólo el contrato actual y los contratos que heredan de él pueden llamar a la función.
- `private`: Sólo el contrato actual puede llamar a la función.

He aquí un ejemplo de un contrato inteligente que ilustra cómo se utiliza la visibilidad de la función en la Solidez:

```solidity
Solidez pragmática ^0.8. ;

contratar SimpleContract {
    function publicFunction() public {}
    function externalFunction() external {}
    function internalFunction() internal {}
    function privateFunction() private {}
}
```

#### Sorobán

- `pub`: El elemento (función, estructura, etc.) es accesible desde cualquier módulo o ámbito.
- `pub(crate)`: El objeto es accesible sólo dentro de la caja actual.
- `pub(super)`: El elemento es accesible sólo dentro de su módulo padre.
- `pub(en ruta::to::module)`: El elemento es accesible sólo dentro de la ruta del módulo especificada.
- `private`: El elemento no está marcado como pub y por lo tanto es privado de su propio módulo, lo que significa que sólo se puede acceder dentro del mismo módulo y no es accesible desde fuera del módulo.

Aquí hay un ejemplo de un módulo que ilustra cómo se utiliza la visibilidad de la función en Soroban:

```rust
#![no_std]
use soroban_sdk::{contractimpl, Env};

mod externo {
    pub struct PublicStructural {
        pub field: u32,
    }

    pub(cris) struct CrateStructural {
        pub(cris) field: u32,
    }

    // Esta estructura es privada porque no está marcada como `pub`.
    struct PrivateStructural {
        field: u32,
    }

    mod inner {
        pub(super) struct SuperStructural {
            pub(super) field: u32,
        }
    }

    pub fn get_all_fields() -> u32 {
        let public_struct = PublicStructural { field: 1 };
        let crate_struct = CrateStructural { field: 2 };
        let private_struct = PrivateStructural { field: 3 };
        let super_struct = inner::Superestructura { field: 4 };
        public_struct. ield + crate_struct.field + private_struct.field + super_struct. ield
    }
}

#[contract]
pub struct NewContract;
 trait (0)[video] terTrait {
    fn get_all_fields() -> u32;
    fn get_public_fields() -> u32;
}

#[contractimpl]
impl (0)[video] terTrait for NewContract {
    fn get_public_fields() -> u32 {
        let public_struct = outer::PublicStructural { field: 1 };
        let crate_struct = outer::CrateStructural { field: 2 };
        // estructuras privadas no se pueden acceder desde fuera de la caja
        public_struct. ield + crate_struct. ield
    }

    fn get_all_fields() -> u32 {
        outer::get_all_fields()
    }
}
```

### Variables basadas en tiempo

El Soroban Rust SDK y Solidity proporcionan un número de variables basadas en el tiempo que se pueden utilizar para acceder a la información sobre el bloque actual (EVM) o el contador (Soroban). Estas variables incluyen:

#### Solidez

- `block.timestamp`: La marca de tiempo del bloque actual.
- `block.number`: El número del bloque actual.

Aquí hay un ejemplo de un contrato inteligente que ilustra cómo se utilizan las variables basadas en el tiempo en Solididad:

```solidity
Solidez pragmática ^0.8. ;

contrato SimpleContract {
    function getTimestamp() vista pública devuelve (uint256) {
        return block. imestamp;
    }

    function getBlockNumber() public view returns (uint256) {
        return block. umber;
    }
}
```

#### Sorobán

- `env.ledger().timestamp()`: Devuelve un timestamp unix para cuando el ledger más reciente fue cerrado.
- `env.ledger().sequence()`: Devuelve el número de secuencia del editor cerrado más recientemente.

Aquí hay un ejemplo de un contrato inteligente que ilustra cómo se utilizan las variables basadas en el tiempo en Rust:

```rust
#![no_std]
use soroban_sdk::{contractimpl, Address, Env};

#[contract]
pub struct SimpleContract;

#[contractimpl]
impl SimpleContract {
    pub fn get_timestamp(env: Env) {
        let timestamp = env. edger().timestamp();
        let sequence = env.ledger().sequence();
    }
}
```

### Autorización

Soroban difiere de Solidez en su enfoque de autorización y modificadores. Aunque la solidez tiene un sistema modificador incorporado, Sorotban no. En cambio, Soroban aprovecha rasgos, sus implementaciones y características básicas para lograr una funcionalidad similar.

#### Solidez

En Solidez, el estándar de token ERC20 incluye la función `approve`, que permite a un titular de fichas autorizar a otra dirección para gastar una cierta cantidad de fichas en su nombre. Esta función se utiliza comúnmente en los intercambios descentralizados y otros escenarios de transferencia de token. Además, nos aseguramos de que el contribuyente esté autorizado a gastar la cantidad de fichas solicitadas por el titular del token.

He aquí un ejemplo de cómo la función de aprobación actúa como un mecanismo de autorización en Solididad:

```solidity
Solidez pragmática ^0.8. ;

contrato ERC20Token {

    constructor() {
        address owner = msg. ender;
        ownerAddress = owner;
    }

    mapeo (dirección => uint256) saldos públicos;
    mapeo (dirección => mapeo (dirección => uint256)) permisos públicos;
    mapeo(dirección => bool) pública autorizada;

    dirección de propietario público;

    función aprobar(pender de direcciones, Cantidad uint256) devoluciones públicas (bool) {
        permisos[msg.sender][spender] = monto;
        return true;
    }

    function setAuthorization(address newAuth) public returns (bool) {
        require(msg. ender == Dirección de propietario);
        isAuthorized[newAuth] = true;
        return true;
    }

    transferencia de función (dirección a, uint256 amount) public returns (bool) {
        require(allowances[msg.sender][to] >= amount, "Not enough allowance");
        requerido(isAuthorized[to] == true, "No autorizado");
        saldos[msg.sender] -= cantidad;
        saldos[to] += cantidad;
        return true;
    }
}
```

La función de aprobación permite al titular de la ficha autorizar al pender a gastar fichas de cantidad en su nombre. La función de transferencia comprueba entonces si el pender está autorizado a gastar la cantidad de fichas solicitadas por el titular del token. Si es así, la transferencia se ejecuta.

Estos ejemplos de solidez ilustra algunos patrones de autorización comunes utilizados en contratos inteligentes de Ethereum. Soroban proporciona enfoques alternativos para lograr una funcionalidad similar, apalancando la funcionalidad principal derivada directamente del soroban SDK.

#### Sorobán

Los principios de diseño de Soroban priorizan la flexibilidad, la seguridad y la probabilidad, que han conducido a diferencias en la forma en que se maneja la autorización en comparación con la solidez.

Soroban proporciona funciones integradas como `require_auth` y `require_auth_for_args` a través de la estructura `Address`. Estas funciones ayudan a hacer cumplir las reglas de autorización dentro de los contratos. Durante la ejecución en cadena, el anfitrión de Soroban realiza la autenticación necesaria, incluyendo la verificación de firmas y **garantizar la prevención de la reproducción**. Esto supone la carga de la autenticación de los propios contratos, promoviendo la seguridad y reduciendo las vulnerabilidades potenciales.

He aquí un ejemplo de un contrato inteligente que ilustra cómo se maneja la autorización en Soroban:

```rust
#![no_std]
use soroban_sdk::{contractimpl, testutils::Address as _, Dirección, Symbol, Env, IntoVal};

#[contract]
pub struct Contract;

#[contractimpl]
impl Contract {
    pub fn transfer(env: Env, dirección: Dirección, cantidad: i128) {
        dirección. equire_auth();
    }
    pub fn transfer2(env: Env, dirección: Dirección, monto: i128) {
        dirección. equire_auth_for_args(monto / 2,).into_val(&env));
    }
}
```

En este ejemplo, tenemos un contrato de Soroban que incluye dos funciones públicas: `transfer` y `transfer2`, ambas incluyen comprobaciones de autorización.

Dentro de la función Transferencia, el método `require_auth` se invoca en el objeto de dirección. Este método garantiza que la persona que llama al contrato tenga la autorización necesaria para ejecutar la transferencia.

La función `transfer2` sigue un patrón similar, pero utiliza el método `require_auth_for_args` en su lugar. Toma los mismos parámetros que la transferencia, pero proporciona una tupla (cantidad / 2,) como el argumento a `require_auth_for_args`. Este método verifica que la persona que llama haya autorizado la invocación del contrato con los argumentos específicos.

Utilizando estos métodos de autorización proporcionados por el objeto `Address` del Soroban Rust SDK, el contrato aplica que sólo las llamadas autorizadas pueden realizar las transferencias. Este enfoque mejora la seguridad del contrato asegurando que las operaciones delicadas sólo puedan ser ejecutadas por partes autorizadas.

El enfoque de Soroban de la autorización en este ejemplo ofrece varias ventajas sobre el modelo de Solidity ERC20 eliminando la necesidad de una gestión de homologación por separado. En su lugar, las comprobaciones de autorización pueden ser incorporadas directamente a cualquier función Soroban. Esto simplifica la base del código del contrato y reduce la complejidad asociada con la gestión de estados de aprobación independientes.

La autorización de Soroban proporciona Autorización de nivel de Contrato, Funcionalidad de Abstracción de Cuenta y comprobaciones de Autorización más avanzadas. Para obtener más información sobre estas ventajas, visite la [Sección de Autorización](../../encyclopedia/security/authorization.mdx) de la documentación.

## Summary

En general, los equivalentes Soroban de los conceptos de Solidez son muy similares. Sin embargo, hay notables diferencias que vale la pena destacar. Soroban usa `env` en lugar de `msg` para acceder a la información sobre todo el entorno de ejecución del contrato, incluyendo el estado del contrato, direcciones involucradas, y más. La autorización también se maneja de forma diferente en Soroban, ya que está incorporado en la funcionalidad central del SDK y es más robusto que confiar en el código de contrato inteligente solamente.

Para más información sobre conceptos de solidez y sus equivalentes sorobanes, se recomienda que uno se refiera tanto a la [documentación de Soroban Rust SDK](https://docs. s/soroban-sdk/latest/soroban_sdk/struct.Env.html) y la [documentación de Solididad](https://docs.soliditylang.org/en/v0.8.19/cheatsheet.html).

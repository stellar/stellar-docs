---
sidebar_position: 3
title: Desarrollo de contratos inteligente con Soroban y Hardhat
description: Explore los conceptos avanzados de Solidez y Soroban, elabore contratos inteligentes seguros y eficientes de Soroban e implemente y ponga a prueba sus contratos en un entorno testnet.
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Desarrollo de contratos inteligente con Soroban y Hardhat

En este tutorial, descubriremos las similitudes en la implementación de contratos inteligentes al examinar los flujos de trabajo con Soroban y [Hardhat](https://hardhat.org/). Nos sumergiremos en las complejidades de cada marco, aprenderemos a escribir un código inteligente seguro y eficiente, y aprovechar el poder de Rust y Soroban para crear una lógica de contrato personalizada.

## Tabla de contenidos

1. [Comparación Soroban y Hardhat](#soroban-and-hardhat-comparison)
2. [Hardhat vs SDKs Soroban](#hardhat-vs-soroban-sdks)
3. [Usando Rust y Soroban para el desarrollo inteligente de contratos](#developing-smart-contracts-with-rust-and-soroban)
4. [Despliegue e interacción del contrato de bóveda](#vault-contract-deployment-and-interaction)

## Comparación Soroban y Hardhat

### Introducción

Soroban y Hardhat son ambos frameworks que permiten a los desarrolladores construir, probar y desplegar contratos inteligentes. En esta sección, profundizaremos en las similitudes y distinciones entre estos dos frameworks.

### Soroban Framework

Soroban es un marco basado en Rust diseñado para desarrollar contratos inteligentes en la red Stellar. Diseñado como un framework ligero, con [herramientas para apoyar a los desarrolladores](../../tools/developer-tools/README.mdx), Soroban permite a los desarrolladores desarrollar contratos inteligentes a través de un flujo de trabajo sencillo e intuitivo.

### Hardhat

Hardhat sirve como un entorno de desarrollo para compilar, desplegar, probar y depurar contratos inteligentes para el EVM. Ayuda a los desarrolladores a gestionar y automatizar tareas recurrentes inherentes a la construcción de contratos inteligentes.

### similitudes

Soroban y Hardhat son marcos potentes diseñados para estirar el proceso de construir, probar y desplegar contratos inteligentes. Equipados con un amplio conjunto de herramientas, estos marcos facilitan el desarrollo de contratos inteligentes y su despliegue en sus respectivas máquinas virtuales.

### Diferencias

Soroban, con su diseño ligero, ofrece a los desarrolladores una plataforma excepcional para redactar contratos inteligentes basados en Rust y desplegarlos sin esfuerzo en la red Stellar. Por el contrario, Hardhat sirve principalmente como un entorno de desarrollo adaptado a la máquina virtual de Ethereum, proporcionando un enfoque y un público objetivo diferentes.

## Hardhat vs. SDKs Soroban

Hardhat ofrece un flujo de trabajo streamlined para implementar contratos inteligentes en la máquina virtual Ethereum, con componentes clave como `ethers. s`, `scripts`, y `testing` reproduciendo roles cruciales.

Por otro lado, Soroban presenta un alternativo convincente que presume de poderosos SDKs que facilitan el desarrollo y el despliegue de contratos inteligentes. En la próxima sección, profundizaremos en [SDKs de Soroban](../../../tools/sdks/library. dx), dibujar comparaciones con los componentes de Hardhat, y resaltar las ventajas únicas que cada plataforma trae a la tabla.

### Ethers.js

`Ethers.js` es una librería `JavaScript` ampliamente utilizada diseñada para una interacción perfecta con la EVM. Ofrece una interfaz fácil de usar que simplifica la conexión a nodos de Ethereum, la administración de cuentas y el envío de transacciones. Además, `Ethers.js` proporciona una API robusta para una comunicación eficiente con contratos inteligentes. Esta biblioteca es un componente central del framework Hardhat y se puede importar en scripts para estirar el despliegue de contratos inteligentes.

```javascript
const { ethers } = require("hardhat");

async function main() {
  const [deployer] = await ethers.getSigners();

  console.log("Deploying contracts with the account:", deployer.address);
}
```

### Soroban Client

Soroban ofrece una biblioteca comparable, [`stellar-sdk`](../../../tools/sdks/library.mdx#javascript-sdk), que permite una interacción perfecta con contratos inteligentes implementados en la red Stellar. Esta biblioteca proporciona una API de red completa para los métodos RPC Soroban, así como la API Horizon tradicional, simplificando el proceso de construcción y firma de transacciones. Adicionalmente, `stellar-sdk` transmite la comunicación con instancias RPC y soporta enviar transacciones o consultar estado de red con facilidad.

### Escrituras

Los scripts de Hardhat transmiten la automatización de las tareas de rutina, como el despliegue y la gestión de contratos inteligentes. Los desarrolladores pueden crear estos scripts usando JavaScript o TypeScript, adaptándose a su estilo de programación preferido. Se almacenan en el directorio `scripts` de un proyecto Hardhat y se pueden ejecutar usando el comando `npx hardhat run`.

```javascript
// scripts/deploy.js

async function main() {
  // Compila e implementa el contrato inteligente
  const MyContract = await ethers. etContractFactory("MyContract");
  const myContract = await MyContract.deploy();

  consola. og("MyContract deployed to:", myContract.address);
}

main()
  .then(() => process. xit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
});
```

### Scripts Soroban

Soroban ofrece una extensa colección de SDKs que incluyen capacidades de scripting, asegurando un flujo de trabajo suave para la implementación y gestión de contratos inteligentes. Los desarrolladores pueden automatizar tareas como compilar, desplegar, e interactuando con contratos inteligentes usando una variedad de SDKs que soportan scripts en idiomas como [`JavaScript`, `TypeScript`, `Python`, y otros](. /../../tools/sdks/library.mdx).

```python
# Este ejemplo muestra cómo implementar un contrato compilado en la red Stellar.
# https://github.com/stellar/soroban-quest/blob/main/quests/6-asset-interop/py-scripts/deploy-contract. y

tiempo de importación

de stellar_sdk import Network, Keypair, TransactionBuilder
from stellar_sdk import xdr as stellar_xdr
from stellar_sdk. oroban importar SorobanServer
desde stellar_sdk.soroban. oroban_rpc import TransactionStatus

# TODO: Debe reemplazar los siguientes parámetros de acuerdo a la situación actual
secreto = "SAAPYAPTTRZMCUZFPG3G66V4ZMHTK4TWA6NS7U4F7Z3IMUD52EK4DDEV"
rpc_server_url = "https://soroban-testnet. tellar.org"
network_passphrase = Red. ESTNET_NETWORK_PASSPHRASE
contract_file_path = "/path/to/compiled/soroban_contract.wasm"

kp = Keypair.from_secret(secret)
soroban_server = SorobanServer(rpc_server_url)

print("installing contract. .")
source = soroban_server.load_account(kp.public_key)

# with open(contract_file_path, "rb") as f:
# contract_bin = f. ead()

tx = (
    TransactionBuilder(source, network_passphrase)
    .set_timeout(300)
    . ppend_install_contract_code_op(
        contrato=contracto_file_path, # la ruta al contrato, o datos binarios
        source=kp. ublic_key,
    )
    .build()
)
...
```

### Pruebas

Hardhat proporciona un framework de pruebas que permite a los desarrolladores escribir pruebas para sus contratos inteligentes. Estas pruebas pueden ser escritas en JavaScript o TypeScript y ejecutarse usando el comando `npx hardhat test`.

```javascript
// test/my-contract. s

const { expect } = require("chai");

describe("MyContract", function () {
  it("Should return the correct name", async function () {
    const MyContract = await ethers. etContractFactory("MyContract");
    const myContract = await MyContract.deploy();

    await myContract. eployed();
    expect(await myContract.name()).to.equal("MyContract");
  });
});
```

### Pruebas Soroban

Soroban permite a los usuarios aprovechar el poder del framework de pruebas Rust para escribir pruebas para sus contratos inteligentes. Estas pruebas se pueden escribir en Rust y ejecutar usando el comando `cargo test`.

```rust
#![cfg(test)]

usa super::*;
usa soroban_sdk::{vec, Env, Symbol, symbol_short};

#[test]
fn test() {
    let env = Env::default();
    let contract_id = env. egister_contract(None, HelloContract);
    let client = HelloContractClient::new(&env, &contract_id);

    let words = cliente. ello(&symbol_short!("Dev"));
    assert_eq!
        palabras,
        vec! &env, symbol_short!("Hola"), symbol_short!("Dev"),]
    );
}
```

En resumen, mientras que Hardhat proporciona un entorno excelente para implementar contratos inteligentes en el EVM, El marco basado en Rust de Soroban ofrece ventajas significativas en términos de rendimiento, lo que la convierte en una opción ideal para construir contratos inteligentes seguros y eficientes.

## Desarrollar contratos inteligentes con Rust y Soroban

### Introducción

Ahora que hemos examinado el flujo de trabajo de despliegue con Hardhat, vamos a explorar el desarrollo y el despliegue de contratos inteligentes con Rust y Soroban. La ventaja clave del uso de Soroban es su habilidad para aprovechar las características de seguridad y rendimiento de Rust, convirtiéndola en una excelente opción para desarrollar contratos inteligentes seguros y eficientes.

Hemos aprendido que los contratos Smart son contratos autoejecutables que se pueden programar para hacer cumplir automáticamente las reglas y reglamentos de un acuerdo en particular. Son un componente central de aplicaciones descentralizadas (dApps) y tecnología blockchain. En esta sección, aprenderemos a utilizar Rust y Soroban para desarrollar e implementar la lógica personalizada de contratos inteligentes.

### Configurar

Si aún no has configurado el entorno dev para Soroban, puedes empezar siguiendo los pasos de [Página de instalación](../../../build/smart-contracts/getting-started/setup.mdx).

Este proyecto requiere usar el archivo `soroban_token_contract.wasm` que necesitará importar manualmente.

Primero, necesitarás clonar la etiqueta `v20.0.0` del repositorio `soroban-examples`:

```bash
git clon -b v20.0.0 https://github.com/stellar/soroban-examples
```

Luego, ve al directorio `soroban-examples/token`

```bash
cd soroban-ejemplos/token
```

A continuación, construir el contrato de Token usando el siguiente comando:

```bash
construcción de contrato soroban
```

Esto construirá el archivo `soroban_token_contract.wasm` que necesitará importar en su proyecto. El archivo `soroban_token_contract.wasm` se encuentra en el directorio `soroban-examples/target/wasm32-unknown-unknown/release`.

```
soroban-examples
Ningito-objetivo
mañanoiano-wasm32-unknown-unknown
mañana-release
mañana:format@@0✓ soroban_token_contract.wasm
 Parlamentario(es)
```

Una vez que tengamos el Token, vamos a crear un nuevo contrato inteligente que lo utilice.

### Escribir un contrato inteligente

Empecemos por escribir un simple ejemplo de un contrato de bóveda que permite a los usuarios depositar fondos y retirar sus fondos con el rendimiento generado.

Aquí hay un desglose de las mecánicas del contrato

- Las acciones se mintan cuando un usuario deposita.
- El protocolo DeFi utiliza los depósitos de los usuarios para generar rendimiento.
- El usuario quema acciones para retirar sus tokens + yield.

En un nuevo terminal, vamos a crear un nuevo proyecto Rust ejecutando el siguiente comando:

```bash
carga nueva bóveda --lib
```

Esto creará un nuevo proyecto Rust llamado `vault`.

Ahora añadamos el archivo `soroban_token_contract.wasm` al proyecto `vault`. Para hacer esto, podemos arrastrar y soltar el archivo en el directorio del proyecto 'vault'.

![vault-project](/img/vault-project.png)

A continuación, necesitaremos añadir el Soroban SDK como dependencia. Para hacer esto, abre el archivo `Cargo.toml` en tu proyecto y asegúrate de que coincide con lo siguiente:

```toml
[package]
name = "vault"
versión = "0.0. "
edition = "2021"
publish = false

[lib]
crate-type = ["cdylib"]

[dependencies]
soroban-sdk = { versión = "20. .0" }
num-integer = { versión = "0.1. 5", default-features = false, features = ["i128"] }

[dev_dependencies]
soroban-sdk = { versión = "20. .0", features = ["testutils"] }

[profile.release]
opt-level = "z"
overflow-checks = true
debug = 0
strip = "símbolos"
debug-assertions = false
(0)[video] = "abort"
unidades de código = 1
lto = true

[profile.release-with-logs]
hereda = "lanzamiento"
afirmaciones de debug-debug" = true
```

En este proyecto necesitaremos crear 3 archivos:

- `src/lib.rs` - Aquí es donde escribiremos nuestra lógica de contrato inteligente de bóveda.
- `src/test.rs` - Aquí es donde escribiremos nuestras pruebas.
- `src/token.rs` - Este es el archivo hereda el contacto de token que importamos anteriormente. También es donde escribiremos nuestra lógica de creación de token.

Para interactuar con el contrato de token, usaremos una interfaz incorporada que puedes encontrar en la pestaña `token_interface.rs`. Esta interfaz incluye las funciones `initialize` y `mint` que usaremos para crear y acuñar tokens para que usemos en nuestro contrato de bóveda. Si quieres ver el código completo del contrato de tokens, puedes revisarlo [here](https://github.com/stellar/soroban-examples/tree/main/token/src).

<Tabs>
<TabItem value="lib.rs" label="src/lib.rs">

```rust
#![no_std]

mod test;
mod token;

use soroban_sdk::{
    contract, contractimpl, contractmeta, Address, BytesN, ConversionError, Env, IntoVal,
    TryFromVal, Val,
};
use token::create_contract;

#[derive(Clone, Copy)]
#[repr(u32)]
pub enum DataKey {
    Token = 0,
    TokenShare = 1,
    TotalShares = 2,
    Reserve = 3,
}

impl TryFromVal<Env, DataKey> for Val {
    type Error = ConversionError;

    fn try_from_val(_env: &Env, v: &DataKey) -> Result<Self, Self::Error> {
        Ok((*v as u32).into())
    }
}

fn get_token(e: &Env) -> Address {
    e.storage().instance().get(&DataKey::Token).unwrap()
}

fn get_token_share(e: &Env) -> Address {
    e.storage().instance().get(&DataKey::TokenShare).unwrap()
}

fn get_total_shares(e: &Env) -> i128 {
    e.storage().instance().get(&DataKey::TotalShares).unwrap()
}

fn get_reserve(e: &Env) -> i128 {
    e.storage().instance().get(&DataKey::Reserve).unwrap()
}

fn get_balance(e: &Env, contract: Address) -> i128 {
    token::Client::new(e, &contract).balance(&e.current_contract_address())
}

fn get_token_balance(e: &Env) -> i128 {
    get_balance(e, get_token(e))
}

fn get_balance_shares(e: &Env) -> i128 {
    get_balance(e, get_token_share(e))
}

fn put_token(e: &Env, contract: Address) {
    e.storage().instance().set(&DataKey::Token, &contract);
}

fn put_token_share(e: &Env, contract: Address) {
    e.storage().instance().set(&DataKey::TokenShare, &contract);
}

fn put_total_shares(e: &Env, amount: i128) {
    e.storage().instance().set(&DataKey::TotalShares, &amount)
}

fn put_reserve(e: &Env, amount: i128) {
    e.storage().instance().set(&DataKey::Reserve, &amount)
}

fn burn_shares(e: &Env, amount: i128) {
    let total = get_total_shares(e);
    let share_contract_id = get_token_share(e);

    token::Client::new(e, &share_contract_id).burn(&e.current_contract_address(), &amount);
    put_total_shares(e, total - amount);
}

fn mint_shares(e: &Env, to: Address, amount: i128) {
    let total = get_total_shares(e);
    let share_contract_id = get_token_share(e);

    token::Client::new(e, &share_contract_id).mint(&to, &amount);

    put_total_shares(e, total + amount);
}

// Metadata that is added on to the Wasm custom section
contractmeta!(
    key = "Description",
    val = "A Vault with a 1% return on investment per deposit."
);

pub trait VaultTrait {
    // Sets the token contract addresses for this vault
    fn initialize(e: Env, token_wasm_hash: BytesN<32>, token: Address);

    // Returns the token contract address for the vault share token
    fn share_id(e: Env) -> Address;

    // Deposits token. Also mints vault shares for the `from` Identifier. The amount minted
    // is determined based on the difference between the reserves stored by this contract, and
    // the actual balance of token for this contract.
    fn deposit(e: Env, from: Address, amount: i128);

    // transfers `amount` of vault share tokens to this contract, burns all pools share tokens in this contracts, and sends the
    // corresponding amount of token to `to`.
    // Returns amount of token withdrawn
    fn withdraw(e: Env, to: Address, amount: i128) -> i128;

    fn get_rsrvs(e: Env) -> i128;
}
#[contract]
struct Vault;

#[contractimpl]
impl VaultTrait for Vault {
    fn initialize(e: Env, token_wasm_hash: BytesN<32>, token: Address) {
        let share_contract_id = create_contract(&e, token_wasm_hash, &token);
        token::Client::new(&e, &share_contract_id).initialize(
            &e.current_contract_address(),
            &7u32,
            &"Vault Share Token".into_val(&e),
            &"VST".into_val(&e),
        );

        put_token(&e, token);
        put_token_share(&e, share_contract_id.try_into().unwrap());
        put_total_shares(&e, 0);
        put_reserve(&e, 0);
    }

    fn share_id(e: Env) -> Address {
        get_token_share(&e)
    }

    fn deposit(e: Env, from: Address, amount: i128) {
        // Depositor needs to authorize the deposit
        from.require_auth();

        let token_client = token::Client::new(&e, &get_token(&e));

        token_client.transfer(&from, &e.current_contract_address(), &amount);

        let balance = get_token_balance(&e);

        mint_shares(&e, from, amount);
        put_reserve(&e, balance);
    }

    fn withdraw(e: Env, to: Address, amount: i128) -> i128 {
        to.require_auth();

        // First transfer the vault shares that need to be redeemed
        let share_token_client = token::Client::new(&e, &get_token_share(&e));
        share_token_client.transfer(&to, &e.current_contract_address(), &amount);

        let token_client = token::Client::new(&e, &get_token(&e));
        token_client.transfer(
            &e.current_contract_address(),
            &to,
            &(&amount + (&amount / &100)),
        );

        let balance = get_token_balance(&e);
        let balance_shares = get_balance_shares(&e);

        burn_shares(&e, balance_shares);
        put_reserve(&e, balance - amount);

        amount
    }

    fn get_rsrvs(e: Env) -> i128 {
        get_reserve(&e)
    }
}
```

</TabItem>
<TabItem value="test.rs" label="src/test.rs" default>

```rust
#![cfg(test)]
extern crate std;

use crate::{token, VaultClient};

use soroban_sdk::{
    symbol_short,
    testutils::{Address as _, AuthorizedFunction, AuthorizedInvocation},
    Address, BytesN, Env, IntoVal,
};

fn create_token_contract<'a>(e: &Env, admin: &Address) -> token::Client<'a> {
    token::Client::new(e, &e.register_stellar_asset_contract(admin.clone()))
}

fn create_vault_contract<'a>(
    e: &Env,
    token_wasm_hash: &BytesN<32>,
    token: &Address,
) -> VaultClient<'a> {
    let vault = VaultClient::new(e, &e.register_contract(None, crate::Vault {}));
    vault.initialize(token_wasm_hash, token);
    vault
}

fn install_token_wasm(e: &Env) -> BytesN<32> {
    soroban_sdk::contractimport!(file = "./soroban_token_contract.wasm");
    e.deployer().upload_contract_wasm(WASM)
}

#[test]
fn test() {
    let e = Env::default();
    e.mock_all_auths();

    let admin1 = Address::random(&e);

    let token = create_token_contract(&e, &admin1);

    let user1 = Address::random(&e);

    let vault = create_vault_contract(&e, &install_token_wasm(&e), &token.address);

    let contract_share = token::Client::new(&e, &vault.share_id());

    let token_share = token::Client::new(&e, &contract_share.address);

    token.mint(&user1, &200);
    assert_eq!(token.balance(&user1), 200);
    token.mint(&vault.address, &100);
    assert_eq!(token.balance(&vault.address), 100);

    vault.deposit(&user1, &100);
    assert_eq!(
        e.auths(),
        std::vec![(
            user1.clone(),
            AuthorizedInvocation {
                function: AuthorizedFunction::Contract((
                    vault.address.clone(),
                    symbol_short!("deposit"),
                    (&user1, 100_i128).into_val(&e)
                )),
                sub_invocations: std::vec![AuthorizedInvocation {
                    function: AuthorizedFunction::Contract((
                        token.address.clone(),
                        symbol_short!("transfer"),
                        (&user1, &vault.address, 100_i128).into_val(&e)
                    )),
                    sub_invocations: std::vec![]
                }]
            }
        )]
    );

    assert_eq!(token_share.balance(&user1), 100);
    assert_eq!(token_share.balance(&vault.address), 0);
    assert_eq!(token.balance(&user1), 100);
    assert_eq!(token.balance(&vault.address), 200);

    e.budget().reset_unlimited();
    vault.withdraw(&user1, &100);
    assert_eq!(
        e.auths(),
        std::vec![(
            user1.clone(),
            AuthorizedInvocation {
                function: AuthorizedFunction::Contract((
                    vault.address.clone(),
                    symbol_short!("withdraw"),
                    (&user1, 100_i128).into_val(&e)
                )),
                sub_invocations: std::vec![AuthorizedInvocation {
                    function: AuthorizedFunction::Contract((
                        token_share.address.clone(),
                        symbol_short!("transfer"),
                        (&user1, &vault.address, 100_i128).into_val(&e)
                    )),
                    sub_invocations: std::vec![]
                }]
            }
        )]
    );
    assert_eq!(token.balance(&user1), 201);
    assert_eq!(token_share.balance(&user1), 0);
    assert_eq!(token.balance(&vault.address), 99);
    assert_eq!(token_share.balance(&vault.address), 0);
}
```

</TabItem>

<TabItem value="token.rs" label="src/token.rs">

```rust
#![allow(unused)]
use soroban_sdk::{xdr::ToXdr, Dirección, Bytes, BytesN, Env};

soroban_sdk::contractimport!(file = "./soroban_token_contract. asm");

pub fn create_contract(e: &Env, token_wasm_hash: BytesN<32>, token: &Address) -> Dirección {
    let mut salt = Bytes::new(e);
    sal. ppend(&token.to_xdr(e));
    let salt = e.crypto().sha256(&salt);
    e. eployer()
        .with_current_contract(salt)
        .deploy(token_wasm_hash)
}
```

</TabItem>

<TabItem value="token_interface.rs" label="src/token_interface.rs">

```rust
//! This contract demonstrates a sample implementation of the Soroban token
//! interface.
use crate::admin::{has_administrator, read_administrator, write_administrator};
use crate::allowance::{read_allowance, spend_allowance, write_allowance};
use crate::balance::{is_authorized, write_authorization};
use crate::balance::{read_balance, receive_balance, spend_balance};
use crate::event;
use crate::metadata::{read_decimal, read_name, read_symbol, write_metadata};
use crate::storage_types::INSTANCE_TTL_EXTEND_AMOUNT;
use soroban_sdk::{contract, contractimpl, Address, Env, String};
use soroban_token_sdk::TokenMetadata;

pub trait TokenTrait {
    fn initialize(e: Env, admin: Address, decimal: u32, name: String, symbol: String);

    fn allowance(e: Env, from: Address, spender: Address) -> i128;

    fn approve(e: Env, from: Address, spender: Address, amount: i128, expiration_ledger: u32);

    fn balance(e: Env, id: Address) -> i128;

    fn spendable_balance(e: Env, id: Address) -> i128;

    fn authorized(e: Env, id: Address) -> bool;

    fn transfer(e: Env, from: Address, to: Address, amount: i128);

    fn transfer_from(e: Env, spender: Address, from: Address, to: Address, amount: i128);

    fn burn(e: Env, from: Address, amount: i128);

    fn burn_from(e: Env, spender: Address, from: Address, amount: i128);

    fn clawback(e: Env, from: Address, amount: i128);

    fn set_authorized(e: Env, id: Address, authorize: bool);

    fn mint(e: Env, to: Address, amount: i128);

    fn set_admin(e: Env, new_admin: Address);

    fn decimals(e: Env) -> u32;

    fn name(e: Env) -> String;

    fn symbol(e: Env) -> String;
}

fn check_nonnegative_amount(amount: i128) {
    if amount < 0 {
        panic!("negative amount is not allowed: {}", amount)
    }
}

#[contract]
pub struct Token;

#[contractimpl]
impl TokenTrait for Token {
    fn initialize(e: Env, admin: Address, decimal: u32, name: String, symbol: String) {
        if has_administrator(&e) {
            panic!("already initialized")
        }
        write_administrator(&e, &admin);
        if decimal > u8::MAX.into() {
            panic!("Decimal must fit in a u8");
        }

        write_metadata(
            &e,
            TokenMetadata {
                decimal,
                name,
                symbol,
            },
        )
    }

    fn allowance(e: Env, from: Address, spender: Address) -> i128 {
        e.storage().instance().extend_ttl(INSTANCE_TTL_EXTEND_AMOUNT);
        read_allowance(&e, from, spender).amount
    }

    fn approve(e: Env, from: Address, spender: Address, amount: i128, expiration_ledger: u32) {
        from.require_auth();

        check_nonnegative_amount(amount);

        e.storage().instance().extend_ttl(INSTANCE_TTL_EXTEND_AMOUNT);

        write_allowance(&e, from.clone(), spender.clone(), amount, expiration_ledger);
        event::approve(&e, from, spender, amount, expiration_ledger);
    }

    fn balance(e: Env, id: Address) -> i128 {
        e.storage().instance().extend_ttl(INSTANCE_TTL_EXTEND_AMOUNT);
        read_balance(&e, id)
    }

    fn spendable_balance(e: Env, id: Address) -> i128 {
        e.storage().instance().extend_ttl(INSTANCE_TTL_EXTEND_AMOUNT);
        read_balance(&e, id)
    }

    fn authorized(e: Env, id: Address) -> bool {
        e.storage().instance().extend_ttl(INSTANCE_TTL_EXTEND_AMOUNT);
        is_authorized(&e, id)
    }

    fn transfer(e: Env, from: Address, to: Address, amount: i128) {
        from.require_auth();

        check_nonnegative_amount(amount);

        e.storage().instance().extend_ttl(INSTANCE_TTL_EXTEND_AMOUNT);

        spend_balance(&e, from.clone(), amount);
        receive_balance(&e, to.clone(), amount);
        event::transfer(&e, from, to, amount);
    }

    fn transfer_from(e: Env, spender: Address, from: Address, to: Address, amount: i128) {
        spender.require_auth();

        check_nonnegative_amount(amount);

        e.storage().instance().extend_ttl(INSTANCE_TTL_EXTEND_AMOUNT);

        spend_allowance(&e, from.clone(), spender, amount);
        spend_balance(&e, from.clone(), amount);
        receive_balance(&e, to.clone(), amount);
        event::transfer(&e, from, to, amount)
    }

    fn burn(e: Env, from: Address, amount: i128) {
        from.require_auth();

        check_nonnegative_amount(amount);

        e.storage().instance().extend_ttl(INSTANCE_TTL_EXTEND_AMOUNT);

        spend_balance(&e, from.clone(), amount);
        event::burn(&e, from, amount);
    }

    fn burn_from(e: Env, spender: Address, from: Address, amount: i128) {
        spender.require_auth();

        check_nonnegative_amount(amount);

        e.storage().instance().extend_ttl(INSTANCE_TTL_EXTEND_AMOUNT);

        spend_allowance(&e, from.clone(), spender, amount);
        spend_balance(&e, from.clone(), amount);
        event::burn(&e, from, amount)
    }

    fn clawback(e: Env, from: Address, amount: i128) {
        check_nonnegative_amount(amount);
        let admin = read_administrator(&e);
        admin.require_auth();

        e.storage().instance().extend_ttl(INSTANCE_TTL_EXTEND_AMOUNT);

        spend_balance(&e, from.clone(), amount);
        event::clawback(&e, admin, from, amount);
    }

    fn set_authorized(e: Env, id: Address, authorize: bool) {
        let admin = read_administrator(&e);
        admin.require_auth();

        e.storage().instance().extend_ttl(INSTANCE_TTL_EXTEND_AMOUNT);

        write_authorization(&e, id.clone(), authorize);
        event::set_authorized(&e, admin, id, authorize);
    }

    fn mint(e: Env, to: Address, amount: i128) {
        check_nonnegative_amount(amount);
        let admin = read_administrator(&e);
        admin.require_auth();

        e.storage().instance().extend_ttl(INSTANCE_TTL_EXTEND_AMOUNT);

        receive_balance(&e, to.clone(), amount);
        event::mint(&e, admin, to, amount);
    }

    fn set_admin(e: Env, new_admin: Address) {
        let admin = read_administrator(&e);
        admin.require_auth();

        e.storage().instance().extend_ttl(INSTANCE_TTL_EXTEND_AMOUNT);

        write_administrator(&e, &new_admin);
        event::set_admin(&e, admin, new_admin);
    }

    fn decimals(e: Env) -> u32 {
        read_decimal(&e)
    }

    fn name(e: Env) -> String {
        read_name(&e)
    }

    fn symbol(e: Env) -> String {
        read_symbol(&e)
    }
}
```

</TabItem>
</Tabs>

Ahora que hemos añadido estos archivos a nuestro proyecto, vamos a desglosar lo que sucede en el `lib. s` archivo anterior y descubrir cómo se genera el "producto" a partir de nuestro contrato de bóveda

Primero, echemos un vistazo a lo que sucede cuando un usuario deposita fichas en el contrato de la bóveda.

```rust
fn depósito(e: Env, de: Dirección, amount: i128) {
    // Deposidor necesita autorizar el depósito
    de. equire_auth();

    let token = token::Client::new(&e, &get_token(&e));

    token.transfer(&from, &e. urrent_contract_address(), &amount);

    // Ahora calcula cuántas nuevas acciones de bóveda para acuñar
    dejar balance = get_token_balance(&e);

    let shares = amount;

    mint_shares(&e, parde, acciones);
    put_reserve(&e, balance + acciones);
}
```

- La función de 'depósito' es llamada por el depositante para depositar fichas en el contrato de la bóveda.
- El método `transfer` de la instancia `token_client` transfiere tokens del deposito al contrato de bóveda.
- El saldo actual de tokens y el total de acciones emitidas por el contrato de bóveda se obtienen utilizando las funciones `get_token_balance` y `get_total_shares`, respectivamente.
- `mint_shares` es llamado para emitir nuevas acciones al registrador del depósito y actualiza el total de acciones emitidas por el contrato de la bóveda.
- `put_reserve` almacena el saldo actual del token en una ubicación reservada.

Si el usuario llamara al método `deposit` con 100 tokens, sucedería lo siguiente:

- Se transferirían 100 fichas del titular del depósito al contrato de la bóveda.
- El saldo actual del token se almacenaría en una ubicación reservada.
- El total de acciones emitidas por el contrato de bóveda se actualizaría a 100.
- Se emitirían 100 acciones al depositante.

Ahora vamos a ver qué sucede cuando un usuario retira fichas de la bóveda.

```rust
fn retiro(e: Env, to: Dirección, cantidad: i128) -> i128 {
    to. equire_auth();

    // Primero transfiere las acciones de bóveda que necesitan ser redimidas
    let share_token_client = token::Client::new(&e, &get_token_share(&e));
    compartir_token_cliente. ransfer(&to, &e. urrent_contract_address(), &amount);

    // Calcular la cantidad total incluyendo rendimiento
    let total_amount = amount + (cantidad / 100);

    let token_client = token::Client::new(&e, &get_token(&e));
    token_client. ransfer(&e. urrent_contract_address(), &to, &total_amount);

    let balance = get_token_balance(&e);
    let balance_shares = get_balance_shares(&e);

    burn_shares(&e, balance_shares);
    put_reserve(&e, balance); // Actualizar la reserva con el saldo real

    total_amount
}
```

- La función de 'retiro' es llamada por el retiro para retirar las fichas del contrato de la bóveda.
- El método `transfer` de la instancia `share_token_client` transfiere acciones del retiro al contrato de bóveda.
- El método `transfer_token` de la instancia `token_client` transfiere tokens del contrato de bóveda al retiro.
- `burn_shares` es llamado para quemar las acciones que fueron transferidas al contrato de la bóveda.
- `put_reserve` almacena el saldo actual del token en una ubicación reservada.
- Devuelve la cantidad total de tokens retirados por el usuario.

> _Note_ : En la función de retiro, notarás que el monto de la transferencia se define como `&(&amount + (&amount / &100)`. Se trata de un simple cálculo de rendimiento que supone que el rendimiento será del 1% de la cantidad que se está retirando. Sin embargo, es importante señalar que este es un enfoque muy simplista y puede que no sea adecuado para sistemas de grado de producción. En realidad, los cálculos de rendimiento son más complejos e implican diversos factores como las condiciones del mercado, la gestión de riesgos y las tasas.

Si el usuario llamara al método 'retirado' con 100 acciones, sucedería lo siguiente:

- Se transferirían 100 acciones del retiro al contrato de la bóveda.
- El saldo actual del token se almacenaría en una ubicación reservada.
- Se quemarían 100 acciones.
- 100 + (100/100) fichas serán transferidas del contrato de bóveda al retiro.

### Pruebas

Para probar el contrato con la bóveda, simplemente podemos ejecutar el siguiente comando en nuestro terminal desde el directorio de nuestro contrato con la bóveda:

```bash
#cd bóveda
prueba de carga
```

Esto ejecutará las pruebas que hemos escrito en el archivo `src/test.rs`.

```bash
ejecutando 1 prueba
test test::test ... ok
```

### Despliegue e interacción del contrato de bóveda

Ahora que tenemos un contrato de bóveda funcional, podemos desplegarlo en una red e interactuar con ella.

Esta sección requiere que tengas un Llavero financiado para usar con Stellar's Testnet. Puedes crear y financiar uno usando [Stellar Laboratory](https://laboratory.stellar.org/#account-creator?network=testnet).

A continuación encontrará una serie de comandos que le ayudarán a construir, desplegar e interactuar con los contratos de bóveda y token. Puede utilizarlos para seguir a medida que caminamos a través del proceso de construcción, despliegue e interacción con los contratos. Puede ser que tengas estos comandos en un directorio `scripts` en tu proyecto. De esta manera, puede ejecutarlos fácilmente desde su terminal.

> _Nota_ : Si decide usar scripts, asegúrese de revisar sus rutas de importación.

<Tabs>
<TabItem value="build" label="build.sh">

```bash
construcción de contrato soroban
```

</TabItem>

<TabItem value="deploy token" label="deploy_token.sh">

```bash
soroban contrato desplegar \
    --wasm soroban_token_contract.wasm \
    --source <SECRET_KEY> \
    --rpc-url https://soroban-testnet.stellar.org:443 \
    --network-passphrase 'Test SDF Network ; septiembre 2015'
```

</TabItem>

<TabItem value="initialize token" label="initialize_token.sh">

```bash
soroban contrato invoca \
    --id <TOKEN_CONTRACT_ID> \
    --source <SECRET_KEY> \
    --rpc-url https://soroban-testnet. vendedor. rg:443 \
    --network-passphrase 'Probar red SDF ; Septiembre 2015' \
    -- \
    inicializar \
    --admin <USER_ADDRESS> \
    --decimal 18 \
    --name <TOKEN_NAME> \
    --symbol <TOKEN_SYMBOL>
```

</TabItem>

<TabItem value="mint" label="mint.sh">

```bash
soroban contrato invoca \
    --id <TOKEN_CONTRACT_ID> \
    --source <SECRET_KEY> \
    --rpc-url https://soroban-testnet. vendedor. rg:443 \
    --network-passphrase 'Probar red SDF ; Septiembre 2015' \
    -- \
    menta \
    --to <USER_OR_VAULT_ADDRESS> \
    --amount 100
```

</TabItem>

<TabItem value="balance" label="balance.sh">

```bash
soroban contrato invoca \
    --id <TOKEN_CONTRACT_ID> \
    --source <SECRET_KEY> \
    --rpc-url https://soroban-testnet. vendedor. rg:443 \
    --network-passphrase 'Probar red SDF ; Septiembre de 2015' \
    -- \
        balance \
    --id <USER_OR_VAULT_ADDRESS>
```

</TabItem>

<TabItem value="insatll wasm" label="install.sh">

```bash
soroban contract install \
    --wasm soroban_token_contract.wasm \
    --source <SECRET_KEY> \
    --rpc-url https://soroban-testnet.stellar.org:443 \
    --network-passphrase 'Test SDF Network ; septiembre 2015'
```

</TabItem>

<TabItem value="deploy vault" label="deploy_vault.sh">

```bash
soroban contrato desplegar \
    --wasm target/wasm32-unknown-unknown/release/vault.wasm \
    --source <SECRET_KEY> \
    --rpc-url https://soroban-testnet.stellar.org:443 \
    --network-passphrase 'Test SDF Network ; septiembre 2015'
```

</TabItem>

<TabItem value="initialize vault" label="initialize_vault.sh">

```bash
soroban contrato invoca \
    --id <VAULT_CONTRACT_ID> \
    --source <SECRET_KEY> \
    --rpc-url https://soroban-testnet. vendedor. rg:443 \
    --network-passphrase 'Probar red SDF ; Septiembre de 2015' \
    -- \
    inicializar \
    --token_wasm_hash 73593275ee3bcacc2aef8d641a1d5108618064bdfff84a826576b8caff395add \
    --token <TOKEN_CONTRACT_ADDRESS>
```

</TabItem>

<TabItem value="get share" label="share_id.sh">

```bash
soroban contrato invoca \
    --id <VAULT_CONTRACT_ID> \
    --source <SECRET_KEY> \
    --rpc-url https://soroban-testnet. vendedor. rg:443 \
    --network-passphrase 'Probar red SDF ; Septiembre de 2015' \
    -- \
    share_id
```

</TabItem>

<TabItem value="deposit" label="deposit.sh">

```bash
soroban contrato invoca \
    --id <VAULT_CONTRACT_ID> \
    --source <SECRET_KEY> \
    --rpc-url https://soroban-testnet. vendedor. rg:443 \
    --network-passphrase 'Probar red SDF ; Septiembre de 2015' \
    --
    depósito \
    --de <USER_ADDRESS> \
    --amount 100
```

</TabItem>

<TabItem value="reserve" label="get_rsrv.sh">

```bash
soroban contrato invoca \
    --id <VAULT_CONTRACT_ID> \
    --source <SECRET_KEY> \
    --rpc-url https://soroban-testnet. vendedor. rg:443 \
    --network-passphrase 'Probar red SDF ; Septiembre de 2015' \
    -- \
    get_rsrvs
```

</TabItem>

<TabItem value="withdraw" label="withdraw.sh">

```bash
soroban contrato invoca \
    --id <VAULT_CONTRACT_ID> \
    --source <SECRET_KEY> \
    --rpc-url https://soroban-testnet. vendedor. rg:443 \
    --network-passphrase 'Probar red SDF ; Septiembre de 2015' \
    -- \
    retirar \
    --a <USER_ADDRESS> \
    --amount 100
```

</TabItem>

</Tabs>

En primer lugar, necesitamos construir el contrato con la bóveda. Podemos hacer esto ejecutando el script `build.sh` desde nuestro directorio de bóvedas.

```bash
##cd bóveda
construcción del contrato de soroban
```

A continuación, tenemos que desplegar el contrato de token. Podemos hacer esto ejecutando el script `deploy_token.sh`.

```bash
soroban contrato desplegar \
    --wasm soroban_token_contract.wasm \
    --source <SECRET_KEY> \
    --rpc-url https://soroban-testnet.stellar.org:443 \
    --network-passphrase 'Test SDF Network ; septiembre 2015'
```

Deberíamos recibir una salida con el ID del contrato de token. Necesitaremos esta identificación para el siguiente paso.

```bash
CBYMG7OPIT67AG4S2FZU7LAYCXUSXEHRGHLDE6H26VCVWNOV7QUQTGNU
```

A continuación tenemos que inicializar el contrato de token. Podemos hacer esto ejecutando el script `initialize_token.sh`.

```bash
soroban contrato invoca \
    --id <TOKEN_CONTRACT_ID> \
    --source <SECRET_KEY> \
    --rpc-url https://soroban-testnet. vendedor. rg:443 \
    --network-passphrase 'Probar red SDF ; Septiembre 2015' \
    -- \
    inicializar \
    --admin <USER_ADDRESS> \
    --decimal 18 \
    --name <TOKEN_NAME> \
    --symbol <TOKEN_SYMBOL>
```

A continuación, tenemos que desplegar el contrato de la bóveda. Podemos hacer esto ejecutando el script `deploy_vault.sh`.

```bash
soroban contrato desplegar \
    --wasm target/wasm32-unknown-unknown/release/vault.wasm \
    --source <SECRET_KEY> \
    --rpc-url https://soroban-testnet.stellar.org:443 \
    --network-passphrase 'Test SDF Network ; septiembre 2015'
```

Deberíamos recibir una salida con el ID del contrato de bóveda. Necesitaremos esta identificación para el siguiente paso.

```bash
CBBPLE6TGYOMO5HUF2AMYLSYYXM2VYZVAVYI5QCCM5OCFRZPBE2XA53F
```

Ahora necesitamos obtener el hash Wasm del contrato token. Podemos hacer esto ejecutando el script `get_token_wasm_hash.sh`.

```bash
soroban contract install \
    --wasm soroban_token_contract.wasm \
    --source <SECRET_KEY> \
    --rpc-url https://soroban-testnet.stellar.org:443 \
    --network-passphrase 'Test SDF Network ; septiembre 2015'
```

Deberíamos recibir el Wasm hash del contrato simbólico.

```bash
6b7e4bfbf47157a12e24e564efc1f9ac237e7ae6d7056b6c2ab47178b9e7a510
```

Ahora tenemos que inicializar el contrato de bóveda. Podemos hacer esto ejecutando el script `initialize_vault.sh` y pasando el token contract ID y token contract Wasm hash.

```bash
soroban contrato invoca \
    --id <VAULT_CONTRACT_ID> \
    --source <SECRET_KEY> \
    --rpc-url https://soroban-testnet. vendedor. rg:443 \
    --network-passphrase 'Probar red SDF ; Septiembre de 2015' \
    -- \
    inicializar \
    --token_wasm_hash 6b7e4bfbf47157a12e24e564efc1f9ac237e7ae6d7056b6c2ab47178b9e7a510 \
    --token <TOKEN_CONTRACT_ADDRESS>
```

Después de recibir la transacción ha sido enviada, acuñaremos algunos tokens a **ambos** direcciones de nuestra cuenta de usuario y del contrato de bóveda. Podemos hacer esto ejecutando el script `mint.sh`.

```bash
soroban contrato invoca \
    --id <TOKEN_CONTRACT_ID> \
    --source <SECRET_KEY> \
    --rpc-url https://soroban-testnet. vendedor. rg:443 \
    --network-passphrase 'Probar red SDF ; Septiembre 2015' \
    -- \
    menta \
    --to <USER_OR_VAULT_ADDRESS> \
    --amount 100
```

Después de enviar la transacción, podemos comprobar el saldo de la cuenta. Podemos hacer esto ejecutando el script `balance.sh`.

```bash
soroban contrato invoca \
    --id <TOKEN_CONTRACT_ID> \
    --source <SECRET_KEY> \
    --rpc-url https://soroban-testnet. vendedor. rg:443 \
    --network-passphrase 'Probar red SDF ; Septiembre de 2015' \
    -- \
        balance \
    --id <USER_ADDRESS>
```

Deberíamos recibir una salida con el saldo de la cuenta.

```bash
100
```

Ahora podemos depositar algunas fichas en nuestra bóveda. Podemos hacerlo ejecutando el script `deposit.sh`.

```bash
soroban contrato invoca \
    --id <VAULT_CONTRACT_ID> \
    --source <ACCOUNT_SECRET_KEY> \
    --rpc-url https://soroban-testnet. vendedor. rg:443 \
    --network-passphrase 'Probar red SDF ; Septiembre de 2015' \
    --
    depósito \
    --de <USER_ADDRESS> \
    --amount 100
```

Después de enviar la transacción, podemos comprobar las reservas de la bóveda. Podemos hacer esto ejecutando el script `reserves.sh`.

```bash
soroban contrato invoca \
    --id <VAULT_CONTRACT_ID> \
    --source <SECRET_KEY> \
    --rpc-url https://soroban-testnet. vendedor. rg:443 \
    --network-passphrase 'Probar red SDF ; Septiembre de 2015' \
    -- \
    get_rsrvs
```

Deberíamos recibir una producción con las reservas de la bóveda.

```bash
"200"
```

100 del depósito y 100 de la minta.

Ahora podemos retirar algunas fichas de la bóveda. Podemos hacer esto ejecutando el script `retiro.sh`.

```bash
soroban contrato invoca \
    --id <VAULT_CONTRACT_ID> \
    --source <SECRET_KEY> \
    --rpc-url https://soroban-testnet. vendedor. rg:443 \
    --network-passphrase 'Probar red SDF ; Septiembre de 2015' \
    -- \
    retirar \
    --a <USER_ADDRESS> \
    --amount 100
```

Deberíamos recibir una producción con el importe de la retirada.

```bash
"100"
```

Ahora es un buen momento para revisar el saldo de nuestra cuenta de nuevo. Podemos hacer esto ejecutando el script `balance.sh`.

Deberíamos ver que nuestro saldo ha aumentado la cantidad que retiramos más rendimiento (monto/100) o %1 de nuestra cantidad de retiro.

```bash
101
```

Y por último, podemos comprobar de nuevo las reservas de la bóveda. Podemos hacer esto ejecutando el script `get_rsrv.sh`.

Deberíamos ver cómo las reservas de la bóveda han disminuido por la cantidad que retiramos + produjo.

```bash
"99"
```

¡Y ahí está! ¡Has desplegado e interactuado con éxito con el contrato de la bóveda!

Es importante señalar que no se trata de un contrato de producción listo y que sólo pretende demostrar las capacidades de la plataforma de contratos inteligentes de Soroban. Esperamos que en el futuro se apliquen contratos de rendimiento mucho más complejos con Soroban y esperamos que ustedes formen parte de ello.

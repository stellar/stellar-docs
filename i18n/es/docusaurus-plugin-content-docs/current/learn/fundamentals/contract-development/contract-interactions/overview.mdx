---
title: Resumen
description: Interactuar con contratos inteligentes.
sidebar_position: 5
---

<head>
  <title>Interactuar con contratos inteligentes.</title>
  <meta charSet="utf-8" />
  <meta property="og:title" content="Interactuar con contratos inteligentes." />
  <meta
    property="og:description"
    content="Interactúa con contratos inteligentes mediante llamadas a funciones, invocación de contratos y operaciones en la blockchain."
  />
</head>

Los contratos se invocan mediante un par de funciones host `call` y `try_call`:

- `try_call(contract, function, args)` llama a la `function` exportada desde el `contract`, pasando `args` y devolviendo un `Error` en caso de cualquier error.
- `call(contract, function, args)` simplemente llama a `try_call` con sus argumentos y atrapa el `Error`, propagando esencialmente el error.

En ambos casos, `contract` es un objeto host `Binary` que contiene el ID del contrato, `function` es un `Symbol` que guarda el nombre de una función exportada a llamar, y `args` es un `Vector` de valores para pasar como argumentos.

Estas funciones host pueden invocarse de dos maneras separadas:

- Desde fuera del host, como cuando un usuario envía una transacción que llama a un contrato.
- Desde dentro del host, cuando un contrato llama a otro.

Ambos casos siguen la misma lógica:

- El bytecode Wasm del contrato se obtiene desde una entrada `CONTRACT_DATA` del libro mayor en el sistema de almacenamiento del host.
- Se instancia una VM Wasm por la duración de la invocación.
- Se busca la función y se invoca, pasando los argumentos del llamador al llamado.

Cuando la llamada ocurre desde fuera del host, normalmente los argumentos se proveen en forma serializada XDR que acompaña a la transacción, y se deserializan y convierten automáticamente a objetos host antes de invocar el contrato.

Cuando la llamada ocurre desde dentro del host, los contratos llamador y llamado _comparten el mismo host_ y el llamador puede pasar referencias a objetos host directamente al llamado sin necesidad de serializar o deserializar.

Dado que los objetos host son inmutables, hay un riesgo limitado al pasar una referencia compartida de un contrato a otro: el llamado no puede modificar el objeto de forma que sorprenda al llamador, solo crear nuevos objetos.

---
sidebar_position: 10
title: Tipos incorporados
description: Tipos incorporados usados como entradas y salidas de contratos inteligentes.
---

<head>
  <title>Tipos incorporados usados como entradas y salidas de contratos inteligentes.</title>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="Tipos incorporados usados como entradas y salidas de contratos inteligentes."
  />
  <meta
    property="og:description"
    content="Conoce los tipos incorporados disponibles en contratos inteligentes Soroban, incluyendo tipos primitivos, símbolos, bytes, cadenas, vecs, mapas y direcciones."
  />
</head>

Los tipos incorporados están disponibles para todos los contratos para usarse como entradas y salidas de funciones del contrato, y son definidos por el [entorno] y el [SDK de Rust].

[entorno]: ../environment-concepts.mdx
[sdk de rust]: ../../../../tools/sdks/contract-sdks.mdx#soroban-rust-sdk

:::tip

También se soportan tipos personalizados como structs, enums y unions. Consulta Tipos personalizados.

:::

## Tipos primitivos

Se soportan los siguientes tipos primitivos:

### Entero sin signo de 32 bits (`u32`)

### Entero con signo de 32 bits (`i32`)

### Entero sin signo de 64 bits (`u64`)

### Entero con signo de 64 bits (`i64`)

### Entero sin signo de 128 bits (`u128`)

### Entero con signo de 128 bits (`i128`)

### Booleano (`bool`)

## Símbolo (`Symbol`)

Los símbolos son cadenas pequeñas y eficientes de hasta 32 caracteres limitados a `a-z`, `A-Z`, `0-9`, `_` y codificados en enteros de 64 bits.

Los símbolos se usan principalmente para nombres de funciones y otros identificadores que se exportan en la API pública de un contrato. También pueden usarse donde se necesitan cadenas cortas para mantener bajos los costos de recursos.

## Bytes, Cadenas (`Bytes`, `BytesN`, `String`)

Arrays de bytes y cadenas pueden pasarse a contratos y almacenes usando el tipo `Bytes`.

Para arrays de bytes de longitud fija, se puede usar `BytesN`. Por ejemplo, los IDs de contrato son arrays de bytes de 32 bytes fijos, representados como `BytesN<32>`.

Ten en cuenta que los bytes contenidos en `String`s no necesariamente cumplen con ninguna codificación de texto estándar como ASCII o Unicode UTF-8. Son bytes simples sin interpretar, y los usuarios que esperen una codificación específica deben hacer que esa codificación se aplique manualmente.

## Vec (`Vec`)

Vec es un tipo de colección secuencial, indexable y ampliable.

Los valores se almacenan en el entorno y están disponibles para el contrato a través de las funciones definidas en Vec. Los valores almacenados en el Vec se transmiten al entorno como RawVals, y cuando se recuperan del Vec, se transmiten de vuelta y se convierten de RawVal a su tipo.

No se garantiza que los valores en un Vec sean de un tipo específico y la conversión fallará si no son del tipo esperado. Por eso, la mayoría de las funciones en Vec devuelven un Result.

## Map (`Map`)

Map es un diccionario clave-valor ordenado.

El mapa está ordenado por sus claves. Iterar un mapa es estable y siempre devuelve las claves y valores en el orden de las claves.

El mapa se almacena en el Host y está disponible para el Guest a través de las funciones definidas en Map. Los valores almacenados en el Map se transmiten al Host como RawVals, y cuando se recuperan del Map se transmiten de vuelta y se convierten de RawVal a su tipo.

No se garantiza que las claves y valores en un Map sean del tipo K/V y la conversión fallará si no lo son. Por eso, la mayoría de las funciones en Map devuelven un Result.

Los mapas tienen a lo sumo una entrada por clave. Establecer un valor para una clave en el mapa que ya tiene un valor para esa clave reemplaza el valor.

## Dirección (`Address`)

Address es un identificador opaco universal para usar en contratos. Puede representar una cuenta 'clásica' Stellar, una cuenta personalizada implementada en Soroban o simplemente un contrato arbitrario.

Address puede usarse como argumento de entrada de función de contrato (por ejemplo, para identificar al receptor de pago), como clave de datos (por ejemplo, para almacenar el saldo), como fuente de autenticación y autorización (por ejemplo, para autorizar una transferencia de token), etc.

Consulta la [documentación de autorización](../authorization.mdx) para más detalles sobre cómo usar el tipo `Address`.

## Opción (`Option`)

Option representa un valor opcional.

El tipo Option se usa para valores que pueden estar presentes o no. El tipo Option es un enum y puede ser `Some` (existe algún valor) o `None` (no existe valor).

Aunque Option actúa como el `Option<T>` de Rust, el tipo Option no se representa explícitamente en XDR. El tipo Option se representa en el XDR por el valor `ScVal` `ScVoid` cuando no existe valor (None), y por cualquier otro valor `ScVal` cuando el valor existe (Some).

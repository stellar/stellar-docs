---
sidebar_position: 20
title: Tipos personalizados
description: Tipos struct, union y enum definidos por contratos.
---

<head>
  <title>Tipos struct, union y enum definidos por contratos.</title>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="Tipos struct, union y enum definidos por contratos."
  />
  <meta
    property="og:description"
    content="Consulta los tipos struct, union y enum que se pueden usar como entradas de contrato, salidas de contrato o para almacenamiento."
  />
</head>

Los tipos personalizados son tipos struct, union y enum definidos por contratos. Se pueden usar en todos los lugares donde se usen tipos primitivos: como entradas de contratos, salidas o para almacenamiento.

:::info

El [ejemplo de tipos personalizados](../../../../build/smart-contracts/example-contracts/custom-types.mdx) muestra cómo definir tus propios tipos.


:::

:::info

Los tipos enum de error son otro tipo que los contratos pueden definir y que tienen comportamientos únicos. Consulta [Errores](../errors-and-debugging/errors.mdx) para más información.

:::

## Structs (con campos nombrados)

Los structs con campos nombrados se almacenan en el libro mayor como un mapa de pares clave-valor, donde la clave es una cadena de 32 caracteres que representa el nombre del campo y el valor es el valor codificado.

Los nombres de campos no deben tener más de 32 caracteres. Los campos con nombres de no más de 9 caracteres son un poco más eficientes en tiempo de ejecución, aunque la diferencia debería ser mínima la mayoría de las veces.

```rust
#[contracttype]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct State {
    pub count: u32,
    pub last_incr: u32,
}
```

Cuando se convierte a XDR, el valor se convierte en un `ScVal`, que contiene un `ScMap`, el cual contiene un arreglo de pares clave-valor.

```json
{
  "map": [
    { "key": { "symbol": "count" }, "val": { "u32": 0 } },
    { "key": { "symbol": "last_incr" }, "val": { "u32": 0 } }
  ]
}
```

## Structs (con campos sin nombre)

Los structs con campos sin nombre se almacenan en el libro mayor como un vector de valores, y son intercambiables con tuplas y vectores. Los elementos se colocan en el vector en el orden en que aparecen en la lista de campos.

```rust
#[contracttype]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct State(pub u32, pub u32);
```

Cuando se convierte a XDR, el valor se convierte en un `ScVal`, que contiene un `ScVec`, el cual contiene un arreglo de valores.

```json
{ "vec": [{ "u32": 0 }, { "u32": 0 }] }
```

## Enum (variantes unitarias y de tupla)

Los enums que contienen variantes unitarias y de tupla se almacenan en el libro mayor como un vector de dos elementos, donde el primer elemento es el nombre de la variante del enum como una cadena de hasta 32 caracteres, y el valor es el valor si la variante tiene uno.

Solo se admiten variantes unitarias y variantes de tupla, como `A` y `B` a continuación.

```rust
#[contracttype]
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum Enum {
    A,
    B(u32),
}
```

Cuando una variante unitaria, como `Enum::A`, se convierte a XDR, el valor se convierte en un `ScVal`, que contiene un `ScVec`, con un arreglo de un solo valor, el símbolo que contiene el nombre de la variante.

```json
{ "vec": [{ "symbol": "A" }] }
```

Cuando una variante de tupla, como `Enum::B`, se convierte a XDR, el valor se convierte en un `ScVal`, que contiene un `ScVec`, con un arreglo de dos valores, el símbolo que contiene el nombre de la variante y el valor de la tupla.

```json
{ "vec": [{ "symbol": "B" }, { "u32": 0 }] }
```

Cuando se implementen variantes de tupla que contengan múltiples valores, los valores se incluirán en el vector.

## Enum (variantes enteras)

Los enums que contienen valores enteros se almacenan en el libro mayor como el valor `u32`.

```rust
#[contracttype]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
#[repr(u32)]
pub enum Enum {
    A = 1,
    B = 2,
}
```

Cuando se convierte a XDR, el valor se convierte en un `ScVal`, que contiene un `U32`.

```json
{ "u32": 1 }
```

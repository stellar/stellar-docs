---
sidebar_position: 30
title: Contratos completamente tipados
desctiption: Los archivos WASM de contratos inteligentes contienen una descripción legible por máquina del tipo de interfaz.
sidebar_label: Contratos completamente tipados
---

<head>
  <title>
    {`Los archivos WASM de contratos inteligentes contienen una descripción legible por máquina del 
    tipo de interfaz.`}
  </title>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="Los archivos WASM de contratos inteligentes contienen una descripción legible por máquina del tipo de interfaz."
  />
  <meta
    property="og:description"
    content="Todos los tipos de interfaz de contratos inteligentes estarán disponibles en la cadena inmediatamente, sin llamadas secundarias a APIs externas, sin gestión secundaria de APIs y mucho más."
  />
</head>

Cuando compilas un contrato creado con [soroban-sdk](../../../../tools/sdks/contract-sdks.mdx#soroban-rust-sdk), el archivo Wasm termina con una [sección personalizada](https://webassembly.github.io/spec/core/appendix/custom.html) que contiene una descripción legible por máquina de los tipos de interfaz de tu contrato, a veces llamada su [especificación](https://github.com/stellar/rs-soroban-sdk/tree/main/soroban-spec) o su [API](https://github.com/stellar/soroban-docs/pull/381#issuecomment-1507283476). Esto es similar a las [ABIs](https://www.quicknode.com/guides/ethereum-development/smart-contracts/what-is-an-abi/) en Ethereum, excepto que Soroban almacenará cada una de ellas en la cadena desde el primer día, e incluyen comentarios del autor del contrato.

Estos tipos de interfaz están formateados usando [XDR](../../../fundamentals/data-format/xdr.mdx), un formato de datos ampliamente utilizado en Stellar. Puede ser complicado crear o consumir XDR manualmente, pero las herramientas pueden obtener estos tipos de interfaz para facilitarte la vida. [Stellar CLI](../../../../tools/cli/README.mdx#cli) y [Stellar SDK](../../../../tools/sdks/client-sdks.mdx#javascript-sdk) son dos herramientas que pueden hacerlo. Veamos cada una.

## Stellar CLI: `stellar contract invoke`

En realidad, cada contrato inteligente es un programa propio y merece su propia CLI.

Eso es justo lo que te ofrece Stellar CLI.

Una CLI única para cada contrato inteligente. Construida dinámicamente, directamente desde los tipos de interfaz en la cadena. Incluyendo los comentarios del autor. Una _CLI implícita_.

Por ejemplo, llamando al contrato del activo nativo en la red de prueba:

```bash
$ stellar contract invoke --network testnet --id CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQQVU2HHGCYSC -- --help
Usage: CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQQVU2HHGCYSC [COMMAND]

Commands:
  balance         Returns the balance of `id`.

                      # Arguments

                      * `id` - The address for which a balance is being queried. If the
                      address has no existing balance, returns 0.
  ...
  transfer        Transfer `amount` from `from` to `to`.

                      # Arguments

                      * `from` - The address holding the balance of tokens which will be
                      withdrawn from.
                      * `to` - The address which will receive the transferred tokens.
                      * `amount` - The amount of tokens to be transferred.

                      # Events

                      Emits an event with topics `["transfer", from: Address, to: Address],
                      data = amount: i128`
  ...

Options:
  -h, --help  Print help
```

Como cualquier otra CLI, también puedes obtener ayuda para cualquiera de estos subcomandos. Omitiendo todo antes del `--` en el comando anterior, esto se vería así: `… -- balance --help`. Stellar CLI vuelve a obtener los tipos de interfaz de la cadena, esta vez usándolos para generar una lista completa de todos los argumentos de la función e incluso genera ejemplos.

:::tip

Si no estás familiarizado con el separador `--` de doble guion, es un patrón usado por otras CLIs. Todo lo que viene después del doble guion, a veces llamado [slop](https://github.com/clap-rs/clap/issues/971), se pasa al proceso hijo. Ejemplos de otras CLIs que usan esto son `npm run` y `cargo run`.

:::

## Stellar JS SDK: `contract.Client`

Para crear un cliente de contrato para el mismo contrato mostrado con `contract invoke` arriba, usarías este JavaScript:

```js
import { contract } from "@stellar/stellar-sdk";
const xlm = contract.Client.from({
  contractId: "CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQQVU2HHGCYSC",
  networkPassphrase: "Test SDF Network ; September 2015",
  rpcUrl: "https://soroban-testnet.stellar.org",
});
```

Como la CLI, esto obtendrá el contrato de la red activa y analizará los tipos/especificaciones del contrato. Generará automáticamente una clase que te permite llamar ergonómicamente a los métodos del contrato:

```js
xlm.balance({ id: "G123…" });
```

Ten en cuenta que todo lo mostrado arriba funciona dinámicamente desde un navegador. Sin embargo, a veces es útil tener este comportamiento disponible como una biblioteca al construir aplicaciones. Y en este caso, es realmente útil tener TypeScript, que permite autocompletado de todos los métodos del contrato, e incluye los comentarios del autor original del contrato. Para eso sirve el comando `contract bindings typescript` de la CLI:

```bash
stellar contract bindings typescript \
  --network testnet \
  --output-dir xlm --overwrite \
  --id CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQQVU2HHGCYSC
```

Esto crea un módulo NPM completamente tipado para el contrato dado.

## Ya es lo mejor; apenas comenzando

Nos encanta que Soroban tuviera todos los tipos de interfaz de contrato disponibles en la cadena desde el primer día. Sin llamadas secundarias a APIs externas, sin gestión secundaria de tokens API, sin iniciar sesión ni crear cuentas en otros lugares, y con una fiabilidad casi perfecta. Es un cambio radical en el espacio blockchain.

Stellar CLI y JS SDK ya muestran cómo esto puede integrarse en herramientas fundamentales para ofrecer experiencias satisfactorias a desarrolladores. Y esto es solo el comienzo. En todos los niveles de la pila, puedes esperar—y [construir](https://stellar.org/foundation/grants-and-funding)—herramientas que hagan la interacción con cualquier contrato predecible y fluida.

Pronto tendremos interfaces gráficas que se adapten a cualquier contrato en tiempo real, funcionando como documentación interactiva. Si escribes contratos que hagan llamadas entre contratos, la mayoría del código que necesitas también puede autogenerarse.

Y todo eso sigue siendo solo el principio. Con esos como fundamentos, ¿qué más podemos construir? ¿Qué más puedes imaginar? ¿Cuál es el futuro de los componentes, ahora que un pequeño programa, es decir, un contrato inteligente, puede ser fácilmente interactuado en todas las capas de la pila de software? Considerando la combinación con Wasm—en la cadena, en el navegador y en [otros lugares](https://en.wikipedia.org/wiki/WebAssembly#Implementations)—¿qué posibilidades de interoperabilidad podemos imaginar y co-crear?

Estamos deseando ver lo que construyes.

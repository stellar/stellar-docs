---
sidebar_position: 20
title: Modos de depuración
description: Depura contratos inteligentes de forma nativa y como WASM.
---

<head>
  <title>Depura contratos inteligentes de forma nativa y como WASM.</title>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="Depura contratos inteligentes de forma nativa y como WASM."
  />
  <meta
    property="og:description"
    content="Compila contratos inteligentes de forma nativa para pruebas locales o en WASM para despliegue, a fin de depurar."
  />
</head>

Los contratos Soroban son, en la medida de lo posible, programas regulares en Rust y pueden ser depurados usando las mismas herramientas que normalmente usarías.

Las facilidades de depuración disponibles difieren significativamente dependiendo de si un contrato se compila de forma nativa para pruebas locales, o si se compila en WASM para despliegue.

Decidir entre estos dos modos y sacarles el máximo provecho durante la depuración requiere una **comprensión cuidadosa** de qué código está compilado en los contratos desplegados y qué código solo está disponible para pruebas locales.

## Modo de pruebas locales

Es posible (y se recomienda durante el desarrollo) compilar los contratos Soroban **de forma nativa** (p. ej., como código x86-64 o AArch64) y enlazarlos directamente contra el entorno host, de modo que el contrato no sea un invitado corriendo en una máquina virtual WASM en absoluto: es simplemente una biblioteca nativa llamando a otra - su host - y ambos, host y contrato, están enlazados juntos como un solo programa, junto con un arnés de pruebas.

Esta configuración se denomina **"modo de pruebas locales"** y, dado que elimina la máquina virtual WASM de la experiencia de depuración, tiene muchas ventajas:

- Las pruebas se ejecutan mucho más rápido porque no hay una VM interpretándolas y, por defecto, se ejecutan en paralelo en múltiples hilos.
- Las pruebas pueden usar numerosas técnicas estándar de prueba y depuración:
  - [El arnés estándar de Rust `#[test]`](https://doc.rust-lang.org/reference/attributes/testing.html), incluyendo soporte en IDE con un botón para ejecutar y volver a ejecutar pruebas individuales.
  - [Depuradores estándar con soporte en IDE](https://code.visualstudio.com/docs/languages/rust#_debugging), incluido soporte para establecer puntos de interrupción e inspeccionar valores tanto en el contrato como en el host.
  - Depuración ligera mediante [registro estándar](https://docs.rs/log/latest/log/) o [tracing](https://docs.rs/tracing/latest/tracing/).
  - Pruebas sistemáticas como [fuzzing](https://crates.io/crates/cargo-fuzz), [pruebas de propiedades](https://crates.io/crates/proptest), o incluso [verificación modelo](https://crates.io/crates/kani-verifier) o [verificación formal](https://github.com/xldenis/creusot).
  - El enfoque más simple de depuración, [imprimir en la salida de error estándar](https://doc.rust-lang.org/std/macro.eprintln.html).

El modo de pruebas locales es la configuración **predeterminada** cuando se compila código dirigido a la CPU y sistema operativo de tu computadora local, que es lo que cargo hará si configuras un nuevo proyecto Rust y no especificas un destino.

## Modo Wasm

Por otro lado, si deseas compilar para despliegue, debes indicarle a cargo que construya para el target Wasm.

Compilar para Wasm _deshabilitará_ muchas de las facilidades de depuración descritas arriba, típicamente por una de tres razones:

- La VM Wasm simplemente no puede proporcionarlas (o la VM que hemos elegido no lo hace).
- La VM Wasm _podría_ proporcionarlas, pero hacerlo violaría las restricciones del [dialecto Rust para contratos](../rust-dialect.mdx).
- La VM Wasm _podría_ proporcionarlas, pero hacerlo haría que el código WASM resultante fuera imprácticamente grande.

Aunque recomendamos que la mayoría de las pruebas ocurran en modo de pruebas locales, algunos problemas surgirán únicamente en despliegue, y algunas facilidades de depuración permanecen disponibles incluso allí:

- Un host "sandbox" con un ledger simulado que puede leer y escribir entradas de ledger `CONTRACT_DATA` en el sistema de archivos local.
- Un sistema de registro general que permite a los contratos registrar valores del [tipo "value" compartido entre host/invitado](../environment-concepts.mdx), incluso en producción.
- Códigos `Error` extensibles por el usuario que pueden ser retornados desde cualquier llamada al contrato para indicar problemas.

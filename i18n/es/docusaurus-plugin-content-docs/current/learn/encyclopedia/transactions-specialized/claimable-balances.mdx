---
title: Saldos reclamables
sidebar_position: 20
---

import { CodeExample } from "@site/src/components/CodeExample";

Los saldos reclamables se introdujeron en [CAP-0023](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0023.md) y se utilizan para dividir un pago en dos partes.

- Parte 1: el envío de la cuenta crea un pago, o ClaimableBalanceEntry usando la operación Crear saldo reclamable
- Parte 2: Las cuentas de destino, o reclamante(s), aceptan el Balance ClaimableBalanceEntry usando la operación de Balance Reclamable

Los saldos reclamables permiten que una cuenta envíe un pago a otra cuenta que no esté necesariamente preparada para recibir el pago. Pueden ser usados cuando se envía un activo no nativo a una cuenta que aún no ha establecido una línea de confianza, que puede ser útil para los anclajes que incorporan nuevos usuarios. Una línea de confianza debe ser establecida por el reclamante del activo antes de poder reclamar el saldo cobrable, de lo contrario, el reclamo resultará en un error `op_no_trust`.

Es importante señalar que si un equilibrio reclamable no es reclamado, se sienta en el contable para siempre, ocupando espacio y, en última instancia, haciendo la red menos eficiente. \*_Por esta razón, es una buena idea poner una de tus propias cuentas como reclamante de un saldo reclamable. _ Entonces usted puede aceptar su propio saldo cobrable si es necesario, liberando espacio en la red.

Cada entrada de ClaimableBalanceEntry es una entrada de contabilidad y cada reclamante en esa entrada incrementa el saldo mínimo de la cuenta de origen en una reserva base.

Una vez que un ClaimableBalanceEntry ha sido reclamado, se elimina.

## Operaciones

### Crear saldo reclamable

Para parámetros básicos, vea la entrada Create Claimable Balance en nuestra [Sección de Lista de Operaciones](../../fundamentals/transactions/list-of-operations.mdx#create-claimable-balance).

#### Parámetros adicionales

`Claim_Predicate_` - un objeto que tiene tanto la cuenta de destino que puede reclamar la entrada de ClaimableBalanceEntry como un ClaimPredicate que debe evaluar como verdadero para que la reclamación tenga éxito.

Un ClaimPredicate es una estructura de datos recursiva que puede ser usada para construir condicionales complejos usando diferentes ClaimPredicateTypes. A continuación se muestran algunos ejemplos con el prefijo `Claim_Predicate_` eliminado para legibilidad. Tenga en cuenta que los SDK esperan que las marcas de tiempo Unix se expresen en segundos.

- Puede reclamar en cualquier momento - `UNCONDITIONAL`
- Puede reclamar si el tiempo de cierre del contador, incluyendo la reclamación es antes de X segundos + el tiempo de cierre del contador en el que la entrada de ClaimableBalanceEntry fue creada - `BEFORE_RELATIVE_TIME(X)`
- Puede reclamar si el tiempo de cierre del libro de notas, incluyendo el reclamo, es antes de X (marca de tiempo Unix) - `BEFORE_ABSOLUTE_TIME(X)`
- Puede reclamar si el tiempo de cierre del contador, incluyendo la reclamación es en o después de X segundos + el tiempo de cierre del contador en el que se creó la ClaimableBalanceEntry - `NOT(BEFORE_RELATIVE_TIME(X)`
- Puede reclamar si el tiempo de cierre del contador, incluyendo el reclamo es en o después de X (marca de tiempo Unix) - `NOT(BEFORE_ABSOLUTE_TIME(X)`
- Puede reclamar entre X y Y Unix timestamps (dado X \< Y) - `AND(NOT(BEFORE_ABSOLUTE_TIME(X))`, `BEFORE_ABSOLUTE_TIME(Y)`
- Puede reclamar fuera de X y Y Unix (dado X \< Y) - `OR(BEFORE_ABSOLUTE_TIME(X)`, `NOT(BEFORE_ABSOLUTE_TIME(Y)`

`ClaimableBalanceID` ClaimableBalanceID es una unión con un tipo posible (`CLAIMABLE_BALANCE_ID_TYPE_V0`). Contiene un hash SHA-256 del OperationID para Balances reclamables.

Una operación exitosa de Crear Balance Reclaimable devolverá un ID de Balance, que es necesario al reclamar la Entrada de Balance de Reclamación con la operación de Balance de Reclamación.

### Reclamar saldo reclamable

Para parámetros básicos, vea la entrada de Balance Reclamable de Reclamo en nuestra [sección de Lista de Operaciones](../../fundamentals/transactions/list-of-operations#claim-claimable-balance).

Esta operación cargará el ClaimableBalanceEntry que corresponde al ID del Balance y luego buscará la cuenta de origen de esta operación en la lista de reclamantes de la entrada. Si se encuentra un partido en el reclamante, y el ClaimPredicate evalúa a verdadero, entonces se puede reclamar la entrada de saldo de reclamación. El saldo de la entrada se moverá a la cuenta original si no hay problemas de límite o de confianza (para activos no nativos), significa que el reclamante debe establecer una línea de confianza al activo antes de reclamarlo.

### Balance reclamable de garrapata

Esta operación recupera un saldo cobrable, devolviendo el activo a la cuenta del emisor, quemándolo. Debe recuperar todo el equilibrio cobrable, no sólo una parte de él. Una vez que se haya reclamado un equilibrio, utilice la operación regular de la garrapata para recuperarla.

Los saldos reclamables de Clawback requieren el equilibrio cobrable DI.

Obtén más información sobre los clawbacks en nuestra [Enciclopedia de Clawback](./clawbacks.mdx).

## Ejemplo

El siguiente código demuestra a través tanto de JavaScript y Go SDKs cómo una cuenta (Cuenta A) crea un ClaimableBalanceEntry con dos reclamantes: Cuenta A (sí misma) y Cuenta B (otro destinatario).

Cada una de estas cuentas sólo puede reclamar el saldo bajo condiciones únicas. La cuenta B tiene un minuto completo para reclamar el saldo antes de que la Cuenta A pueda recuperar el saldo por sí misma.

**Nota:** no hay un mecanismo de recuperación para un saldo reclamable en general — si ninguno de los pronósticos puede cumplirse, el saldo no puede ser recuperado. El ejemplo de reclamación a continuación actúa como una red de seguridad para esta situación.

<CodeExample>

```js
const sdk = require("stellar-sdk");

async function main() {
  let server = new sdk.Server("https://horizon-testnet.stellar.org");

  let A = sdk.Keypair.fromSecret(
    "SAQLZCQA6AYUXK6JSKVPJ2MZ5K5IIABJOEQIG4RVBHX4PG2KMRKWXCHJ",
  );
  let B = sdk.Keypair.fromPublicKey(
    "GAS4V4O2B7DW5T7IQRPEEVCRXMDZESKISR7DVIGKZQYYV3OSQ5SH5LVP",
  );

  // NOTE: Proper error checks are omitted for brevity; always validate things!

  let aAccount = await server.loadAccount(A.publicKey()).catch(function (err) {
    console.error(`Failed to load ${A.publicKey()}: ${err}`);
  });
  if (!aAccount) {
    return;
  }

  // Create a claimable balance with our two above-described conditions.
  let soon = Math.ceil(Date.now() / 1000 + 60); // .now() is in ms
  let bCanClaim = sdk.Claimant.predicateBeforeRelativeTime("60");
  let aCanReclaim = sdk.Claimant.predicateNot(
    sdk.Claimant.predicateBeforeAbsoluteTime(soon.toString()),
  );

  // Create the operation and submit it in a transaction.
  let claimableBalanceEntry = sdk.Operation.createClaimableBalance({
    claimants: [
      new sdk.Claimant(B.publicKey(), bCanClaim),
      new sdk.Claimant(A.publicKey(), aCanReclaim),
    ],
    asset: sdk.Asset.native(),
    amount: "420",
  });

  let tx = new sdk.TransactionBuilder(aAccount, { fee: sdk.BASE_FEE })
    .addOperation(claimableBalanceEntry)
    .setNetworkPassphrase(sdk.Networks.TESTNET)
    .setTimeout(180)
    .build();

  tx.sign(A);
  let txResponse = await server
    .submitTransaction(tx)
    .then(function () {
      console.log("Claimable balance created!");
    })
    .catch(function (err) {
      console.error(`Tx submission failed: ${err}`);
    });
}
```

```go
paquete principal

importar (
    "fmt"
    "time"

    sdk "github. om/stellar/go/clients/horizonclient"
    "github. om/stellar/go/keypair"
    "github.com/stellar/go/network"
    "github. om/stellar/go/txnbuild"
)


func main() {
    client := sdk. efaultTestNetClient

    // Supongamos que estas cuentas existen y se financian en consecuencia:
    A := "SCZANGBA5YHTNYVVV4C3U252E2B6P6F5T3U6MM63WBSBZATAQI3EBTQ4"
    B := "GA2C5RFPE6GCKMY3US5PAB6UZLKIGSPIUKSLRB6Q723BM2OARMDUYEJ5"

    // Carga la cuenta correspondiente para A.
    aKeys := keypair.MustParseFull(A)
    aAccount, err := client. ccountDetail(sdk.AccountRequest{
        AccountID: aKeys. ddress(),
    })
    check(err)

    // Crear un balance reclamable con nuestras dos condiciones descritas anteriormente.
    pronto := hora. ow().Add(time.Second * 60)
    bCanClaim := txnbuild. eforeRelativeTimePredicate(60)
    aCanReclaim := txnbuild.NotPredicate(
        txnbuild. eforeAbsoluteTimePredicate(soon.Unix()),
    )

    reclamantes := []txnbuild.Claimant{
        txnbuild. ewClaimant(B, &bCanClaim),
        txnbuild.NewClaimant(aKeys. ddress(), &aCanReclaim),
    }

    // Crear la operación y enviarla en una transacción.
    claimableBalanceEntry := txnbuild. reateClaimableBalance{
        Destinaciones: reclamantes,
        Activos: txnbuild. ativeAsset{},
        Monto: "420",
    }

    // Construido, firmar, y enviar la transacción
    tx, err := txnbuild. ewTransaction(
        txnbuild. ransactionParams{
            SourceAccount: aAccount. ccountID,
            IncrementSequenceNum: true,
            BaseFee: txnbuild. inBaseFee,
            // ¡Usa un tiempo de espera real en la producción!
            Límites de tiempo: txnbuild. ewInfiniteTimeout(),
            Operaciones: []txnbuild. peration{&claimableBalanceEntry},
        },
    )
    check(err)
    tx, err = tx. ign(network.TestNetworkPassphrase, aKeys)
    check(err)
    txResp, err := cliente. ubmitTransaction(tx)
    check(err)

    fmt.Println(txResp)
    fmt.Println("¡Claimable balance creado!")
}
```

```python
importar tiempo
desde stellar_sdk.xdr import TransactionResult, OperationType
from stellar_sdk. xceptions importar NotFoundError, BadResponseError, BadRequestError
de importación stellar_sdk (
    Keypair,
    Red,
    Servidor,
    TransactionBuilder,
    Transacción,
    activo,
    Operación,
    reclamante,
    ClaimPredicate,
    CreateClaimableBalance,
    ClaimClaimableBalance
)

server = Server("https://Budgeton-testnet. vendedor. rg")

A = Keypair.from_secret("SANRGB5VXZ52E7XDGH2BHVBFZR4S25AUQ4BR7SFXIQYT5J6W2OES2OP7")
B = Keypair. rom_public_key("GAAPSRMYNFAO3TDQTLNLKN76IQ3E6IQAKU23PSQX3BIV7RTEBXHQIWU6")

# NOTA: Se omiten las comprobaciones de errores correctas para brevedad, ¡siempre valida cosas!

intento:
    aAccount = server. cargar_cuenta(A. ublic_key)
excepto NotFoundError:
    raise Exception(f"Failed to load {A.public_key}")

# Create a claimable balance with our two above-described conditions.
pronto = int(time.time() + 60)
bCanClaim = ClaimPredicate. redicate_before_relative_time(60)
aCanClaim = ClaimPredicate.predicate_not(
    ClaimPredicate.predicate_before_absolute_time(pronto)
)

# Crea la operación y envíala en una transacción.
claimableBalanceEntry = CreateClaimableBalance(
    asset = Asset. ative(),
    monto = "420",
    reclamantes = [
        reclamante (destino = B. ublic_key, predicate = bCanClaim),
        Claimant(destino = A. ublic_key, predicate = aCanClaim)
    ]
)

tx = (
    TransactionBuilder (
        source_account = acount,
        network_passphrase = Red. ESTNET_NETWORK_PASSPHRASE,
        base_fee = server.fetch_base_fee()
    )
    . ppend_operation(claimableBalanceEntry)
    .set_timeout(180)
    . uild()
)

tx.sign(A)
try:
    txResponse = servidor. ubmit_transaction(tx)
    impresión ("¡Saldo reclamable creado! )
excepto (BadRequestError, BadResponseError) como err:
    print(f"Tx envío falló: {err}")
```

</CodeExample>

En este punto, el `ClaimableBalanceEntry` existe en el contador, pero necesitaremos su ID de saldo para reclamarlo, que se puede hacer de varias maneras:

1. El remitente de la entrada (Cuenta A en este caso) puede recuperar el ID de Saldo antes de enviar la transacción;
2. El presentador analiza el XDR de las operaciones del resultado de la transacción; o
3. Alguien pregunta la lista de saldos reclamables.

Cualquiera de las partes también podría comprobar los /efectos de la transacción, consultar /claimable_balances con diferentes filtros, etc. Tenga en cuenta que aunque (1) puede no estar disponible en algunos SDKs ya que es sólo un ayudante, los otros métodos son universales.

<CodeExample>

```js
// Método 1: No disponible en el SDK JavaScript todavía.

// Método 2: Supongamos `txResponse` proviene del envío de la transacción
// arriba.
let txResult = sdk.xdr.TransactionResult.fromXDR(
  txResponse.result_xdr,
  "base64",
);
let results = txResult.result(). esults();

// Miramos el primer resultado desde nuestra primera (y sólo) operación
// en la transacción fue el CreateClaimableBalanceOp.
let operationResult = results[0].value().createClaimableBalanceResult();
let balanceId = operationResult.balanceId().toXDR("hex");
consola. og("Balance ID (2):", balanceId);

// Método 3: Account B podría hacer algo como:
let balances = await server
  . laimableBalances()
  .claimant(B.publicKey())
  . imit(1) // puede haber muchos en general
  .order("desc") // así que siempre obtenga el último
  . all()
  .catch(function (err) {
    consola. rror(`Recuperación del balance reclamable falló: ${err}`);
  });
if (!balances) {
  return;
}

balanceId = balances. ecords[0].id;
console.log("Balance ID (3):", balanceId);
```

```go
// Método 1: Supongamos que `tx` viene de la transacción construida arriba.
// Observa que esto puede hacerse *before* envío.
balanceId, err := tx. laimableBalanceID(0)
check(err)

// Método 2: Supongamos que `txResp` viene del envío de la transacción arriba.
var txResult xdr. ransactionResult
err = xdr.SafeUnmarshalBase64(txResp.ResultXdr, &txResult)
check(err)

if results, ok := txResult. perationResults(); ok {
    // Miramos el primer resultado desde nuestra primera (y única) operación en la
    // la transacción fue el CreateClaimableBalanceOp.
    operationResult := results[0].MustTr().CreateClaimableBalanceResult
    balanceId, err := xdr. arshalHex(operationResult.BalanceId)
    check(err)
    fmt. rintln("Balance ID:", balanceId)
}

// Método 3: Cuenta B alternativamente podría hacer algo como:
balances, err := client. laimableBalances(sdk.ClaimableBalanceRequest{Claimant: B})
check(err)
balanceId := balances.Embedded.Records[0].BalanceID
```

```python
# Método 1: No disponible en el SDK de Python todavía.

# Método 2: Supongamos `txResponse` viene del envío de la transacción
# anterior.
txResult = TransactionResult.from_xdr(txResponse["result_xdr"])
resultados = txResult.result. esults

# Miramos el primer resultado desde nuestra primera (y únicamente) operación
# en la transacción fue CreateClaimableBalanceOp.
operationResult = results[0].tr.create_claimable_balance_result
balanceId = operationResult.balance_id.to_xdr_bytes(). ex()
print(f"Balance ID (2): {balanceId}")

# Método 3: Cuenta B podría alternativamente hacer algo como:
intento:
    balances = (
        server
        . laimable_balances()
        .for_claimant(B. ublic_key)
        .limit(1)
        . rder(desc = True)
        . all()
    )
excepto (BadRequestError, BadResponseError) como err:
    print(f"Recuperación de saldo reclamable falló: {err}")

balanceId = balances["_embedded"]["records"][0]["id"]
print(f"ID de saldo (3): {balanceId}")
```

</CodeExample>

Con la identificación de saldo reclamable adquirida, tanto la Cuenta B como A pueden presentar una reclamación, dependiendo del predicado que se cumpla. Supondremos aquí que ha pasado un minuto, así que la Cuenta A sólo recupera la entrada del saldo.

<CodeExample>

```js
let claimBalance = sdk.Operation.claimClaimableBalance({
  balanceId: balanceId,
});
console.log(A. ublicKey(), "claiming", balanceId);

let tx = new sdk.TransactionBuilder(aAccount, { fee: sdk.BASE_FEE })
  .addOperation(claimBalance)
  . etNetworkPassphrase(sdk.Networks.TESTNET)
  .setTimeout(180)
  .build();

tx.sign(A);
await server. ubmitTransaction(tx).catch(function (err) {
  console.error(`Tx submission failed: ${err}`);
});
```

```go
claimBalance := txnbuild.ClaimClaimableBalance{BalanceID: balanceId}
tx, err = txnbuild. ewTransaction(
    txnbuild.TransactionParams{
        SourceAccount: aAccount. ccountID, // o Cuenta B, dependiendo de la condición!
        IncrementSequenceNum: verdadero,
        BaseFee: txnbuild. inBaseFee,
        Timebounds: txnbuild. ewInfiniteTimeout(),
        Operaciones: []txnbuild. peration{&claimBalance},
    },
)
check(err)
tx, err = tx. ign(network.TestNetworkPassphrase, aKeys)
check(err)
txResp, err = client.SubmitTransaction(tx)
check(err)
```

```python
claimBalance = ClaimClaimableBalance(balance_id = balanceId)
print(f"{A.public_key} reclamando {balanceId}")

tx = (
    TransactionBuilder (
        source_account = acuenta,
        network_passphrase = Red. ESTNET_NETWORK_PASSPHRASE,
        base_fee = servidor. etch_base_fee()
    )
    .append_operation(claimBalance)
    . et_timeout(180)
    .build()
)

tx. ign(A)
intento:
    txResponse = servidor. ubmit_transaction(tx)
excepto (BadRequestError, BadResponseError) como err:
    print(f"Envío de Tx falló: {err}")
```

</CodeExample>

¡Y eso es todo! Puesto que hemos optado por la ruta de reclamación, la cuenta A debe tener el mismo saldo que comenzó con lo que comenzó (menos cuotas), y la cuenta B deben estar sin cambios.

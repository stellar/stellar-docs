---
title: Garrones
sidebar_position: 30
---

import { CodeExample } from "@site/src/components/CodeExample";

Las devoluciones se introdujeron en CAP-0035 y permiten a un emisor de activos quemar una cantidad específica de un activo habilitado para recuperar de una línea de confianza o de un saldo cobrable, destruirla de forma efectiva y eliminarla del balance de un receptor.

Se diseñaron para permitir a los emisores de activos cumplir con las normas de valores. que en muchas jurisdicciones requieren que los emisores de activos (o agentes de transferencia designados) tengan la capacidad de revocar activos en el caso de una transacción errónea o fraudulenta u otra acción regulatoria relativa a una persona o activo específico.

Los garrapatos son útiles para:

- Recuperación de activos obtenidos de forma fraudulenta
- Respuesta a las acciones reguladoras
- Permitir a las personas identificadas recuperar un activo habilitado en caso de pérdida de la custodia clave o robo

## Operaciones

### Configurar opciones

El emisor configura su cuenta para habilitar las devoluciones usando la bandera `AUTH_CLAWBACK_ENABLED`. Esto hace que cada línea de confianza establecida desde la cuenta tenga el `TRUSTLINE_CLAWBACK_ENABLED_FLAG` establecido automáticamente.

Si una cuenta emisora quiere establecer el `AUTH_CLAWBACK_ENABLED_FLAG`, debe tener el `AUTH_REVOCABLE_FLAG`. Esto permite a un emisor de activos recuperar los balances bloqueados en las ofertas al revocar la autorización de una línea de confianza, que atrae todas las ofertas que implican esa confianza. El emisor puede entonces realizar la devolución.

### Garrón

La cuenta emisora utiliza esta operación para recuperar parte o la totalidad de un activo. Una vez que una cuenta tiene un activo en particular para el que se han habilitado las devoluciones, la cuenta emisora puede recuperarla, quemándola. Necesita proporcionar el activo, una cantidad, y la cuenta desde la que recupera el activo.

### Balance reclamable de garrapata

Esta operación recupera un saldo cobrable, devolviendo el activo a la cuenta del emisor, quemándolo. Debe recuperar todo el equilibrio cobrable, no sólo una parte de él. Una vez que se haya reclamado un equilibrio, utilice la operación regular de la garrapata para recuperarla.

Los saldos reclamables de Clawback requieren el equilibrio cobrable DI.

### Establecer bandera de línea de confianza

Elimina las capacidades de recuperación en una línea de confianza específica eliminando `TRUSTLINE_CLAWBACK_ENABLED_FLAG` a través de la operación `SetTrustLineFlags`.

Sólo puedes borrar una bandera, no establecerla. Así que limpiar una bandera de garra en una línea de confianza es irreversible. Esto se hace para que no cambie de forma retroactiva las reglas de sus tenedores de activos. Si quieres activar de nuevo los garrillos, los poseedores deben volver a emitir su confianza.

## Ejemplos

Aquí cubriremos los siguientes enfoques para recuperar un activo.

**Ejemplo 1:** Cuenta de emisión (Cuenta A) crea un activo habilitado para recuperar y lo envía a Cuenta B. Cuenta B envía ese activo a Cuenta C. La cuenta A recuperará entonces el activo de C. **Ejemplo 2:** La Cuenta B crea un saldo cobrable para la Cuenta C y la Cuenta A recupera el saldo cobrable. **Ejemplo 3:** Cuenta A emite un activo habilitado para clawback a Cuenta B. Una garra devuelve parte del activo de B, luego quita la bandera habilitada para el garrapato de la línea de confianza y ya no puede recoger el activo.

### Preámbulo: Emisión de un recurso recuperable

En primer lugar, crearemos una cuenta para habilitar las devoluciones y emitir un activo en consecuencia.

La emisión correcta de un activo (con una emisión separada y cuentas de distribución) es un poco más involucrada, pero usaremos un método más simple aquí.

Además, ten en cuenta que primero necesitamos habilitar los garrillos y luego establecer líneas de confianza, ya que no puedes habilitar retroactivamente la devolución de las garras en las líneas de confianza existentes.

<CodeExample>

```js
const sdk = require("stellar-sdk");

let server = new sdk.Server("https://greenon-testnet.stellar.org");

const A = sdk.Keypair. romtformat@@1 (
  "SAQLZCQA6AYUXK6JSKVPJ2MZ5K5IIABJOEQIG4RVBHX4PG2KMRKWXCHJ",
);
const B = sdk.Keypair.from)[video] (
  "SAY2H7SANIS3JLFBFPLJRTYNLUYH4UTROIKRVFI4FEYV4LDW5Y7HDZ4",
);
const C = sdk. eypair.fromFirst(
  "SCZANGBA5YHTNYVVV4C3U252E2B6P6F5T3U6M63WBSBZATAQI3EBTQ4",
);

const ASSET = new sdk.Asset("CLAW", A. ublicKey());

/// Habilita AuthClawbackEnabledFlag en una cuenta.
function enableClawback(account, keys) {
  return server. ubmitTransaction(
    buildTx(account, keys, [
      sdk.Operation. etOptions({
        setFlags: sdk.AuthClawbackEnabledFlag | sdk.AuthRevocableFlag,
      }),
    ]),
  );
}

/// Establece una línea de confianza para `recipient` para ASSET (desde arriba).
const establishTrustline = function (recipient, key) {
  return server. ubmitTransaction(
    buildTx(recipiente, llave, [
      sdk.Operation. hangeTrust({
        asset: ASSET,
        limit: "5000", // arbitrario
      }),
    ]),
  );
};

/// Obtiene la última información de la cuenta para todas las cuentas.
function getAccounts() {
  return Promise.all([
    server.loadAccount(A.publicKey()),
    server.loadAccount(B. ublicKey()),
    server.loadAccount(C. ublicKey()),
  ]);
}

/// Permite recuperar en A, y establece líneas de confianza desde C, B -> A.
function preamble() {
  return getAccounts(). hen(function (accounts) {
    let [accountA, accountB, accountC] = accounts;
    return enableClawback(accountA, A). hen(
      Promise. lla([
        establishTrustline(accountB, B),
        establishTrustline(accountC, C),
      ]),
    );
  });
}

/// Ayuda a simplificar la creación y firma de una transacción.
function buildTx(source, signer, ops) {
  var tx = new StellarSdk.TransactionBuilder(source, {
    fee: 100,
    networkPassphrase: StellarSdk.Networks.TESTNET,
  });
  ops. orEach((op) => tx.addOperation(op));
  tx = tx.setTimeout(30).build();
  tx. ign(signer);
  retorna tx;
}

/// Imprime los balances de una lista de cuentas.
function showBalances(accounts) {
  accounts.forEach((acc) => {
    console.log(`${acc.accountId().substring(0, 5)}: ${getBalance(acc)}`);
  });
}
```

</CodeExample>

### Ejemplo 1: Pagos

Con el código de configuración compartido fuera del camino, ahora podemos demostrar cómo funciona la recuperación para los pagos. Este ejemplo resaltará cómo el emisor de activos tiene el control sobre sus activos independientemente de cómo se distribuya al mundo.

En nuestro escenario, la Cuenta A pagará la Cuenta B con 1000 fichas de su activo personalizado; Luego, B pagará tokens de la cuenta C 500 por turno. Finalmente, A recuperará la mitad del equilibrio de C, quemando 250 fichas para siempre. Vamos a sumergirnos en las funciones auxiliares:

<CodeExample>

```js
/// Hacer un pago a `toAccount` desde `fromAccount` para `amount`.
function makePayment(toAccount, fromAccount, fromKey, amount) {
  return server. ubmitTransaction(
    buildTx(fromAccount, fromKey, [
      sdk. peration.payment({
        destino: toAccount. ccountId(),
        activo: ASSET, // definido en el preámbulo
        monto: monto,
      }),
    ]),
  );
}

/// Realiza un clawback por `byAccount` de `amount` de `fromAccount`.
function doClawback(byAccount, byKey, fromAccount, amount) {
  return server. ubmitTransaction(
    buildTx(byAccount, byKey, [
      sdk. peration.clawback({
        desde: fromAccount. ccountId(),
        activo: ASSET, // definido en el preámbulo
        monto: monto,
      }),
    ]),
  );
}

/// Obtiene el saldo de ASSET en `account`.
function getBalance(account) {
  const balances = account.balances. ilter((balance) => {
    return (
      balance.asset_code == ASSET. ode && balance.asset_issuer == ASSET.issuer
    );
  });
  saldos de retorno. ength > 0 ? balances[0].balance : "0";
}
```

</CodeExample>

Estos fragmentos nos ayudarán con la composición final: hacer algunos pagos para distribuir el activo al mundo y recuperar parte de él.

<CodeExample>

```js
function examplePaymentClawback() {
  return getAccounts()
    . hen(function (cuentas) {
      let [accountA, accountB, accountC] = cuentas;
      return makePayment(accountB, accountA, "1000")
        . hen(makePayment(accountC, accountB, B, "500"))
        . hen(doClawback(accountA, A, accountC, "250"));
    })
    . hen(getAccounts)
    .then(showBalances);
}

preamble().then(examplePaymentClawback);
```

</CodeExample>

Después de ejecutar nuestro ejemplo, deberíamos ver que los balances reflejan el flujo de ejemplo:

```
GCIHA: 0
GDS5N: 500
GC2BK: 250
```

Tenga en cuenta que `GCIHA` (Cuenta A, el emisor) no tiene ningún activo a pesar de recuperar 250 de Cuenta C. Esto debería llevar a casa el hecho de que los activos recuperados son quemados, no transferidos.

(Puede ser extraño que A nunca posea ninguna ficha de su activo personalizado, pero así es exactamente como funciona la emisión: se crea un valor donde antes no había ninguno. Enviar un activo a su cuenta emisora es equivalente a quemarlo, y auditar la cantidad total de un activo en existencia es uno de los beneficios de distribuir un activo correctamente a través de una cuenta de distribución, que evitamos hacer aquí, por ejemplo, brevedad.)

### Ejemplo 2: Balance reclamable

Los pagos directos no son la única forma de transferir activos entre cuentas: los saldos cobrables también lo hacen. Dado que son un mecanismo de pago separado, necesitan un mecanismo separado.

Necesitamos algunos métodos adicionales de ayuda para empezar a trabajar eficientemente con equilibrios que se pueden reclamar:

<CodeExample>

```js
function createClaimable(fromAccount, fromKey, toAccount, amount) {
  return server.submitTransaction(
    buildTx(fromAccount, fromKey, [
      sdk.Operation.createClaimableBalance({
        asset: ASSET,
        amount: amount,
        claimants: [new sdk.Claimant(toAccount.accountId())],
      }),
    ]),
  );
}

// https://developers.stellar.org/docs/encyclopedia/claimable-balance/#example
function getBalanceId(txResponse) {
  const txResult = sdk.xdr.TransactionResult.fromXDR(
    txResponse.result_xdr,
    "base64",
  );
  const operationResult = txResult.result().results()[0];

  let creationResult = operationResult.value().createClaimableBalanceResult();
  return creationResult.balanceId().toXDR("hex");
}

function clawbackClaimable(issuerAccount, issuerKey, balanceId) {
  return server.submitTransaction(
    buildTx(issuerAccount, issuerKey, [
      sdk.Operation.clawbackClaimableBalance({ balanceId }),
    ]),
  );
}
```

</CodeExample>

Ahora, podemos cumplir el flujo: A paga B, que envía un saldo reclamable a C, que lo recupera con A. (Tenga en cuenta que dependemos del ayudante `makePayment` del ejemplo anterior.)

<CodeExample>

```js
function exampleClaimableBalanceClawback() {
  return getAccounts()
    . hen(function (cuentas) {
      let [accountA, accountB, accountC] = cuentas;

      return makePayment(accountB, accountA, "1000")
        . hen(() => createClaimable(accountB, B, accountC, "500"))
        . hen((txResp) => clawbackClaimable(accountA, A, getBalanceId(txResp)));
    })
    .then(getAccounts)
    .then(showBalances);
}
```

</CodeExample>

Después de ejecutar `preamble().then(examplePaymentClawback)`, deberíamos ver que los balances reflejan nuestro flujo:

```
GCIHA: 0
GDS5N: 500
GC2BK: 0
```

### Ejemplo 3: Activando Selectivamente Clawback

Cuando habilites el `AUTH_CLAWBACK_ENABLED_FLAG` en tu cuenta, hará que todas las líneas de confianza futuras tengan habilitadas para recuperar cualquiera de tus activos emitidos. Esto puede no ser siempre deseable, ya que puede que desee que ciertos activos se comporten como antes. Aunque se podría solucionar esto reemitiendo activos desde una cuenta de “clawback dedicado”, también puede desactivar los garras para ciertas líneas de confianza limpiando el `TRUST_LINE_CLAWBACK_ENABLED_FLAG` en una línea de confianza.

En el siguiente ejemplo, tendremos una cuenta (Cuenta A, como antes) emite un nuevo activo y distribuirlo a una segunda cuenta (Cuenta B). Luego, demostraremos cómo A garras devuelve algunos de los activos de B, luego elimina la confianza y ya no puede recuperar el activo.

Primero, preparemos las cuentas (ten en cuenta que aquí dependemos de las funciones de ayuda definidas en los ejemplos anteriores):

<CodeExample>

```js
function getAccounts() {
  return Promise.all([
    server.loadAccount(A.publicKey()),
    servidor. oadAccount(B.publicKey()),
  ]);
}

function preambleRedux() {
  return getAccounts(). hen((cuentas) => {
    return enableClawback(cuentas[0], A). hen(() =>
      establishTrustline(cuentas[1], B),
    );
  });
}
```

</CodeExample>

Ahora, vamos a distribuir parte de nuestro activo a la cuenta B, sólo para recuperarlo. Después, despejaremos la bandera de la línea de confianza y mostraremos que otro torrente no es posible:

<CodeExample>

```js
function disableClawback(issuerAccount, issuerKeys, forTrustor) {
  return server.submitTransaction(
    buildTx(issuerAccount, issuerKeys, [
      sdk.Operation.setTrustLineFlags({
        trustor: forTrustor.accountId(),
        asset: ASSET, // defined in the (original) preamble
        flags: {
          clawbackEnabled: false,
        },
      }),
    ]),
  );
}

function exampleSelectiveClawback() {
  return getAccounts()
    .then((accounts) => {
      let [accountA, accountB] = accounts;
      return makePayment(accountB, accountA, A, "1000")
        .then(getAccounts)
        .then(showBalances)
        .then(() => doClawback(accountA, A, accountB, "500"))
        .then(getAccounts)
        .then(showBalances)
        .then(() => disableClawback(accountA, A, accountB))
        .then(() => doClawback(accountA, A, accountB, "500"))
        .catch((err) => {
          if (err.response && err.response.data) {
            // Note that this is a *very* specific way to check for an error, and
            // you should probably never do it this way.
            // We do this here to demonstrate that the clawback error *does*
            // occur as expected.
            const opErrors = err.response.data.extras.result_codes.operations;
            if (
              opErrors &&
              opErrors.length > 0 &&
              opErrors[0] === "op_not_clawback_enabled"
            ) {
              console.info("Clawback failed, as expected!");
            } else {
              console.error(
                "Uh-oh, some other failure occurred:",
                err.response.data.extras,
              );
            }
          } else {
            console.error("Uh-oh, unknown failure:", err);
          }
        });
    })
    .then(getAccounts)
    .then(showBalances);
}
```

</CodeExample>

Ejecuta el ejemplo (por ejemplo, `via preambleRedux().then(exampleSelectiveClawback)`) y observe sus resultados:

```
GCIHA: 0
GDS5N: 1000
GCIHA: 0
GDS5N: 500
¡Clawback falló, como se esperaba!
GCIHA: 0
GDS5N: 500
```

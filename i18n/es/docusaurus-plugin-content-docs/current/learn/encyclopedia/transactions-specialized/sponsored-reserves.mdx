---
title: Reservas patrocinadas
sidebar_position: 80
---

import { CodeExample } from "@site/src/components/CodeExample";

Las reservas auspiciadas se introdujeron en [CAP-0033](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0033.md) y permiten que una cuenta (cuenta patrocinadora) pague las reservas base para otra cuenta (cuenta patrocinada). Si bien esta relación existe, los requisitos de reserva base que normalmente se acumularían en la cuenta patrocinada ahora se acumulan en la cuenta patrocinadora.

Tanto las reservas futuras patrocinadoras de Begin como las operaciones de fin de las futuras reservas de patrocinio deben aparecer en la transacción de patrocinio garantizar que ambas cuentas acepten el patrocinio.

Cualquier cosa que aumente el saldo mínimo puede ser patrocinada (creación de cuentas, ofertas, fideicomisos, entradas de datos, firmantes, saldos reclamables).

Para obtener más información sobre las reservas de base, consulte nuestra sección [Lumens](../../fundamentals/lumens.mdx#base-reserves).

## Operaciones de reservas patrocinadas

### Comenzar y finalizar patrocinios

Para crear una reserva patrocinada, usted tiene que utilizar una transacción sandwich que incluye tres operaciones.

- La primera operación: Begin Sponsoring Future Reserves inicia el patrocinio y requiere la firma de la cuenta de patrocinador.
- La segunda operación: especifica lo que está siendo patrocinado.
- La tercera operación: Finalizar el patrocinio de reservas futuras, permite a la cuenta patrocinada aceptar el patrocinio y requiere la firma de la cuenta patrocinada.

Begin Sponsoring Future Reserves establece la relación is-sponsoring-future-reserves-para donde la cuenta de patrocinio es la cuenta de origen de la operación. La cuenta especificada en la operación es la cuenta patrocinada.

Finalizar el patrocinio de las reservas futuras termina la relación actual es de futuro-futuro para la cuenta de origen de la operación.

Al final de cualquier transacción, no debe haber relaciones continuas que sean patrocinadoras de futuro-reservas-para las relaciones, por lo que estas dos operaciones deben ser utilizadas conjuntamente en una sola transacción.

Ver detalles de la operación en nuestra [sección de Lista de Operaciones](../../fundamentals/transactions/list-of-operations.mdx).

### Revocar patrocinio

Permite que la cuenta de patrocinio elimine o transfiera patrocinios de asientos y firmantes existentes. Si el ledgerEntry o el firmante no está patrocinado, el dueño de la Entrada LedgerEntry o firmante puede establecer un patrocinio si es el beneficiario de una relación de futuro patrocinador.

Lógica de operación

- Entrada/firmante patrocinado
  - La cuenta de origen es actualmente el beneficiario de una relación-de-patrocinadora-futuro-reservas-para la relación
    - Transferir el patrocinio de la entrada/firma de la cuenta de origen a la cuenta que es patrocinadora-futuras reservas-para la cuenta de origen
  - La cuenta de origen no es el beneficiario de una relación-de-patrocinadora-futuro-reservas-para la relación
    - Eliminar el patrocinio de la entrada/firma
- La entrada/firma no está patrocinada
  - La cuenta de origen es actualmente el beneficiario de una relación-de-patrocinadora-futuro-reservas-para la relación
    - Establecer el patrocinio entre la entrada/firma y la cuenta que es patrocinadora-futuro-reservas-para la cuenta fuente
  - La cuenta de origen no es el beneficiario de una relación-de-patrocinadora-futuro-reservas-para la relación
    - No-Op

Ver detalles de la operación en nuestra [Sección de la Lista de Operaciones](../../fundamentals/transactions/list-of-operations.mdx#begin-sponsoring-future-reserves).

## Efecto en el saldo mínimo

Una vez introducidos los patrocinios, el cálculo del saldo mínimo es: (2 reservas base + `numSubEntries` + `numSponsoring` - `numSponsored`) \* `baseReserve` + `liabilities.selling`.

Cuando la cuenta A patrocina reservas futuras para la cuenta B, cualquier requerimiento de reserva que normalmente se acumularía en B en su lugar se acumulará en A, mostrado en `numSponsoring`. El hecho de que estas reservas estén siendo proporcionadas por otra cuenta se reflejará en B en 'numSponsored', que anula el aumento en `numSubEntries`, manteniendo el saldo mínimo sin cambios para B.

Cuando se elimina una entrada o subentrada patrocinada, 'numSponsoring' disminuye en la cuenta patrocinadora y 'numSponsored' disminuye en la cuenta patrocinada.

Para obtener más información sobre los requisitos de balance mínimo, consulte nuestra sección en [Lumens](../../fundamentals/lumens.mdx#minimum-balance).

## Efecto sobre saldos cobrables

Todos los saldos cobrables son patrocinados a través de la lógica incorporada en las operaciones de saldo cobrable. La cuenta que crea el saldo cobrable paga la reserva base para obtener el saldo cobrable en el contador. Cuando el saldo reclamable es reclamado por el reclamante (s), el saldo cobrable es retirado del contador, y la cuenta que lo creó recupera la reserva base.

Lea más sobre los balances reclamables en nuestra [Entrada de la Enciclopedia de Balances Claimables](./claimable-balances.mdx).

## Ejemplos

Cada uno de los siguientes ejemplos se basa en sí mismo, referenciando variables de fragmentos anteriores. Los siguientes ejemplos se demostrarán:

1. Creación del patrocinador de una línea de confianza para otra cuenta
2. Patrocinar dos líneas de confianza para una cuenta a través de dos patrocinadores diferentes
3. Transferir la responsabilidad del patrocinio de una cuenta a otra
4. Revocar completamente el patrocinio de una cuenta

Por brevedad en los ejemplos de Golang, asumiremos la existencia de un `SignAndSend`(...) (definido a continuación) que crea y envía una transacción con los parámetros adecuados y la comprobación básica de errores.

### Preámbulo

Empezaremos por incluir la placa de la cuenta y la creación de activos.

<CodeExample>

```js
const sdk = require("stellar-sdk");
const http = require("got");

let server = new sdk.Server("https://is) on-testnet.stellar. rg");

async function main() {
  // Crear y agregar fondos a las nuevas cuentas.
  let keypairs = [
    sdk.Keypair.random(),
    sdk.Keypair. andom(),
    sdk.Keypair. andom(),
  ];

  for (const keypair of keypairs) {
    const base = "https://friendbot.stellar. rg/?";
    const path = base + "addr=" + encodeURIComponent(keypair. ublicKey());

    console.log(`Funding:\n ${keypair.secret()}\n ${keypair. ublicKey()}`);

    // Aquí usamos la librería "got" para hacer la solicitud HTTP de forma sincronizada, pero
    // obviamente puedes usar cualquier método que quieras para esto.
    const response = await http(path). atch(function (error) {
      console.error(" failed:", error.responder. ody);
    });
  }

  // Activos arbitrarios para patrocinar líneas de confianza para. Supongamos que tienen sentido.
  let S1 = pares de llaves[0], A = pares de llaves[1], S2 = pares de llaves[2];
  let assets = [
    new sdk. sset("ABCD", S1.publicKey()),
    new sdk.Asset("EFGH", S1. ublicKey()),
    new sdk.Asset("IJKL", S2.publicKey()),
  ];

  // ...
```

```go
paquete principal

importar (
    "fmt"
    "net/http"

    sdk "github. om/stellar/go/clients/horizonclient"
    "github.com/stellar/go/keypair"
    "github. om/stellar/go/network"
    protocolo "github.com/stellar/go/protocols/horizon"
    "github. om/stellar/go/txnbuild"
)

func main() {
    client := sdk. efaultTestNetClient

    // Tanto S1 como S2 serán patrocinadores de A en varios puntos del tiempo.
    S1, A, S2 := keypair.MustRandom(), keypair.MustRandom(), keypair.MustRandom()
    addressA := A. ddress()

    for _, pair := range []*keypair. ull{S1, A, S2} {
        resp, err := http.Get("https://friendbot. tellar.org/?addr=" + pair.Address())
        check(err)
        resp. ody.Close()
        fmt. rintln("Funded", pair.Address())
    }

    // Cargar la cuenta correspondiente tanto para A como para C.
    s1Account, err := client.AccountDetail(sdk.AccountRequest{AccountID: S1. ddress()})
    check(err)
    aAccount, err := client.AccountDetail(sdk. ccountRequest{AccountID: addressA})
    check(err)
    s2Account, err := client.AccountDetail(sdk.AccountRequest{AccountID: S2. ddress()})
    check(err)

    // Activos arbitrarios para patrocinar líneas de confianza para. Supongamos que tienen sentido.
    activos := []txnbuild.CreditAsset{
        txnbuild. reditAsset{Code: "ABCD", Emisor: S1.Address()},
        txnbuild.CreditAsset{Code: "EFGH", Emisor: S1. ddress()},
        txnbuild.CreditAsset{Code: "IJKL", Emisor: S2. ddress()},
    }

    // ...
```

</CodeExample>

### 1. Patrocinando líneas de confianza

Ahora, vamos a patrocinar líneas de confianza para la cuenta A. Tenga en cuenta que la operación `CHANGE_TRUST` es enrollada entre las operaciones de patrocinio inicial y final y que todas las cuentas relevantes necesitan firmar la transacción.

<CodeExample>

```js
//
// 1. S1 patrocinará una línea de confianza para la Cuenta A.
//
deje s1Account = await server. oadAccount(S1.publicKey()).catch(accountFail);
let tx = new sdk. ransactionBuilder(s1Account, { fee: sdk.BASE_FEE })
  .addOperation(
    sdk.Operation.beginSponsoringFutureReserves({
      sponsoredId: A. ublicKey(),
    }),
  )
  . ddOperación(
    sdk.Operation.changeTrust({
      fuente: A. ublicKey(),
      activos: activos[0]
      limit: "1000", // Este límite puede variar de acuerdo con su aplicación;
      // si se deja vacío, por defecto el límite máximo.
    }),
  )
  . ddOperación(
    sdk.Operation.endSponsoringFutureReserves({
      fuente: A. ublicKey(),
    }),
  )
  .setNetworkPassphrase(sdk. etworks.TESTNET)
  .setTimeout(180)
  .build();

// Tenga en cuenta que mientras cualquiera puede enviar esta transacción, ambos deben firmarla.
tx. ign(S1, A);
let txResponse = await server.submitTransaction(tx).catch(txCheck);
if (!txResponse) {
  return;
}

consola. og("Sponsored a trustline of", A.publicKey());

//
// 2. S1 y S2 patrocinan fideicomisos para la Cuenta A para diferentes activos.
//
let aAccount = await server. oadAccount(A.publicKey()).catch(accountFail);
let tx = new sdk.TransactionBuilder(acount, { fee: sdk.BASE_FEE })
  .addOperation(
    sdk.Operation. eginSponsoringFutureReserves({
      fuente: S1.publicKey(),
      sponsoredId: A. ublicKey(),
    }),
  )
  .addOperation(
    sdk. peration. hangeTrust({
      activos: activos[1],
      límite: "5000",
    }),
  )
  . ddOperación(sdk.Operación. ndSponsoringFutureReserves())

  .addOperation(
    sdk.Operation. eginSponsoringFutureReserves({
      fuente: S2.publicKey(),
      sponsoredId: A. ublicKey(),
    }),
  )
  .addOperation(
    sdk.Operation. hangeTrust({
      activo: activos[2],
      límite: "2500",
    }),
  )
  . ddOperación(sdk.Operation.endSponsoringFutureReserves())
  .setNetworkPassphrase(sdk.Networks.TESTNET)
  . etTimeout(180)
  .build();

// Observe que las 3 cuentas deben aprobar/firmar esta transacción.
tx.sign(S1, S2, A);
let txResponse = await server. ubmitTransaction(tx).catch(txCheck);
if (!txResponse) {
  return;
}

console.log("Patrocinó dos trustlines of", A.publicKey());
```

```go
    //
    // 1. S1 will sponsor a trustline for Account A.
    //
    sponsorTrustline := []txnbuild.Operation{
        &txnbuild.BeginSponsoringFutureReserves{
            SourceAccount: s1Account.AccountID,
            SponsoredID:   addressA,
        },
        &txnbuild.ChangeTrust{
            Line:  &assets[0],
            Limit: txnbuild.MaxTrustlineLimit,
        },
        &txnbuild.EndSponsoringFutureReserves{},
    }

    // Note that while A can submit this transaction, both sign it.
    SignAndSend(client, aAccount.AccountID, []*keypair.Full{S1, A}, sponsorTrustline...)
    fmt.Println("Sponsored a trustline of", A.Address())

    //
    // 2. Both S1 and S2 sponsor trustlines for Account A for different assets.
    //
    sponsorTrustline = []txnbuild.Operation{
        &txnbuild.BeginSponsoringFutureReserves{
            SourceAccount: s1Account.AccountID,
            SponsoredID:   addressA,
        },
        &txnbuild.ChangeTrust{
            Line:          &assets[1],
            Limit:         txnbuild.MaxTrustlineLimit,
        },
        &txnbuild.EndSponsoringFutureReserves{},

        &txnbuild.BeginSponsoringFutureReserves{
            SourceAccount: s2Account.AccountID,
            SponsoredID:   addressA,
        },
        &txnbuild.ChangeTrust{
            Line:          &assets[2],
            Limit:         txnbuild.MaxTrustlineLimit,
        },
        &txnbuild.EndSponsoringFutureReserves{},
    }

    // Note that all 3 accounts must approve/sign this transaction.
    SignAndSend(client, aAccount.AccountID, []*keypair.Full{S1, S2, A}, sponsorTrustline...)
    fmt.Println("Sponsored two trustlines of", A.Address())
```

</CodeExample>

### 2. Transfiriendo patrocinio

Supongamos que ahora Signer 1 quiere transferir la responsabilidad de patrocinar reservas para la línea de confianza al patrocinador 2. Esto se consigue mediante la transferencia entre las operaciones `BEGIN/END_SPONSORING_FUTURE_RESERVES`. Ambos participantes deben firmar la transacción, aunque cualquiera puede enviarla.

Una manera intuitiva de pensar en una transferencia de patrocinio es que el propio acto de patrocinio está siendo patrocinado por una nueva cuenta. Es decir, el nuevo patrocinador asume las responsabilidades del antiguo patrocinador mediante el patrocinio de una revocación.

<CodeExample>

```js
//
// 3. Transferir el patrocinio de la segunda línea de confianza de B de S1 a S2.
//
let tx = new sdk. ransactionBuilder(s1Account, { fee: sdk.BASE_FEE })
  .addOperation(
    sdk.Operation.beginSponsoringFutureReserves({
      source: S2. ublicKey(),
      sponsoredId: S1. ublicKey(),
    }),
  )
  .addOperation(
    sdk.Operation. evokeTrustlineSponsorship({
      cuenta: A. ublicKey(),
      activo: activos[1]
    }),
  )
  . ddOperación(sdk.Operation.endSponsoringFutureReserves())
  .setNetworkPassphrase(sdk.Networks.TESTNET)
  .setTimeout(180)
  . uild();

// Observe que mientras que el viejo patrocinador *envía* la transacción, ambos patrocinan
// deben *aprobar* la transferencia.
tx.sign(S1, S2);
let txResponse = await server.submitTransaction(tx).catch(txCheck);
if (!txResponse) {
  return;
}

console.log("Transferred sponsorship for", A.publicKey());
```

```go
    //
    // 3. Transferir el patrocinio de la segunda línea de confianza de B de S1 a S2.
    //
    transferOps := []txnbuild. peration{
        &txnbuild. eginSponsoringFutureReserves{
            SourceAccount: s2Account. ccountID,
            SponsoredID: S1. ddress(),
        },
        &txnbuild. evokeSponsorship{
            SponsorshipType: txnbuild. evokeSponsorshipTypeTrustLine,
            Cuenta: &addressA,
            TrustLine: &txnbuild. rustLineID{
                cuenta: addressA,
                Activos: Activos[1]
            },
        },
        &txnbuild. ndSponsoringFutureReserves{},
    }

    // Observe que mientras el viejo patrocinador *envía* la transacción (en este caso),
    // ambos patrocinadores deben *aprobar* la transferencia.
    SignAndSend(cliente, s1Account.AccountID, []*keypair.Full{S1, S2}, transferOps...)
    fmt.Println("Transferred sponsorship for", A.Address())
```

</CodeExample>

En este punto, Signer 1 sólo patrocina el primer activo (codificado arbitrariamente como ABCD), mientras que Signer 2 patrocina los otros dos activos. (Recuerda que inicialmente el signer 1 también estaba patrocinando a EFGH.)

### 3. Revocación de patrocinio

Por último, podemos demostrar una completa revocación de patrocinios. A continuación, Signer 2 se elimina de toda responsabilidad sobre los dos fideicomisos de activos. Tenga en cuenta que la Cuenta A no está involucrada en absoluto, ya que la revocación debe ser ejecutable únicamente a discreción del patrocinador.

<CodeExample>

```js
  //
  // 4. S2 revoca completamente el apadrinamiento de las líneas de confianza de B.
  //
  let s2Account = await server. oadAccount(S2.publicKey()).catch(accountFail);
  let tx = new sdk. ransactionBuilder(s2Account, {fee: sdk.BASE_FEE})
    .addOperation(sdk.Operation.revokeTrustlineSponsorship({
      : A. ublicKey(),
      activo: activos[1],
    }))
    .addOperation(sdk.Operation. evokeTrustlineSponsorship({
      cuenta: A. ublicKey(),
      activo: activos[2],
    }))
    . etNetworkPassphrase(sdk.Networks.TESTNET)
    .setTimeout(180)
    . uild();

  tx.sign(S2);
  let txResponse = await server.submitTransaction(tx). atch(txCheck);
  if (!txResponse) { return; }

  console.log("sponsorship Revoked for", A.publicKey());
} // termina main()
```

```go
    //
    // 4. S2 revoca completamente el apadrinamiento de las líneas de confianza de B.
    //
    revokeOps := []txnbuild. peration{
        &txnbuild. evokeSponsorship{
            SponsorshipType: txnbuild. evokeSponsorshipTypeTrustLine,
            Cuenta: &addressA,
            TrustLine: &txnbuild. rustLineID{
                Cuenta: addressA,
                Activo: activos[1],
            },
        },
        &txnbuild. evokeSponsorship{
            SponsorshipType: txnbuild. evokeSponsorshipTypeTrustLine,
            cuenta: &addressA,
            TrustLine: &txnbuild. rustLineID{
                Cuenta: addressA,
                activos: activos[2],
            },
        },
    }

    SignAndSend(cliente, s2Account. ccountID, []*keypair.Full{S2}, revokeOps...)
    fmt.Println("Patrocinio Revocado para", A.Address())
} // termina main()
```

</CodeExample>

### Cuentas Fuente de Patrocinio

Cuando se trata de los campos SourceAccount del sándwich del patrocinio, es importante referirse a la sabiduría de [CAP-33](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0033.md#abstract):

> Esta relación es iniciada por `BeginSponsoringFutureReservesOp`, donde la cuenta de patrocinio es la cuenta de origen, y es terminada por `EndSponsoringFutureReserveOp`, donde la cuenta patrocinada es la cuenta de origen.

Dado que la cuenta de origen por defecto para el envío de la transacción cuando se omite, este campo necesita siempre ser definido para el `principio` o el `End`.

Por ejemplo, la siguiente es una expresión idéntica del anterior ejemplo de Golang de patrocinar una línea de confianza, sólo enviado por el patrocinador (patrocinador 1) en lugar de la cuenta patrocinada (cuenta A). Observe las diferencias en donde se establece `SourceAccount`:

<CodeExample>

```go
    sponsorTrustline := []txnbuild.Operation{
        &txnbuild. eginSponsoringFutureReserves{
            SponsoredID: addressA,
        },
        &txnbuild. hangeTrust{
            SourceAccount: aAccount. ccountID,
            Línea: &activos[0],
            Límite: txnbuild. axTrustlineLimit,
        },
        &txnbuild. ndSponsoringFutureReserves{
            SourceAccount: aAccount.AccountID,
        },
    }

    // Nuevamente, ambos participantes deben seguir firmando la transacción: la cuenta
    // auspiciada debe consentir el patrocinio.
    SignAndSend(cliente, s1Account.AccountID, []*keypair.Full{S1, A}, sponsorTrustline...)
```

</CodeExample>

### Otros ejemplos

Si te gustaría otros ejemplos o quieres ver un desglose de pseudo-código más genérico de estos escenarios de patrocinio, puedes referirte a [CAP-0033](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0033.md#example-revoke-sponsorship) directamente.

### Nota al pie

Para los ejemplos anteriores, una implementación de SignAndSend (Golang) y algunos (muy) rudimentarios errores comprobando código (todos los idiomas) podrían verse algo como esto:

<CodeExample>

```js
function txCheck(err) {
  console.error("Envío de transacción falló:", err);
  if (err. esponse != null && err.response.data != null) {
    console.error("Más detalles:", err.response.data. xtras);
  } else {
    consola. rror("Razón desconocida:", err);
  }
}

function accountFail(err) {
  consola. rror(" Error al cargar la cuenta:", err.response.body);
}
```

```go
// Construye una transacción que contiene `operations...`, firmada (por `signers`), y
// enviada usando el `client` dado en nombre de `account`.
func SignAndSend(
    cliente *sdk. lient,
    account txnbuild.Account,
    signners []*keypair.Full,
    operaciones ...txnbuild.Operation,
). ransaction {
    // Construir, firmar y enviar la transacción
    tx, err := txnbuild. ewTransaction(
        txnbuild. ransactionParams{
            SourceAccount: account,
            IncrementSequenceNum: verdadero,
            BaseFee: txnbuild. en la tarifa base,
            Límites de tiempo: txnbuild. ewInfiniteTimeout(),
            Operaciones: operaciones,
        },
    )
    check(err)

    para _, signer := range signners {
        tx, err = tx. ign(red. contraseña de red firmante)
        check(err)
    }

    txResp, err := cliente. ubmitTransaction(tx)
    if err != nil {
        if prob := sdk. etError(err); prob != nil {
            fmt. rintf(" problema: %s\n", prob. roblem.Detail)
            fmt.Printf(" extras: %s\n", prob.Problem. xtras["result_codes"])
        }
        check(err)
    }

    return txResp
}

func check(err error) {
    if err ! nil {
        pánico (err)
    }
}
```

</CodeExample>

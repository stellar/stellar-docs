---
title: Pagos por Ruta
sidebar_position: 60
---

import { CodeExample } from "@site/src/components/CodeExample";

En un pago por ruta, el activo recibido difiere del activo enviado. En lugar de que la operación transfiera activos directamente de una cuenta a otra, los pagos por ruta atraviesan el SDEX y/o fondos de liquidez antes de llegar a la cuenta de destino. Para que el pago por ruta tenga éxito, debe existir una oferta DEX o un camino de intercambio de fondos de liquidez. A veces puede tomar varias conversiones para tener éxito.

Por ejemplo:

La Cuenta A vende XLM → [comprar XLM / vender ETH → comprar ETH / vender BTC → comprar BTC / vender USDC] → La Cuenta B recibe USDC

Es posible que los pagos por ruta fallen si no existen caminos de intercambio viables.

Para más información sobre el Stellar Decentralized Exchange y los Fondos de Liquidez, consulta nuestra [Entrada de Enciclopedia sobre Liquidez en Stellar: SDEX y Fondos de Liquidez](../sdex/liquidity-on-stellar-sdex-liquidity-pools.mdx)

## Operaciones

Los pagos por ruta utilizan las operaciones de Envío Estricto de Pago por Ruta o Recepción Estricta de Pago por Ruta.

### Envío Estricto de Pago por Ruta

Permite a un usuario especificar la cantidad del activo a enviar. La cantidad recibida variará según las ofertas en los libros de órdenes y/o fondos de liquidez.

### Recepción Estricta de Pago por Ruta

Permite a un usuario especificar la cantidad del activo recibido. La cantidad enviada variará según las ofertas en los libros de órdenes/fondos de liquidez.

## Pagos por Ruta - más información

- Los pagos por ruta no permiten que las ofertas intermedias provengan de la cuenta de origen ya que esto resultaría en un peor tipo de cambio. Deberás dividir el pago por ruta en dos pagos por ruta más pequeños o asegurarte de que las ofertas de la cuenta de origen no estén en la parte superior del libro de órdenes.
- Los saldos se liquidan al final de la operación.
  - Esto es especialmente importante cuando (`Destino, Activo de Destino) == (Origen, Activo a Enviar`) ya que esto proporciona una funcionalidad equivalente a obtener un préstamo sin interés durante la duración de la operación.
- `Destino mínimo` es una medida protectora, permite especificar un límite inferior para una conversión aceptable. Si las ofertas en los libros de órdenes no son lo suficientemente favorables para que la operación entregue esa cantidad, la operación fallará.

## Ejemplo

Primero, asegúrate de que el receptor tenga una trustline establecida para el activo que recibirá. En este ejemplo, usaremos USDC como el activo recibido. El emisor enviará XLM, que se convertirá a USDC a través de la operación de pago por rutas.

<CodeExample>

```js
import {
  Horizon,
  Asset,
  Keypair,
  TransactionBuilder,
  Networks,
  BASE_FEE,
  Operation,
  Memo,
} from "@stellar/stellar-sdk";

const USDC_ISSUER = "GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5"; // USDC issuer on Stellar Testnet
const USDC_ASSET = new Asset("USDC", USDC_ISSUER); // USDC asset on Stellar Testnet
const RECEIVER_SECRET = "S..."; // Receiver's secret key

const SENDER_SECRET = "S..."; // Sender's secret key
const horizonServer = new Horizon.Server("https://horizon-testnet.stellar.org");

// Create a USDC trustline for the receiver
const receiverKP = Keypair.fromSecret(RECEIVER_SECRET);
let account = await horizonServer.loadAccount(receiverKP.publicKey());
let transaction = new TransactionBuilder(account, {
  fee: BASE_FEE * 100,
  networkPassphrase: Networks.TESTNET,
})
  .addOperation(
    Operation.changeTrust({
      asset: USDC_ASSET,
      limit: "10",
    }),
  )
  .addMemo(Memo.text("Trusting USDC"))
  .setTimeout(30)
  .build();

transaction.sign(receiverKP);
const resp = await SERVER.submitTransaction(transaction);
console.log("resp", resp);
```

</CodeExample>

Ahora enviemos un pago por rutas del emisor al receptor, convirtiendo XLM a USDC.

<CodeExample>

```js
// Use path payment to send XLM from the receiver to the sender, who receives USDC
let senderKP = Keypair.fromSecret(SENDER_SECRET);
let account = await horizonServer.loadAccount(senderKP.publicKey());
let transaction = new TransactionBuilder(account, {
  fee: BASE_FEE * 100,
  networkPassphrase: Networks.TESTNET,
})
  .addOperation(
    Operation.pathPaymentStrictReceive({
      sendAsset: Asset.native(), // Sending XLM
      sendMax: "10", // Maximum amount of XLM to send
      destAsset: USDC_ASSET, // Receiving USDC
      destAmount: "1", // Amount of USDC to receive
      destination: receiverKP.publicKey(), // Receiver's public key
    }),
  )
  .addMemo(Memo.text("XLM to USDC"))
  .setTimeout(30)
  .build();

transaction.sign(senderKP);
const resp = await horizonServer.submitTransaction(transaction);
console.log("resp", resp);
```

</CodeExample>

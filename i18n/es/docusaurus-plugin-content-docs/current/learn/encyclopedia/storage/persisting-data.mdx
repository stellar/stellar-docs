---
sidebar_position: 10
title: Datos persistentes
description: Almacenar y acceder a los datos de contratos inteligentes.
---

<head>
  <title>Almacena y accede a los datos del contrato inteligente.</title>
  <meta charSet="utf-8" />
  <meta property="og:title" content="Almacena y accede a los datos del contrato inteligente." />
  <meta
    property="og:description"
    content="Almacena y accede a los datos inteligentes del contrato."
  />
</head>

## Entradas Ledger

Los contratos pueden acceder a entradas del libro de contadores del tipo `CONTRACT_DATA`. Las funciones de host se proporcionan para sondear, leer, escribir y borrar entradas del libro `CONTRACT_DATA`.

Cada entrada `CONTRACT_DATA` del libro de valores está clavada en el libro de valores por el ID del contrato que lo posee, su tipo de almacenamiento (`Persistent`, `Temporary`, `Instance`) así como un único valor elegido por el usuario, del tipo de valor estándar. Esto significa que la clave elegida por el usuario puede ser un valor simple como un músico, número o blob, o puede ser un valor estructurado más complejo como un vector o un mapa con múltiples subvalores.

Cada entrada del ledger `CONTRACT_DATA` también contiene (además de su clave) un único valor asociado con la clave. De nuevo, este valor puede ser simple como un símbolo o número, o puede ser complejo como un vector o un mapa con muchos subvalores.

No se requiere ninguna serialización o deserialización en el código del contrato al acceder a las entradas del libro principal `CONTRACT_DATA`: el host automáticamente serializa y deserializa cualquier entrada del libro de rendimiento, intercambiándolas con el contrato como valores deserializados. Si un contrato desea utilizar un formato de serialización personalizado, puede almacenar una entrada 'CONTRACT_DATA' con valor binario y proporcionar su propio código para serializar y deserializar, pero Soroban ha sido diseñado con la intención de minimizar la necesidad de contratos para hacer esto.

## Control de acceso

Los contratos sólo están permitidos para leer y escribir entradas del libro de valores `CONTRACT_DATA` propiedad del contrato: aquellas con el mismo ID del contrato que el contrato que realiza la lectura o escritura. Intentar acceder a otras entradas del ledger `CONTRACT_DATA` causará que una transacción falle.

No hay control de acceso para las operaciones de extensión TTL. Cualquier usuario puede invocar `ExtendFootprintTTLOp` en cualquier LedgerEntry.

## Granularidad

Una entrada `CONTRACT_DATA` es leída o escrita desde el libro de valores en su totalidad; no hay forma de leer o escribir "sólo una parte" de una entrada del libro de datos `CONTRACT_DATA`. También hay un coste fijo de sobrecarga para acceder a cualquier entrada del libro de `CONTRACT_DATA`. Por lo tanto, los contratos son responsables de dividir las estructuras de datos lógicamente "grandes" en "piezas" con una granularidad de tamaño apropiada, para su uso en lectura y escritura. Si las piezas son demasiado grandes, puede haber costes innecesarios pagados por leer y escribir datos no utilizados, así como contenciones innecesarias en la ejecución paralela; pero si las piezas son demasiado pequeñas puede haber costes innecesarios pagados por la sobrecarga fija de cada entrada.

## Huellas digitales y contención paralela

Los contratos sólo pueden acceder a las entradas del contador especificadas en la huella de su transacción. Se dice que las transacciones con huellas superpuestas contenen, y sólo se ejecutarán secuencialmente con respecto a las demás, en un solo hilo. Las transacciones con huellas no superpuestas pueden ejecutarse en paralelo. Esto significa que una granularidad más fina de las entradas del libro de contabilidad 'CONTRACT_DATA' puede reducir la contención artificial entre las transacciones que utilizan un contrato, y por lo tanto aumentar el paralelismo.

## Mejores prácticas de Contrato de Datos

### Estado de cuenta vs. Estado compartido

Aunque no hay distinción entre el estado de "cuenta" y el estado "compartido" en el nivel de protocolo, puede ser útil pensar en datos en estos términos a la hora de decidir qué tipo de almacenamiento y estrategia de extensión TTL a usar para un caso determinado. Como pauta, la cuenta y el estado compartido pueden describirse de la siguiente manera:

- La mayoría de los estados del contrato pueden ser asociados con una cuenta específica o compartidos entre múltiples partes interesadas ("bien público")
  - Estado específico de la cuenta
    - Saldos, posiciones, permisos, etc.
  - Estado compartido
    - Entrada de administrador, valores del billar, etc.
- Hay dos subcategorías de estado compartido
  - Estado "Global" compartido por todos los usuarios del contrato
    - Ejemplo de contrato, lavado de contratos, o un administrador global
  - Estado compartido por sólo un subconjunto específico de usuarios
    - Valores de reserva AMM En un contrato de monolito AMM (estilo Uniswap V4)
- Nota: A veces la cuenta y el estado compartido pueden fusionarse cuando el alcance del contrato es pequeño
  - Es decir. monedero inteligente o un solo pasillo, donde se genera una nueva instancia de contrato para cada cuenta

### Contratos poseidos vs. Contratos Autonómicos

Además de los tipos de estado, también es útil considerar el tipo de instancia del contrato que se está utilizando. De nuevo, estos tipos no se aplican a nivel de protocolo, pero pueden ser útiles.

- Contratos poseídos
  - Contraer instancias que tienen un propietario claro
    - Una cartera inteligente o un solo pasillo, donde se genera una nueva instancia de contrato para cada cuenta
    - Activos respaldados de reserva personalizada (USDC, etc.)
- Contratos autonómicos
  - Instancia de contrato que no tienen claro el propietario, o que tienen un grupo descentralizado de propietarios
    - La mayoría de los protocolos, especialmente los no actualizables

### Mejores prácticas

- Preferir el almacenamiento `Temporary` sobre `Persistent` y `Instance`
  - Cualquier cosa que pueda tener un tiempo de espera debe ser `Temporary` con TTL establecido en el tiempo de espera. Vea la [tabla de límites de recursos](../../networks/resource-limits-fees.mdx) para el máximo TTL/timeout actual.
  - Idealmente, las entradas `Temporary` deben estar asociadas con un límite absoluto de ledger y por lo tanto nunca necesitan una extensión TTL
    - Ejemplo: Las firmas Soroban Auth tienen un contador de expiración absoluto, por lo que no se pueden almacenar en entradas `Temporary` sin riesgos de seguridad
    - Ejemplo: franquicia SAC que vive sólo hasta que un contador determinado (de modo que alguna antigua firma de franquicia no se puede utilizar en el futuro si no se agota)
- Todo el estado global que no puede ser `Temporary` debe estar en almacenamiento `Instance`
  - Esto garantiza que la TTL de la instancia del contrato y todos los globales relevantes estén unidos
  - Dado que el estado global se utiliza con frecuencia, esto garantiza que nunca será necesario restaurar el estado global, lo que conducirá a invocaciones contractuales más baratas y eficientes.
- Los contratos automáticos deben extender la TTL de cualquier estado compartido tocado por una invocación a través de la función de host `extend_ttl()`
  - Dado que estos contratos no tienen propietarios, dejar las extensiones de TTL a clientes benevolentes podría conducir a una “tragedia de los comunes” situación
  - La mayoría de los usuarios no extienden el TTL porque no es necesario, pero aún así se benefician del cliente benevolente que extiende el TTL
- Los propietarios de contratos de propiedad deberían subsidiar las tarifas de extensión TTL estatales compartidas enviando manualmente las operaciones de ampliación
  - Los propietarios deben llevar un seguimiento de TTLs para todo el estado compartido
  - Esto podría implementarse a través de algo como un trabajo de cron donde un `ExtendFootprintTTLOp` para todo el estado compartido relevante se envía periódicamente (es decir, una vez al mes)
  - Alternativamente, esto también podría implementarse a través de una función de contrato inteligente de administración llamada rutinariamente por el propietario
- Los clientes (Wallets/Dapps) deben identificar el estado que se relaciona con su respectiva cuenta, presentar información TTL a los usuarios, y sugerir extensiones TTTL cuando sea necesario
- Las extensiones TTL nunca deben ser confiadas por funcionalidad o seguridad
  - Ejemplo inseguro: Una entrada debe ser permanente, pero en lugar de usar almacenamiento `Persistent`, un contrato utiliza almacenamiento 'Temporario' pero continuará extendiendo la entrada para que siempre esté en vivo
    - Debido a que no hay una interfaz de extensión TTL automática, y cada extensión TTL debe provenir de una invocación inteligente del contrato o de `ExtendFootprintTTTLOp`, debe asumirse que el TTL de una entrada puede ir a 0 y la entrada será eliminada
    - Las extensiones TTL son variables, y puede llegar a ser demasiado caro extender la TTL de pseudo-entradas "persistentes" 'Temporario' si las tarifas aumentan inesperadamente
    - Si el proceso de extensión TTL es automatizado (i.e. un trabajo cron) la cuenta automáticamente enviando `ExtendFootprintTTLOps` puede quedarse sin fondos inesperadamente en caso de que las extensiones TTL aumenten, haciendo que la entrada `Temporary` escape su TTL y sea eliminada permanentemente
- El agotamiento de la entrada TTL nunca debe ser confiado por funcionalidad o seguridad
  - Ejemplo inseguro: un nonce debe expirar en 7 días, para que un contrato cree una entrada 'Temporario' y amplíe la TTL a 7 días sin ninguna otra aplicación de por vida.
  - Cualquiera puede enviar una operación de extensión TTL en cualquier entrada sin autorización, lo que significa que el nonce puede tener su TTL extendido indefinidamente por cualquier usuario
  - Si una entrada necesita ser invalidada después de un cierto período de tiempo, esto debe ser implementado manualmente por el contrato

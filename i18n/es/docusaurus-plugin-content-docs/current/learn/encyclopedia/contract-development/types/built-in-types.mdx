---
sidebar_position: 10
title: Tipos incorporados
description: Tipos integrados utilizados como entradas inteligentes y salidas de contratos.
---

Tipos integrados <head>
  <title>utilizados como entradas y salidas inteligentes del contrato.</title>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="Tipos incorporados utilizados como entradas inteligentes y salidas."
  />
  <meta
    property="og:description"
    content="Aprende sobre los tipos integrados que están disponibles en los contratos inteligentes de Soroban, incluyendo tipos primitivos, símbolos, bytes, cadenas, vecs, mapas y direcciones."
  />
</head>

Los tipos integrados están disponibles para todos los contratos para su uso como entradas y salidas de funciones del contrato y son definidos por el [environment] y el [SDK de Rust].

[ambiente]: ../environment-concepts.mdx
[polvo sdk]: ../../../../tools/sdks/library.mdx#soroban-rust-sdk

:::tip

También se apoyan los tipos de costumbres como las estructuras, los enums y los sindicatos. Ver [Tipos personalizados]. [Tipos personalizados]\: custom-types.mdx

:::

## Tipos primitivos

Se admiten los siguientes tipos primitivos:

### Entero sin signo de 32 bits (`u32`)

### Entero firmado de 32 bits (`i32`)

### Entero sin signo de 64 bits (`u64`)

### Entero firmado de 64 bits (`i64`)

### Entero sin signo de 128-bit (`u128`)

### Entero firmado de 128-bit (`i128`)

### Librería (`bool`)

## Símbolo (`Symbol`)

Los Symbols son pequeñas cadenas eficientes de hasta 32 caracteres de longitud y se limitan a `a-z` `A-Z` `0-9` que están codificadas en enteros de 64 bits.

Los Symbols se utilizan principalmente para nombres de funciones y otros identificadores que se exportan en la API pública de un contrato. También pueden utilizarse allí donde se necesiten cuerdas cortas para reducir los costos de los recursos.

## Bytes, Cadenas (`Bytes`, `BytesN`)

Los arreglos y cadenas de caracteres pueden pasarse a contratos y almacenes utilizando el tipo `Bytes`.

Para arreglos de bytes de longitud fija, `BytesN` puede ser usado. Por ejemplo, los IDs del contrato son arreglados arreglos de 32 bytes y se representan como `BytesN<32>`.

## Vec (`Vec`)

Vec es un tipo de colección secuencial e indexable.

Los valores se almacenan en el entorno y están disponibles para contratar a través de las funciones definidas en Vec. Los valores almacenados en el Vec se transmiten al medio ambiente como RawVals, y cuando se recuperan del Vec se transmiten de vuelta y se convierten de RawVal de nuevo a su tipo.

Los valores en un Vec no están garantizados de ser de ningún tipo específico y la conversión fallará si no son del tipo esperado. La mayoría de las funciones en Vec devuelven un Resultado debido a esto.

## Mapa (`Map`)

El mapa es un diccionario clave-valor ordenado.

El mapa está ordenado por sus llaves. Iterar un mapa es estable y siempre devuelve las claves y valores en orden de las llaves.

El mapa se almacena en el host y está disponible para el huésped a través de las funciones definidas en el mapa. Los valores almacenados en el Mapa se transmiten al Host como RawVals, y cuando se recupera del Mapa se transmiten de vuelta y se convierten de RawVal de nuevo a su tipo.

Las claves y valores de un Mapa no están garantizados de ser de tipo K/V y la conversión fallará si no lo están. La mayoría de las funciones en Mapa devuelven un Resultado debido a esto.

Los mapas tienen como máximo una entrada por clave. Establecer un valor para una clave en el mapa que ya tiene un valor para esa clave reemplaza el valor.

## Dirección (`Dirección`)

La dirección es un identificador opaco universal a usar en los contratos. Puede representar una cuenta estelar "clásica", una cuenta personalizada implementada en Soroban o simplemente un contrato arbitrario.

La dirección puede utilizarse como argumento de entrada de la función de contrato (por ejemplo, para identificar al destinatario del pago), como clave de datos (por ejemplo, para almacenar el saldo), como fuente de autenticación y autorización (por ejemplo, para autorizar una transferencia de tokens) etc.

Vea [documentación de autorización](../../security/authorization.mdx) para más detalles sobre cómo usar el tipo `Address`.

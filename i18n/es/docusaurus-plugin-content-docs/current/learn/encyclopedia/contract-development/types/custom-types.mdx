---
sidebar_position: 20
title: Tipos personalizados
description: Tipos estructurales, uniones y enum definidos por contratos.
---

<head>
  <title>Tipos de estructura, unión y enum definidos por contratos.</title>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="Estructura, unión, y enum tipos definidos por contratos".
  />
  <meta
    property="og:description"
    content="Ver los tipos de estructura, unión y enum que se pueden utilizar como entradas de contrato, salidas de contratos o para almacenamiento."
  />
</head>

Los tipos personalizados son tipos de estructura, unión y enum definidos por contratos. Se pueden utilizar en cualquier lugar donde se puedan utilizar primitivos: como entradas de contrato, salidas o para almacenamiento.

:::info

El [ejemplo de tipos personalizados] demuestra cómo definir sus propios tipos.

[ejemplo de tipos personalizados]: ../../../../build/smart-contracts/example-contracts/custom-types.mdx

:::

:::info

Los tipos de número de error son otro tipo de contratos pueden definir que tienen algunos comportamientos únicos. Vea [Errors](../../errors-and-debugging/errors.mdx) para más información.

:::

## Estructuras (con nombres de campos)

Las estructuras con campos nombrados se almacenan en el libro de contabilidad como un mapa de pares clave-valor, donde la clave es una cadena de 32 caracteres que representa el nombre del campo, y el valor es el valor codificado.

Los nombres de campo no deben tener más de 32 caracteres. Los campos con nombres de no más de 9 caracteres son ligeramente más eficientes en tiempo de ejecución, aunque la diferencia debe ser la mayor parte del tiempo.

```rust
#[contracttype]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct State {
    pub count: u32,
    pub last_incr: u32,
}
```

Cuando se convierte a XDR, el valor se convierte en un `ScVal`, que contiene un `ScMap`, que contiene un array de pares clave-valor.

```json
{
  "map": [
    { "key": { "symbol": "count" }, "val": { "u32": 0 } },
    { "key": { "symbol": "last_incr" }, "val": { "u32": 0 } }
  ]
}
```

## Estructuras (con campos sin nombre)

Las estructuras con campos sin nombre se almacenan en el contador como un vector de valores, y son intercambiables con tubos y vectores. Los elementos se colocan en el vector para que aparezcan en la lista de campos.

```rust
#[contracttype]
#[derive(Clone, Debug, Eq, ParcialEq)]
pub struct State(pub u32, pub u32);
```

Cuando se convierte a XDR, el valor se convierte en un `ScVal`, que contiene un `ScVec`, que contiene un array de valores.

```json
{ "vec": [{ "u32": 0 }, { "u32": 0 }] }
```

## Enum (Unidad y Tuple Variantes)

Los números que contienen la unidad y las variantes de tubos se almacenan en el libro de valores como un vector de dos elementos, donde el primer elemento es el nombre de la variante enum como una cadena de hasta 32 caracteres de longitud, y el valor es el valor si la variante tiene una.

Sólo se admiten variantes unitarias y variantes tuples, como `A` y `B`.

```rust
#[contracttype]
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum Enum {
    A,
    B(u32),
}
```

Cuando una variante de unidad, como `Enum::A`, se convierte en XDR, el valor se convierte en un `ScVal`, que contiene un `ScVec`, que contiene una matriz con un único valor, el símbolo que contiene el nombre de la variante.

```json
{ "vec": [{ "symbol": "A" }] }
```

Cuando una variante tuple, como `Enum::B`, es convertida a XDR, el valor se convierte en un `ScVal`, que contiene un `ScVec`, que contiene una matriz con dos valores, el símbolo que contiene el nombre de la variante y el valor de la tupla.

```json
{ "vec": [{ "symbol": "B" }, { "u32": 0 }] }
```

Cuando se implementan variantes tuples que contienen valores múltiples, los valores se incluirán en el vector.

## Enum (variantes enteras)

Los números que contienen valores enteros se almacenan en el libro de valores como el valor `u32`.

```rust
#[contracttype]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
#[repr(u32)]
pub enum Enum {
    A = 1,
    B = 2,
}
```

Cuando se convierte a XDR, el valor se convierte en un `ScVal`, que contiene un `U32`.

```json
{ "u32": 1 }
```

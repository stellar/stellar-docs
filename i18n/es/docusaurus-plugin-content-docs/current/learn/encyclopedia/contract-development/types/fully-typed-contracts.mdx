---
sidebar_position: 30
title: Contratos de tipo completo
desctiption: Los archivos WASM de contrato inteligente contienen una descripción legible de la máquina del tipo de interfaz.
sidebar_label: Contratos de tipo completo
---

<head>
  <title>
    {`Smart contract WASM files contienen una descripción legible de la máquina del tipo de interfaz
    . }
  </title>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="Smart contract WASM files contain a machine-readable description of the interface type."
  />
  <meta
    property="og:description"
    content="Todos los tipos de interfaz de contrato inteligente estarán disponibles inmediatamente en cadena sin llamadas API secundarias a servicios externos, no hay gestión secundaria de API, y más."
  />
</head>

Cuando compile un contrato creado con [soroban-sdk](../../../../tools/sdks/library.mdx#soroban-rust-sdk), el archivo Wasm termina con una [sección personalizada](https://webassembly.github.io/spec/core/appendix/custom. tml) que contiene una descripción legible por maquinaria de los tipos de interfaz de tu contrato, a veces llamada su [spec](https://github.com/stellar/rs-soroban-sdk/tree/main/soroban-spec) o su [API](https://github.com/stellar/soroban-docs/pull/381#issuecomment-1507283476). Esto es similar a [ABIs](https://www.quicknode. om/guías/ethereum-development/smart-contracts/what-is-an-abi/) en Ethereum, excepto que Soroban almacenará cada uno de ellos en cadena desde el primer día e incluirá los comentarios del autor del contrato.

Hoy, estos tipos de interfaz están formateados usando [XDR](../../data-format/xdr.mdx), pero este [puede cambiar](https://github.com/stellar/rs-soroban-sdk/issues/683) por el camino.

La parte importante es que las herramientas pueden obtener estos tipos de interfaces para hacer su vida más fácil. [CLI Stellar](../../../tools/developer-tools/README.mdx#cli) es la primera herramienta para hacerlo. Específicamente, un subcomando:

## `invoca un contrato estelar`

Realmente, cada contrato inteligente es su propio programa y merece su propio CLI.

Así que eso es lo que Stellar CLI te da.

Un CLI único para cada contrato inteligente. Construido sobre la marcha, a partir de los tipos de interfaz en cadena. Incluye los comentarios del autor. Una _implícita CLI_.

Con alias en su shell, también puede hacer fácilmente CLIs explícitas de sus contratos más utilizados. Por ejemplo, si utiliza el contrato de activos nativos en la red de pruebas:

```bash
$ alias native="soroban contract invoke --network testnet --id CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQQVU2HHGCYSC --"
$ native --help
Usage: CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQVU2HHGCYSC [COMMAND]

Commands:
  balance Devuelve el saldo de `id`.

                      # Argumentos

                      * `id` - La dirección para la que se está consultando un saldo. Si la dirección
                      no tiene saldo existente, devuelve 0.
  ...
  transfiere `monto` de `de` a `hacia`.

                      # Argumentos

                      * `de` - La dirección que mantiene el saldo de las fichas que serán
                      retiradas.
                      * `a` - La dirección que recibirá las fichas transferidas.
                      * `amount` - La cantidad de tokens a transferir.

                      # Eventos

                      Emite un evento con temas `["transfer", desde: Dirección, a: Dirección],
                      datos = [monto: i128]`
  . .

Opciones:
  -h, --help Imprimir ayuda
```

Como cualquier otro CLI, también puede obtener ayuda para cualquiera de estos subcomandos usando algo como `native balance --help`. CLI estelar vuelve a obtener los tipos de interfaz en cadena, esta vez usándolo para generar una lista completa de todos los argumentos a la función, e incluso genera ejemplos.

:::tip

Y para ser totalmente claro, no es necesario alias de estos comandos. Esto también funcionaría:

```bash
soroban contrato invocar --network testnet --id CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQQVU2HHGCYSC -- balance --help
```

:::

Si no estás familiarizado con el separador de doble guión `--`, este es un patrón usado por otras CLIs. Todo después del doble guión, a veces llamado [slop](https://github.com/clap-rs/clap/issues/971), se pasa al proceso secundario. Un ejemplo de otro CLI que hace uso de esto es `cargo run`.

Por supuesto, la manera exacta en que Stellar CLI analiza los argumentos es una discusión de diseño en curso. Representar argumentos personalizados complejos en la línea de comandos es un desafío de diseño que ningún blockchain CLI todavía se hace perfecto; muchos, incluyendo Stellar CLI, actualmente usan JSON. Pero esto tiene desventajas, y otras opciones son posibles. [¿Cómo te gustaría ver que funciona?](https://docs.google.com/document/d/1LASaLyxIA2-YqLn2NqI5NZGnEmdzx9lLh-j7n0-i4A/edit#)

## Ya es el mejor; sólo empezando

Nos encanta que Soroban tenga todos los tipos de interfaces de contrato disponibles en la cadena desde el primer día. No hay llamadas secundarias de API a servicios externos, no hay administración secundaria de tokens, no hay inicio de sesión o creación de una cuenta en ningún otro lugar, y una fiabilidad casi perfecta. Es un cambiador de juego dentro del espacio de la cadena de bloques.

Stellar CLI ya muestra cómo esto se puede incorporar en herramientas fundacionales para dar a los desarrolladores experiencias deliciosas. Y esto es sólo el principio. En cada nivel de la pila, puedes esperar —y [build](https://stellar.org/foundation/grants-and-funding)—herramientas que hacen que interactuar con cualquier contrato predecible y sin costuras.

Pronto tendremos librerías TypeScript/JavaScript que reflejan el comportamiento de `soroban contract invoke`, personalizadas para entornos de navegador y nodejs. Puede esperar que GUI se adapte a cualquier contrato al vuelo, funcionando como documentación interactiva. Si está escribiendo contratos que hacen llamadas entre contratos, la mayoría del código que necesita también puede ser generado automáticamente.

Y eso es sólo el comienzo. Con estos como fundamentos, ¿qué más podemos construir? ¿Qué más puedes imaginar? ¿Cuál es el futuro de los componentes, ahora que un pequeño programa, conocido como contrato inteligente, se puede interactuar fácilmente con todas las capas de la pila de software? Cuando se considera en combinación con Wasm—on-chain, in-browser, y [elsewhere](https://en.wikipedia.org/wiki/WebAssembly#Implementations)—¿qué posibilidades de interop podemos imaginar y cocrear?

No podemos esperar a ver lo que construyes.

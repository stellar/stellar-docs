---
sidebar_position: 40
title: Eventos
description: Controlar los cambios de contrato inteligente fuera de la cadena.
---

<head>
  <title>Monitorear los cambios de contrato inteligente fuera de cadena.</title>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="Monitorear cambios de contrato inteligente fuera de cadena."
  />
  <meta
    property="og:description"
    content="Aprende sobre el mecanismo que las aplicaciones fuera de cadena pueden usar para monitorear los cambios y eventos en los contratos inteligentes que están en cadena."
  />
</head>

Los eventos son el mecanismo que las aplicaciones fuera de la cadena pueden utilizar para monitorear los cambios y eventos en los contratos en cadena.

## ¿Cómo se emiten los eventos?

`ContractEvents` son emitidos en la `TransactionMeta` de Stellar Core. Puedes ver en la [TransactionMetaV3] XDR abajo que hay una lista de `OperationEvents` llamado `events`. Cada 'OperationEvent' corresponde a una operación en una transacción, y contiene una lista de 'ContractEvents'. Ten en cuenta que los `events` sólo serán poblados si la transacción tiene éxito. Echa un vistazo a las [guías de eventos](../../build/guides/events/README.mdx) y [este ejemplo](../../build/smart-contracts/example-contracts/events.mdx) para aprender más sobre cómo trabajar con eventos.

:::info

Los eventos son efímeros, la ventana de retención de datos es de aproximadamente 24 horas. Vea la [guía de ingestión](../../../build/guides/events/ingest.mdx) para aprender cómo trabajar con esta restricción.

:::

[transactionmetav3]: #transactionmetav3

### Evento de contrato

Un evento puede contener hasta cuatro temas. Los temas no tienen que estar hechos del mismo tipo. Puede mezclar diferentes tipos siempre y cuando el número total de temas permanezca por debajo del límite.

Un evento también contiene un objeto de datos de cualquier valor o tipo incluyendo tipos definidos por contratos usando `#[contracttype]`

```cpp
struct ContractEvent
{
    // Podemos usar esto para añadir más campos, o porque
    // es el primero, para cambiar ContractEvent a una unión.
    Extensión Punto ext;

    Hash* contractID;
    ContractEventType type;

    union switch (int v)
    {
    case 0:
        struct
        {
            SCVec topics;
            datos de SCVal;
        } v0;
    }
    cuerpo;
};
```

### Eventos Operativos

```cpp
Construye OperationEvents
{
    Eventos de ContractEvento<>;
};
```

### TransacciónMetaV3

```cpp
struct TransactionMetaV3
{
    LedgerEntryChanges txChangesBefore; // el nivel de tx cambia antes de las operaciones
                                        // se aplican si hay alguna operación
    OperationMeta<>; // meta para cada operación
    LedgerEntryChanges txChangesAfter; // los cambios de nivel de tx después de las operaciones son
                                        // aplicados si hay
    eventos de OperationEventes<>; // eventos personalizados poblados por el
                                        // se contrata a sí mismos. Una lista por operación.
    TransactionResult txResult;

    Hash hasks[3]; // almacena sha256(txChangesBefore, operations, txChangesAfter),
                                        // sha256(events), y sha256(txResult)

    // Diagnósticos eventos que no son hashed. Una lista por operación.
    // Esto contendrá todos los eventos de contrato y diagnóstico. Incluso las
    // que fueron emitidas en una llamada de contrato fallida.
    OperationDiagnosticEvents diagnósticos<>;
};
```

[Link](https://github.com/stellar/stellar-xdr/blob/eab1622f18b8101aa0cea76361c08beaeaa8d715/Stellar-ledger.x#L444) al XDR anterior.

### Tipos de eventos

Hay tres 'ContractEventType' -

1. Los eventos `CONTRACT` son eventos emitidos por contratos que usan la función de host `contract_event` para transmitir cambios de estado.
2. Los eventos `SYSTEM` son eventos emitidos por el anfitrión. Por el momento, sólo hay un evento del sistema emitido por el anfitrión. Se emite cuando se llama a la función host `update_current_contract_wasm`, donde `topics = ["executable_update", old_executable: ContractExecutable, old_executable: ContractExecutable]` y `data = []`.
3. Los eventos `DIAGNOSTIC` están destinados a la depuración y no serán emitidos a menos que la instancia del host lo habilite explicativamente. Puede leer más sobre esto a continuación.

## ¿Qué son los diagnósticos?

Mientras observas la estructura XDR `TransactionMetaV3` anterior, puede que hayas notado el campo `diagnosticEvents`. Esta lista estará vacía por defecto a menos que tu instancia stellar-core tenga `ENABLE_SOROBAN_DIAGNOSTIC_EVENTS=true` en su archivo de configuración. Si los eventos de diagnóstico están habilitados, esta lista no solo incluirá todos los ContractEvents en `events`, sino que también incluirá eventos de llamadas de contrato fallidas, desde el host, eventos para rastrear la pila de llamadas contrato, y registros desde la función de host `log_from_linear_memory`. Estos eventos pueden ser identificados por `type == DIAGNOSTIC`. Los eventos de diagnóstico emitidos por el anfitrión para rastrear la pila de llamadas se definen a continuación.

### fn_llamar

El evento de diagnóstico `fn_call` se emite cuando un contrato es llamado y contiene -

- Temas
  1. El símbolo "fn_call".
  2. El identificador del contrato a punto de ser llamado.
  3. Un símbolo que contiene el nombre de la función que se está llamando.
- Datos
  1. Un vector de los argumentos pasados a la función que está siendo llamada.

### de_fn

El evento de diagnóstico `fn_return` se emite cuando una llamada de contrato se completa y contiene -

- Temas
  1. El símbolo "fn_return".
  2. Un símbolo que contiene el nombre de la función que está a punto de regresar.
- Datos
  1. El valor devuelto por la función del contrato.

### ¿Cuándo deben habilitarse los eventos de diagnóstico?

`events` contienen `ContractEvents` que debe transmitir información sobre los cambios de estado. Por otra parte, 'diagnosticEvents' contiene eventos que no son útiles para la mayoría de los usuarios. pero puede ser útil para depurar problemas o construir la pila de llamadas por contrato. Debido a que no serán utilizados por la mayoría de los usuarios, pueden ser habilitados opcionalmente porque no son apresurados en el ledger, y por lo tanto no son parte del protocolo. Esto se hace para que un nodo de núcleo estelar pueda estar sincronizado con la red mientras emite estos eventos que normalmente no serían útiles para la mayoría de usuarios.

Debido al hecho de que un nodo con eventos diagnósticos habilitados ejecutará rutas de código que difieren de un nodo normal, recomendamos altamente usar sólo esta función en el nodo vigilante (nodos donde está establecido `NODE_IS_VALIDATOR=false`).

---
sidebar_position: 30
title: Transacción estelar
description: Invocar y desplegar contratos inteligentes con la operación InvokeHostFunctionOp.
toc_max_heading_level: 4
---

<head>
  <title>
    {`Invocar y desplegar contratos inteligentes con la operación InvokeHostFunctionOp. }
  </title>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="Invocar e implementar contratos inteligentes con la operación InvokeHostFunctionOp."
  />
  <meta
    property="og:description"
    content="Invocar e implementar contratos inteligentes con la operación InvokeHostFunctionOp."
  />
</head>

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

## Ejemplo de uso de SDK

Algunos (pero no todos) de los SDK Stellar tienen funciones integradas para manejar la mayor parte del proceso de construcción de una transacción Stellar para interactuar con un contrato inteligente Soroban. A continuación, demostramos en JavaScript y Python cómo construir y enviar una transacción estelar que invocará una instancia del [ejemplo de incremento](. /../../../build/smart-contracts/getting-started/storing-data.mdx) contrato inteligente.

<Tabs>
<TabItem value="js" label="JavaScript">

:::tip

El [JavaScript SDK](https://github.com/stellar/js-stellar-sdk) ahora incorpora todos los elementos necesarios para Soroban. Todo lo que necesitas hacer es instalarlo utilizando tu gestor de paquetes preferido.

```bash
npm install --save @stellar/stellar-sdk
```

:::

```js
(async () => {
  const {
    Keypair,
    Contract,
    SorobanRpc,
    TransactionBuilder,
    Networks,
    BASE_FEE,
  } = require("@stellar/stellar-sdk");

  // The source account will be used to sign and send the transaction.
  // GCWY3M4VRW4NXJRI7IVAU3CC7XOPN6PRBG6I5M7TAOQNKZXLT3KAH362
  const sourceKeypair = Keypair.fromSecret(
    "SCQN3XGRO65BHNSWLSHYIR4B65AHLDUQ7YLHGIWQ4677AZFRS77TCZRB",
  );

  // Configure the SDK to use the `soroban-rpc` instance of your choosing.
  const server = new SorobanRpc.Server(
    "https://soroban-testnet.stellar.org:443",
  );

  // Here we will use a deployed instance of the `increment` example contract.
  const contractAddress =
    "CBEOJUP5FU6KKOEZ7RMTSKZ7YLBS5D6LVATIGCESOGXSZEQ2UWQFKZW6";
  const contract = new Contract(contractAddress);

  // Transactions require a valid sequence number (which varies from one
  // account to another). We fetch this sequence number from the RPC server.
  const sourceAccount = await server.getAccount(sourceKeypair.publicKey());

  // The transaction begins as pretty standard. The source account, minimum
  // fee, and network passphrase are provided.
  let builtTransaction = new TransactionBuilder(sourceAccount, {
    fee: BASE_FEE,
    networkPassphrase: Networks.TESTNET,
  })
    // The invocation of the `increment` function of our contract is added
    // to the transaction. Note: `increment` doesn't require any parameters,
    // but many contract functions do. You would need to provide those here.
    .addOperation(contract.call("increment"))
    // This transaction will be valid for the next 30 seconds
    .setTimeout(30)
    .build();

  // We use the RPC server to "prepare" the transaction. This simulating the
  // transaction, discovering the storage footprint, and updating the
  // transaction to include that footprint. If you know the footprint ahead of
  // time, you could manually use `addFootprint` and skip this step.
  let preparedTransaction = await server.prepareTransaction(builtTransaction);

  // Sign the transaction with the source account's keypair.
  preparedTransaction.sign(sourceKeypair);

  // Let's see the base64-encoded XDR of the transaction we just built.
  console.log(
    `Signed prepared transaction XDR: ${preparedTransaction
      .toEnvelope()
      .toXDR("base64")}`,
  );

  // Submit the transaction to the Soroban-RPC server. The RPC server will
  // then submit the transaction into the network for us. Then we will have to
  // wait, polling `getTransaction` until the transaction completes.
  try {
    let sendResponse = await server.sendTransaction(preparedTransaction);
    console.log(`Sent transaction: ${JSON.stringify(sendResponse)}`);

    if (sendResponse.status === "PENDING") {
      let getResponse = await server.getTransaction(sendResponse.hash);
      // Poll `getTransaction` until the status is not "NOT_FOUND"
      while (getResponse.status === "NOT_FOUND") {
        console.log("Waiting for transaction confirmation...");
        // See if the transaction is complete
        getResponse = await server.getTransaction(sendResponse.hash);
        // Wait one second
        await new Promise((resolve) => setTimeout(resolve, 1000));
      }

      console.log(`getTransaction response: ${JSON.stringify(getResponse)}`);

      if (getResponse.status === "SUCCESS") {
        // Make sure the transaction's resultMetaXDR is not empty
        if (!getResponse.resultMetaXdr) {
          throw "Empty resultMetaXDR in getTransaction response";
        }
        // Find the return value from the contract and return it
        let transactionMeta = getResponse.resultMetaXdr;
        let returnValue = getResponse.returnValue;
        console.log(`Transaction result: ${returnValue.value()}`);
      } else {
        throw `Transaction failed: ${getResponse.resultXdr}`;
      }
    } else {
      throw sendResponse.errorResultXdr;
    }
  } catch (err) {
    // Catch and report any errors we've thrown
    console.log("Sending transaction failed");
    console.log(JSON.stringify(err));
  }
})();
```

</TabItem>
<TabItem value="py" label="Python">

:::tip

La [`py-stellar-base`](https://stellar-sdk.readthedocs.io/en/soroban/) SDK Python tiene soporte estable para interactuar con contratos inteligentes de Soroban a partir de [v9.0.0](https://github.com/StellarCN/py-stellar-base/releases/tag/9.0.0).

```bash
pip instalar stellar-sdk
```

:::

```py
import time

from stellar_sdk import Keypair, Network, SorobanServer, TransactionBuilder, xdr as stellar_xdr
from stellar_sdk.exceptions import PrepareTransactionException
from stellar_sdk.soroban_rpc import GetTransactionStatus, SendTransactionStatus

# The source account will be used to sign and send the transaction.
# GCWY3M4VRW4NXJRI7IVAU3CC7XOPN6PRBG6I5M7TAOQNKZXLT3KAH362
source_keypair = Keypair.from_secret('SCQN3XGRO65BHNSWLSHYIR4B65AHLDUQ7YLHGIWQ4677AZFRS77TCZRB')

# Configure SorobanClient to use the `soroban-rpc` instance of your choosing.
soroban_server = SorobanServer('https://soroban-testnet.stellar.org')

# Here we will use a deployed instance of the `increment` example contract.
contract_address = 'CBEOJUP5FU6KKOEZ7RMTSKZ7YLBS5D6LVATIGCESOGXSZEQ2UWQFKZW6'

# Transactions require a valid sequence number (which varies from one account to
# another). We fetch this sequence number from the RPC server.
source_account = soroban_server.load_account(source_keypair.public_key)

# The transaction begins as pretty standard. The source account, minimum fee,
# and network passphrase are provided.
built_transaction = (
    TransactionBuilder(
        source_account=source_account,
        base_fee=100,
        network_passphrase=Network.TESTNET_NETWORK_PASSPHRASE,
    )
    # The invocation of the `increment` function of our contract is added to the
    # transaction. Note: `increment` doesn't require any parameters, but many
    # contract functions do. You would need to provide those here.
    .append_invoke_contract_function_op(
        contract_id=contract_address,
        function_name="increment",
        parameters=[],
    )
    # This transaction will be valid for the next 30 seconds
    .set_timeout(30)
    .build()
)

# We use the RPC server to "prepare" the transaction. This simulating the
# transaction, discovering the storage footprint, and updating the transaction
# to include that footprint. If you know the footprint ahead of time, you could
# manually use `addFootprint` and skip this step.
try:
    prepared_transaction = soroban_server.prepare_transaction(built_transaction)
except PrepareTransactionException as e:
    print(f"Exception preparing transaction: {e}")
    raise e

# Sign the transaction with the source account's keypair.
prepared_transaction.sign(source_keypair)

# Let's see the base64-encoded XDR of the transaction we just built.
print(f"Signed prepared transaction XDR: {prepared_transaction.to_xdr()}")

# Submit the transaction to the Soroban-RPC server. The RPC server will then
# submit the transaction into the network for us. Then we will have to wait,
# polling `getTransaction` until the transaction completes.
send_response = soroban_server.send_transaction(prepared_transaction)
print(f"Sent transaction: {send_response}")

if send_response.status != SendTransactionStatus.PENDING:
    raise Exception("sending transaction failed")

# Poll `getTransaction` until the status is not "NOT_FOUND"
while True:
    print("Waiting for transaction confirmation...")
    # See if the transaction is complete
    get_response = soroban_server.get_transaction(send_response.hash)
    if get_response.status != GetTransactionStatus.NOT_FOUND:
        break
    # Wait one second
    time.sleep(1)

print(f"get_transaction response: {get_response}")

if get_response.status == GetTransactionStatus.SUCCESS:
    # Make sure the transaction's resultMetaXDR is not empty
    assert get_response.result_meta_xdr is not None

    # Find the return value from the contract and return it
    transaction_meta = stellar_xdr.TransactionMeta.from_xdr(
        get_response.result_meta_xdr
    )
    return_value = transaction_meta.v3.soroban_meta.return_value
    output = return_value.u32.uint32
    print(f"Transaction result: {output}")
else:
    print(f"Transaction failed: {get_response.result_xdr}")
```

</TabItem>
<TabItem value="java" label="Java">

:::tip

[java-stellar-sdk](https://github.com/stellar/java-stellar-sdk) proporciona soporte para Soroban, por favor visita la página principal del proyecto para más información.

:::

```java
import java.io.IOException;
import org.stellar.sdk.AccountNotFoundException;
import org.stellar.sdk.InvokeHostFunctionOperation;
import org.stellar.sdk.KeyPair;
import org.stellar.sdk.Network;
import org.stellar.sdk.PrepareTransactionException;
import org.stellar.sdk.SorobanServer;
import org.stellar.sdk.Transaction;
import org.stellar.sdk.TransactionBuilder;
import org.stellar.sdk.TransactionBuilderAccount;
import org.stellar.sdk.requests.sorobanrpc.SorobanRpcErrorResponse;
import org.stellar.sdk.responses.sorobanrpc.GetTransactionResponse;
import org.stellar.sdk.responses.sorobanrpc.SendTransactionResponse;
import org.stellar.sdk.scval.Scv;
import org.stellar.sdk.xdr.TransactionMeta;

public class SorobanExample {
  public static void main(String[] args)
      throws SorobanRpcErrorResponse, IOException, InterruptedException {

    // The source account will be used to sign and send the transaction.
    KeyPair sourceKeypair =
        KeyPair.fromSecretSeed("SCQN3XGRO65BHNSWLSHYIR4B65AHLDUQ7YLHGIWQ4677AZFRS77TCZRB");

    // Configure SorobanClient to use the `soroban-rpc` instance of your choosing.
    SorobanServer sorobanServer = new SorobanServer("https://soroban-testnet.stellar.org");

    // Here we will use a deployed instance of the `increment` example contract.
    String contractAddress = "CBEOJUP5FU6KKOEZ7RMTSKZ7YLBS5D6LVATIGCESOGXSZEQ2UWQFKZW6";

    // Transactions require a valid sequence number (which varies from one account to
    // another). We fetch this sequence number from the RPC server.
    TransactionBuilderAccount sourceAccount = null;
    try {
      sourceAccount = sorobanServer.getAccount(sourceKeypair.getAccountId());
    } catch (AccountNotFoundException e) {
      throw new RuntimeException("Account not found, please activate it first");
    }

    // The invocation of the `increment` function of our contract is added to the
    // transaction. Note: `increment` doesn't require any parameters, but many
    // contract functions do. You would need to provide those here.
    InvokeHostFunctionOperation operation =
        InvokeHostFunctionOperation.invokeContractFunctionOperationBuilder(
                contractAddress, "increment", null)
            .build();

    // Create a transaction with the source account and the operation we want to invoke.
    Transaction transaction =
        new TransactionBuilder(sourceAccount, Network.TESTNET)
            .addOperation(operation)
            .setTimeout(30) // This transaction will be valid for the next 30 seconds
            .setBaseFee(100) // The base fee is 100 stroops (0.00001 XLM)
            .build();

    // We use the RPC server to "prepare" the transaction. This simulating the
    // transaction, discovering the storage footprint, and updating the transaction
    // to include that footprint. If you know the footprint ahead of time, you could
    // manually use `addFootprint` and skip this step.
    try {
      transaction = sorobanServer.prepareTransaction(transaction);
    } catch (PrepareTransactionException e) {
      // You should handle the error here
      throw new RuntimeException(e);
    }

    // Sign the transaction with the source account's keypair.
    transaction.sign(sourceKeypair);

    // Let's see the base64-encoded XDR of the transaction we just built.
    System.out.println("Signed prepared transaction XDR: " + transaction.toEnvelopeXdrBase64());

    // Submit the transaction to the Soroban-RPC server. The RPC server will then
    // submit the transaction into the network for us. Then we will have to wait,
    // polling `getTransaction` until the transaction completes.
    SendTransactionResponse response = sorobanServer.sendTransaction(transaction);
    if (!SendTransactionResponse.SendTransactionStatus.PENDING.equals(response.getStatus())) {
      throw new RuntimeException("Sending transaction failed");
    }

    // Poll `getTransaction` until the status is not "NOT_FOUND"
    GetTransactionResponse getTransactionResponse;
    while (true) {
      System.out.println("Waiting for transaction confirmation...");
      // See if the transaction is complete
      getTransactionResponse = sorobanServer.getTransaction(response.getHash());
      if (!GetTransactionResponse.GetTransactionStatus.NOT_FOUND.equals(
          getTransactionResponse.getStatus())) {
        break;
      }
      // Wait one second
      Thread.sleep(1000);
    }

    System.out.println("get_transaction response: " + getTransactionResponse);

    if (GetTransactionResponse.GetTransactionStatus.SUCCESS.equals(
        getTransactionResponse.getStatus())) {
      // Find the return value from the contract and return it
      TransactionMeta transactionMeta =
          TransactionMeta.fromXdrBase64(getTransactionResponse.getResultMetaXdr());
      long returnValue = Scv.fromUint32(transactionMeta.getV3().getSorobanMeta().getReturnValue());
      System.out.println("Transaction result: " + returnValue);
    } else {
      System.out.println("Transaction failed: " + getTransactionResponse.getResultXdr());
    }
  }
}
```

</TabItem>
</Tabs>

## Uso XDR

Stellar soporta invocar y desplegar contratos con una nueva operación llamada `InvokeHostFunctionOp`. El [`stellar-cli`] abstracta estos detalles lejos del usuario, pero no todos los SDK lo hacen todavía. Si estás construyendo un dapp probablemente te encuentres construyendo la transacción XDR para enviarla a la red.

La opción `InvokeHostFunctionOp` puede utilizarse para realizar las siguientes operaciones de Soroban:

- Invocar funciones de contrato.
- Subir Wasm of the new contracts.
- Despliega nuevos contratos usando Wasm subido o implementaciones incorporadas (esto actualmente sólo incluye el [token contract](../../../../tokens/stellar-asset-contract.mdx)).

[`stellar-cli`]: ../../../../build/smart-contracts/getting-started/setup.mdx#install-the-stellar-cli

Sólo hay un solo `InvokeHostFunctionOp` permitido por transacción. Los contratos deben utilizarse para realizar múltiples acciones atómicamente, por ejemplo, para desplegar un nuevo contrato e inicializarlo atómicamente.

### Invocar función de host

El XDR de `HostFunction` y `InvokeHostFunctionOp` a continuación se puede encontrar [here][xdr].

[xdr]: https://github.com/stellar/stellar-xdr/blob/e372df9f677961aac04c5a4cc80a3667f310b29f/Stellar-transaction.x#L581

```cpp
union HostFunction switch (HostFunctionType type)
{
case HOST_FUNCTION_TYPE_INVOKE_CONTRACT:
    InvokeContractArgs invokeContract;
caso HOST_FUNCTION_TYPE_CREATE_CONTRACT:
    CreateContractArgs createContract;
caso HOST_FUNCTION_TYPE_UPLOAD_CONTRACT_WASM:
    lavadero opaco<>;
};

struct InvokeHostFunctionOp
{
    // Host function to invoke.
    HostFunction;
    // Autorizaciones por dirección para esta función host.
    SorobanAuthorizationEntry auth<>;
};
```

#### Función

El `hostFunction` en `InvokeHostFunctionOp` será ejecutado por el entorno de host Soroban. Las funciones soportadas son:

1. `HOST_FUNCTION_TYPE_INVOKE_CONTRACT`

   - Esto invocará una función del contrato desplegado con argumentos especificados en la estructura 'invokeContract'.

   ```cpp
   struct InvokeContractArgs {
    SCAddress contractAddress;
    SCSymbol functionName;
    SCVal args<>;
   };
   ```

   `contractAddress` es la dirección del contrato a facturar, `functionName` es el nombre de la función a invocar y `args` son los argumentos a pasar a esa función.

2. `HOST_FUNCTION_TYPE_UPLOAD_CONTRACT_WASM`
   - Esto subirá el contrato de Wasm usando el bloque `wasm` proporcionado.
   - Wasm subido puede ser identificado por el hash SHA-256 del Wasm subido.

3. `HOST_FUNCTION_TYPE_CREATE_CONTRACT`

   - Esto desplegará una instancia de contrato en la red usando el `executable` especificado. El identificador de contrato de 32 bytes se basa en el valor `contractIDPreimage` y el identificador de red (de modo que cada red tiene un espacio de nombre de identificador de contrato separado).

   ```cpp
   struir CreateContractArgs
   {
       ContractIDPreimage contractIDPreimage;
       ContractExecutable executable;
   };
   ```

   - `executable` puede ser un hash SHA-256 del Wasm subido previamente o puede especificar que un contrato incorporado tiene que ser usado:

   ```cpp
   enum ContractExecutableType
   {
       CONTRACT_EXECUTABLE_WASM = 0,
       CONTRACT_EXECUTABLE_TOKEN = 1
   };

   union ContractExecutable switch (ContractExecutableType type)
   {
   case CONTRACT_EXECUTABLE_WASM:
       Hash wasm_hash;
   caso CONTRACT_EXECUTABLE_TOKEN:
       void;
   };
   ```

   - `contractIDPreimage` se define como sigue:

     ```cpp
     union ContractIDPreimage switch (ContractIDPreimageType type)
     {
     case CONTRACT_ID_PREIMAGE_FROM_ADDRESS:
         struct
         {
             SCAddress address;
             uint256 sal,
         } fromAddress;
     caso CONTRACT_ID_PREIMAGE_FROM_ASSET:
         Activo desde:
     };
     ```

     - El identificador final del contrato se crea calculando SHA-256 de esto junto con el identificador de red como parte de [`HashIDPreimage`]\:

     [`hashidpreimage`]: https://github.com/stellar/stellar-xdr/blob/e372df9f677961aac04c5a4cc80a3667f310b29f/Stellar-transaction.x#L697

     ```cpp
     union HashIDPreimage switch (EnvelopeType type)
     {
     ...
     caso ENVELOPE_TYPE_CONTRACT_ID:
         struct
         {
             Hash networkID;
             ContractIDPreimage contractIDPreimage;
         } contractID;
     ...
     ```

     - `CONTRACT_ID_PREIMAGE_FROM_ADDRESS` especifica que el contrato será creado usando la dirección y sal proporcionadas. Esta operación tiene que ser autorizada por `address` (ver la siguiente sección para más detalles).
     - `CONTRACT_ID_FROM_ASSET` especifica que el contrato será creado usando el activo Stellar. Esto sólo es soportado cuando `executable == CONTRACT_EXECUTABLE_TOKEN`. Tenga en cuenta que el activo no necesita existir cuando se aplica esto, sin embargo el emisor del activo será el administrador inicial del token. Cualquiera puede desplegar contratos de activos.

##### Uso de JavaScript

Cada una de estas variaciones de invocación de la función del host tiene métodos de conveniencia en el [SDK de JavaScript](../../../tools/sdks/library.mdx#javascript-sdk):

- [`Operation.invokeHostFunction`](https://stellar.github.io/js-stellar-sdk/Operation.html#.invokeHostFunction) es el método de nivel más bajo que corresponde directamente al XDR.
- [`Operation.invokeContractFunction`](https://stellar.github.io/js-stellar-sdk/Operation.html#.invokeContractFunction) es una abstracción para invocar el método de un contrato en particular, similar a [`Contract.call`](https://stellar.github.io/js-stellar-sdk/Contract.html#call).
- [`Operation.createStellarAssetContract`](https://stellar.github.io/js-stellar-sdk/Operation.html#.createStellarAssetContract) y [`Operation.createCustomContract`](https://stellar.github.io/js-stellar-sdk/Operation.html#. reateCustomContract) son abstracciones para instanciar contratos: la primera es para envolver un [activo Stellar](. /../../../tokens/how-to-issue-an-asset.mdx) en un contrato inteligente y éste último es para desplegar su propio contrato.
- [`Operation.uploadContractWasm`](https://stellar.github.io/js-stellar-sdk/Operation.html#.uploadContractWasm) corresponde a la variante anterior `HOST_FUNCTION_TYPE_UPLOAD_CONTRACT_WASM`, permitiéndote subir el búfer WASM sin procesar al ledger.

#### Datos de autorización

El [marco de autorización](../../security/authorization.mdx) de Soroban proporciona una forma estandarizada para pasar los datos de autorización a las invocaciones de contrato a través de las estructuras `SorobanAuthorizationEntry`.

```cpp
struct SorobanAuthorizationEntry
{
    Credenciales de SorobanCredentials;
    SorobanAuthorizedInvocation rootInvocation;
};

union SorobanCredentials switch (SorobanCredentialsType type)
{
case SOROBAN_CREDENTIALS_SOURCE_ACCOUNT:
    void;
caso SOROBAN_CREDENTIALS_ADDRESS:
    dirección SorobanAddressCredentials
};
```

`SorobanAuthorizationEntry` contiene un árbol de invocaciones con `rootInvocation` como raíz. Este árbol está autorizado por un usuario especificado en `credenciales`.

`SorobanAddressCredentials` tienen dos opciones:

- `SOROBAN_CREDENTIALS_SOURCE_ACCOUNT` - esto simplemente utiliza la firma de la transacción (o operación, si existe) cuenta de origen y por lo tanto no requiere ninguna carga adicional.
- `SOROBAN_CREDENTIALS_ADDRESS` - contiene `SorobanAddressCredentials` con la siguiente estructura:
  ```cpp
  struct SorobanAddressCredentials
  {
      SCAddress address;
      int64 nonce;
      uint32 signatureExpirationLedger;
      SCVal signature;
  };
  ```
  Los campos de esta estructura tienen los siguientes semánticos:
  - Cuando `dirección` es la dirección que autoriza la invocación.
  - `signatureExpirationLedger` el número de secuencia de ledger en el que expira la firma. La firma todavía se considera válida en `signatureExpirationLedger`, pero ya no es válida en `signatureExpirationLedger + 1`. Se recomienda mantener esto tan pequeño como viable, ya que hace que la transacción sea más barata.
  - `nonce` es un valor arbitrario único para todas las firmas realizadas por `address` hasta `signatureExpirationLedger`. Un buen enfoque para generar esto es simplemente utilizar un valor aleatorio.
  - `signature` es una estructura que contiene la firma (o varias firmas) que firmó la preimagen de 32-byte, SHA-256 del `ENVELOPE_TYPE_SOROBAN_AUTHORIZATION` ([XDR][envelope-xdr]). La estructura de la firma es definida por el contrato de cuenta correspondiente a la "Dirección" (ver abajo la estructura de la firma de la cuenta Stellar).

`SorobanAuthorizedInvocation` define un nodo en el árbol de facturación autorizado:

```cpp
struct SorobanAuthorizedInvocation
{
    Función SorobanAuthorizedFuntion;
    SubInvocaciones SorobanAuthorizedInvocations<>;
};

union SorobanAuthorizedFunction switch (SorobanAuthorizedFunctionType type)
{
case SOROBAN_AUTHORIZED_FUNCTION_TYPE_CONTRACT_FN:
    SorobanAuthorizedContractFunction contractFn;
caso SOROBAN_AUTHORIZED_FUNCTION_TYPE_CREATE_CONTRACT_HOST_FN:
    CreateContractArgs createContractHostFn;
};

struct SorobanAuthorizedContractFunction
{
    SCAddress contractAddress;
    SCSymbol functionName;
    SCVec args;
};
```

`SorobanAuthorizedInvocation` consiste en la `función` que está siendo autorizada (ya sea la función del contrato o una función del servidor) y las sub-invocaciones autorizadas que `función` realiza (si existe).

`SorobanAuthorizedFunction` tiene dos variantes:

- `SOROBAN_AUTHORIZED_FUNCTION_TYPE_CONTRACT_FN` es una función de contrato que incluye la dirección del contrato, nombre de la función siendo invocada, y argumentos de la llamada `require_auth`/`require_auth_for_args` realizada en nombre de la dirección. Ten en cuenta que si `require_auth[_for_args]` no fue llamado, no debería haber una entrada `SorobanAuthorizedInvocation` en la transacción.
- `SOROBAN_AUTHORIZED_FUNCTION_TYPE_CREATE_CONTRACT_HOST_FN` es autorización para `HOST_FUNCTION_TYPE_CREATE_CONTRACT` o para la función host `create_contract` llamada desde un contrato. Sólo contiene la estructura XDR `CreateContractArgs` correspondiente al contrato creado.

Construir árboles `SorobanAuthorizedInvocation` puede simplificarse utilizando el modo de autenticación de grabación en el mecanismo de `simulateTransaction` de Soroban (ver [docs][simulate-transaction-doc] para más detalles).

[envoltorio-xdr]: https://github.com/stellar/stellar-xdr/blob/e372df9f677961aac04c5a4cc80a3667f310b29f/Stellar-transaction.x#L703
[simular-transacción-doc]: <autorización transaction-simulation.mdx#>

##### Firmas de cuenta estelar

El formato `signatureArgs` está definido por el usuario para las [cuentas personalizadas], pero es un protocolo definido para las cuentas Stellar.

Las firmas de la cuenta Stellar son un vector del siguiente Soroban [structures] en el formato Soroban SDK:

```rust
#[contracttype]
pub struct AccountEd25519Signature {
    pub public_key: BytesN<32>,
    pub signature: BytesN<64>,
}
```

[estructuras]: https://github.com/stellar/rs-soroban-env/blob/99d8c92cdc7e5cd0f5311df8f88d04658ecde7d2/soroban-env-host/src/native_contract/account_contract.rs#L51
[cuentas personalizadas]: ../../security/authorization.mdx#account-abstraction

##### Uso de JavaScript

Hay un par de métodos útiles en el SDK para facilitar el tratamiento de la autorización:

- Una vez que hayas identificado las entradas de autorización de [`simulateTransaction`](https://soroban.stellar.org/api/methods/simulateTransaction), puedes usar el ayudante [`authorizeEntry`](https://stellar.github.io/js-stellar-sdk/global.html#authorizeEntry) para "rellenar" la entrada vacía en consecuencia. Necesitará, por supuesto, el firmante apropiado para cada una de las entradas si se encuentra en una situación multipartidista.

```typescript
const signedEntries = simTx.auth.map(async (entry) =>
  // In this case, you can authorize by signing the transaction with the
  // corresponding source account.
  entry.switch() ===
  xdr.SorobanCredentialsType.sorobanCredentialsSourceAccount()
    ? entry
    : await authorizeEntry(
        entry,
        // The `signer` here will be unique for each entry, perhaps reaching out
        // to a separate entity.
        signer,
        currentLedger + 1000,
        Networks.TESTNET,
      ),
);
```

- Si en cambio, quieres _build_ una entrada de autorización desde cero en lugar de depender de la simulación, puedes usar [`authorizeInvocation`](https://stellar. ithub.io/js-stellar-sdk/global.html#authorizeInvocation), que construirá la estructura con los campos apropiados.

### Recursos de la transacción

Cada transacción Soroban tiene que tener una transacción `SorobanTransactionData` [extension] poblada. Esto es necesario para calcular la [comisión de recursos Soroban](../../fundamentals/fees-resource-limits-metering.mdx).

[extensión]: https://github.com/stellar/stellar-xdr/blob/c2e702c70951ff59a1eff257f08cf38d47210e5f/Stellar-transaction.x#L874

Los datos de la transacción Soroban se definen de la siguiente manera:

```cpp
struct SorobanResources
{
    // La huella del libro principal de la transacción.
    huella de LedgerFootprint;
    // El número máximo de instrucciones que esta transacción puede usar instrucciones
    uint32;

    // El número máximo de bytes que esta transacción puede leer desde ledger
    uint32 readBytes;
    // El número máximo de bytes que esta transacción puede escribir en el libro libro de escritura
    uint32 writeBytes;
};

struct SorobanTransactionData
{
    Recursos de SorobanResources ;
    // Porción de la transacción `fee` asignada a las comisiones reembolsables.
    int64 reembolsable;
    ExtensionPoint ext;
};
```

Estos datos comprenden dos partes: los recursos Soroban y el `refundableFee`. El `refundableFee` es la porción de la cuota de transacción elegible para el reembolso. Incluye los honorarios de los eventos del contrato emitidos por la transacción, el valor devuelto de la invocación de la función anfitrión, y comisiones para el [ledger space rent](. /../storage/state-archival.mdx).

La estructura de `SorobanResources` incluye la huella del libro de contabilidad y los valores de los recursos, los cuales juntos determinan el límite de consumo de recursos y el precio de los recursos. La huella debe contener la `LedgerKey`s que será leída y/o escrita.

El método más simple para determinar los valores en `SorobanResources` y `refundableFee` es utilizar el mecanismo [`simulateTransaction`](transaction-simulation.mdx).

#### Uso de JavaScript

Puedes usar el [`SorobanDataBuilder`](https://stellar.github.io/js-stellar-sdk/SorobanDataBuilder.html) para apalancar el [patrón del constructor](https://en.wikipedia.org/wiki/Builder_pattern) y obtener/establecer todos los recursos anteriores en consecuencia. Luego, llamas a `.build()` y pasas la estructura resultante al método [`setSorobanData`](https://stellar.github.io/js-stellar-sdk/TransactionBuilder.html#setSorobanData) del correspondiente [`TransactionBuilder`](https://stellar.github.io/js-stellar-sdk/TransactionBuilder.html).

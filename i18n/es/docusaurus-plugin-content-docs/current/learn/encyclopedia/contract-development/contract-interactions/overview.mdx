---
title: Resumen
description: Interactuar con contratos inteligentes.
sidebar_position: 5
---

<head>
  <title>Interactuar con contratos inteligentes.</title>
  <meta charSet="utf-8" />
  <meta property="og:title" content="Interactuar con contratos inteligentes." />
  <meta
    property="og:description"
    content="Interactuar con contratos inteligentes con llamadas de función, invocación de contratos y operaciones de blockchain."
  />
</head>

Los contratos son invocados a través de un par de funciones de host `call` y `try_call`:

- `try_call(contract, function, args)` llama a `function` exportada desde `contract`, pasando `args` y devolviendo un `Status` en cualquier error.
- `call(contract, function, args)` simplemente llama a `try_call` con sus argumentos y trampas en `Status`, propagando esencialmente el error.

En ambos casos `contract` es un objeto `Binary` que contiene el ID del contrato, `function` es un `Symbol` que contiene el nombre de una función exportada a llamar, y `args` es un `Vector` de valores a pasar como argumentos.

Estas funciones de host pueden ser invocadas de dos maneras separadas:

- Desde fuera del host, como cuando un usuario envía una transacción que llama a un contrato.
- Desde dentro del host, cuando un contrato llama a otro.

Ambos casos siguen la misma lógica:

- El bytecode Wasm del contrato es recuperado de una entrada `CONTRACT_DATA` en el sistema de almacenamiento del host.
- Una máquina virtual Wasm es instanciada por la duración de la invocación.
- La función se busca e invoca, con argumentos pasados de llamador a callee.

Cuando una llamada ocurre desde fuera del host, cualquier argumento se proporcionará normalmente en forma XDR serializada acompañando la transacción, y se deserializará y convertirá a objetos anfitriones automáticamente antes de invocar el contrato.

Cuando una llamada ocurre desde el interior del host, la persona que llama y callee contrata _share el mismo host_ y el que llama puede pasar referencias a los objetos anfitriones directamente a la callee sin necesidad de serializarlos o deserializarlos.

Puesto que los objetos del host son inmutables, hay un riesgo limitado de pasar una referencia compartida de un contrato a otro: la callee no puede modificar el objeto de una manera que sorprenda al llamante, sólo crear nuevos objetos.

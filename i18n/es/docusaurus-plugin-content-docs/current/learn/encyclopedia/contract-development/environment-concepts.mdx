---
sidebar_position: 10
title: Conceptos de entorno
description: La interfaz que define objetos, funciones y datos disponibles para contratos inteligentes.
---

<head>
  <title>
    {`La interfaz que define objetos, funciones, y datos disponibles para contratos inteligentes
    . }
  </title>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="La interfaz que define objetos, funciones y datos disponibles para contratos inteligentes."
  />
  <meta
    property="og:description"
    content="Aprende sobre el entorno de interfaz que define los objetos, funciones, fuentes de datos y más que están disponibles en contratos inteligentes."
  />
</head>

El entorno de contrato es una _interface_ que define las instalaciones -- objetos, funciones, fuentes de datos, etc. disponibles para contratos.

## Anfitrión e Invitado

Como interfaz, el entorno tiene dos caras, a las que nos referimos como el entorno de host y el entorno invitado. Código en el entorno host _implements_ la interfaz de entorno; código en el entorno huésped _uses_ la interfaz de entorno.

El **entorno anfitrión** es proporcionado por un conjunto conocido de cajas de Rust, compiladas una vez en stellar-core (o el SDK). Múltiples contratos interactúan con el mismo entorno de host, y el entorno anfitrión tiene acceso a cualquier instalación de su sistema operativo: archivos, redes, memoria, etc.

En contraste, se establece un nuevo **entorno de invitado** para cada invocación de cada contrato inteligente. Cada contrato ve una única interfaz de entorno, y sólo puede llamar a las funciones proporcionadas por la interfaz de entorno. En otras palabras, el entorno invitado es un sandbox para ejecutar código arbitrario dentro de parámetros seguros.

## WebAssembly

El entorno de invitados en cadena está aislado dentro de una máquina virtual WebAssembly (Wasm) ("VM"). Esto significa que el código del contrato desplegado es compilado a bytecode Wasm en lugar de código de máquina nativo. El entorno de host incluye un intérprete para la máquina virtual, y una nueva máquina virtual de corta duración es instanciada por cada llamada a un contrato, ejecutando el código de byte del contrato y luego saliendo.

El uso de una máquina virtual ayuda a proporcionar seguridad contra cualquier posible error en el código de huéspedes, tanto para el host como para otros entornos de huéspedes, así como asegurar la portabilidad del código de invitados entre hosts que se ejecutan en diferentes tipos de hardware.

Al desarrollar y probar código de contrato fuera de la cadena, es posible compilar código de contrato con código de máquina nativo en lugar de bytecode de Wasm, y [ejecutar pruebas y contratos de depuración](. /errors-and-debugging/debugging.mdx) contra una copia local del entorno de host enlazando directamente a él, en lugar de ejecutarse dentro de una máquina virtual. Esta configuración se ejecuta mucho más rápido y proporciona mucha mejor información de depuración, pero sólo es posible localmente, fuera de la cadena. Los contratos desplegados en cadena siempre son Wasm.

WebAssembly es una máquina virtual de nivel relativamente bajo, lo que significa que no proporciona un conjunto muy rico de operaciones estándar o "incorporadas". En contraste con máquinas virtuales como la JVM, no tiene recolector de basura (ni siquiera una asignación de memoria), sin instalaciones IO, sin estructuras de datos estándar como listas, , mapeos o cadenas, ningún concepto de objetos o tipos aparte de tipos básicos de máquinas como enteros de 32 y 64 bits.

Como resultado, los programas compilados a bytecode de Wasm suelen enfrentarse a un dilema: si quieren una funcionalidad estándar enriquecida, a menudo deben incluir una copia de todo el "código de soporte" para esa funcionalidad dentro de sí mismos. Pero si lo hacen, aumentan drásticamente su tamaño de código, lo que entraña costos y limita el rendimiento. Además, incluyendo tal código de soporte limita su capacidad de interactuar con otros programas que pueden incluir código de soporte diferente e incompatible.

La manera de salir de este dilema es que el propio entorno proporcione código de apoyo para una funcionalidad estándar rica, en forma de objetos y funciones de host que el código de huésped puede usar por referencia. Cada contrato se refiere a la misma funcionalidad implementada en el anfitrión, asegurando un tamaño de código mucho más pequeño, un mayor rendimiento y una mayor interoperabilidad entre contratos. Esto es lo que hace Soroban.

## Objetos y funciones del host

Compartida, la funcionalidad estándar disponible para todo el código de invitado del contrato se proporciona a través de la interfaz de entorno en términos de objetos de host y funciones de host.

El entorno soporta un pequeño número de tipos de objetos que cubren estructuras de datos como vectores, mapas, blobs binarios, direcciones, cadenas y enteros grandes. Los objetos del host son todos inmutables, se asignan y residen dentro del entorno de host, y sólo están disponibles en el entorno de huésped por referencia. Código de huésped se refiere a los objetos del host por manejadores con valores enteros.

También hay un conjunto ligeramente más grande de funciones de host que actúan sobre objetos de host: crear, modificar, inspeccionarlos y manipularlos. Algunas funciones de host permiten copiar bloques de datos binarios dentro y fuera de la memoria VM del invitado, y algunas funciones de host realizan operaciones criptográficas en objetos de host.

También hay funciones de host para interactuar con componentes selectos del entorno del host más allá de la repercusión del objeto del host, como la lectura y la escritura de entradas del libro de notas, emitiendo eventos, llamando a otros contratos y accediendo a la información sobre el contexto de la transacción en el que se está ejecutando el código de invitado.

### Serialización

Los objetos anfitriones pueden pasarse (por mano) directamente a las rutinas de almacenamiento o entre los contratos de colaboración. **No es necesario que exista un código de serialización o deserización**: el huésped sabe cómo serializar y deserializar todos sus tipos de objetos y lo hace de forma transparente cuando sea necesario.

## Valores y tipos

Todas las funciones de host pueden aceptar como argumentos y devolver valores, como máximo, el impacto limitado de Wasm VM de tipos de máquina. Para simplificar las cosas, Soroban limita aún más todas las funciones de host a pasar y devolver valores desde dentro de una única forma especializada de enteros de 64 bits llamados "value" o "el tipo de valor". A través de un paquete de bits cuidadoso, el tipo de valor puede codificar cualquiera de varios tipos separados más significativos para los usuarios que sólo "enteros".

Específicamente, el tipo de valor puede codificar directamente enteros pequeños (hasta 56 bits), pero también booleanos verdaderos y falsos, firmados o sin signo de 32 bits, tecleó los manejadores de objetos de host, códigos de error escritos, símbolos pequeños (hasta 9 caracteres alfanuméricos de latín) o un valor vacío único. Los bits individuales en un valor se asignan a la etiqueta y al cambio entre estos casos dinámicamente, y funciones u objetos que requieran casos específicos pueden rechazar valores de otros casos.

Dado que el tipo de valor puede contener un handle a un objeto host, cualquier objeto contenedor que pueda contener el tipo de valor puede contener cualquier objeto. Por lo tanto, los tipos de mapa de host y vectorial -- estructuras de datos de contenedores -- se definen simplemente como contenedores para el tipo de valor, donde el caso específico de cada valor puede variar de contenedor a contenedor o incluso entre los elementos de un contenedor. De esta manera, los tipos de contenedores de host son más parecidos a los contenedores de lenguajes dinámicos como JavaScript o Python. El SDK también proporciona envolturas estáticas, de tipo uniforme, cuando esto es deseado, prohibiendo que los valores fuera del caso designado se añadan al contenedor.

![](/assets/diagrams/environment-concepts.png)

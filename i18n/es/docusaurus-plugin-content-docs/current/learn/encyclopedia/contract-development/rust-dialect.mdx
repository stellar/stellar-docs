---
sidebar_position: 20
title: Dialecto de robusto de contrato
description: Diferencias entre la programación Soroban Rust y la típica Rust .
---

<head>
  <title>Diferencias entre Soroban Rust y la programación típica de Rust.</title>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="Diferencias entre el óxido Soroban y la programación típica del óxido."
  />
  <meta
    property="og:description"
    content="Aprende cómo el lenguaje de programación de Rust se utiliza de forma diferente en lo que respecta a las restricciones y prioridades en Soroban versus lo contrario."
  />
</head>

El desarrollo del contrato ocurre en el lenguaje de programación Rust, pero varias características del lenguaje Rust no están disponibles en el entorno de invitados de implementación. o no recomendado porque su uso incurriría en costes inaceptables en tiempo de ejecución.

Por esta razón tiene sentido considerar el código escrito para contratos como una variante _dialect_ o especial del lenguaje de programación Rust con ciertas limitaciones y prioridades inusuales, como el determinismo y el tamaño del código.

Estas restricciones y prioridades son _similar_ a las encontradas al escribir código de Rust para "sistemas embebidos", y las herramientas, las bibliotecas y técnicas utilizadas en el "dialecto del contrato" se toman frecuentemente en la [comunidad de sistemas embebidos de Rust](https://docs. incrustado. rg/book/index.html), y por defecto los contratos son recomendados para ser construidos con el \[`#[no_std]mode](https://docs.rust-embedded. rg/book/intro/no-std.html) que excluye por completo la biblioteca estándar de Rust, basándose en la librería `core\` subyacente más pequeña en su lugar.

Nota: estas restricciones y prioridades **no se aplican cuando se construye en modo de prueba local**, y, de hecho, las pruebas de contrato local usarán _frecuentemente_ facilidades -- para generar entrada de pruebas, inspeccionar la salida de las pruebas, y guiar las pruebas -- que no están soportadas en el entorno de invitados de implementación. Los desarrolladores **deben entender** la diferencia entre el código que está compilado en módulos Wasm para implementación y el código que está compilado condicionalmente para pruebas. Vea [debugging contracts](../errors-and-debugging/debugging.mdx) para más detalles.

El "dialecto del contrato" tiene las siguientes características:

## Sin punto flotante

La aritmética de punto floreciente en el huésped está totalmente prohibida. Las operaciones de punto flotante en Wasm tienen algunos aspectos no deterministas o específicos de la plataforma: principalmente patrones de bits NaN, así como ajustes de entorno de punto flotante como el modo de redondeo.

Si bien es teóricamente posible forzar a todo código de punto flotante a comportamientos deterministas a través de implementaciones de Wasm, hacer esto en algunas implementaciones de Wasm puede ser difícil, costoso o propenso a errores. Para evitar la complejidad, todo el código de coma flotante es rechazado en el momento de la instanciación.

Esta restricción puede ser revisada en una versión futura.

## Asignación limitada (idealmente cero) de memoria dinámica

La asignación de memoria dinámica dentro del huésped está **fuertemente** desalentada, pero no completamente prohibida.

El impacto del objeto anfitrión y la función del anfitrión ha sido diseñado para evitar que el huésped tenga que realizar una asignación dinámica dentro de su propia memoria lineal; en su lugar, se espera que el huésped tenga la intención de asignar estructuras dinámicas _dentro de objetos del anfitrión_ e interactuar con ellos usando manejadores ligeros.

El uso de objetos host en lugar de estructuras de datos en la memoria del huésped conlleva numerosos beneficios: un rendimiento mucho mayor, un tamaño de código mucho más pequeño, un tamaño de código mucho más pequeño interoperabilidad entre contratos, soporte compartido de host para serialización, depuración e introspección de estructura de datos.

El huésped tiene, sin embargo, una pequeña memoria lineal disponible en los casos en que sea necesaria la asignación de memoria dinámica. El uso de esta memoria conlleva costos: el huésped debe incluir en su código una copia completa de un asignador de memoria, y debe pagar el coste de ejecución de la ejecución del código de asignación dentro de la máquina virtual.

Esta restricción se debe a la capacidad limitada de Wasm para soportar el uso compartido de código: no hay una forma estándar para que el sandbox de Wasm proporcione código compartido de "biblioteca estándar" dentro de un invitado, como un asignador de memoria, ni el anfitrión tiene una visión adecuada del contenido de la memoria del huésped para proporcionar un asignador mismo. Cada contrato que desee utilizar una asignación dinámica debe llevar por tanto su propia copia de un asignador.

Muchas instancias en las que la asignación de memoria dinámica podría _seem_ para ser requerida también pueden ser abordadas con una biblioteca como [heapless](https://docs.rs/heapless/latest/heapless/). Esta biblioteca (y otras de su tipo) proporciona estructuras de datos con API familiares que _aparecen_ dinámicas, pero están realmente implementados en términos de una sola pila o asignación estática, con un tamaño máximo fijo establecido en la construcción: los intentos de crecer el tamaño dinámico más allá del tamaño máximo simplemente fallan. En el contexto de un contrato, esto puede ser a veces un comportamiento perferible y evita por completo la cuestión de la asignación dinámica.

## Non-standard I/O

Todas las instalaciones estándar de E/S y el acceso al sistema operativo que un programa típico de Rust esperaría realizar utilizando la biblioteca estándar de Rust está prohibido; los programas que intentan importar dichas funciones desde el host (por ejemplo) a través de la interfaz WASI fallarán al instanciar, ya que se refieren a funciones no proporcionadas por el host.

No hay ningún sistema operativo ni ninguna simulación en el sandbox por contrato. Una vez más, la repercusión de los objetos anfitriones y las funciones de anfitrión está destinada a sustituir y en gran medida evitar la necesidad de tales instalaciones en la biblioteca estándar.

Esta restricción surge del hecho de que los contratos necesitan funcionar con garantías _stronger_ que las hechas por las API típicas del sistema operativo. Específicamente los contratos deben realizar E/S con semántica transaccional (relativa a su ejecución exitosa o fallida) así como la consistencia serializable. Esto elimina la mayoría de las APIs que se relacionan con la E/S del archivo típico. Además, los contratos deben aislarse de todas las fuentes de no determinismo, como el trabajo en red o el control de procesos, que elimina la mayoría de las APIs restantes. Una vez que los archivos, la red y el control de procesos han desaparecido, simplemente no queda suficiente en las facilidades de E/S del sistema operativo estándar para molestarse en intentar proporcionarlas.

## Sin hilos múltiples

La lectura múltiple no está disponible. Al igual que con las funciones de E/S, intentar importar cualquier API del host relacionada con la lectura múltiple fallará en tiempo de instanciación.

Esta restricción también se basa en la necesidad de que los contratos se ejecuten en un entorno con fuertes garantías de determinismo y consistencia serializable.

## Inmediatamente

La instalación `panic!()` de Rust para errores irrecuperables atrapará a la máquina virtual de Wasm inmediatamente, deteniendo la ejecución en la instrucción que trampa en lugar de desenvolver. Esto significa que el código `Drop` en tipos de Rust no se ejecutará durante un pánico. Este comportamiento es similar al perfil de "abort"\` con el que el código de Rust puede (y a menudo lo hace) compilado.

Esta no es una restricción dura impuesta por el anfitrión, pero una configuración suave hecha a través de una mezcla de funciones SDK y banderas utilizadas al compilar, en interés de minimizar el tamaño del código y limitar los costes de ejecución. Se puede omitir con cierto esfuerzo si se desea desenrollar y `Drop` código, a costa de aumentar enormemente el tamaño del código.

## Colecciones puras funcionales

Los objetos anfitriones tienen semánticas significativamente diferentes que las estructuras de datos tradicionales de Rust, especialmente aquellas que implementan _collections_ como mapas y vectores.

En particular: los objetos host son **inmutables**, y a menudo **comparten subestructura**. Por lo tanto, se asemejan más a las estructuras de datos de una programación puramente funcional que al modelo imperativo típico utilizado en muchos programas de Rust.

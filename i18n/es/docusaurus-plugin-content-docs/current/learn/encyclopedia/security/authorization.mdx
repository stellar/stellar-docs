---
title: Autorización de Contratos Inteligentes
sidebar_position: 10
---

<head>
  <title>Autorización de contrato inteligente</title>
  <meta charSet="utf-8" />
  <meta property="og:title" content="Smart contract authorization" />
  <meta
    property="og:description"
    content="Aprende sobre el marco de autorización de Soroban, autorización inteligente específica del contrato, abstracción de la cuenta y otros conceptos de autorización en blockchain."
  />
</head>

La autorización es el proceso de juzgar qué operaciones "deberían" o "no deberían" ocurrir; se trata de juzgar _permission_.

La autorización difiere de _authentication_, que es el problema más estrecho de juzgar si una persona "es quien dice que eran", o si un mensaje que afirmaba venir de una persona "realmente" vino de ellos.

La autorización a menudo utiliza autenticación criptográfica (a través de firmas) para soportar sus juicios, pero es un proceso más amplio y general.

## Marco de autorización de Soroban

Soroban tiene como objetivo proporcionar un marco ligero, flexible y extensible que permita a los contratos implementar reglas de autorización arbitrariamente complejas mientras se proporciona la implementación integrada para algunas tareas comunes (como la prevención de repetición). El framework consta de los siguientes componentes:

- Autorización específica al contrato - Reglas de autorización personalizadas implementadas por contratos que utilizan el almacenamiento privado de contratos y cuentas abstractas.
- Abstracción de la cuenta - permite a los usuarios personalizar sus reglas de autenticación y definir políticas de autorización universales a través de contratos de cuenta personalizada (esto incluye el soporte incorporado para las cuentas Stellar).
- Biblioteca de autorización basada en hosts - asegura la integridad entre las cuentas personalizadas y los contratos regulares. También define el formato de carga útil estructurada de firmas, asegura la prevención de repetición y se encarga de proporcionar los contextos de firma correctos.

Soroban host también proporciona algunas funciones criptográficas (verificación de firmas, hashing) que pueden ser útiles para la implementación de cuenta personalizada.

Los contratos que utilizan el marco de autorización de Soroban son interoperables. También es más fácil para las aplicaciones cliente escribir código genérico para la interacción con el framework de autorización de Soroban. Por ejemplo, las carteras pueden implementar una manera generalizada de presentar y firmar las cargas útiles de Soroban.

Somos conscientes de que no es posible cubrir todos y cada uno de los casos, pero esperamos que la gran mayoría de los contratos puedan funcionar dentro del marco y contribuir así a la construcción de un ecosistema más cohesionado. Todavía es posible implementar marcos de autorización personalizados, pero no se animan (a menos que no haya alternativas).

### Autorización específica del contrato

#### Almacenamiento del contrato

Los contratos tienen acceso exclusivo de lectura y escritura a su [storage](../../../build/smart-contracts/getting-started/storing-data.mdx) en el ledger. Esto permite que los contratos controlen y gestionen de forma segura el acceso de los usuarios a sus datos. Por ejemplo, un contrato de token puede garantizar que sólo el administrador puede acuñar más del token guardando la identidad del administrador en su almacenamiento. De la misma manera, puede asegurarse de que sólo un propietario del saldo pueda transferir ese equilibrio.

#### `Dirección`

El enfoque basado en el almacenamiento descrito en la sección anterior requiere una forma de representar las identidades del usuario y autenticarlas. El tipo `Address` es un tipo administrado por host que realiza estas funciones.

Desde la perspectiva del contrato, `Address` es un tipo opaco de identificación. La lógica del contrato no necesita depender de la representación interna de la `Dirección` (vea la sección [Abstracción de la cuenta](#account-abstraction) a continuación para más detalles).

El tipo `Address` tiene dos métodos similares en Soroban SDK: `require_auth` y `require_auth_for_args` (estos métodos llaman a la respectiva función de host Soroban). La única diferencia entre las funciones es la capacidad de personalizar los argumentos de invocación. Vea [ejemplo de autor] que muestra cómo usar estas funciones.

Ambas funciones aseguran que `Address` ha autorizado la llamada de la función actual dentro del contexto actual (donde el contexto es definido por llamadas `require_auth` en la pila de llamadas actual; ver más definición formal en la [sección de abajo](#require_auth-implementation-details)). Las reglas de autenticación para esta autorización son definidas por el `Address` y son ejecutadas por el host Soroban. La protección de repetición también se implementa en el anfitrión, es decir, normalmente no hay necesidad de un contrato para gestionar sus propios.

[ejemplo de autenticación]: ../../../build/smart-contracts/example-contracts/auth.mdx

#### Autorizar llamadas de subcontratos

Una de las características clave de Soroban Authorization Framework es la capacidad de realizar llamadas de subcontratos autorizadas fácilmente. Por ejemplo, es posible que un contrato llame a `require_auth` para una `Addres` y luego llame a `token. fer` autorizado para la misma `Dirección` (ver [ejemplo de timelock] que demuestra este patrón).

Los contratos no necesitan hacer nada especial para beneficiarse de esta función. Sólo llamar un subcontrato que llame `require_auth` asegurará que la llamada subcontrato ha sido autorizada correctamente.

[ejemplo de timelock]: ../../../build/smart-contracts/example-contracts/timelock.mdx

#### Cuándo a `require_auth`

La decisión principal relacionada con la autorización que un autor del contrato necesita hacer para cualquier `Address` dado es si necesitan llamar `require_auth` para ello. Si bien la decisión debe tomarse caso por caso, aquí hay algunas reglas de miniatura:

- Si el acceso a los datos de `Address` en este contrato es de sólo lectura, entonces `require_auth` probablemente no es necesario.
- Si los datos de `Dirección` en este contrato están siendo modificados de una manera que no es estrictamente beneficiosa para el usuario, entonces `require_auth` es probablemente necesario (e. . la reducción del balance del token del usuario necesita ser autorizado, mientras que su aumento no necesita ser autorizado)
- Si un contrato llama a otro contrato que llamará `require_auth` para la `Dirección` (por ejemplo, `token. fer`), a continuación, añadir `require_auth` en la persona que llama se aseguraría de que la autorización para la llamada interna no puede ser reutilizada fuera de su contrato. Por ejemplo, si quieres hacer algo positivo para el usuario, pero sólo cuando han transferido algún token a su contrato, entonces el contrato se llama a sí mismo debería `require_auth`.

#### Autorizando Múltiples `Dirección`es

No hay restricciones explícitas sobre cuántas entidades `Address` usa el contrato y cuántas `Address`es tienen `require_auth` llamado. Esto significa que es posible autorizar una llamada de contrato en nombre de varios usuarios. que puede incluso tener diferentes contextos de autorización (personalizados a través de argumentos en `require_auth_for_args`). [Atomic swap] es un ejemplo que trata de la autorización de dos `Dirección`es.

[intercambio atómico]: ../../../build/smart-contracts/example-contracts/atomic-swap.mdx

Nota, sin embargo, que contrata que tratan con múltiples direcciones autorizadas necesitan un soporte un poco más complejo en el lado del cliente (para recoger y adjuntar las firmas adecuadas).

### Resumen de la cuenta

La abstracción de la cuenta es una forma de desacoplar la lógica de autenticación de las reglas de autorización específicas del contrato. La 'Dirección' definida anteriormente es de hecho un identificador de una cuenta 'abstract'. Es decir, los contratos conocen la 'Dirección' y pueden requerir autorización, pero no saben exactamente cómo se implementa.

Por ejemplo, imaginemos un contrato de token. Sus responsabilidades son gestionar los balances de múltiples usuarios (transferencia, mint, burn etc.). Realmente no hay nada sobre estas responsabilidades que tenga nada que ver con _cómo exactamente_ el usuario autorizó la transacción que modifica el balance. Los usuarios pueden querer usar alguna clave de hardware que soporte una nueva generación de algoritmos criptográficos (que ni siquiera tienen que existir hoy) o tal vez quieran tener un esquema multifirma y nada de esto realmente tiene nada que ver con la lógica de token.

La abstracción de la cuenta proporciona un punto de extensión conveniente para cada contrato que utiliza `Dirección` para la autorización. No resuelve todos los problemas automáticamente - las herramientas del lado del cliente pueden necesitar ser adaptadas para soportar diferentes esquemas de autenticación o diferentes carteras. Pero el estado en cadena no necesita ser modificado y modificar el estado en cadena es un problema mucho más difícil.

#### Tipos de Implementaciones de Cuenta

Conceptualmente, cada cuenta abstracta es un contrato especial que define las reglas de autenticación y potencialmente algunas políticas de autorización adicionales específicas de la cuenta. Sin embargo, en aras de la optimización y la integración con las cuentas Stellar existentes, Soroban soporta 4 tipos diferentes de implementaciones de la cuenta.

A continuación se muestran las descripciones generales de estas implementaciones. Vea la transacción [guide](../contract-development/contract-interactions/stellar-transaction.mdx) para obtener información concreta de cómo se representan las diferentes cuentas.

##### Cuenta estelar

Corresponde a `Dirección::Cuenta`.

Este es un "contrato de cuenta" especial integrado que maneja todas las cuentas Stellar. No es un contrato real y no necesita ser desplegado.

Esto apoya el Multisig Estelar con soporte medio. Vea Stellar [documentation] para más detalles sobre Multisig y umbrales.

[documentación]: ../../encyclopedia/security/signnatures-multisig.mdx

##### Invocador de la transacción

Corresponde a `Dirección::Cuenta`.

Esta es también una cuenta Stellar, pero su firma es inferior desde la cuenta de origen de la transacción Stellar (o operación, si tiene una).

Esto es puramente una optimización de la [Cuenta Estelar](#stellar-account) que puede omitir una firma en caso de que la cuenta de origen de la transacción también autorice la facturación del contrato.

##### Invocador de Contrato

Corresponde a `Address::Contract`.

Este es un caso especial de una "cuenta" que puede aparecer sólo cuando un contrato llama a otro contrato. Consideramos que dado que el contrato hace una llamada, entonces debe estar autorizándolo (de lo contrario, no debería haber hecho esa llamada). De ahí que todas las llamadas `require_auth` realizadas en nombre del contrato de invoker **directo** se consideren autorizadas (pero no cualquier llamada en nombre del contrato más profundo en la pila).

##### Cuenta personalizada

Corresponde a `Address::Contract`.

Este es el punto de extensión de la abstracción de la cuenta. La cuenta personalizada es un contrato especial que implementa el método `__check_auth`. Si cualquier contrato llama a `require_auth` para el `Addres` de este contrato, Soroban host llamará `__check_auth` con los argumentos correspondientes.

`__check_auth` obtiene un payload de firma, una lista de firmas (en cualquier formato definido por el usuario) y una lista de las invocaciones del contrato que están siendo autorizadas por estas firmas. Su responsabilidad es realizar la autenticación a través de la verificación de las firmas y también (opcionalmente) aplicar una política de autorización personalizada. Por ejemplo, se puede implementar un sistema de peso de la firma similar a Stellar, pero también puede tener reglas personalizables para los pesos, e. . para permitir gastar más de X unidades de token Y sólo dado el peso de la firma Z.

La cuenta personalizada también puede ser tratada como una cartera inteligente custodial. Posee los fondos del usuario (saldos de tokens, NFTs, etc.) y proporciona al usuario formas de autorizar las operaciones sobre estos fondos. Dicho esto, nada impide que las cuentas personalizadas autoricen operaciones que no tienen nada que ver con ningún saldo, por ejemplo, puede ser usado para realizar funciones administrativas para tokens (no false, cuenta personalizada simplemente define qué hacer cuando se llama a `require_auth`).

Para obtener la interfaz exacta y más detalles, consulte el [ejemplo de cuenta personalizada].

[ejemplo de cuenta personalizada]: ../../../build/smart-contracts/example-contracts/custom-account.mdx

### Secp256r1, contraseñas y carteras inteligentes

Después de un exitoso voto del validador público para actualizar la red principal de Stellar al protocolo 21, se habilitó el esquema de firmas secp256r1 para las transacciones de contratos inteligentes. Esto permite a los desarrolladores implementar claves de acceso para firmar transacciones en lugar de usar claves secretas o frases de semilla. La documentación oficial es un trabajo en progreso, ver toda la información de passkey y wallet inteligente en la página [Smart Wallets](../../../build/apps/smart-wallets.mdx) de la documentación.

### Conceptos avanzados

La mayoría de los contratos no deberían necesitar los conceptos descritos en esta sección. Refiérase a esto cuando desarrolle contratos complejos que tratan con arboles de llamadas de contratos profundos y/o múltiples `Direcciones`es.

#### Detalles de implementación `require_auth`

Cuando una transacción Soroban se ejecuta en cadena, el host recoge una lista de entradas `SorobanAuthorizationEntry` de la transacción ([XDR][soroban-auth-entry]). Estas entradas contienen credenciales de autorizador firmadas y árboles de invocación autorizados. El host utiliza estas entradas para verificar la autorización durante la ejecución del contrato.

Cada vez que la función host `require_auth`/`require_auth_for_args` es llamada para una cuenta non-contract-invoker, los siguientes pasos suceden:

- Encuentra un árbol de invocación autorizado que coincida con la llamada `require_auth`. El proceso de emparejamiento es bastante involucrado y se describe en la sección de abajo.
- Si la autenticación no ha ocurrido para este árbol todavía, entonces ejecutarla:
  - Verifique la caducidad de la firma. Las firmas caducadas no son válidas.
  - Verifique y consuma nunca. Nonce es un número arbitrario, que tiene que ser único entre todas las firmas no caducadas de la dirección.
  - Construye la [firma payload preimage] esperada y calcula su hash SHA-256 para obtener el payload final de firma
  - Llama a `__check_auth` del contrato de cuenta correspondiente a la `Dirección` usando el payload de firmas y las invocaciones del árbol de autorización
- Marque la invocación como 'agotado' en su árbol de invocación autorizado. Las invocaciones 'Exhausted' se omitirán cuando coincidan con las futuras llamadas 'require_auth'.

Si alguno de los pasos anteriores falla, entonces la autorización se considera fallida.

Tenga en cuenta que la autenticación ocurre sólo una vez por árbol, ya que todo el árbol necesita ser firmado.

[soroban-autentificación-entrada]: https://github.com/stellar/stellar-xdr/blob/e372df9f677961aac04c5a4cc80a3667f310b29f/Stellar-transaction.x#L570
[signature payload preimage]: https://github.com/stellar/stellar-xdr/blob/e372df9f677961aac04c5a4cc80a3667f310b29f/Stellar-transaction.x#L703

#### Árboles de invocación autorizados coincidentes

Para que las autorizaciones tengan éxito, todas las llamadas `require_auth`/`require_auth_for_args` deben estar cubiertas por los árboles de `SorobanAuthorizedInvocation` correspondientes en una transacción (definida en la transacción [XDR][invocation-xdr]).

Formalmente, esta correspondencia se define de la siguiente manera.

Dada una invocación de contrato de alto nivel `I` podemos construir un 'árbol de invocación de contratos' `T` rastreando todas las llamadas de sub-contrato (un borde dirigido `A->B` en el árbol significa 'función de contrato A llama función de contrato B). Tenga en cuenta que sólo tenemos en cuenta las funciones que se implementan en diferentes contratos, p.ej. cualquier llamada de función que no involucre una invocación de contrato a través del host `call` se considera perteneciente al mismo nodo.

Digamos que se requiere autorización de las direcciones `A_1..A_N`. Luego para cada dirección `A_i` hay dos tipos de nodos en el árbol de invocaciones `T`: `R`-nodes que tenían una llamada `require_auth` para `A_i` y `N`-nodos que no tenían tal llamada. Luego eliminamos todos los nodos `N`y todos los bordes de `T` y añadimos los bordes dirigidos que conectan los nodos restantes `R`, de tal manera que el borde va de `R_j` a `R_k` si había una ruta entre `R_j` y `R_k` en `T` que no contiene ningún otro `R`-nodos. Como resultado, obtenemos un bosque de árboles `SorobanAuthorizedInvocation` para `A_i`. Tenga en cuenta que estos árboles no tienen que tener su raíz como nodo `I` (es decir, la llamada de contrato de nivel superior), así que es posible hacerlo. . agrupar la llamada autorizada sin necesidad de firmar la función por lotes.

En términos más sencillos, Los árboles `SorobanAuthorizedInvocation` para una `Dirección` son subconjuntos del árbol de invocación completo que son 'condensados' para contener solo invocaciones que tienen `require_auth` llamada para esa `Dirección`.

Durante el proceso de emparejamiento que sucede para cada host `require_auth` intenta emparejar la ruta actual en `T` con un árbol `SorobanAuthorizedInvocation` para la correspondiente `Address`. La ruta se considera que coincide sólo cuando hay una ruta correspondiente de nodos _exhausted_ `R` que conduce a la llamada actual. Esto significa que si la `Dirección` firma una secuencia de llamadas `A.foo->B.bar->C.baz`, su verificación de autorización fallará en caso de que `A. oo` llama directamente a `C.baz` porque `C.baz` estrictamente tiene que ser llamado desde `B.bar`.

##### Duplicar direcciones

En caso de que la misma función de contrato llame a `require_auth` para la misma `Addres` varias veces (p. ej. cuando múltiples operaciones del mismo usuario están siendo bateadas), cada llamada `require_auth` todavía tiene que tener un nodo correspondiente en el árbol `SorobanAuthorizedInvocation`. Debido a esto, puede haber múltiples árboles válidos que hacen que todas las comprobaciones de autorización pasen. No hay nada malo en eso - la dirección debe haber autorizado todas las invocaciones. El único requisito para que tales casos se manejen correctamente es asegurar que las llamadas `require_auth` para una `Dirección` sucedan antes de las llamadas subcontratadas correspondientes.

[invocación-xdr]: https://github.com/stellar/stellar-xdr/blob/e372df9f677961aac04c5a4cc80a3667f310b29f/Stellar-transaction.x#L537

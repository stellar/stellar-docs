---
sidebar_position: 60
title: Interfaz de Token
description: La interfaz común implementada por tokens que son compatibles con los tokens incorporados de Soroban.
---

Contratos de fichas, incluyendo el Contrato de Activos Estelares y las implementaciones de token de ejemplo exponen la siguiente interfaz común.

Las fichas desplegadas en Soroban pueden implementar cualquier interfaz que elijan, sin embargo, deberían satisfacer la siguiente interfaz para ser interoperable con contratos construidos para soportar los tokens incorporados de Soroban.

Tenga en cuenta que en los casos específicos la interfaz no tiene que ser completamente implementada. Por ejemplo, el token personalizado puede no implementar la interfaz administrativa compatible con el Contrato de Activos Estelares - no impedirá que sea utilizable en los contratos que sólo realizan las operaciones regulares de usuario (transferencias, permisos, saldos, etc.).

### Requisitos de compatibilidad

Para cualquier función de contrato determinada, hay 3 requisitos que deben ser consistentes con la interfaz descrita aquí:

- Interfaz de función (nombre y argumentos) - si no es consistente, entonces los usuarios simplemente no podrán usar la función en absoluto. Esta es la dura exigencia.
- Autorización - los usuarios tienen que autorizar las llamadas a la función token con todos los argumentos de la invocación (ver los comentarios de la interfaz). Si esto es incoherente, entonces el token personalizado puede tener problemas para obtener las firmas correctas de los usuarios y también puede confundir el software de la cartera.
- Eventos - el token tiene que emitir los eventos en el formato especificado. Si es inconsistente, entonces el token no puede ser manejado correctamente por los sistemas de aguas abajo, como los exploradores de bloques.

### Código

La siguiente interfaz utiliza la interfaz Rust [soroban-sdk](../tools/sdks/library.mdx#soroban-rust-sdk) para declarar un rasgo que cumple con la interfaz de tokens [SEP-41](https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0041.md) .

```rust
pub trait TokenInterface {
    /// Returns the allowance for `spender` to transfer from `from`.
    ///
    /// # Arguments
    ///
    /// * `from` - The address holding the balance of tokens to be drawn from.
    /// * `spender` - The address spending the tokens held by `from`.
    fn allowance(env: Env, from: Address, spender: Address) -> i128;

    /// Set the allowance by `amount` for `spender` to transfer/burn from
    /// `from`.
    ///
    /// # Arguments
    ///
    /// * `from` - The address holding the balance of tokens to be drawn from.
    /// * `spender` - The address being authorized to spend the tokens held by
    ///   `from`.
    /// * `amount` - The tokens to be made available to `spender`.
    /// * `expiration_ledger` - The ledger number where this allowance expires. Cannot
    ///    be less than the current ledger number unless the amount is being set to 0.
    ///    An expired entry (where expiration_ledger < the current ledger number)
    ///    should be treated as a 0 amount allowance.
    ///
    /// # Events
    ///
    /// Emits an event with topics `["approve", from: Address,
    /// spender: Address], data = [amount: i128, expiration_ledger: u32]`
    fn approve(env: Env, from: Address, spender: Address, amount: i128, expiration_ledger: u32);

    /// Returns the balance of `id`.
    ///
    /// # Arguments
    ///
    /// * `id` - The address for which a balance is being queried. If the
    ///   address has no existing balance, returns 0.
    fn balance(env: Env, id: Address) -> i128;

    /// Transfer `amount` from `from` to `to`.
    ///
    /// # Arguments
    ///
    /// * `from` - The address holding the balance of tokens which will be
    ///   withdrawn from.
    /// * `to` - The address which will receive the transferred tokens.
    /// * `amount` - The amount of tokens to be transferred.
    ///
    /// # Events
    ///
    /// Emits an event with topics `["transfer", from: Address, to: Address],
    /// data = [amount: i128]`
    fn transfer(env: Env, from: Address, to: Address, amount: i128);

    /// Transfer `amount` from `from` to `to`, consuming the allowance of
    /// `spender`. Authorized by spender (`spender.require_auth()`).
    ///
    /// # Arguments
    ///
    /// * `spender` - The address authorizing the transfer, and having its
    ///   allowance consumed during the transfer.
    /// * `from` - The address holding the balance of tokens which will be
    ///   withdrawn from.
    /// * `to` - The address which will receive the transferred tokens.
    /// * `amount` - The amount of tokens to be transferred.
    ///
    /// # Events
    ///
    /// Emits an event with topics `["transfer", from: Address, to: Address],
    /// data = [amount: i128]`
    fn transfer_from(env: Env, spender: Address, from: Address, to: Address, amount: i128);

    /// Burn `amount` from `from`.
    ///
    /// # Arguments
    ///
    /// * `from` - The address holding the balance of tokens which will be
    ///   burned from.
    /// * `amount` - The amount of tokens to be burned.
    ///
    /// # Events
    ///
    /// Emits an event with topics `["burn", from: Address], data = [amount:
    /// i128]`
    fn burn(env: Env, from: Address, amount: i128);

    /// Burn `amount` from `from`, consuming the allowance of `spender`.
    ///
    /// # Arguments
    ///
    /// * `spender` - The address authorizing the burn, and having its allowance
    ///   consumed during the burn.
    /// * `from` - The address holding the balance of tokens which will be
    ///   burned from.
    /// * `amount` - The amount of tokens to be burned.
    ///
    /// # Events
    ///
    /// Emits an event with topics `["burn", from: Address], data = [amount:
    /// i128]`
    fn burn_from(env: Env, spender: Address, from: Address, amount: i128);

    /// Returns the number of decimals used to represent amounts of this token.
    ///
    /// # Panics
    ///
    /// If the contract has not yet been initialized.
    fn decimals(env: Env) -> u32;

    /// Returns the name for this token.
    ///
    /// # Panics
    ///
    /// If the contract has not yet been initialized.
    fn name(env: Env) -> String;

    /// Returns the symbol for this token.
    ///
    /// # Panics
    ///
    /// If the contract has not yet been initialized.
    fn symbol(env: Env) -> String;
}
```

:::caution CAUCIÓN CUANDO MODIFYING ALLOWANCES

La función `approve` sobrescribe el valor anterior con `amount`, por lo que es posible que la asignación anterior se gaste en una transacción anterior antes de que la `cantidad` se escriba en una transacción posterior. El resultado de esto es que `spender` puede gastar más de lo previsto. Este problema se puede evitar primero estableciendo la asignación a 0, verificar que el gasto no gastó ninguna parte de la asignación anterior, y luego establecer la asignación para la nueva cantidad deseada. Puedes leer más sobre este problema aquí - https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729.

:::

### Metadatos

Otro requisito para cumplir con la interfaz de token es escribir los metadatos estándar (`decimal`, `name`, y `symbol`) para el token en un formato específico. Este formato permite a los usuarios leer directamente los datos constantes del libro en lugar de invocar una función Wasm. El [ejemplo de tokor](https://github.com/stellar/soroban-examples/blob/main/token/src/metadata.rs) demuestra cómo usar el Rust [soroban-token-sdk](https://github.com/stellar/rs-soroban-sdk/blob/main/soroban-token-sdk/src/lib.rs) para escribir los metadatos, y animamos fuertemente las implementaciones de tokens a seguir este enfoque.

### Condiciones de fracaso de Manejo

En la interfaz de tokens, hay varias instancias en las que las llamadas a funciones pueden fallar debido a varias razones como la falta de autorización adecuada, No hay franquicia o saldo suficiente, etc. Para manejar estas condiciones de fracaso, es importante especificar el comportamiento esperado cuando surjan tales situaciones.

Es importante señalar que la interfaz del token no sólo incorpora el concepto de autorización para coincidir con la autorización de activos en Stellar Classic, pero también utiliza el mecanismo de autorización de Soroban. Por lo tanto, si intenta hacer una llamada de token y falla, podría ser debido a cualquiera de los procesos de autorización de token.

Para proporcionar más contexto, cuando se utiliza la interfaz de tokens, hay una función llamada `authorized` que devuelve "true" si una dirección tiene autorización de token.

More details on Authorization can be found [here](../learn/encyclopedia/security/authorization.mdx).

Para las funciones en la interfaz de tokens, [trapping](https://doc.rust-lang.org/book/ch09-00-error-handling. tml) debe ser usado como la forma estándar de manejar las condiciones de fallo ya que la interfaz no está diseñada para devolver códigos de error. Esto significa que cuando una función encuentra un error, detendrá la ejecución y revertirá cualquier cambio de estado que se haya producido durante la llamada a la función.

### Condiciones de fallo

Aquí hay una lista de las condiciones básicas de fallo y su comportamiento esperado para las funciones en la interfaz de tokens:

#### Funciones de administración:

- Si el administrador no autorizó la llamada, la función debe atrapar.
- Si el administrador intenta realizar una acción no válida (por ejemplo, mintar una cantidad negativa), la función debe atrapar.

#### Funciones de ficha:

- Si la persona que llama no está autorizada a realizar la acción (por ejemplo, la transferencia de tokens sin la debida autorización), la función debe atrapar.
- Si la acción resultara en un estado no válido (por ejemplo, transferir más fichas que las disponibles en el balance o la autorización), la función debe atrapar.

### Ejemplo: Manejo de Permiso Insuficiente en la función `burn_from`

En la función `burn_from`, el contrato de token debe comprobar si el pender tiene suficiente permiso para grabar la cantidad especificada de fichas de la dirección `from`. Si el subsidio es insuficiente, la función debe atrapar, detener la ejecución y revertir cualquier cambio de estado.

Aquí hay un ejemplo de cómo la función `burn_from` puede ser modificada para manejar esta condición de falla:

```rust
fn burn_from(
    env: soroban_sdk::Env,
    spender: Address,
    from: Address,
    amount: i128,
) {
    // Check if the spender has enough allowance
    let current_allowance = allowance(env, from, spender);
    if current_allowance < amount {
        // Trap if the allowance is insufficient
        panic!("Insufficient allowance");
    }

    // Proceed with burning tokens
    // ...
}
```

Al describir claramente cómo manejar fallos e incorporar las técnicas correctas de gestión de errores en la interfaz de tokens, podemos hacer que los contratos simbólicos sean más fuertes y seguros.

---
title: Emitir un Tutorial de Activos
sidebar_position: 70
---

import { CodeExample } from "@site/src/components/CodeExample";
import { Alert } from "@site/src/components/Alert";

En este tutorial, pasaremos por los pasos para emitir un activo en la red de pruebas Stellar.

:::note

Si quieres interactuar con un activo emitido en la red Stellar en contratos inteligentes, puedes crear o desplegar el [Contrato de Activos Stellar](. stellar-asset-contract.mdx) para ese activo.

:::

## Prerrequisitos

Debe asegurarse de que tiene la cantidad requerida de XLM para crear sus cuentas de emisión y distribución y cubrir el saldo mínimo y las comisiones de transacción. Si estás emitiendo un activo en la red de pruebas, puedes depositar fondos en tu cuenta obteniendo XLM de prueba de amigo. Si está emitiendo un activo en producción, necesitará adquirir XLM de otra cartera o intercambio.

Si desea evitar que sus usuarios se enfrenten a las comisiones de transacción, considere usar transacciones de cobro de comisiones. Lea más en nuestra [Enciclopedia de la Enciclopedia de la Enciclopedia](../learn/encyclopedia/transactions-specialized/fee-bump-transactions.mdx).

Conozca la red de pruebas y el mainnet en nuestra [sección de redes](../learn/fundamentals/networks.mdx).

Obtenga más información sobre las tarifas en nuestra [sección de tasas, límites de recursos y medida](../learn/fundamentals/fees-resource-limits-metering.mdx).

## Herramientas fundacionales

### Punto de clave de cuenta del emisor

Primero, debe generar un par de claves único. La clave pública actuará como tu [identidad emisora](../learn/fundamentals/stellar-data-structures/assets.mdx#issuer) en la red, mientras que usas la clave secreta para firmar transacciones.

<CodeExample>

```js
const issuerKeypair = StellarSdk.Keypair.random();

console.log("Issuer Public Key:", issuerKeypair.publicKey());
console.log("Issuer Secret Key:", issuerKeypair.secret());
```

```python
from stellar_sdk import Keypair

issuer_keypair = Keypair.random()

print("Issuer Public Key:", issuer_keypair.public_key)
print("Issuer Secret Key:", issuer_keypair.secret)
```

```java
KeyPair issuerKeypair = KeyPair.random();

System.out.println("Issuer Public Key: " + issuerKeypair.getAccountId());
System.out.println("Issuer Secret Key: " + issuerKeypair.get:/Seed());
```

```go
import (
  "github.com/stellar/go/keypair"
  "fmt"
)

issuerKeypair := keypair.MustRandom()

fmt.Println("Issuer Public Key:", issuerKeypair.Address())
fmt.Println("Issuer Secret Key:", issuerKeypair.Seed())
```

</CodeExample>

:::info

Su dirección de cuenta no cambiará una vez que emita su activo, incluso si modifica su [signers](../learn/encyclopedia/security/signnatures-multisig.mdx). Muchos emisores emplean [llaves públicas vanidad](https://github.com/JFWooten4/py-stellar-vanity-toolkit) relacionadas con su activo. Por ejemplo, puedes configurar un firmante personalizado en [base32](../learn/glossary.mdx#account-id) como `GASTRO...USD`.

:::

:::note

Muchos usuarios aseguran su cuenta de emisión con técnicas de almacenamiento en frío, como una cartera de hardware o configuración multifirma. Esto añade una capa extra de protección manteniendo su clave secreta fuera de línea o requiriendo múltiples aprobaciones para las transacciones.

:::

### Conjunto de claves de la cuenta de distribución

Su activo puede ser emitido y transferido entre cuentas a través de un pago, contrato o saldo cobrable. Aunque no es necesario crear una cuenta de distribución, es una buena práctica, así que lo haremos en este ejemplo. Lee más en nuestra [Sección de Cuentas de Emisión y Distribución](./control-asset-access.mdx#issuing-and-distribution-accounts).

#### Tres operaciones

##### Generar un nuevo par de claves

<CodeExample>

```js
const distributorKeypair = StellarSdk.Keypair.random();
```

```python
distributor_keypair = Keypair.random()
```

```java
DistributorKeyPair = KeyPair.random();
```

```go
distributorKeypair := keypair.MustRandom()
```

</CodeExample>

##### Importar un par de claves existente

<CodeExample>

```js
const distributorKeypair = StellarSdk.Keypair.from)[video] (‘SCZANGBA5YHTNYVVV4C3U252E2B6P6F5T3U6MM63WBSBZATAQI3EBTQ4’)
```

```python
distributor_keypair = Keypair.from_secret("SCZANGBA5YHTNYVV4C3U252E2B6P6F5T3U6MM63WBSBZATAQI3EBTQ4")
```

```java
KeyPair distributorKeypair = KeyPair.from)[video] Seed("SCZANGBA5YHTNYVVV4C3U252E2B6P6F5T3U6MM63WBSBZATAQI3EBTQ4");
```

```go
distributorKeypair := keypair.MustParseFull("SCZANGBA5YHTNYVV4C3U252E2B6P6F5T3U6M63WBSBZATAQI3EBTQ4")
```

</CodeExample>

##### Emplear [múltiples firmas](../learn/encyclopedia/security/signnatures-multisig.mdx)

:::danger

Tenga cuidado al trabajar con claves secretas sin procesar. Si no tienes la línea de confianza del emisor [clawback](../learn/encyclopedia/transactions-specialized/clawbacks.mdx) activada, cualquier paso erróneo podría convertir permanentemente los activos perdidos. Muchos usuarios ponen sus primeros proyectos en [testnet](../learn/fundamentals/networks#testnet) o prueban [Quests](../learn/interactive/quest.mdx) que proporcionan un entorno sandbox introductorio de baja apuesta.

:::

### Objeto de activo local

El objeto de activo es una combinación de su [code](./control-asset-access.mdx#naming-an-asset) y su clave pública emisora. Después de su emisión, cualquiera puede buscar en la red su activo único.

<CodeExample>

```js
const astroDollar = new StellarSdk.Asset(
  "AstroDollar",
  issuerKeypair.publicKey(),
);
```

```python
from stellar_sdk import Keypair, Activo

astro_dollar = Activo ("AstroDollar", issuer_keypair.public_key)
```

```java
Asset astroDollar = Asset.createNonNativeAsset("AstroDollar", issuerKeypair.getAccountId());
```

```go
import (
  "github.com/stellar/go/keypair"
  "github.com/stellar/go/txnbuild"
)

astroDollar := txnbuild.CreditAsset{Code: "AstroDollar", Issuer: issuerKeypair.Address()}
```

</CodeExample>

:::info

While anyone can create an asset, there may be real-world [compliance](./anatomy-of-an-asset.mdx#compliance) implications relevant to your use case.

:::

:::note

Usted querrá asegurarse de que publica información sobre su activo para establecer confianza con sus usuarios y prevenir errores. Aprende cómo hacerlo con nuestra [sección Publicar información sobre tu activo](./publishing-asset-info.mdx).

:::

## Transacciones en red

### Confianza del distribuidor establecido

Las cuentas deben establecer una [trustline](../learn/fundamentals/stellar-data-structures/accounts.mdx#trustlines) con la cuenta emisora para mantener el activo de ese emisor. Esto es cierto para todos los activos excepto para el token nativo de la red, [Lumens](../learn/fundamentals/lumens.mdx).

:::note

Si desea evitar que sus usuarios tengan que lidiar con líneas de confianza o XLM, considere el uso de reservas patrocinadas. Lea más en nuestra [Entrada de Enciclopedia de Reservas Patrocinadas](../learn/encyclopedia/transactions-specialized/sponsored-reserves.mdx).

:::

<CodeExample>

```js
const StellarSdk = require("stellar-sdk");
const server = new StellarSdk.Horizon.Server(
  "https://is) on-testnet.stellar.org",
);
const account = await server. oadAccount(distributorKeypair.publicKey());

const transaction = new StellarSdk.TransactionBuilder(account, {
  fee: StellarSdk.BASE_FEE,
  networkPassphrase: StellarSdk.Networks. ESTNET,
})
  // La operación `changeTrust` crea (o altera) una línea de confianza
  .addOperation(
    StellarSdk.Operation. hangeTrust({
      asset: astroDollar,
      limit: "1000", // fuente opcional
      : distributorKeypair. ublicKey(),
    }),
  )
  .setTimeout(100)
  .build();
```

```python
from stellar_sdk import Keypair, Asset, Network, Server, TransactionBuilder

server = Server("https://mediumon-testnet.stellar.org")
distributor_account = server.load_account(distributor_keypair. ublic_key)

transacción = (
  TransactionBuilder(
    source_account=distributor_account,
    network_passphrase=Network. ESTNET_NETWORK_PASSPHRASE,
    base_fee=100
  )
  . ppend_change_trust_op(asset=astro_dollar, limit="1000")
  .set_timeout(100)
  .build()
)
```

```java
Servidor servidor = new Server("https://mediumon-testnet.stellar.org");
Distribuidor AccountResponse = server.accounts().account(distributorKeypair.getAccountId());

Transacción de transacción = new Transaction.Builder(distributorAccount, Network. ESTNET)
  .addOperation(
    new ChangeTrustOperation.Builder(astroDollar, "1000")
    . etSourceAccount(distributorKeypair.getAccountId())
    .build()
  )
  .setTimeout(100)
  .build();
```

```go
import (
  "github.com/stellar/go/clients/horizonclient"
  "github.com/stellar/go/keypair"
  "github.com/stellar/go/network"
  "github.com/stellar/go/txnbuild"
)

client := horizonclient. efaultTestNetClient
distributorAccountRequest := horizonclient.AccountRequest{AccountID: distributorKeypair.Address()}
distributorAccount, _ := client.AccountDetail(distributorAccountRequest)

transaction, _ := txnbuild. ewTransaction(
  txnbuild. ransactionParams{
    SourceAccount: &distributorAccount,
    IncrementSequenceNum: verdadero,
    BaseFee: txnbuild. inBaseFee,
    Operaciones: []txnbuild. peration{
      &txnbuild. hangeTrust{
        Línea: astroDollar,
        Límite: "1000",
      },
    },
    Límites de tiempo: txnbuild. ewInfiniteTimeout(),
  },
)
```

</CodeExample>

### Pago del emisor al distribuidor

Los pagos son la operación más popular para emitir (o mint) tu activo, comparado con [otras emisiones](../learn/fundamentals/transactions/list-of-operations.mdx#path-payment-strict-send). Un pago crea la cantidad de un activo especificado, hasta [el máximo entero de 64-bits](../learn/fundamentals/stellar-data-structures/assets.mdx#amount-precision). De forma relevante, no necesitas escalar la cantidad emisora de tu activo por el XDR [incremento mínimo](../learn/fundamentals/stellar-data-structures/assets.mdx#amount-precision).

<CodeExample>

```js
// Estamos usando TransactionBuilder(...) como una mano corta aquí
// para mostrar que estas operaciones pueden ser "chained" juntos.
const transaction = new StellarSdk. ransactionBuilder(...
  // La operación `payment` envía la `amount` de la
  // `asset` especificada a nuestra cuenta de distribuidor
  . ddOperation(StellarSdk.Operation.payment({
    destino: distributorKeypair. ublicKey(),
    activo: astroDollar,
    monto: '1000', Fuente
    : issuerKeypair. ublicKey()
}))
```

```python
# Estamos usando TransactionBuilder(...) como una mano corta aquí
# para mostrar que estas operaciones pueden ser "encadenadas" juntas.
transacción = (
  TransactionBuilder(. .)
  .append_payment_op(
    destination=distributor_keypair. ublic_key,
    asset=astro_dollar,
    amount="1000"
  )
)
```

```java
// Estamos usando TransactionBuilder(...) como una mano corta aquí
// para mostrar que estas operaciones pueden ser "encadenadas" juntos.
Transacción de transacción = new Transaction.Builder(...)
  .addOperation(new PaymentOperation. uilder(
    distributorKeypair. etAccountId(),
    astroDollar,
    "1000"
  )
  . etSourceAccount(
    issuerKeypair.getAccountId()
)
```

```go
// Estamos usando TransactionBuilder(...) como una mano corta aquí
// para mostrar que estas operaciones pueden ser "encadenadas" juntos.
transacción, _ := txnbuild. ewTransaction(
  txnbuild. ransactionParams{
    SourceAccount: &issuerAccount,
    IncrementSequenceNum: verdadero,
    BaseFee: txnbuild. inBaseFee,
    Operaciones: []txnbuild.Operation{
      &txnbuild. ayment{
        Destination: distributorKeypair. ddress(),
        Monto: "1000",
        activo: astroDollar,
      },
    },
    Timebounds: txnbuild. ewInfiniteTimeout(),
  },
)
```

</CodeExample>

:::note

También puede crear un mercado directamente desde la cuenta emisora y emitir tokens a través de operaciones.

:::

### Transacciones opcionales

#### Configurar suministro máximo

:::danger

Esta sección detalla cómo bloquear su cuenta con el propósito de limitar el suministro de su activo emitido. Sin embargo, bloquear tu cuenta significa que nunca podrás hacer nada con ella otra vez—ya sea que esté ajustando a los signadores, cambiando el dominio principal, reclamando cualquier XLM sostenido, o cualquier otra operación. Tu cuenta será completamente congelada.

:::

Puede configurar permanentemente el número exacto de un activo que existirá jamás. Más información sobre el suministro de activos en nuestra sección sobre [Limitar el suministro de un activo](./control-asset-access.mdx#limiting-the-supply-of-an-asset)

<CodeExample>

```js
const lockAccountTransaction = new StellarSdk.TransactionBuilder(...)
  // This `setOptions` operation locks the issuer account
  // so there can never be any more of the asset minted
  .addOperation(StellarSdk.Operation.setOptions({
    masterWeight: 0,
    source: issuerKeypair.publicKey()
  }))
```

```python
lock_account_transaction = (
  TransactionBuilder(...)
  .append_set_options_op(master_weight=0)
)
```

```java
Transacción lockAccountTransaction = new Transaction.Builder(...)
  .addOperation(new SetOptionsOperation.Builder()
    .setMasterKeyWeight(0)
    .setSourceAccount(issuerKeypair.getAccountId())
)
```

```go
lockAccountTransaction, _ := txnbuild.NewTransaction(
  txnbuild.TransactionParams{
    SourceAccount:        &issuerAccount,
    IncrementSequenceNum: true,
    BaseFee:              txnbuild.MinBaseFee,
    Operations: []txnbuild.Operation{
      &txnbuild.SetOptions{
        MasterWeight: txnbuild.NewThreshold(0),
      },
    },
    Timebounds: txnbuild.NewInfiniteTimeout(),
  },
)
```

</CodeExample>

#### Aprobar la línea de confianza del distribuidor

Si activas la [bandera de autorización](./control-asset-access.mdx#authorization-required-0x1), la cuenta emisora también necesita aprobar la solicitud de línea de confianza de la cuenta del distribuidor antes de realizar el pago. Tendrá que hacer esto para todas las cuentas nuevas cuando se configure para su activo.

<CodeExample>

```js
const issuingAccount = await server.loadAccount(issuerKeypair.publicKey());
const transaction = new StellarSdk.TransactionBuilder(...)
  .addOperation(
    StellarSdk.Operation. etTrustLineFlags({
      trustor: distributorKeypair. ublicKey(),
      activo: astroDollar,
      banderas: {
        authorized: true,
      }
    }),
  )
  . etTimeout(100)
  .build();
```

```python
from stellar_sdk import Server, Keypair, Network, TransactionBuilder, SetTrustLineFlags

server = Server("https://parallon-testnet.stellar. rg")
issuer_account = server.load_account(issuer_keypair.public_key)

transacción = (
    TransactionBuilder(...
    .append_set_trust_line_flags_op(
        trustor=distributor_keypair. ublic_key,
        asset=astro_dollar,
        flags=SetTrustLineFlags. UTHORIZED_FLAG
    )
    .set_timeout(100)
    .build()
)
```

```java
AccountResponse issuerAccount = server.accounts().account(issuerKeys.getAccountId());
Transaction transaction = new Transaction.Builder(...)
  .addOperation(new SetTrustLineFlagsOperation.Builder(
    distributorKeys.getAccountId(),
    astroDollar
  ).setAuthorized(true).build())
  .setTimeout(100)
  .build();
```

```go
issuerAccountRequest := horizonclient.AccountRequest{AccountID: issuerKeypair.Address()}
issuerAccount, _ := client.AccountDetail(issuerAccountRequest)

transaction, _ := txnbuild. ewTransaction(
  txnbuild. ransactionParams{
    SourceAccount: &issuerAccount,
    IncrementSequenceNum: verdadero,
    BaseFee: txnbuild. inBaseFee,
    Operaciones: []txnbuild.Operation{
      &txnbuild. etTrustLineFlags{
        Trustor: distributorKeypair. ddress(),
        Activo: astroDollar,
        Autorizado: txnbuild. uthorizeFlag,
      },
    },
    Timebounds: txnbuild. ewInfiniteTimeout(),
  },
)
```

</CodeExample>

## Ejemplo de código completo

<CodeExample title="Issuing an Asset">

```js
var StellarSdk = require("stellar-sdk");
var server = new StellarSdk.Horizon.Server(
  "https://is) on-testnet.stellar. rg",
);

// Claves para las cuentas a emitir y recibir el nuevo activo
var issuerKeys = StellarSdk.Keypair. romtformat@@1 (
  "SCZANGBA5YHTNYVVV4C3U252E2B6P6F5T3U6MM63WBSBZATAQI3EBTQ4",
);
var receivingKeys = StellarSdk.Keypair. romtformat@@1 (
  "SDSAVCRE5JRAI7UFAVLE5IMIZRD6N6WOJUWKY4GFN34LOBEEUS4W2T2D",
);

// Crear un objeto para representar el nuevo activo
var astroDollar = new StellarSdk.Asset("AstroDollar", issuerKeys. ublicKey());

// Primero, la cuenta receptora debe confiar en el servidor

  . oadAccount(receivingKeys.publicKey())
  .then(function (receiver) {
    var transaction = new StellarSdk. ransactionBuilder(receptor, {
      fee: 100,
      networkPassphrase: StellarSdk.Networks.TESTNET,
    })
      // La operación `changeTrust` crea (o altera) una línea de confianza
      // El parámetro `limit` de abajo es opcional
      . ddOperación(
        StellarSdk.Operación. hangeTrust({
          activo: astroDollar,
          límite: "1000",
        }),
      )
      // setTimeout es necesario para una transacción
      . etTimeout(100)
      .build();
    transaction.sign(receivingKeys);
    return server. ubmitTransaction(transaction);
  })
  .then(consola. og)

  // Segundo, la cuenta emisora envía un pago usando el activo
  . hen(function () {
    return server.loadAccount(issuerKeys.publicKey());
  })
  . hen(function (issuer) {
    var transaction = new StellarSdk. ransactionBuilder(issuer, {
      fee: 100,
      networkPassphrase: StellarSdk.Networks.TESTNET,
    })
      .addOperation(
        StellarSdk. peration.payment({
          destino: receivingKeys. ublicKey(),
          activo: astroDollar,
          monto: "10",
        }),
      )
      // setTimeout es necesario para una transacción
      . etTimeout(100)
      .build();
    transacción. ign(issuerKeys);
    servidor de devolución.submitTransaction(transacción);
  })
  . hen(console.log)
  .catch(function (error) {
    console.error("Error!", error);
});
```

```python
desde stellar_sdk importar activos, Keypair, Network, Server, TransactionBuilder

# Configurar SDK Stellar para hablar con la instancia Horizon alojada por SDF
# Para usar la red en vivo, establecer el nombre de host a horizon_url para el servidor mainnet
= Server(horizon_url="https://Budgeton-testnet. tellar.org")
# Utilice la red de pruebas, si necesita usar la red pública, por favor configure a `Network.PUBLIC_NETWORK_PASSPHRASE`
network_passphrase = Network. ESTNET_NETWORK_PASSPHRASE

# Claves para las cuentas a emitir y recibir el nuevo activo
issuerKeypair = Keypair. rom_secret(
    "SCZANGBA5YHTNYVVV4C3U252E2B6P6F5T3U6MM63WBSBZATAQI3EBTQ4"
)
issuer_public = issuerKeypair.public_key

distributor_keypair = Keypair. rom_secret(
    "SDSAVCRE5JRAI7UFAVLE5IMIZRD6N6WOJUWKY4GFN34LOBEEUS4W2T2D"
)
distributor_public = distributor_keypair. ublic_key

# Las transacciones requieren un número de secuencia válido específico de esta cuenta.
# Podemos obtener el número de secuencia actual para la cuenta de origen de Horizon.
distributor_account = servidor. oad_account(distributor_public)

# Crear un objeto para representar el nuevo activo
astro_dollar = Activos ("AstroDollar", issuer_public)

# Primero, la cuenta receptora debe confiar en el activo
trust_transaction = (
    TransactionBuilder(
        source_account=distributor_account,
        network_passphrase=network_passphrase,
        base_fee=100,
    )
    # La operación `changeTrust` crea (o altera) una línea de confianza
    # El parámetro `limit` de abajo es opcional
    . ppend_change_trust_op(asset=astro_dollar, limit="1000")
    .set_timeout(100)
    .build()
)

trust_transaction.sign(distributor_keypair)
trust_transaction_resp = servidor. ubmit_transaction(trust_transaction)
print(f"Change Trust Transaction Resp:\n{trust_transaction_resp}")

issuer_account = server. oad_account(issuer_public)
# Segundo, la cuenta emisora realmente envía un pago usando el activo.
payment_transaction = (
    TransactionBuilder(
        source_account=issuer_account,
        passphrase=network_passphrase,
        base_fee=100,
    )
    . ppend_payment_op(
        destino=distribuidor_public
        asset=astro_dolar,
        amount="10",
    )
    . uild()
)
pago_transacción. ign(issuerKeypair)
payment_transaction_resp = server.submit_transaction(payment_transaction)
print(f"Resp:\n{payment_transaction_resp}")
```

```java
Servidor de servidor = new Server("https://Texton-testnet.stellar. rg");

// Claves para que las cuentas emitan y reciban el nuevo activo
KeyPair issuerKeys = KeyPair
  . rom://ka-perseus-graphie.s3.amazonaws.com/Seed("SCZANGBA5YHTNYVVV4C3U252E2B6P6F5T3U6MM63WBSBZATAQI3EBTQ4");
KeyPair receivingKeys = KeyPair
  .fromimming Seed("SDSAVCRE5JRAI7UFAVLE5IMIZRD6N6WOJUWKY4GFN34LOBEEUS4W2T2D");

// Crear un objeto para representar el nuevo activo
AstroDollar = Activos. reateNonNativeAsset("AstroDollar", issuerKeys.getAccountId());

// Primero, la cuenta receptora debe confiar en el activo
AccountResponse receiving = server. ccounts().account(receivingKeys.getAccountId());
Transaction allowAstroDollars = new Transaction.Builder(receiving, Network.TESTNET)
  . ddOperación(
    // La operación `ChangeTrust` crea (o altera) una línea de confianza
    // El segundo parámetro limita la cantidad que la cuenta puede mantener
    new ChangeTrustOperation. uilder(astroDollar, "1000").build())
  . uild();
allowAstroDollars.sign(receivingKeys);
server.submitTransaction(allowAstroDollars);

// Segundo, la cuenta emisora envía un pago usando el activo
AccountResponse issuer = server. ccounts().account(issuerKeys.getAccountId());
Transaction sendAstroDollars = new Transaction.Builder(issuer, Network.TESTNET)
  .addOperation(
    new PaymentOperation. uilder(receivingKeys.getAccountId(), astroDollar, "10").build())
  .build();
sendAstroDollars.sign(issuerKeys);
server.submitTransaction(sendAstroDollars);
```

```go
package main

import (
  "github.com/stellar/go/clients/horizonclient"
  "github.com/stellar/go/keypair"
  "github.com/stellar/go/network"
  "github.com/stellar/go/txnbuild"
  "log"
)

func main() {
  client := horizonclient.DefaultTestNetClient

  // Remember, these are just examples, so replace them with your own seeds.
  issuerSeed := "SDR4C2CKNCVK4DWMTNI2IXFJ6BE3A6J3WVNCGR6Q3SCMJDTSVHMJGC6U"
  distributorSeed := "SBUW3DVYLKLY5ZUJD5PL2ZHOFWJSVWGJA47F6FLO66UUFZLUUA2JVU5U"

  /*
   * We omit error checks here for brevity, but you should always check your
   * return values.
   */

  // Keys for accounts to issue and distribute the new asset.
  issuer, err := keypair.ParseFull(issuerSeed)
  distributor, err := keypair.ParseFull(distributorSeed)

  request := horizonclient.AccountRequest{AccountID: issuer.Address()}
  issuer_account, err := client.AccountDetail(request)

  request = horizonclient.AccountRequest{AccountID: distributor.Address()}
  distributorAccount, err := client.AccountDetail(request)

  // Create an object to represent the new asset
  astroDollar := txnbuild.CreditAsset{Code: "AstroDollar", Issuer: issuer.Address()}

  // First, the receiving (distribution) account must trust the asset from the
  // issuer.
  tx, err := txnbuild.NewTransaction(
    txnbuild.TransactionParams{
      SourceAccount:        distributorAccount.AccountID,
      IncrementSequenceNum: true,
      BaseFee:              txnbuild.MinBaseFee,
      Timebounds:           txnbuild.NewInfiniteTimeout(),
      Operations: []txnbuild.Operation{
        &txnbuild.ChangeTrust{
          Line:  astroDollar,
          Limit: "5000",
        },
      },
    },
  )

  signedTx, err := tx.Sign(network.TestNetworkPassphrase, distributor)
  resp, err := client.SubmitTransaction(signedTx)
  if err != nil {
    log.Fatal(err)
  } else {
    log.Printf("Trust: %s\n", resp.Hash)
  }

  // Second, the issuing account actually sends a payment using the asset
  tx, err = txnbuild.NewTransaction(
    txnbuild.TransactionParams{
      SourceAccount:        issuer_account.AccountID,
      IncrementSequenceNum: true,
      BaseFee:              txnbuild.MinBaseFee,
      Timebounds:           txnbuild.NewInfiniteTimeout(),
      Operations: []txnbuild.Operation{
        &txnbuild.Payment{
          Destination: distributor.Address(),
          Asset:       astroDollar,
          Amount:      "10",
        },
      },
    },
  )

  signedTx, err = tx.Sign(network.TestNetworkPassphrase, issuer)
  resp, err = client.SubmitTransaction(signedTx)

  if err != nil {
    log.Fatal(err)
  } else {
    log.Printf("Pay: %s\n", resp.Hash)
  }
}
```

</CodeExample>

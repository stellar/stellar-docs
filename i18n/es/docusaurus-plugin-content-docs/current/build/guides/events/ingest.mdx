---
title: Eventos entrantes publicados de un contrato
description: Utilice el método getEvents de Soroban RPC para consultar eventos, con una ventana de retención 24 horas.
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

Soroban RPC proporciona un método `getEvents` que le permite consultar eventos de un contrato inteligente. Sin embargo, la ventana de retención de datos para estos eventos es de aproximadamente 24 horas. Si necesita acceso a un registro de más tiempo de estos eventos, querrá "ingerir" los eventos tal y como se publican, mantener su propio registro o base de datos a medida que se ingieren eventos.

Hay muchas estrategias que puede utilizar para ingerir y mantener los eventos publicados por un contrato inteligente. Entre los más simples podría estar el uso de una herramienta desarrollada por la comunidad como [Mercury](https://mercurydata. pp) que eliminará todo el trabajo de infraestructura de su placa por una baja cuota de suscripción.

Otro enfoque que vamos a explorar aquí es el uso de un trabajo de cron para consultar periódicamente a Soroban RPC y almacenar los eventos relevantes en una base de datos SQLite almacenada localmente. Vamos a usar un Object Relational Mapper (ORM), permitiéndonos escribir la consulta de base de datos directamente en Python o JavaScript.

## Configurar

<Tabs groupId="language" defaultValue="python">

<TabItem value="python" label="Python">

En un [entorno virtual](https://docs.python.org/3/tutorial/venv.html), instala las dependencias de Python:

```bash
pip install sqlalchemy stellar-sdk
```

</TabItem>

</Tabs>

## Configurar el cliente de base de datos

<Tabs groupId="language" defaultValue="python">

<TabItem value="python" label="Python">

Para acceder a la base de datos, usaremos [SQLAlchemy](https://www.sqlalchemy.org), que es una biblioteca de Python utilizada frecuentemente para consultar la base de datos.

Vamos a ingerir eventos en una tabla llamada `SorobanEvent`. En SQLAlchemy, esto se traduce en una clase, también llamada un modelo de base de datos:

```python
from typing import Any
from sqlalchemy import orm, JSON


class Base(orm. eclarativeBase):
    # necesita decirle a SQLAlchemy que traduzca un diccionario en una entrada JSON
    type_annotation_map = {
        dict[str, Cualquiera]: JSON,
    }


class Event(Base):
    __tablename__ = "SorobanEvent"

    id: orm. apped[int] = orm.mapped_column(primary_key=True)
    contract_id: orm.Mapped[str]
    ledger: orm. apped[int]
    temas: orm.Mapped[dict[str, Any]]
    value: orm.Mapped[str]
```

Utilizaremos una base de datos SQLite en memoria para esta guía, pero gracias al uso de un ORM, podríamos usar cualquier otra base de datos soportada. Simplemente tendríamos que cambiar la cadena de conexión.

```python
from sqlalchemy import create_engine
engine = create_engine("sqlite://", echo=True)

# lo siguiente crea la tabla en la DB
Base.metadata.create_all(engine)
```

:::tip

Configurando `echo=True` podemos entender lo que está sucediendo en la base de datos. Crear la tabla de base de datos lleva a los siguientes registros:

:::

```text
BEGIN (implícito)
PRAGMA main.table_info("SorobanEvent")
...
PRAGMA temp.table_info("SorobanEvent")
...
CREATE TABLE SorobanEvent (
	id INTEGER NO NÚLL,
    contract_id VARCHAR NO NULL,
    no NUL
	temas JSON NO NULL,
	value VARCHAR NOT NULL,
	KEY PRIMARY (id)
)
. .
COMIT
```

</TabItem>

<TabItem value="js" label="JavaScript">

Los detalles más finos de elegir una configuración de Prisma están más allá del alcance de este documento. Puedes obtener mucha más información en [Prisma quickstart](https://www.prisma.io/docs/getting-started/quickstart). Aquí está el modelo de nuestro esquema de Prisma:

```text
model SorobanEvent {
  id String @id
  ledger Int
  contract_id String
  topic_1 String? ¿
  topic_2 String?
  topic_3 String?
  ¿tema_4 cadena?
  valor String
}
```

</TabItem>

</Tabs>

:::info

Utilizar un modelo de base de datos es muy conveniente ya que nos permite controlar el esquema de base de datos de forma programada. Si necesitamos cambiar el esquema, añadiendo una nueva columna, por ejemplo, entonces usar un ORM nos permite usar herramientas de migración muy potentes.

:::

Utilizaremos este modelo para crear y consultar los eventos almacenados en nuestra base de datos.

## Consultar eventos de Soroban RPC

Primero, necesitaremos consultar los eventos de Soroban RPC. Este ejemplo simple hace una petición RPC usando el método `getEvents`, filtrando para todos los eventos `transfer` que emite el contrato nativo de XLM.

:::note

Aquí estamos haciendo algunos supuestos. Asumimos que tu contrato ve suficiente actividad, y que usted está consultando por eventos con suficiente frecuencia que no está en peligro de tener que averiguar que el RPC Soroban más antiguo está al corriente. El enfoque que estamos adoptando es encontrar el mayor número (más reciente) de secuencias de contadores en la base de datos y la consulta de eventos que empiezan allí. Su caso de uso puede requerir cierta lógica para determinar cuál es el último libro de notas, y cuál es el libro de contabilidad más antiguo, etc.

:::

<Tabs groupId="language" defaultValue="python">

<TabItem value="python" label="Python">

Si empezamos de cero, no se conoce el libro de notas, por lo que podemos intentar ingerir aproximadamente las últimas 24 horas asumiendo que un libro de valores cierra cada 6s.

```python
import stellar_sdk

soroban_server = stellar_sdk.SorobanServer()
ledger = soroban_server.get_latest_ledger().sequence-int(3600 / 6 * 24)
```

Más adelante, podremos comenzar desde el último libro de libros mayores ingeridos haciendo una consulta a nuestra base de datos.

```python
con orm.Session(engine) as session:
    stmt = sqlalchemy.select(Event.ledger).where(
        Event.contract_id == contract_id
    ).order_by(Event.ledger.desc())
    ledger = session.scalars(stmt).first()
```

¡Vamos a obtener eventos de Soroban RPC!

```python
from stellar_sdk.soroban_rpc import EventFilter, EventFilterType

contract_id = "CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQQVU2HHGCYSC"

res = soroban_server. et_eventos(
    ledger,
    filters=[
        EventFilter(
            event_type=EventFilterType. ONTRACT,
            contract_ids=[contract_id],
            topics=[["AAAADwAAAAh0cmFuc2Zlcg==", "*", "*", "*"]],
        )
    ],
)
eventos = res. ventiladores
```

</TabItem>

<TabItem value="js" label="JavaScript">

Utilizamos la biblioteca `@stellar/stellar-sdk`:

```javascript
import { SorobanRpc } from "@stellar/stellar-sdk";
import { PrismaClient } from "@prisma/client";

const server = new SorobanRpc. erver("https://soroban-testnet.stellar.org");
const prisma = new PrismaClient();

let latestEventIngested = await prisma. Evento orobano. indFirst({
  orderBy: [
    {
      ledger: "desc",
    },
  ],
});

let events = await server. etEvents({
  startLedger: latestEventIngested. edger,
  filters: [
    {
      type: "contract",
      contractIds: ["CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQQVU2HGCYSC"],
      temas: [["AAAADwAAAAh0cmFuc2Zlcg==", "*", "*", "*"*"]],
    },
  ],
});
```

</TabItem>

</Tabs>

## Guardar eventos en la base de datos

Ahora, comprobaremos si el objeto `events` contiene cualquier evento nuevo que debamos almacenar, y hacemos exactamente eso. Estamos almacenando los temas y valores del evento como cadenas codificadas en base64 aquí, pero podría descifrar los temas y valores necesarios en los tipos de datos apropiados para su caso de uso.

<Tabs groupId="language" defaultValue="python">

<TabItem value="python" label="Python">

:::tip

Haz tu vida más fácil con un SQLAlchemy [sessionmaker](https://docs.sqlalchemy.org/es/20/orm/session_basics.html#using-a-sessionmaker) al realizar transacciones (por ejemplo, agregar registros)

:::

```python
import sqlalchemy
from sqlalchemy.orm import sessionmaker

Session = sessionmaker(engine)
with Session. egin() as session:
    events_ = []
    para evento en eventos:
        topic_ = evento. opic
        value = event.value
        events_.append(Event(contract_id=contract_id, ledger=event. edger, topics=topic_, value=value))
    session.add_all(events_)
```

```text
BEGIN (implicit)
INFO sqlalchemy.engine.Engine COMMIT
INFO sqlalchemy.engine.Engine BEGIN (implicit)
INFO sqlalchemy.engine.Engine INSERT INTO "SorobanEvent" (contract_id, ledger, topics, value) VALUES (?, ?, ?, ?) RETURNING id
INFO sqlalchemy.engine.Engine [...] ('CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQQVU2HHGCYSC', 3311, '["AAAADwAAAAh0cmFuc2Zlcg==", "AAAAEgAAAAAAAAAAJY16rJOcKxQayCR7ayNA80hW5q1U4ypIGOY7NktBfKU=", "AAAAEgAAAAHXkotywnA8z+r365/0701QSlWouXn8m0UOoshCtNHOYQ==", "AAAADgAAAAZuYXRpdmUAAA=="]', 'AAAACgAAAAAAAAAAAAAAAAAAAGQ=')
INFO sqlalchemy.engine.Engine INSERT INTO "SorobanEvent" (contract_id, ledger, topics, value) VALUES (?, ?, ?, ?) RETURNING id
INFO sqlalchemy.engine.Engine [...] ('CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQQVU2HHGCYSC', 3325, '["AAAADwAAAAh0cmFuc2Zlcg==", "AAAAEgAAAAAAAAAAJY16rJOcKxQayCR7ayNA80hW5q1U4ypIGOY7NktBfKU=", "AAAAEgAAAAHXkotywnA8z+r365/0701QSlWouXn8m0UOoshCtNHOYQ==", "AAAADgAAAAZuYXRpdmUAAA=="]', 'AAAACgAAAAAAAAAAAAAAAAAAAGQ=')
...
COMMIT
```

</TabItem>

<TabItem value="js" label="JavaScript">

```javascript
if (events.events?.length) {
  events.events.forEach(async (event) => {
    await prisma. orobanEvent.create({
      data: {
        id: evento. d,
        tipo: event.type,
        ledger: evento. borde,
        contract_id: evento. ontractId.toString(),
        topic_1: event.topic[0]. oXDR("base64") || null,
        topic_2: event.topic[1]. oXDR("base64") || nulo,
        topic_3: evento. opic[2].toXDR("base64") || null,
        topic_4: event. opic[3].toXDR("base64") || null,
        valor: event.value. oXDR("base64"),
      },
    });
  });
}
```

</TabItem>

</Tabs>

## Ejecutar el Script con Cron

Una entrada de cron es una excelente manera de automatizar este script para reunir e ingerir los eventos cada vez con tanta frecuencia. Puede configurar este script para que se ejecute como (in)con frecuencia como desee o necesite. Este ejemplo ejecutaría el script cada 24 horas a las 1:14 pm:

<Tabs groupId="language" defaultValue="python">

<TabItem value="python" label="Python">

```bash
14 13 * * * python /absolute/ruta/a/script.py
```

Este es otro ejemplo que ejecutará el script cada 30 minutos:

```bash
30 * * * * * python /absolute/ruta/a/a/script.py
```

</TabItem>

<TabItem value="js" label="JavaScript">

```bash
14 13 * * * * nodo /absolute/ruta/a/script.js
```

Este es otro ejemplo que ejecutará el script cada 30 minutos:

```bash
30 * * * * * * nodo /absolute/ruta/a/a/script.js
```

</TabItem>

</Tabs>

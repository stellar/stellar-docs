---
title: Consume eventos previamente ingeridos
description: Consume eventos ingeridos sin consultar el RPC de nuevo.
---

Una vez que los eventos han sido ingeridos en una base de datos, por ejemplo como realizados en la [guía más ingenios], pueden ser consumidos sin tener la necesidad de consultar de nuevo Soroban RPC. En lo siguiente, mostraremos cómo podemos consumir estos acontecimientos.

¡Empecemos!

## Primero, consigue algunos eventos en una BD

Continuando a la derecha donde dejamos en la [guía más ingeniosa], usaremos los modelos ORM para añadir algunos eventos más.

```python
from sqlalchemy import create_engine
engine = create_engine("sqlite://", echo=True)
```

Recuerde que los eventos publicados por Soroban están codificados por XDR. Podemos usar [stellar-sdk] para convertir entre valores y representación XDR.

En lo siguiente, usaremos un tema llamado `transfer` y necesitaremos algunos valores y direcciones. Podemos generar algunos datos de prueba:

```python
import stellar_sdk

stellar_sdk.scval.to_symbol("transfer").to_xdr()
# 'AAAADwAAAAh0cmFuc2Zlcg=='
stellar_sdk.scval.to_int32(10_000).to_xdr()
# 'AAAABAAAJxA='
stellar_sdk.scval.to_int32(5_000).to_xdr()
# 'AAAABAAAE4g='
stellar_sdk.scval.to_int32(1_000).to_xdr()
# 'AAAABAAAA+g='
stellar_sdk.scval.to_address("GA7YNBW5CBTJZ3ZZOWX3ZNBKD6OE7A7IHUQVWMY62W2ZBG2SGZVOOPVH").to_xdr()
# 'AAAAEgAAAAAAAAAAP4aG3RBmnO85da+8tCofnE+D6D0hWzMe1bWQm1I2auc='
stellar_sdk.scval.to_address("GAFYGBHKVFP36EOIRGG74V42F3ORAA2ZWBXNULMNDXAMMXQH5MCIGXXI").to_xdr()
# 'AAAAEgAAAAAAAAAAC4ME6qlfvxHIiY3+V5ou3RADWbBu2i2NHcDGXgfrBIM='
```

Ahora podemos hacer algunos eventos usando nuestro ORM y enviarlos a la base de datos:

```python
from sqlalchemy.orm import sessionmaker

contract_id = "CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQVU2HHGCYSC"
Session = sessionmaker(engine)
with Session. egin() como sesión:
    event_1 = Event(
        ledger=1,
        contract_id=contract_id,
        temas={
            # transfer
            "topic_1": "AAAADwAAAh0cmFuc2Zlcg==",
            # GA7YNBW5CBTJZ3ZZOWX3ZNBKD6OE7A7IHUQVWMY62W2ZBG2SGZVOOPVH
            "topic_2": "AAAAAAAAAAAAAAAAP4aG3RBmnO85da+8tCofnE+D6D0hWzMe1bWQm1I2auc="
        },
        value="AAABAAAJxA="
    )
    event_2 = Evento(
        ledger=1,
        contract_id=contract_id,
        topics={
            # transfer
            "topic_1": "AAAADwAAAh0cmFuc2Zlcg==",
            # GAFYGBHKVFP36EOIRGG74V42F3ORAA2ZWBXNULMNDXAMXQH5MCIGXXXI
            "topic_2": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC4ME6qlfvxHIiY3+V5ou3RADWbBu2i2NHcDGXgfrBIM="
        },
        value="AAABAAAAE4g="
    )
    sesión. dd_all([evento_1, evento_2])
```

```text
INFO sqlalchemy.engine.Engine BEGIN (implícito)
INFO sqlalchemy.engine.Engine INSERT INTO "SorobanEvent" (contract_id, ledger, topics, value) VALUES (?, ?, ?) RETURNING id
INFO sqlalchemy.engine. ngine [...] ('CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQQVU2HGCYSC', 1, '{"topic_1": "AAAADwAAAh0cmFuc2Zlcg==", "topic_2": "AAAAAAAAAAAAAP4aG3RBmnO85da+8tCofnE+D6D0hWzMe1bWQm1I2auc="}', 'AAAAAAAABAAJxA=')
INFO sqlalchemy. ngine.Engine INSERT INTO "SorobanEvent" (contract_id, ledger, topics, value) VALUES (?, ?, ?, ?) RETURNING id
INFO sqlalchemy.engine. ngine [...] ('CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQQVU2HGCYSC', 1, '{"topic_1": "AAAADwAAh0cmFuc2Zlcg==", "topic_2": "AAAAAAAAAAAAAAAAAAAAAC4ME6qlfvxHIiY3+V5ou3RADWbBu2i2NHcDGXgfrBIM="}', 'AAAAAAAAAAAAEE4g=')
INFO sqlalchemy.engine.Engine COMMIT
```

:::info

Aquí, estamos almacenando valores codificados por XDR. En su lugar, podríamos haber decidido almacenar valores decodificados en la base de datos. XDR siendo un formato comprimido, elegir cuándo decodificar el valor es un ajuste entre el uso de CPU y el consumo de memoria.

:::

## Eventos de consumo

Usando el mismo modelo que usamos para ingerir eventos en la base de datos, podemos consultar la base de datos para iterar sobre todos los eventos presentes en la tabla.

```python
import sqlalchemy
from sqlalchemy import orm

with orm.Session(engine) as session:
    stmt = sqlalchemy.select(Event)
    for event in session.scalars(stmt):
        print(event.topics, event.value)
```

```text
INFO sqlalchemy.engine.Engine BEGIN (implicit)
INFO sqlalchemy.engine.Engine SELECT "SorobanEvent".id, "SorobanEvent".contract_id, "SorobanEvent".ledger, "SorobanEvent".topics, "SorobanEvent".value
FROM "SorobanEvent"
INFO sqlalchemy.engine.Engine [...] ()
...
['AAAADwAAAAh0cmFuc2Zlcg==', 'AAAAEgAAAAAAAAAAbskHLxwXdlUVH3X3pVMFqpLHYpwmDD/PoaqYnQkX7J4=', 'AAAAEgAAAAGqo5kAOYww4Z8QWIx9TqXkXUvjFUg8mpEbsg03vV+8/w==', 'AAAADgAAAAZuYXRpdmUAAA=='] AAAACgAAAAAAAAAAAAAAC6Q7dAA=
['AAAADwAAAAh0cmFuc2Zlcg==', 'AAAAEgAAAAAAAAAAL6/diRR4by9YIZCM/+O0/BGYKWlSn2CvTEiHBptJs+k=', 'AAAAEgAAAAGqo5kAOYww4Z8QWIx9TqXkXUvjFUg8mpEbsg03vV+8/w==', 'AAAADgAAAAZuYXRpdmUAAA=='] AAAACgAAAAAAAAAAAAAAAAvrwgA=
{'topic_1': 'AAAADwAAAAh0cmFuc2Zlcg==', 'topic_2': 'AAAAEgAAAAAAAAAAP4aG3RBmnO85da+8tCofnE+D6D0hWzMe1bWQm1I2auc='} AAAABAAAJxA=
{'topic_1': 'AAAADwAAAAh0cmFuc2Zlcg==', 'topic_2': 'AAAAEgAAAAAAAAAAC4ME6qlfvxHIiY3+V5ou3RADWbBu2i2NHcDGXgfrBIM='} AAAABAAAE4g=
INFO sqlalchemy.engine.Engine ROLLBACK
```

:::note

Observe eventos anteriores estando presentes y teniendo un formato ligeramente diferente. Aunque estamos usando un esquema, todavía es fácil corromper una base de datos. Esto sólo se muestra con fines de demostración.

:::

SQLAlchemy permite realizar consultas avanzadas. Por ejemplo, podríamos filtrar un solo evento basado en algunos campos específicos.

```python
con orm.Session(engine) as session:
    stmt = sqlalchemy.select(Event).where(Event.ledger == 1)
    para evento en session.scalars(stmt):
        print(event.topics, event.value)
```

```text
INFO sqlalchemy.engine.Engine BEGIN (implicit)
INFO sqlalchemy.engine.Engine SELECT "SorobanEvent".id, "SorobanEvent".contract_id, "SorobanEvent".ledger, "SorobanEvent".topics, "SorobanEvent".value
FROM "SorobanEvent"
WHERE "SorobanEvent".ledger = ?
INFO sqlalchemy.engine.Engine [...] (1,)
{'topic_1': 'AAAADwAAAAh0cmFuc2Zlcg==', 'topic_2': 'AAAAEgAAAAAAAAAAP4aG3RBmnO85da+8tCofnE+D6D0hWzMe1bWQm1I2auc='} AAAABAAAJxA=
{'topic_1': 'AAAADwAAAAh0cmFuc2Zlcg==', 'topic_2': 'AAAAEgAAAAAAAAAAC4ME6qlfvxHIiY3+V5ou3RADWbBu2i2NHcDGXgfrBIM='} AAAABAAAE4g=
INFO sqlalchemy.engine.Engine ROLLBACK
```

## Eventos de streaming

Dependiendo de nuestra aplicación, tal vez queramos consumir eventos periódicamente llamando a la base de datos para ver si hay algo nuevo. O buscar datos según sea necesario por nuestra aplicación. Hay otra posibilidad: los oyentes de eventos!

Mientras estamos en él, podemos hacer los resultados más legibles o utilizables en Python usando el ayudante de conversión proporcionado por [stellar-sdk].

```python
@sqlalchemy.event.listens_for(Event, "after_insert")
def event_handler(mapper, connection, target):
    topics = target.topics
    value = stellar_sdk.scval.to_native(target. alue)

    para la clave, tema en topics.items():
        tópicos[key] = stellar_sdk. cval.to_native(tema)

    print(f"Event listener: {topics} {value}")
```

La próxima vez que un registro se inserte en la base de datos, este controlador de eventos será llamado. Intentemos esto:

```python
with Session.begin() as session:
    event_3 = Event(
        ledger=2,
        contract_id=contract_id,
        topics={
            # transfer
            "topic_1": "AAAADwAAAAh0cmFuc2Zlcg==",
            # GA7YNBW5CBTJZ3ZZOWX3ZNBKD6OE7A7IHUQVWMY62W2ZBG2SGZVOOPVH
            "topic_2": "AAAAEgAAAAAAAAAAP4aG3RBmnO85da+8tCofnE+D6D0hWzMe1bWQm1I2auc="
        },
        value="AAAABAAAJxA="
    )
    session.add(event_3)
```

```text
INFO sqlalchemy.engine.Engine BEGIN (implícito)
INFO sqlalchemy.engine.Engine INSERT INTO "SorobanEvent" (contract_id, ledger, topics, value) VALUES (?, ?, ?, ?)
INFO sqlalchemy.engine. ngine [...] ('CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQQVU2HGCYSC', 2, '{"topic_1": "AAAADwAAAh0cmFuc2Zlcg==", "topic_2": "AAAAAAAAAAAAAAAAAP4aG3RBmnO85da+8tCofnE+D6D0hWzMe1bWQm1I2auc="}', 'AAAAAAABAAJxA=')
Receptor del evento: {'transfer', 'topic_2': <Address [type=ACCOUNT, address=GA7YNBW5CBTJZ3ZZOWX3ZNBKD6OE7A7IHUQVWMY62W2ZBG2SGZVOOPVH]>} 10000
INFO sq
```

¡Enhorabuena, estás listo para consumir eventos de Soroban RPC!

## Ir más lejos

El uso de las técnicas que acabamos de presentar probablemente sería suficiente para muchos casos de uso. Aún así, para los lectores que quieren ir más allá hay algunas cosas en las que hay que mirar.

### Programación asincrónica

Hasta ahora, hemos utilizado SQLAlchemy de una manera sincrónica. Si tuviéramos un punto final en el backend llamando a la base de datos, este punto final se bloquearía durante la llamada a la base de datos. SQLAlchemy soporta programación asincrónica con palabras clave `async` y `await`.

Como pensamiento general, es más sencillo comenzar con una lógica sincrónica y luego pasar a añadir soporte para asíncrona cuando todo funciona como se esperaba. La depuración de la aplicación simultánea trae una capa adicional de complejidad.

SQLAlchemy le permite simplemente cambiar de una sesión sincrónica a una asíncrona sin tener que cambiar sus modelos ni consultas, haciendo una tarea muy fácil usar uno o el otro.

### Consideraciones de la idemenidad

Dependiendo de su aplicación, tal vez quiera estudiar el concepto de idemiciclo. O simplemente poner: garantizar que un evento se consume sólo una vez.

Por ejemplo, si utiliza eventos para fines de contabilidad en una solicitud de pago, procesar dos veces el mismo evento podría dar lugar a un doble gasto. En tales casos, querrá que su sistema sea idempotente para garantizar que este escenario sea cubierto.

Hay un gran cuerpo de literatura técnica en torno a este tema y no hay una solución para todos. Puede ser suficiente para que su aplicación añada una columna en la base de datos para marcar un mensaje como procesado, aunque necesitaría tener en cuenta los problemas de red que ocurren mientras procesa un evento determinado. Usar SQLAlchemy con una base de datos como PostgreSQL podría ayudar como si se hiciera correctamente las operaciones se pueden hacer atómicas. es decir, puede asegurarse de que se ha realizado una cierta cadena de acciones antes de comprometer una transacción a la base de datos.

Mientras investiga este tema, podría buscar _message brokers_ como RabbitMQ de Kafka---para citar soluciones ampliamente usadas.

[guía de ingest]: ingest.mdx
[sdk-estelar]: https://stellar-sdk.readthedocs.io/

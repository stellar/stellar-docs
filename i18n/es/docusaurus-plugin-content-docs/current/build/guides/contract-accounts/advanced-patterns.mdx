---
title: Patrones avanzados de cuenta de contrato
description: Límites de gasto por capa, listas de permitidos, reglas de tiempo y otros mecanismos de protección para cuentas de contrato.
sidebar_position: 40
---

Utiliza estos patrones para extender una cuenta de contrato básica con mecanismos de protección. Coloca la lógica en `__check_auth` o en un auxiliar que este llame, y prueba tanto las rutas de autorización como de denegación. Trata las reglas del firmante como “quién puede actuar” y las reglas de la política como “bajo qué condiciones.”

## Límites de gasto

- Almacena un límite y un total acumulado en el almacenamiento de la instancia (por ejemplo, salidas durante las últimas 24 horas).
- Deriva una clave de ventana a partir de la marca temporal del libro mayor (por ejemplo, `day = timestamp / 86_400`) y reinicia el total cuando la ventana cambia.
- En cada solicitud, verifica la asignación restante; si la cantidad la excedería, rechaza y emite un evento con la cantidad intentada y la asignación restante.

Consulta el [ejemplo de Cuenta Compleja](../../smart-contracts/example-contracts/complex-account.mdx) para una implementación de referencia con firmantes ponderados y límites.

## Listas de permitidos

- Mantén las direcciones de destino permitidas o IDs de contrato en el almacenamiento.
- Inspecciona tanto la invocación raíz como las subinvocaciones en `auth_context` antes de aprobar para que las llamadas anidadas no puedan evitar la lista.

## Firmantes de políticas

- Define uno o más roles de firmantes de políticas en el almacenamiento. Un firmante de política existe para aprobar o denegar acciones específicas (por ejemplo, una clave de auditor, una clave de guardián, o un servicio que aplica reglas de gasto).
- Para llamadas de contrato de alto riesgo (p. ej., transferencias grandes, cambio de firmantes), requiere tanto al usuario final como a un firmante de política; rechaza si falta alguno de los dos.
- Separa roles (administrador vs. estándar) para que el uso diario pueda delegarse mientras las actualizaciones o recuperación se mantengan con administradores.

## Reglas de tiempo

- Bloquea la ejecución hasta una marca temporal específica del libro mayor, o agrega un tiempo de espera tras acciones como rotación de claves o transferencias grandes.
- Almacena la marca temporal más temprana permitida en el almacenamiento de la instancia; compárala con la marca temporal actual del libro mayor en `__check_auth`.

## Claves de sesión

- Genera una clave de sesión de corta duración (por ejemplo, una clave p256 creada del lado del cliente y guardada en almacenamiento seguro del navegador) y limita su uso a una función y a una cantidad máxima.
- Guarda un registro para la clave de sesión con su expiración, alcance permitido y asignación restante; reduce la asignación en cada llamada autorizada.
- Rechaza si la clave de sesión es desconocida, ha expirado, no tiene asignación o se usa fuera de su alcance permitido.

## Contratos de política externos

- Delegar verificaciones específicas (listas de denegados, ventanas temporales, postura del dispositivo) a un contrato de política dedicado; pasa el contexto a `__check_auth` y exige que el contrato de política apruebe antes de devolver éxito.
- Mantén la interfaz de la política mínima (por ejemplo, `fn approve(auth_context) -> bool`) para que puedas cambiar políticas sin modificar tu cuenta.

## A dónde ir a continuación

- Consulta estos patrones aplicados en los [ejemplos de cuentas de contrato](./examples.mdx).
- Explora implementaciones de referencia y bibliotecas:
  - [Contratos Stellar de OpenZeppelin](https://github.com/OpenZeppelin/stellar-contracts/)
  - [Cuenta inteligente Crossmint](https://github.com/Crossmint/stellar-smart-account)

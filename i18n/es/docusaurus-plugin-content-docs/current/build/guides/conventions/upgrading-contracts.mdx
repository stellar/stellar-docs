---
title: Actualizar el Bytecode de Wasm para un Contrato Desplegado
---

<head>
  <title>Actualizar el Bytecode de Wasm para un contrato desplegado</title>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="Upgrading Wasm Bytecode for a Deployed Contract"
  />
  <meta
    property="og:description"
    content="Upgrading Wasm Bytecode for a Deployed Contract"
  />
</head>

## Introducción

Mejorar un contrato inteligente le permite mejorar o modificar su contrato sin cambiar su dirección. Esta guía le guiará a través del proceso de actualización de un contrato de código de byte WebAssembly (Wasm) usando el SDK Soroban.

### Requisitos previos:

- Entendimiento básico de [Lenguaje de Programación de Rust]. Para subir a Rust, echa un vistazo a [Rustlings](https://github.com/rust-lang/rustlings) o [The Rust book](https://doc.rust-lang.org/book/).
- Familiaridad con [Stellar smart contracts](../../smart-contracts/getting-started/hello-world.mdx)
- Instalado [Stellar CLI](../../smart-contracts/getting-started/setup.mdx#install-the-stellar-cli) y Soroban SDK

### Descargar el ejemplo de contrato actualizable

El [ejemplo de contrato actualizable] demuestra cómo actualizar un contrato de Wasm.

[![Abrir en Gitpod](https://gitpod.io/button/open-in-gitpod.svg)][oigp]

[oigp]: https://gitpod.io/#https://github.com/stellar/soroban-examples/tree/v20.2.0
[ejemplo de contrato actualizable]: https://github.com/stellar/soroban-examples/tree/v20.2.0/upgradeable_contract
[Idioma de programación de Rust]: https://www.rust-lang.org/

### Código

El ejemplo contiene tanto un contrato "antiguo" como "nuevo", donde pasamos de "viejo" a "nuevo". El siguiente código es para el contrato "antiguo".

```rust title="upgradeable_contract/old_contract/src/lib.rs"
#![no_std]

use soroban_sdk::{contractimpl, contractimpl, contracttype, Dirección, BytesN, Env};

#[contracttype]
#[derive(Clone)]
enum DataKey {
    Admin,
}

#[contract]
pub struct UpgradeableContract;

#[contractimpl]
impl UpgradeableContract {
    pub fn init(e: Env, admin: Dirección) {
        e. torage().instance(). et(&DataKey::Admin, &admin);
    }

    pub fn version() -> u32 {
        1
    }

    pub fn upgrade(e: Env, new_wasm_hash: BytesN<32>) {
        let admin: Dirección = e. torage().instance().get(&DataKey::Admin).unwrap();
        admin.require_auth();

        e. eployer().update_current_contract_wasm(new_wasm_hash);
    }
}

```

## Cómo funciona

Al actualizar un contrato, la función clave utilizada es `e.deployer().update_current_contract_wasm`, que toma el hash Wasm del nuevo contrato como parámetro. Aquí hay un desglose paso a paso de cómo funciona este proceso:

1. **Sin cambios en el ID del contrato**: El ID del contrato sigue siendo el mismo incluso después de la actualización. Esto garantiza que todas las referencias al contrato permanezcan intactas.
2. **Autorización del administrador**: Antes de actualizar, el contrato comprueba si la acción está autorizada por un administrador. Esto es crucial para prevenir mejoras no autorizadas. Sólo alguien con derechos de administrador puede realizar la actualización.
3. **Función de actualización**: Debajo está la función que maneja el proceso de actualización:

```rust
pub fn upgrade(e: Env, new_wasm_hash: BytesN<32>) {
    let admin: Address = e.storage().instance().get(&DataKey::Admin).unwrap();
    admin.require_auth();

    e.deployer().update_current_contract_wasm(new_wasm_hash);
}
```

- `e: Env`: El objeto de entorno que representa el estado actual de la cadena de bloques.
- `new_wasm_hash: BytesN<32>`: El hash del nuevo código Wasm para el contrato. El bytecode de Wasm debe estar ya instalado/presente en el ledger.
- La función primero recupera la dirección del administrador desde el almacenamiento del contrato.
- Entonces requiere la autorización del administrador (`admin.require_auth()`) para continuar.
- Finalmente, actualiza el contrato con el nuevo código Wasm (`e.deployer().update_current_contract_wasm(new_wasm_hash)`).

4. La función de host `update_current_contract_wasm` también emitirá un contrato `SYSTEM` [event] que contiene la referencia antigua y nueva del lavado, permitiendo que los usuarios de downstream sean notificados cuando se actualiza un contrato que utilizan. La estructura del evento tendrá `topics = ["executable_update", old_executable: ContractExecutable, old_executable: ContractExecutable]` y `data = []`.

[aqui]: https://docs.rs/soroban-sdk/20.0.2/soroban_sdk/struct.Env.html#method.update_current_contract_wasm
[evento]: ../../../learn/encyclopedia/contract-development/events.mdx#event-types

## Tests

Abre el archivo `upgradeable_contract/old_contract/src/test.rs` para seguir .

```rust title="upgradeable_contract/old_contract/srctest.rs"
#![cfg(test)]

use soroban_sdk::{testutils::Dirección como _, Dirección, BytesN, Env};

mod old_contract {
    soroban_sdk::contractimport!
        archivo =
            "target/wasm32-unknown-unknown/release/soroban_upgradeable_contract_old_contract. asm"
    );
}

mod new_contract {
    soroban_sdk::contractimport! Archivo
        = ". /new_contract/target/wasm32-unknown-unknown/release/soroban_upgradeable_contract_new_contract.wasm"
    );
}

fn install_new_wasm(e: &Env) -> BytesN<32> {
    e. nstall_contract_wasm(new_contract::Wasm)
}

#[test]
fn test() {
    let env = Env::default();
    env. ock_all_auths();

    // Tenga en cuenta que usamos register_contract_wasm en lugar de register_contract
    // porque se espera que Wasm exista en el almacenamiento.
    let contract_id = env. egister_contract_wasm(None, old_contract::Wasm);

    let client = old_contract::Client::new(&env, &contract_id);
    let admin = Address::random(&env);
    cliente. nit(&admin);

    assert_eq!(1, cliente. ersion());

    let new_wasm_hash = install_new_wasm(&env);

    client.upgrade(&new_wasm_hash);
    assert_eq!(2, client. ersion());

    // new_v2_fn fue añadido en el nuevo contrato, para que el cliente
    // esté desactualizado. Genera una nueva.
    let client = new_contract::Client::new(&env, &contract_id);
    assert_eq!(1010101, cliente. ew_v2_fn());
}

```

Primero importamos archivos Wasm para ambos contratos:

```rust
mod old_contract {
    soroban_sdk::contractimport!
        file =
            "target/wasm32-unknown-unknown/release/soroban_upgradeable_contract_old_contract. asm"
    );
}

mod new_contract {
    soroban_sdk::contractimport!
        archivo = ". /new_contract/target/wasm32-unknown-unknown/release/soroban_upgradeable_contract_new_contract.wasm"
    );
}
```

Registramos el contrato antiguo, lo intializamos con un administrador, y verificamos la versión que regresa. La nota en el código siguiente es importante:

```rust
// Tenga en cuenta que usamos register_contract_wasm en lugar de register_contract
// porque se espera que Wasm exista en el almacenamiento.
let contract_id = env. egister_contract_wasm(None, old_contract::Wasm);

let client = old_contract::Client::new(&env, &contract_id);
let admin = Address::random(&env);
client.init(&admin);

assert_eq!(1, client.version());
```

Instalamos el nuevo contrato Wasm:

```rust
let new_wasm_hash = install_new_wasm(&env);
```

Luego ejecutamos la actualización, y verificamos que la actualización funcionó:

```rust
client.upgrade(&new_wasm_hash);
assert_eq!(2, client.version());
```

## Construir el contrato

Para construir los archivos `.wasm`, ejecuta `stellar contract build` tanto en `upgradeable_contract/old_contract` como en `upgradeable_contract/new_contract` en ese orden.

Ambos archivos `.wasm` deben encontrarse en ambos directorios `target` del contrato después de construir ambos contratos:

```
objetivo/wasm32-unknown-unknown/release/soroban_upgradeable_contract_old_contract.wasm
```

```
objetivo/wasm32-unknown-unknown/release/soroban_upgradeable_contract_new_contract.wasm
```

## Ejecutar el contrato

Si tienes instalado [`stellar-cli`], puedes invocar las funciones de contrato. Despliegue el antiguo contrato e instale el Wasm para el nuevo contrato.

Navega a `upgradeable_contract/old_contract`

```sh
despliegue de contrato estelar \
  --wasm target/wasm32-unknown-unknown/release/soroban_upgradeable_contract_old_contract.wasm \
  --source alice \
  --network testnet
```

- Cuando despliega un contrato inteligente en una red, necesita especificar una identidad que se utilizará para firmar las transacciones. Cambia el `alice` a tu propio [identity].

[identidad]: ../../smart-contracts/getting-started/setup.mdx#configure-an-identity

Debería ver este ID de contrato similar después de haber ejecutado el comando de despliegue:

```
CAS6FKBXGVXFGU2SPPPJJOIULJNPMPR6NVKWLOQP24SZJPMB76TGH7Y3
```

Navega a `upgradeable_contract/new_contract` y ejecuta el siguiente comando:

```
stellar contract install \
--source-account alice \
--wasm target/wasm32-unknown-unknown/release/soroban_upgradeable_contract_new_contract.wasm \
--network testnet
```

Debería ver este hash de Wasm desde el comando de instalación:

```
aa24c81289997ad815489b29db337b53f284cca5aba86e9a8ae5cef7d31842c2
```

También necesitas llamar al método `init` para que se establezca la dirección `admin`. Esto requiere que configuremos algo [identities].

[identidades]: ../../smart-contracts/getting-started/setup.mdx#configure-an-identity

Dado que previamente hemos configurado una identidad, para obtener la dirección de identidad, ejecutamos el siguiente comando:

```sh
dirección de llaves estelares
```

Ejemplo:

```
GCJ2R5ST4UQP2D4F54Y3IIAQKPMLMEEZCNZ3PEDKY4AGDYEMYUC2MOO7
```

Navega a `upgradeable_contract/old_contract` y ahora llama a `init` con esta clave (asegúrate de sustituir con la clave generada):

```sh
stellar contract invoke \
  --id CAS6FKBXGVXFGU2SPPPJOIULJNPMPR6NVKWLOQP24SZJPMB76TGH7Y3 \
  --source alice \
  --network testnet \
  -- \
  init \
  --admin GCJ2R5ST4UQP2D4F54Y3IIAQKPMLMEEZCNZ3PEDKY4AGDYEMYUC2MOOO7
```

Nuestra dirección `old_contract` implementada es `CAS6FKBXGVXFGU2SPPPJJOIULJNPMPR6NVKWLOQP24SZJPMB76TGH7Y3`. Puede que necesite reemplazar este valor por el suyo. Invoca la función `version` del contrato:

```sh
stellar contract invoke \
  --id CAS6FKBXGVXFGU2SPPPJOIULJNPMPR6NVKWLOQP24SZJPMB76TGH7Y3 \
  --source alice \
  --network testnet \
  -- \
  versión

```

La siguiente salida debería ocurrir usando el código anterior:

```json
1
```

Ahora actualice el contrato. Tenga en cuenta que `--source` debe ser el nombre de identidad que coincida con la dirección pasada a la función `init`.

```sh
stellar contract invoke \
  --id CAS6FKBXGVXFGU2SPPPJOIULJNPMPR6NVKWLOQP24SZJPMB76TGH7Y3 \
  --source alice \
  --network testnet \
  -- \
  upgrade \
  --new_wasm_hash aaa24c81289997ad815489b29db337b53f284cca5aba86e9a8ae5cef7d31842c2
```

Vuelve a invocar la función `version`.

```sh
stellar contract invoke \
  --id CAS6FKBXGVXFGU2SPPPJOIULJNPMPR6NVKWLOQP24SZJPMB76TGH7Y3 \
  --source alice \
  --network testnet \
  -- \
  versión
```

Ahora que el contrato ha sido actualizado, verás una nueva versión.

```json
2
```

¡Sin embargo, nuestro contrato ha sido actualizado!

[`stellar-cli`]: ../../smart-contracts/getting-started/setup.mdx#install-the-stellar-cli

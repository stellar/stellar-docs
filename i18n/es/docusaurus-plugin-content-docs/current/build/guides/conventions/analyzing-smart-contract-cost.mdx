---
title: Analizando costes y eficiencia de contratos inteligentes
hide_table_of_contents: false
---

Varios factores influyen en la rapidez y eficiencia de la ejecución de sus contratos inteligentes en la red Stellar. Esta guía le ayudará a entender estos factores y a proporcionar consejos sobre cómo escribir contratos rentables.

# **Cómo optimizar el coste del contrato inteligente**:

Los contratos complejos con numerosas condiciones, bucles y cálculos requieren más potencia de procesamiento en Stellar. Esto puede llevar a mayores costos de gas (tasas de transacción) y a plazos de ejecución más lentos.

## 1. **Uso eficiente de las llamadas de bucle y almacenamiento**

Un contrato que requiere múltiples bucles y condiciones de ejecución costará más que un simple contrato que ejecuta una sola operación.

#### Contrato no óptimo ❎

```rust
#![no_std]
use soroban_sdk::{contract, contractimpl, log, vec, Map, Env};

#[contract]
pub struct EjemploContract;

#[contractimpl]
impl ExampleContract {
    // Función para actualizar los valores en almacenamiento ineficientemente
    pub fn update_values(env: Env, valores: Vec<u32>) {
        para &valor en valores. ter() {
            let current_count = env.storage(). ersistent().get("total_count");
            env. torage().persistent().set("total_count", &(current_count + valor));
        }
    }
}

```

:::danger

**Problema**: Cada iteración del bucle realiza una operación de lectura y escritura separada para actualizar total_count en el almacenamiento.

**Inefficiente**: Esto resulta en múltiples operaciones de almacenamiento caras (leer y escribir) dentro del bucle, aumentando significativamente los costos de gas a medida que crece el tamaño de la matriz (values.len()).

:::

#### Contrato óptimo ✅

```rust
#![no_std]
use soroban_sdk::{contract, contractimpl, log, vec, Env, Map};

#[contract]
pub struct ExampleContract;

#[contractimpl]
impl ExampleContract {
    // Función para actualizar los valores en almacenamiento eficientemente
    pub fn update_values(env: Env, valores: Vec<u32>) {
        let mut total_count = env. torage().persistent().get("total_count");

        para &valor en valores. ter() {
            total_count += value;
        }

        env. torage().persistent().set("total_count", &total_count);
    }
}

```

:::tip

En este enfoque optimizado, acumularemos los cambios fuera del bucle y realizaremos una única actualización de almacenamiento y también una operación de lectura única. Esto reduce el número de operaciones de almacenamiento y el coste total del gas del contrato.

:::

## 2. **Uso adecuado de las operaciones por lotes**

Desde el primer ejemplo, podemos ver que las operaciones por lotes son más eficientes que las operaciones individuales. Esto se debe a que las operaciones por lotes reducen el número de llamadas externas a la cadena de bloques, lo que puede ser costoso. Sin embargo, hay algunos escenarios en los que el uso de las operaciones por lotes puede ser optimizado aún más. Los ejemplos se muestran a continuación.

#### Contrato no óptimo ❎

```rust
#![no_std]
use soroban_sdk::{contract, contractimpl, Address, Env, Symbol};
use soroban_sdk::token::Client as TokenClient;

#[contract]
pub struct TokenTransferContract;

#[contractimpl]
impl TokenTransferContract {
    // Ineficaz manera: Múltiples transferencias individuales
    pub fn transfer_tokens_inefficient(
        env: Env,
        token: Dirección,
        de: Dirección,
        a: Vec<Address>,
        monto_cada: i128,
    ) {
        let token_client = TokenClient::new(&env, &token);

        para el destinatario dentro. ter() {
            token_client. ransfer(&de, destinatario, &amount_each);
        }
    }
}
```

:::danger

Esta función realiza transferencias individuales para cada destinatario. Si bien es sencillo, es ineficiente porque cada transferencia es una llamada de subcontrato por separado, lo que potencialmente lleva a mayores costos de gas y a una ejecución más lenta.

:::

#### Contrato óptimo ✅

```rust
#![no_std]
use soroban_sdk::{contract, contractimpl, Address, Env, Symbol};
use soroban_sdk::token::Client as TokenClient;

#[contract]
pub struct TokenTransferContract;

#[contractimpl]
impl TokenTransferContract {
    // Efficiente manera: transferencia por lote
    pub fn transfer_tokens_efficient(
        env: Env,
        token: Dirección,
        desde: Dirección,
        a: Vec<Address>,
        monto_cada: i128,
    ) {
        let token_client = TokenClient::new(&env, &token);
        let total_amount = monto_cada * (a. es() como i128);

        // Realizar una sola transferencia por la cantidad total
        token_client. ransfer(&de, &env. urrent_contract_address(), &total_amount);

        // Luego distribuya desde el contrato
        para el destinatario dentro. ter() {
            token_client.transfer(&env. urrent_contract_address(), destinatario, &amount_each);
        }
    }
}
```

:::tip

Esta función optimiza el proceso por:

- En primer lugar, transfiriendo la cantidad total al propio contrato en una sola operación.
- Luego, distribuyendo las fichas del contrato a cada destinatario.

Las distribuciones internas son más baratas debido a la reducción en el número de costosas transacciones externas en blockchain. Al transferir la cantidad total al contrato y luego distribuirla internamente, el contrato minimiza el número de llamadas externas, reduciendo los costes de gas y mejorando la eficiencia.

:::

## 3. **Uso de eventos sobre el almacenamiento**

Los eventos son una forma rentable de almacenar datos a los que no es necesario acceder con frecuencia. Los eventos son más baratos que las operaciones de almacenamiento y se pueden utilizar para almacenar datos a los que no es necesario acceder con frecuencia.

#### Contrato por defecto

```rust
#![no_std]
use soroban_sdk::{
    contract, contractimpl, log, symbol_short, vec, Address, Env, Symbol,Map, Vec
};

#[contract]
pub struct GameContract;

#[contractimpl]
impl GameContract {
    // Function to record a game move and update storage
    pub fn record_move(env: Env, player: Address, move_type: Symbol) {
        let mut player_moves: Map<Address, Vec<Symbol>> = env.storage().persistent().get("player_moves");
        let moves = player_moves.get(&player);
        moves.push(move_type.clone());
        player_moves.set(player, moves);
        env.storage().persistent().set("player_moves", &player_moves);
    }

    // Function to unlock an achievement and update storage
    pub fn unlock_achievement(env: Env, player: Address, achievement: Symbol) {
        let mut player_achievements: Map<Address, Vec<Symbol>> = env.storage().persistent().get("player_achievements");
        let achievements = player_achievements.get(&player);
        achievements.push(achievement.clone());
        player_achievements.set(player, achievements);
        env.storage().persistent().set("player_achievements", &player_achievements);
    }

}
```

:::danger

No podemos almacenar todo en almacenamiento como lo haríamos en una base de datos tradicional. Este enfoque no es rentable ya que implica múltiples operaciones de almacenamiento para cada jugador que se mueva y ahorra cada logro en el almacenamiento

:::

#### Optimizado usando eventos

```rust
#![no_std]
use soroban_sdk::{
    contrato, contractimpl, log, symbol_short, vec, Dirección, Env, Symbol,Map, Vec,
};

#[contract]
pub struct GameContract;

#[contractimpl]
impl GameContract {
    // Función para grabar un movimiento de juego y emitir un evento
    pub fn record_move(env: Env, jugador: Dirección, move_type: Symbol) {
        // Emitir evento para el juego move
        env. vents().publish(("game_move",), (&player, move_type. lone()));
    }

    // Función para desbloquear un logro y emitir un evento
    pub fn unlock_achievement(env: Env, jugador: Dirección, achievement: Symbol) {
        // Emitir evento para el logro desbloqueado
        env. vents().publish(("achievement_unlocked",), (&player, achievement.clone()));
    }
}
```

:::tip

En este enfoque optimizado, utilizamos eventos para almacenar datos que no necesitan ser accedidos frecuentemente. Esto reduce el número de operaciones de almacenamiento y el coste total del gas del contrato.

:::

#### Desplazamientos:

El enfoque actual que utiliza los acontecimientos está optimizado para la eficiencia del gas, pero viene con su propio conjunto de compensaciones. Veamos diferentes enfoques y sus implicaciones:

**Enfoque actual (Usando eventos)**:

- Pros:

  - Ejercicio de gas porque minimiza las operaciones de almacenamiento
  - Útil para aplicaciones fuera de cadena que pueden escuchar y procesar eventos
  - Ideal para datos que no necesitan ser accedidos en cadena frecuentemente

- Contras:

  - Los datos no son accesibles directamente dentro del contrato
  - Depende de sistemas externos para capturar y procesar los datos del evento
  - No es adecuado si necesita consultar o validar movimientos pasados dentro del contrato

**Almacenar el último movimiento en almacenamiento persistente e historia en almacenamiento temporal**:

Este enfoque ofrece un equilibrio entre accesibilidad y eficiencia.

- Pros:

  - El último movimiento es siempre accesible en cadena
  - Los datos históricos están disponibles en la misma transacción
  - Más flexible para la lógica del contrato que podría necesitar historia reciente

- Contras:

  - Coste de gas ligeramente más alto que usar sólo eventos
  - El almacenamiento temporal se limpia después de cada transacción, por lo que los datos históricos no son permanentemente accesibles en cadena

## 4. **Uso de estructuras de datos eficientes**

Las matrices asignadas en el montón son lentas y costosas. Preferimos arreglos de tamaño fijo o `soroban_sdk::vec!`. Esto es crucial para arreglos grandes, ya que excede el tamaño de memoria lineal actual (un múltiplo de 64KB) activa `wasm32::memory_grow`, que es altamente intensivo en cálculos.

##### Ejemplo (Heap Allocated Array) ❎

```rust
let mut v1 = alloc::vec![];
```

##### Ejemplo (Array) ✅

```rust
let mut v2 = [0; 100];
```

Almacenar muchos objetos en un `Vec` puede ser ineficiente debido a la complejidad del tiempo lineal de las comprobaciones de membresía. Sin embargo, hay algunas alternativas a tener un 'Vec' engorroso:

##### Ejemplo (Almacenamiento Ineficiente) ❎

```rust
#![no_std]
use soroban_sdk::{contract, contractimpl, Dirección, Env, Symbol, Vec};

#[derive(Clone)]
estructura de pub PlayerMove {
    jugador: Dirección,
    move_type: Symbol,
}

#[derive(Clone)]
estructura de pub PlayerAchievement {
    jugador: Dirección,
    logro: Symbol,
}

#[contract]
pub struct NonOptimalGameContract;

#[contractimpl]
impl NonOptimalGameContract {
    // Función para grabar un movimiento para un jugador específico
    pub fn record_move(env: Env, player: Dirección, move_type: Symbol) {
        let mut all_moves: Vec<PlayerMove> = env. torage().persistent().get("all_moves").unwrap_or_default();
        all_moves. ush(PlayerMove { player: player.clone(), move_type });
        env.storage().persistent(). et("all_moves", &all_moves);
    }

    // Función para obtener movimientos para un jugador específico
    pub fn get_moves(env: Env, player: Address) -> Vec<Symbol> {
        let all_moves: Vec<PlayerMove> = env. torage().persistent().get("all_moves"). nwrap_or_default();
        all_moves
            . ter()
            . ilter(|m| m.player == jugador)
            . ap(|m| m.move_type.clone())
            . ollect()
    }

    // Función para desbloquear un logro para un jugador específico
    pub fn unlock_achievement(env: Env, player: Dirección, logro: Symbol) {
        let mut all_achievements: Vec<PlayerAchievement> = env. torage().persistent().get("all_achievements").unwrap_or_default();
        if !all_achievements.iter().any(|a| a.player == player && a. chievement == achievement) {
            all_achievements. ush(PlayerAchievement { player: player.clone(), achievement });
            env. torage().persistent(). et("all_achievements", &all_achievements);
        }
    }

    // Función para obtener logros para un jugador específico
    pub fn get_achievements(env: Env, player: Address) -> Vec<Symbol> {
        let all_achievements: Vec<PlayerAchievement> = env. torage().persistent().get("all_achievements"). nwrap_or_default();
        all_achievements
            . ter()
            . ilter(|a| a.player == player)
            .map(|a| a.achievement. lone())
            .collect()
    }
}
```

:::danger Esta versión no óptima tiene varias ineficiencias:

- Vec único para todos los datos:

  Todos los movimientos y logros se almacenan en Vecs individuales (all_moves y all_achievements), independientemente del jugador. Esto significa que cada operación requiere cargar y guardar todo el conjunto de datos, lo que resulta cada vez más caro a medida que crece el número de entradas.

- Operaciones lineales de búsqueda:

  Recuperar movimientos o logros para un jugador específico requiere iterar a través de todo el Vec, que tiene complejidad de tiempo O(n). Esto se hace muy lento e intensivo en gas a medida que aumenta el número de entradas.

- Almacenamiento de datos redundante:

  La dirección del jugador se almacena repetidamente para cada movimiento y logro, lo que conduce a una duplicación de datos innecesaria.

- Control de Logros Ineficientes:

  Antes de añadir un nuevo logro, el código se iterará a través de todos los logros para comprobar los duplicados, que es una operación de O(n).

- Ineficiencia del gas:

  Cada operación (añadiendo un movimiento, desbloqueando un logro, recuperando datos) requiere cargar y guardar todo el conjunto de datos, que es extremadamente eficiente.

- Problemas de escalabilidad:

  A medida que el número de jugadores y sus acciones aumentan, el rendimiento de este contrato se degradará significativamente.

- Falta de separación de datos:

  Los movimientos y los logros no están claramente separados en la estructura de almacenamiento, lo que hace que resulte más difícil de manejar y potencialmente llevar a la confusión en escenarios más complejos.

:::

##### Alternativo: usando vecs clavados ✅

```rust
#![no_std]
use soroban_sdk::{contract, contractimpl, Address, Env, Symbol, Vec};

#[derive(Clone)]
pub enum DataKey {
    Moves(Address),
    Achievements(Address),
}

#[contract]
pub struct GameContract;

#[contractimpl]
impl GameContract {
    // Function to record a move for a specific player
    pub fn record_move(env: Env, player: Address, move_type: Symbol) {
        let key = DataKey::Moves(player.clone());
        let mut moves: Vec<Symbol> = env.storage().persistent().get(&key).unwrap_or_default();
        moves.push(move_type.clone());
        env.storage().persistent().set(&key, &moves);
    }

    // Function to get moves for a specific player
    pub fn get_moves(env: Env, player: Address) -> Vec<Symbol> {
        let key = DataKey::Moves(player);
        env.storage().persistent().get(&key).unwrap_or_default()
    }

    // Function to unlock an achievement for a specific player
    pub fn unlock_achievement(env: Env, player: Address, achievement: Symbol) {
        let key = DataKey::Achievements(player.clone());
        let mut achievements: Vec<Symbol> = env.storage().persistent().get(&key).unwrap_or_default();
        if !achievements.contains(&achievement) {
            achievements.push(achievement);
            env.storage().persistent().set(&key, &achievements);
        }
    }

    // Function to get achievements for a specific player
    pub fn get_achievements(env: Env, player: Address) -> Vec<Symbol> {
        let key = DataKey::Achievements(player);
        env.storage().persistent().get(&key).unwrap_or_default()
    }
}
```

:::tip

Aquí hay un desglose de las optimizaciones y beneficios:

- Almacenamiento específico:

  Los movimientos y logros de cada jugador se almacenan por separado, permitiendo una recuperación eficiente de los datos específicos del jugador. El enum de DataKey proporciona una estructura clara para organizar diferentes tipos de datos asociados con direcciones.

- Acceso a datos eficientes:

  Usando el enum como clave, podemos acceder directamente a los datos de un jugador específico sin necesidad de buscar a través de una estructura de datos más amplia. Este enfoque es especialmente eficiente cuando necesitas acceder o actualizar frecuentemente los datos para los jugadores individuales.

- Estructura de datos flexible:

  El uso de `Vec<Symbol>` tanto para movimientos como para logros permite un número ilimitado de entradas para cada jugador. Esta estructura es adecuada para almacenar listas ordenadas de movimientos o logros únicos.

- Eficiencia del gas:

  Almacenando los datos por separado para cada jugador, evitamos tener que cargar y modificar una estructura de datos grande para cada operación. Esto puede dar lugar a un ahorro significativo de gas, especialmente a medida que aumenta el número de jugadores y la cantidad de datos.

- Separación clara de preocupaciones:

  El enum separa claramente diferentes tipos de datos (se mueve contra logros), haciendo el código más legible y mantenible.

- Extensibilidad fácil:

  Si necesitas añadir nuevos tipos de datos asociados con los jugadores, puedes ampliar fácilmente el enum de DataKey sin cambiar la estructura existente.

:::

## 5. **Uso de los mecanismos apropiados `env.storage`**

Existen tres tipos de mecanismos de almacenamiento en Stellar:

### [`env.storage().persistent()`](https://docs.rs/soroban-sdk/latest/soroban_sdk/storage/struct.Storage.html#method.persistent)

El almacenamiento persistente se utiliza para almacenar datos que deben conservarse a través de las invocaciones contractuales. Los datos almacenados en el almacenamiento persistente se mantienen entre las invocaciones del contrato y son accesibles a todas las funciones del contrato. El almacenamiento de datos aquí está destinado a permanecer en el contador indefinidamente hasta que se elimine explícitamente. Las entradas caducadas pueden ser restauradas pero no pueden ser recreadas.

#### Casos de uso

- Datos que requieren persistencia a largo plazo, tales como saldos de tokens y propiedades del usuario.
- Cuando los datos necesitan ser almacenados indefinidamente y deben sobrevivir incluso si expiran y necesitan ser restaurados.
- Ejemplos: saldos de fichas, propiedades del usuario.

#### Costo

- Más alto costo en comparación con otros debido a la persistencia a largo plazo.

#### Duración

- Los datos se comportan como si se almacenaran para siempre, pero pueden expirarse y ser restaurados.

### [`env.storage().temporary()`](https://docs.rs/soroban-sdk/latest/soroban_sdk/storage/struct.Storage.html#method.temporary)

El almacenamiento temporal se utiliza para almacenar datos que sólo son necesarios durante la invocación del contrato actual. Los datos almacenados en almacenamiento temporal se borran al final de la invocación del contrato y no son accesibles a otras funciones del contrato. El almacenamiento para los datos aquí se realiza con una vida útil limitada en el contador. Las entradas se eliminarán después de que termine su vida útil y pueden ser recreadas con diferentes valores.

#### Casos de uso

- Datos que sólo necesitan existir temporalmente, tales como datos de oráculos, saldos y ofertas reclamables.
- Cuando los datos sólo necesitan existir por un tiempo limitado y pueden ser recreados si es necesario.
- Ejemplos: datos Oracle, saldos reclamables, ofertas.

#### Costo

- Más barato que el almacenamiento persistente debido a la limitada vida útil de los datos. (Corro barato).

#### Duración

- Los datos existen para un período predefinido y luego se eliminan.

### [`env.storage().instance()`](https://docs.rs/soroban-sdk/latest/soroban_sdk/storage/struct.Storage.html#method.instance)

El almacenamiento aquí se hace para una pequeña cantidad de datos persistentes estrechamente acoplados a la instancia del contrato. Los datos se cargan desde el contador cada vez que se carga la instancia del contrato y están limitados por el tamaño de la entrada del contador normalmente en el orden de 100 KB serializado.

#### Casos de uso

- Datos pequeños directamente asociados con el contrato, tales como detalles de administración, configuración y tokens. Para datos pequeños y frecuentemente utilizados que son parte integrante de la instancia del contrato y se benefician de ser cargados cada vez que se utiliza el contrato.
- Ejemplos: Detalles del administrador del contrato, ajustes de configuración, tokens operados por el contrato.

#### Costo

- Probablemente más barato que almacenar datos por separado en almacenamiento persistente.

#### Duración

- Propiedades de por vida similares al almacenamiento persistente pero no aparece en la huella del libro de notas.

## 5. **Tamaño del contrato**

El tamaño del binario 'wasm' de su contrato inteligente influye en el costo de ejecutar su contrato inteligente en la red Stellar. Los binarios "wasm" más grandes requieren más potencia de procesamiento y memoria para ejecutarse, lo que conlleva mayores costos de gas. Los binarios más grandes también cuestan más gas para desplegar e invocar.

Para optimizar el tamaño de tu binario `wasm`, puedes:

- Eliminar código innecesario
- Minimizar el uso de dependencias externas
- Utilice herramientas integradas para optimizar el tamaño de su binario `wasm`

## Otros consejos para optimizar el coste del contrato inteligente:

### 1. **Uso de herramientas integradas**

Una forma de optimizar el tamaño de su binario `wasm` es usar el comando `soroban optimize`. Este comando viene del [CLI Soroban](https://www.google. om) optimizará el tamaño de su binario 'lavado' eliminando el código innecesario y reduciendo el tamaño del binario.

```bash
contrato estelar optimizar \
  --wasm target/wasm32-unknown-unknown/release/project.wasm
```

Otra forma de optimizar tu contrato inteligente es usar el comando `invoke contrato estelar` con las banderas `--cost` y `--sim-only`. Este comando le proporcionará un desglose detallado del coste de ejecutar su contrato inteligente en la red Stellar.

```bash
stellar contract invoke \
  --id C6MWZMG2JPQEENRL7XVICAY5RNMHJ2OORMUHXKRDID6MNGXSOJZLF \
  --source alice \
  --network testnet \
  --cost \
  --sim-only \
  -- \
  incremento
```

Referencia: https://sorobandev.com/guides/soroban-cli

### 2. **Revisión manual de código**

Realiza una revisión manual del código de tu contrato inteligente para identificar las áreas donde puedes optimizar el código. Busca bucles, condiciones y operaciones de almacenamiento redundantes que se puedan minimizar o eliminar.

### 3. **Pruebas unitarias con mediciones de gas**

Utilice pruebas unitarias para medir el coste de gas de sus funciones de contrato inteligente. Esto le ayudará a identificar funciones que están consumiendo mucho gas y optimizarlas en consecuencia.

Además, usar el método de ayuda rpc [simulateTransaction](/docs/data/rpc/api-reference/methods/simulateTransaction) puede darte una visión del costo de gas de tus funciones contractuales.

### 4. **Herramientas de análisis estáticos**

Herramientas como [Clippy](https://doc.rust-lang.org/clippy/) (parte del compilador de Rust) pueden identificar posibles problemas de rendimiento durante la etapa de compilación. Estas herramientas pueden advertir:

- Asignaciones innecesarias
- Código redundante

### 5. **Reconociendo ubicaciones de almacenamiento**

- #### Variables del Estado:

  - Coste: Las variables del estado se almacenan directamente en el almacenamiento del blockchain. El costo está influenciado principalmente por la cantidad de datos almacenados (medidos en bytes) y la frecuencia de operaciones de lectura y escritura.
  - Consideraciones: Escribir datos a variables de estado típicamente incurre en mayores costos de gas en comparación con datos de lectura. Las estructuras complejas de datos (por ejemplo, arrays, mapeos) o grandes cantidades de datos aumentan los costos de almacenamiento y el consumo de gas. Estelar cobra tasas de gas por cada byte de datos almacenados y actualizados, lo que hace que la gestión eficiente de datos sea crucial para la optimización de costes.

- #### Registros de eventos:

  - Precio: La emisión de eventos en los contratos de Rust no implica costes de almacenamiento directo, ya que los eventos no se almacenan permanentemente en la cadena de bloques. En su lugar, se incluyen en los registros de transacciones.
  - Consideraciones: La emisión de eventos consume gas, principalmente debido a los recursos computacionales necesarios para ejecutar la emisión de eventos y la generación de registros. Los eventos son útiles para aplicaciones fuera de la cadena y arquitecturas basadas en eventos pero no contribuyen directamente a los costos de almacenamiento en cadena.

- #### Fuentes de datos externas:

  - Coste: Interactuar con fuentes externas de datos como oráculos implica gastos de transacción para recuperación y procesamiento de datos.
  - Consideraciones: Oracle llama a los costos de gas incur para la ejecución del contrato, que puede variar en función de la complejidad y frecuencia de la obtención de datos. Los desarrolladores de contratos deben considerar los límites de gas y optimizar las interacciones de oráculo para minimizar los costos y al mismo tiempo asegurar la integración de datos fiables.

- #### Datos inmutables y constantes:

  - Coste: Las variables inmutables y constantes incurren en costes de almacenamiento, ya que son típicamente almacenados como parte del bytecode o metadatos del contrato.
  - Consideraciones: Los constantes y los datos inmutables son cruciales para la configuración y la parametrización del contrato, pero no tienen un impacto significativo en los costes de transacción o almacenamiento. Se predefinen durante el despliegue del contrato y no cambian durante la ejecución del contrato, evitando costes adicionales de gas para las actualizaciones de almacenamiento.

- #### Almacenamiento off-Chain e IPFS:
  - Coste: Almacenar datos fuera de la cadena utilizando soluciones como IPFS evita costos directos de almacenamiento en cadena, pero incurre en costos de recuperación de datos y uso de red IPFS.
  - Consideraciones: Los contratos almacenan sólo el hash o referencia a los datos fuera de la cadena en cadena, minimizando los costos de almacenamiento en cadena. Los costes de gas pueden aplicarse a la hora de recuperar y procesar datos fuera de la cadena, dependiendo de la complejidad y frecuencia de acceso. Las soluciones de almacenamiento off-chain ofrecen escalabilidad y flexibilidad, pero requieren una cuidadosa consideración de las tarifas de red y la disponibilidad de datos.

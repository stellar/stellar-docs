---
title: Pagos con rutas
sidebar_position: 60
description: Enviar un pago donde el activo recibido sea diferente del activo enviado.
---

En un pago con ruta, el activo recibido es diferente del activo enviado. En lugar de que la operación transfiera activos directamente de una cuenta a otra, los pagos con rutas cruzan a través del SDEX y/o Fondos de Liquidez antes de llegar a la cuenta de destino. Para que el pago con ruta tenga éxito, debe existir una oferta DEX o un camino de exchange mediante Fondos de Liquidez. A veces puede ser necesario realizar varios saltos de conversión para que tenga éxito.

Por ejemplo:

La Cuenta A vende XLM → [compra XLM / vende ETH → compra ETH / vende BTC → compra BTC / vende USDC] → La Cuenta B recibe USDC

Es posible que los pagos con rutas fallen si no existen rutas de exchange viables.

Para más información sobre el Stellar Decentralized Exchange y los Fondos de Liquidez, consulta nuestra [Liquidez en Stellar: Entrada de Enciclopedia sobre SDEX y Fondos de Liquidez](../../../learn/fundamentals/liquidity-on-stellar-sdex-liquidity-pools.mdx).

## Operaciones

Los pagos con rutas utilizan las operaciones Path Payment Strict Send o Path Payment Strict Receive.

### Path Payment Strict Send

Permite a un usuario especificar la cantidad del activo a enviar. La cantidad recibida variará según las ofertas en los libros de órdenes y/o Fondos de Liquidez.

### Path Payment Strict Receive

Permite a un usuario especificar la cantidad del activo recibido. La cantidad enviada variará según las ofertas en los libros de órdenes y Fondos de Liquidez.

## Pagos con rutas - más información

- Los pagos con rutas no permiten que las ofertas intermedias provengan de la cuenta de origen, ya que esto resultaría en una tasa de exchange peor. Debes dividir el pago con ruta en dos pagos con rutas más pequeños o asegurarte de que las ofertas de la cuenta de origen no estén en la parte superior del libro de órdenes.
- Los saldos se liquidan al final de la operación.
  - Esto es especialmente importante cuando (`Destination, Destination Asset) == (Source, Send Asset`) ya que proporciona una funcionalidad equivalente a obtener un préstamo sin intereses durante la duración de la operación.
- `Destination min` es una medida de protección, que te permite especificar un límite inferior para una conversión aceptable. Si las ofertas en los libros de órdenes no son lo suficientemente favorables para que la operación entregue esa cantidad, la operación fallará.

## Ejemplo

Primero, asegúrate de que el receptor tenga establecida una trustline para el activo que recibirá. En este ejemplo, usaremos USDC como el activo recibido. El remitente enviará XLM, que será convertido a USDC mediante la operación de pago con ruta.

```js
import {
  Horizon,
  Asset,
  Keypair,
  TransactionBuilder,
  Networks,
  BASE_FEE,
  Operation,
  Memo,
} from "@stellar/stellar-sdk";

const USDC_ISSUER = "GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5"; // USDC issuer on Stellar Testnet
const USDC_ASSET = new Asset("USDC", USDC_ISSUER); // USDC asset on Stellar Testnet
const RECEIVER_SECRET = "S..."; // Receiver's secret key

const SENDER_SECRET = "S..."; // Sender's secret key
const horizonServer = new Horizon.Server("https://horizon-testnet.stellar.org");

// Create a USDC trustline for the receiver
const receiverKP = Keypair.fromSecret(RECEIVER_SECRET);
let account = await horizonServer.loadAccount(receiverKP.publicKey());
let transaction = new TransactionBuilder(account, {
  fee: BASE_FEE * 100,
  networkPassphrase: Networks.TESTNET,
})
  .addOperation(
    Operation.changeTrust({
      asset: USDC_ASSET,
      limit: "10",
    }),
  )
  .addMemo(Memo.text("Trusting USDC"))
  .setTimeout(30)
  .build();

transaction.sign(receiverKP);
const resp = await SERVER.submitTransaction(transaction);
console.log("resp", resp);
```

Ahora enviemos un pago con ruta del remitente al receptor, convirtiendo XLM a USDC.

```js
// Use path payment to send XLM from the receiver to the sender, who receives USDC
let senderKP = Keypair.fromSecret(SENDER_SECRET);
let account = await horizonServer.loadAccount(senderKP.publicKey());
let transaction = new TransactionBuilder(account, {
  fee: BASE_FEE * 100,
  networkPassphrase: Networks.TESTNET,
})
  .addOperation(
    Operation.pathPaymentStrictReceive({
      sendAsset: Asset.native(), // Sending XLM
      sendMax: "10", // Maximum amount of XLM to send
      destAsset: USDC_ASSET, // Receiving USDC
      destAmount: "1", // Amount of USDC to receive
      destination: receiverKP.publicKey(), // Receiver's public key
    }),
  )
  .addMemo(Memo.text("XLM to USDC"))
  .setTimeout(30)
  .build();

transaction.sign(senderKP);
const resp = await horizonServer.submitTransaction(transaction);
console.log("resp", resp);
```

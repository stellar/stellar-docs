---
title: Crea un frontend para tu dapp usando React
description: Conecte las interfaces de dapp a contratos y cartera de carga usando @soroban-react.
---

import { Alert } from "@site/src/components/Alert";

Esta sección explica cómo los frontends de tu dapp pueden interactuar con los contratos de ejemplo y los datos de la cadena de acceso y conéctese a una cartera de cargueros. Esto se ilustrará utilizando bibliotecas proporcionadas por [`@soroban-react`](https://soroban-react.gitbook.io/index/), un framework simple y potente para construir Dapps modernas usando React. `@soroban-react` fue creado y es mantenido por un miembro increíble de la comunidad!

<Alert>

Esta guía demostrará cómo se desarrolló un frontend [ejemplo de crowdfund dapp] con React. Si bien gran parte del código es específico de este proyecto, los principios demostrados deben ser lo suficientemente educativos como para que empieces.

</Alert>

A continuación se muestra una lista de las bibliotecas utilizadas a través del código frontend y sus respectivas importaciones:

```jsx
import { SorobanReactProvider } from "@soroban-react/core";
import { testnet, sandbox, standalone } from "@soroban-react/chains";
importar { freighter } de "@soroban-react/freighter";
importar { ChainMetadata, Connector } de "@soroban-react/types";
import type {
  WalletChain,
  ChainMetadata,
  ChainName,
} from "@soroban-react/types";
importar { useSorobanReact } de "@soroban-react/core";
```

Estas importaciones incluyen `SorobanReactProvider` de `@soroban-react/core`, que es un proveedor de contexto usado para pasar la instancia SorobanReact a otros componentes. También importa varios tipos como `WalletChain`, `ChainMetadata`, y `ChainName`, que ayudan a mantener la seguridad de tipo dentro de nuestra aplicación.

## Componentes React y Prop Pasing

React impulsa su arquitectura basada en componentes. Los componentes son piezas reutilizables de código que devuelven un elemento React para ser renderizado en la página. Una aplicación típica de React consiste en múltiples componentes trabajando armoniosamente para crear una interfaz de usuario dinámica.

Veamos un componente del [ejemplo crowdfund dapp], el [componente MintButton\`](https://github.com/stellar/soroban-example-dapp/blob/07504b922bc75a48e5220711aea2cb4962f90367/components/molecules/form-pledge/index.tsx#L27):

```tsx
function MintButton({
  cuenta,
  decimales,
  mañana,
}: {
  cuenta: cadena;
  decimales: número; símbolo
  : cadena;
}) {
  const [isSubmitting, setSubmitting] = useState(false);
  const { activeChain, server } = useNetwork();
  const networkPassphrase = activeChain? etworkPassphrase ?? "";
  const { sendTransaction } = useSendTransaction();
  const amount = BigNumber(100);

  return <Button props omitted here />;
}
```

Este componente funcional toma tres propiedades como argumentos: `account`, `decimals` y `symbol`. Demuestra el concepto de paso de prop, una manera de pasar datos de los componentes padre a hijo en React. El accesorio `onComplete` incluso te permite pasar funciones a tus copos como accesorios. También vemos el gancho `useState` de React para la administración de estado local, un método para preservar valores entre las llamadas de función.

## Gestión del Estado y Hooks

La gestión estatal es otro concepto central de React, permitiendo a los componentes crear y administrar sus propios datos. El gancho `useState` es una característica introducida en React 16.8 que permite a los componentes funcionales tener su propio estado.

En el componente `MintButton`, el gancho `useState` se utiliza para administrar el estado `isSubmitting`:

```tsx
const [isSubmitting, setSubmitting] = useState(false);
```

El gancho `useState` devuelve un par de valores: el estado actual y una función que lo actualiza. En este caso, el estado `isSubmitting` se inicializa a `false` y la función `setSubmitting` se utiliza para actualizarlo. React también permite la creación de ganchos personalizados, como `useNetwork` y `useSendTransaction`, para encapsular y reutilizar la lógica de estado a través de múltiples componentes.

## Custom Hooks

Los ganchos React son funciones que le permiten “engancharse” el estado de React y las características del ciclo de vida de los componentes funcionales. Los ganchos personalizados te permiten encapsular la lógica compleja y hacerla reutilizable a través de los componentes. Echemos un vistazo a `useNetwork` y `useSendTransaction`, dos ganchos personalizados usados en el [ejemplo de crowdfund dapp].

El gancho `useNetwork` se utiliza para interactuar con la red blockchain, y el gancho `useSendTransaction` se utiliza para enviar transacciones. Estos ganchos abstraen la lógica compleja, haciendo más fácil leer y entender el código principal del componente.

Así es como usas estos ganchos en el componente `MintButton`:

```tsx
const { activeChain, server } = useNetwork();
const networkPassphrase = activeChain?.networkPassphrase ?? "";
const { sendTransaction } = useSendTransaction();
```

`useNetwork` proporciona la cadena activa y el servidor, y `useSendTransaction` nos da el método `sendTransaction`, que usarás más tarde para acuñar tokens. De esta manera, puede mantener el componente centrado en la lógica de renderizado y manejo de eventos, facilitando la prueba y el mantenimiento.

## Procesamiento asincrónico y manejo de errores robustos

Cuando se trata de operaciones que pueden tomar una cantidad impredecible de tiempo, como peticiones de red o, en nuestro caso, mintar tokens en la cadena de bloques, el soporte de React para operaciones asíncronas es crucial. Esto permite la ejecución del resto del código sin ser bloqueado por estas operaciones.

Vamos a sumergirnos en el fragmento de código que maneja el proceso de minting asíncrono:

```tsx
try {
  console.log("Minting the token...");
  const paymentResult = await sendTransaction(
    new SorobanClient.TransactionBuilder(adminSource, {
      networkPassphrase,
      fee: "1000",
    })
      .setTimeout(10)
      .addOperation(
        SorobanClient.Operation.payment({
          destination: walletSource.accountId(),
          asset: new SorobanClient.Asset(symbol, Constants.TokenAdmin),
          amount: amount.toString(),
        }),
      )
      .build(),
    {
      timeout: 10 * 1000,
      skipAddingFootprint: true,
      secretKey: Constants.TokenAdminSecretKey,
      sorobanContext,
    },
  );
  console.debug(paymentResult);
  sorobanContext.connect();
} catch (err) {
  console.log("Error while minting the token: ", err);
  console.error(err);
}
```

Este bloque es donde se produce la minting real de token. Está envuelto en un bloque 'try-catch', asegurando que cualquier error durante el proceso de minting sea capturado y manejado apropiadamente, impidiendo que la aplicación se bloquee y dándole la oportunidad de proporcionar comentarios al usuario.

La palabra clave `await` pausa la ejecución de la función hasta que se resuelva la promesa devuelta por `sendTransaction`. `sendTransaction` es una función obtenida de nuestro gancho `useSendTransaction`, y construye y envía una operación de pago a la red Stellar.

El método `sendTransaction` acepta dos argumentos: una instancia de `TransactionBuilder` y un objeto de opciones. El `TransactionBuilder` configura los detalles de la transacción, como la cuenta de origen, la contraseña de red, la cuota de transacción y las operaciones a realizar, en este caso, una operación de pago.

Si la transacción es exitosa, `paymentResult` contiene el resultado, el cual registras para propósitos de depuración. Si ocurre un error durante la transacción, la función arroja un error, el cual puede capturar y registrarse.

## Conclusión

React ofrece un montón de conceptos de alto nivel que pueden mejorar drásticamente su proceso de desarrollo web. Al entender y utilizar estos conceptos, como componentes, pases de props, gestión estatal, operaciones asincrónicas y manejo de errores, puede crear aplicaciones escalables, mantenibles y eficientes.

Recuerda, la clave para dominar React es la práctica. Así que, ¡siga construyendo y experimentando!

[ejemplo dapp crowdfund]: https://github.com/stellar/soroban-example-dapp

---
title: Restaurar datos de contrato archivados usando el SDK JavaScript
hide_table_of_contents: true
description: Restaurar datos de contrato persistentes archivados usando el SDK JavaScript.
---

Esta es una ocurrencia bastante probable: mi pieza de datos persistentes se archiva porque no he interactuado con mi contrato en un tiempo. ¿Cómo vuelvo a hacerla accesible?

Si encuentras que una pieza de datos persistentes es archivada, puede ser restaurada usando una transacción estelar que contiene una operación `RestoreFootprintOp`. Haremos dos supuestos por el bien de esta guía:

- La instancia del contrato en sí sigue en vivo (es decir, otros han estado extendiendo su TTL mientras usted estaba fuera).
- No sabes cómo se representan tus datos archivados en el libro de notas.

El proceso de restauración que utilizaremos implica tres pasos discretos:

1. Simula nuestra transacción como normalmente haríamos.
2. Si la simulación lo indicó, realizaremos la restauración con una operación `RestoreFootprintOp` usando las pistas que recibimos de la simulación.
3. Reintentamos ejecutar nuestra transacción inicial.

Aquí hay una función llamada `submitOrRestoreAndRetry()` que se encargará de todos esos pasos para nosotros:

:::info

Esta guía hace uso de la función `yeetTx` (nombre apropiado) que creamos en [otra guía](../transactions/submit-transaction-wait-js.mdx).

:::

```typescript
import {
  BASE_FEE,
  Networks,
  Keypair,
  TransactionBuilder,
  SorobanDataBuilder,
  SorobanRpc,
  xdr,
} from "@stellar/stellar-sdk"; // add'l imports to yeetTx
const { Api, assembleTransaction } = SorobanRpc;

// assume that `server` is the Server() instance from the yeetTx

async function submitOrRestoreAndRetry(
  signer: Keypair,
  tx: Transaction,
): Promise<Api.GetTransactionResponse> {
  // We can't use `prepareTransaction` here because we want to do
  // restoration if necessary, basically assembling the simulation ourselves.
  const sim = await server.simulateTransaction(tx);

  // Other failures are out of scope of this tutorial.
  if (!Api.isSimulationSuccess(sim)) {
    throw sim;
  }

  // If simulation didn't fail, we don't need to restore anything! Just send it.
  if (!Api.isSimulationRestore(sim)) {
    const prepTx = assembleTransaction(tx, sim);
    prepTx.sign(signer);
    return yeetTx(prepTx);
  }

  // Build the restoration operation using the RPC server's hints.
  const account = await server.getAccount(signer.publicKey());
  let fee = parseInt(BASE_FEE);
  fee += parseInt(sim.restorePreamble.minResourceFee);

  const restoreTx = new TransactionBuilder(account, { fee: fee.toString() })
    .setNetworkPassphrase(Networks.TESTNET)
    .setSorobanData(sim.restorePreamble.transactionData.build())
    .addOperation(Operation.restoreFootprint({}))
    .build();

  restoreTx.sign(signer);

  const resp = await yeetTx(restoreTx);
  if (resp.status !== Api.GetTransactionStatus.SUCCESS) {
    throw resp;
  }

  // now that we've restored the necessary data, we can retry our tx using
  // the initial data from the simulation (which, hopefully, is still
  // up-to-date)
  const retryTxBuilder = TransactionBuilder.cloneFrom(tx, {
    fee: (parseInt(tx.fee) + parseInt(sim.minResourceFee)).toString(),
    sorobanData: sim.transactionData.build(),
  });
  // because we consumed a sequence number when restoring, we need to make sure
  // we set the correct value on this copy
  retryTxBuilder.source.incrementSequenceNumber();

  const retryTx = retryTxBuilder.build();
  retryTx.sign(signer);

  return yeetTx(retryTx);
}
```

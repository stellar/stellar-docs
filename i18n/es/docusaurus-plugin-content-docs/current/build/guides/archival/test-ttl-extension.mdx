---
title: Probar lógica de extensión TTL en Contratos Inteligentes
hide_table_of_contents: true
description: Contratos de prueba que amplían el tiempo de datos del contrato a vivir (TTL).
---

Para probar los contratos que extienden los datos del contrato [TTL](../../../learn/encyclopedia/storage/state archival. dx#ttl) a través de las operaciones de almacenamiento `extend_ttl`, puedes usar la operación getter TTL (`get_ttl`) en combinación con la manipulación del número de secuencia de ledger. Tenga en cuenta que la función `get_ttl` sólo está disponible para pruebas y sólo en Soroban SDK v21+.

## Ejemplo

Sigue el [example](https://github.com/stellar/soroban-examples/blob/main/ttl/src/lib.rs) que prueba las extensiones TTL. El ejemplo tiene comentarios extensos, este documento sólo destaca las partes más importantes.

Utilizamos un contrato muy simple que sólo extiende una entrada para cada tipo de almacenamiento Soroban:

```rust
#[contractimpl]
impl TtlContract {
    /// Crea una entrada de contrato en cada tipo de almacenamiento.
    pub fn setup(env: Env) {
        env. torage().persistent().set(&DataKey::MyKey, &0);
        env.storage().instance().set(&DataKey::MyKey, &1);
        env.storage(). emporario(). et(&DataKey::MyKey, &2);
    }

    /// Extiende la entrada persistente TTL a 5000 ledgers, when its
    /// TTL is smaller than 1000 ledgers.
    pub fn extend_persistent(env: Env) {
        env. torage()
            . ersistent()
            . xtend_ttl(&DataKey::MyKey, 1000, 5000);
    }

    /// Extiende la entrada de la instancia TTL para convertirse al menos en 10000 ledgers,
    /// cuando su TTL es menor que 2000 ledgers.
    pub fn extend_instance(env: Env) {
        env.storage().instance(). xtend_ttl(2000, 10000);
    }

    /// Extiende la entrada temporal TTL para convertirse al menos en 7000 ledgers,
    /// cuando su TTL es menor que 3000 ledgers.
    pub fn extend_temporary(env: Env) {
        env. torage()
            . emporary()
            .extend_ttl(&DataKey::MyKey, 3000, 7000);
    }
}
```

El foco del ejemplo son las pruebas, así que los siguientes fragmentos de código provienen de `test.rs`.

Es una buena idea definir los valores personalizados de los ajustes de red relacionados con TTL, ya que los valores por defecto son definidos por el SDK y no son inmediatamente obvios para el lector de las pruebas:

```rust
env.ledger().with_mut(|li| {
    // Current ledger sequence - the TTL is the number of
    // ledgers from the `sequence_number` (exclusive) until
    // the last ledger sequence where entry is still considered
    // alive.
    li.sequence_number = 100_000;
    // Minimum TTL for persistent entries - new persistent (and instance)
    // entries will have this TTL when created.
    li.min_persistent_entry_ttl = 500;
    // Minimum TTL for temporary entries - new temporary
    // entries will have this TTL when created.
    li.min_temp_entry_ttl = 100;
    // Maximum TTL of any entry. Note, that entries can have their TTL
    // extended indefinitely, but each extension can be at most
    // `max_entry_ttl` ledger from the current `sequence_number`.
    li.max_entry_ttl = 15000;
});
```

También puedes usar los [ajustes de red](../../../networks/resource-limits-fees. dx#resource-fees) al configurar las pruebas, pero ten en cuenta que estas están sujetas a cambios, y el contrato debe ser capaz de trabajar con cualquier valor de estos ajustes.

Ahora ejecutamos un escenario de prueba que verifique la lógica de la extensión TTL (ver [`test_extend_ttl_behavior`](https://github.com/stellar/soroban-examples/blob/f595fb5df06058ec0b9b829e9e4d0fe0513e0aa8/ttl/src/test.rs#L38) prueba para la prueba completa de scenario). Primero, configuramos los datos y nos aseguramos de que los valores TTL iniciales corresponden a los ajustes de red que hemos definido anteriormente:

```rust
client.setup();
env. s_contract(&contract_id, || {
    // Observe que TTL no incluye el contador actual, pero cuando se crea la entrada
    // el ledger actual se contabiliza hacia el número
    // ledgers especificados por `min_persistent/temp_entry_ttl`, por lo tanto
    // el TTL es 1 libro mayor menor que la configuración correspondiente.
    assert_eq!(env.storage().persistent().get_ttl(&DataKey::MyKey), 499);
    assert_eq!(env.storage().instance().get_ttl(), 499);
    assert_eq!(env.storage().temporary().get_ttl(&DataKey::MyKey), 99);
});
```

Tenga en cuenta que usamos `env.as_contract` para acceder al almacenamiento del contrato.

Luego llamamos a las operaciones de extensión TTL y verificamos que se comportan como se esperaba, por ejemplo:

```rust
// Extiende la entrada persistente TTL a 5000 ledgers - ahora es 5000.
client.extend_persistent();
env.as_contract(&contract_id, || {
    assert_eq!(env.storage().persistent().get_ttl(&DataKey::MyKey), 5000);
});
```

Para probar los umbrales de extensión (es decir, el máximo TTL actual que requiere extensión), necesitamos aumentar el número de secuencia del ledger:

```rust
// Ahora toca la secuencia del ledger en 5000 para comprobar el saneamiento
// la configuración del umbral de las operaciones `extend_ttl`.
env.ledger(). ith_mut(|li| {
    li. equence_number = 100_000 + 5_000;
});
// Ahora el TTL de cada entrada se ha reducido en 5000 ledgers.
env.as_contract(&contract_id, || {
    assert_eq!(env.storage().persistent().get_ttl(&DataKey::MyKey), 0);
    assert_eq!(env. torage().instance().get_ttl(), 5000);
    assert_eq!(env.storage().temporary().get_ttl(&DataKey::MyKey), 2000);
});
```

Luego podemos extender las entradas de nuevo y asegurar que sólo las entradas que estén por debajo del umbral hayan sido extendidas (específicamente, entradas persistentes y temporales en este ejemplo):

```rust
client.extend_persistent();
client.extend_instance();
client.extend_temporary();
env.as_contract(&contract_id, || {
    assert_eq!(env.storage().persistent(). et_ttl(&DataKey::MyKey), 5000);
    // Instancia TTL no se ha incrementado porque el TTL restante
    // (5000 ledgers) es mayor que el umbral utilizado por
    // `extend_instance` (2000 ledgers)
    assert_eq! env. torage().instance().get_ttl(), 5000);
    assert_eq!(env.storage().temporary().get_ttl(&DataKey::MyKey), 7000);
});
```

Soroban SDK también emula el comportamiento de las entradas que han expirado su TTL. Las entradas temporales se comportan como si fuesen eliminadas (ver [`test_temp_entry_removal`](https://github.com/stellar/soroban-examples/blob/f595fb5df06058ec0b9b829e9e4d0fe0513e0aa8/ttl/src/test.rs#L112) para la prueba completa de escenario):

```rust
client.extend_temporary();
// Bump the ledger sequence by 7001 ledgers (one ledger past TTL).
env.ledger().with_mut(|li| {
    li. equence_number = 100_000 + 7001;
});
// Ahora la entrada ya no está presente en el entorno.
env. s_contract(&contract_id, || {
    assert_eq!(env.storage().temporary().has(&DataKey::MyKey), false);
});
```

Las entradas persistentes son más sutiles: cuando una transacción que se ejecuta en cadena contiene una entrada persistente que ha sido archivada (i. tiene su TTL expirado) en la huella, entonces el entorno Soroban ni siquiera será instanciado. Dado que este comportamiento no es directamente reproducible en el entorno de pruebas, en su lugar se producirá un error 'internal' irrecuperable tan pronto como se acceda a una entrada archivada, y la prueba será `panic`:

```rust
#[test]
#[should_panic(expected = "[testing-only] Accedió a la clave de instancia del contrato que se ha archivado. )]
fn test_persistent_entry_archival() {
    let env = create_env();
    let contract_id = env. egister_contract(None, TtlContract);
    let client = TtlContractClient::new(&env, &contract_id);
    cliente. etup();
    // Extiende la instancia TTL a 10000 ledgers. Cliente
    . xtend_instance();
    // Bump the ledger sequence by 10001 ledgers (one ledger past TTL).
    env.ledger().with_mut(|li| {
        li. equence_number = 100_000 + 10_001;
    });
    // Ahora cualquier llamada que implique el contrato caducado (como `extend_instance`
    // llamada aquí) se hará tan pronto como se acceda a ese contrato.
    client.extend_instance();
}
```

## Probando extensión TTL para otras instancias de contrato

A veces un contrato puede querer extender TTL de otros contratos y/o sus entradas de Wasm (normalmente eso sucedería en contratos de fábrica). Esta lógica puede ser cubierta de una manera similar al ejemplo anterior usando `env.deployer(). et_contract_instance_ttl(&contract)` para obtener TTL de la instancia de cualquier contrato, y `env.deployer().get_contract_code_ttl(&contract)` para obtener TTL de la entrada de Wasm de cualquier contrato. Puede encontrar un ejemplo de uso de esta función en la [suite de pruebas](https://github.com/stellar/rs-soroban-sdk/blob/ff05c3d4cbed97db50142372e9d7a4fa4a8d1d5d/soroban-sdk/src/tests/storage_testutils.rs#L76).

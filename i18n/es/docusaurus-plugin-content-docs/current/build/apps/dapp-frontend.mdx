---
sidebar_position: 70
title: Construir una interfaz de Dapp
description: Crea una aplicación web frontend que interactúe con tus contratos inteligentes.
pagination_prev: build/smart-contracts/getting-started/deploy-increment-contract
---

Esta es una continuación del [tutorial iniciado](../smart-contracts/getting-started/README.mdx), donde deberías haber desplegado dos contratos inteligentes a la red pública. En esta sección, crearemos una aplicación web que interactúa con los contratos mediante llamadas RPC.

Comencemos.

## Inicializar una toolchain del frontend

Puede construir una aplicación Soroban con cualquier toolchain de interfaz o integrarla en cualquier aplicación de full-stack existente. Para este tutorial, vamos a usar [Astro](https://astro.build/). Astro trabaja con React, Vue, Svelte, cualquier otra biblioteca de interfaz de usuario o ninguna biblioteca de interfaz de usuario. En este tutorial, no estamos usando una biblioteca de interfaz de usuario. Las partes específicas de Soroban de este tutorial serán similares sin importar qué herramienta de interfaz use.

Si eres nuevo en frontend, no te preocupes. No vamos demasiado profundo. Pero será útil para usted ver y experimentar el proceso de desarrollo del frontend utilizado por las aplicaciones Soroban. Vamos a cubrir los bits relevantes de JavaScript y Astro, pero enseñar todo el desarrollo de frontend y Astro está más allá del alcance de este tutorial.

Comencemos.

Necesitarás [Node.js](https://nodejs.org/en/download/package-manager/) v18.14.1 o superior. Si aún no lo has hecho, instálalo ahora.

Queremos inicializar nuestro proyecto actual como un proyecto Astro. Para hacer esto, podemos volver a girar al comando `stellar contract init`, que tiene una bandera `--frontend-template` que nos permite pasar la url de un repositorio de plantillas de frontend. Como aprendimos en [Almacenando datos](../smart-contracts/getting-started/storing-data.mdx#adding-the-increment-contract), `stellar contract init` no sobreescribirá los archivos existentes, y es seguro de usarlos para añadir a un proyecto existente.

Desde nuestro directorio `soroban-hello-world`, ejecuta el siguiente comando para añadir los archivos de plantilla de Astro.

```sh
stellar contract init ./ \
  --frontend-template https://github.com/stellar/soroban-astro-template
```

Esto añadirá lo siguiente a tu proyecto, el cual iremos más detallados a continuación.

```bash
├── CONTRIBUTING.md
├── initialize.js
├── package-lock.json
├── package.json
├── packages
├── public
│   └── favicon.svg
├── src
│   ├── components
│   │   └── Card.astro
│   ├── env.d.ts
│   ├── layouts
│   │   └── Layout.astro
│   └── pages
│       └── index.astro
└── tsconfig.json
```

## Generar un paquete NPM para el contrato Hola World

Antes de abrir los nuevos archivos frontend, vamos a generar un paquete de NPM para el contrato Hello World. Esta es nuestra forma sugerida de interactuar con los contratos de frontends. Estas bibliotecas generadas funcionan con cualquier proyecto JavaScript (no una interfaz específica como React), y hacer que sea fácil trabajar con algunos de los bits más complicados de Soroban, como la codificación [XDR](. /../learn/encyclopedia/contract-development/types/fully-typed-contracts.mdx).

Esto va a utilizar el comando CLI `stellar contract bindings typescript`:

```bash
stellar contract bindings typescript \
  --network testnet \
  --contract-id $(cat .stellar/contract-ids/hello_world.txt) \
  --output-dir packages/hello_world
```

Este proyecto está configurado como un espacio de trabajo de NPM, por lo que la biblioteca de clientes `hello_world` fue generada en el directorio `packages` en `packages/hello_world`.

Intentamos mantener el código en estas bibliotecas generadas legibles, así que sigamos adelante y miremos hacia el futuro. Abre el nuevo directorio `packages/hello_world` en tu editor. Si has construido o contribuido a proyectos de Node, todo se verá familiar. Verás un archivo `package.json`, un directorio `src`, un `tsconfig.json`, e incluso un README.

## Generar un paquete NPM para el contrato Increment

Aunque podemos ejecutar `soroban contract bindings typescript` para cada uno de nuestros contratos individualmente, la [soroban-astro-template](https://github. om/stellar/soroban-astro-templation) que usamos como nuestra plantilla incluye un muy práctico `initialize. s` script que manejará esto para todos los contratos en nuestro directorio `contracts`.

Además de generar los paquetes NPM, `initialize.js` también:

- Generar y depositar fondos en nuestra cuenta Stellar
- Construir todos los contratos en el directorio `contracts`
- Desplegar nuestros contratos
- Crear clientes de contratos prácticos para cada contrato

Ya nos hemos ocupado de los tres primeros puntos de bala en pasos anteriores de este tutorial, así que esas tareas serán noops cuando ejecutemos `initialize. s`.

### Configurar initialize.js

Necesitamos asegurarnos de que `initialize.js` tenga todas las variables de entorno que necesita antes de hacer cualquier otra cosa. Copia el archivo `.env.example` a `.env`. Las variables de entorno establecidas en `.env` son usadas por el script `initialize.js`.

```bash
cp .env.example .esv
```

Echemos un vistazo al contenido del archivo `.env`:

```
# Prefijo con "PUBLIC_" para poner disponible en los archivos de Astro frontend
PUBLIC_SOROBAN_NETWORK_PASSPHRASE="Red independiente ; Febrero de 2017"
PUBLIC_SOROBAN_RPC_URL="http://localhost:8000/soroban/rpc"

SOROBAN_ACCOUNT="me"
SOROBAN_NETWORK="standalone"

# vars env que comienzan con PUBLIC_ estarán disponibles para el cliente
PUBLIC_SOROBAN_RPC_URL=$SOROBAN_RPC_URL
```

Este `. el archivo nv` por defecto se conecta a una red que se ejecuta localmente pero queremos configurar nuestro proyecto para comunicarnos con Testnet, ya que ahí es donde desplegamos nuestros contratos. Para hacer eso, vamos a actualizar el archivo `.env` para que se vea así:

```diff
# Prefijo con "PUBLIC_" para poner disponible en los archivos de Astro frontend
-PUBLIC_SOROBAN_NETWORK_PASSPHRASE="Red independiente ; Febrero 2017"
+PUBLIC_SOROBAN_NETWORK_PASSPHRASE="Probar red SDF ; Septiembre de 2015"
-PUBLIC_SOROBAN_RPC_URL="http://localhost:8000/soroban/rpc"
+PUBLIC_SOROBAN_RPC_URL="https://soroban-testnet. tellar.org:443"

-SOROBAN_ACCOUNT="me"
+SOROBAN_ACCOUNT="alice"
-SOROBAN_NETWORK="standalone"
+SOROBAN_NETWORK="testnet"
```

:::info

Este archivo `.env` se utiliza en el script `initialize.js`. Al usar la CLI, todavía podemos usar la configuración de red que configuramos en la [Setup](.. paso smart-contracts/getting-started/setup.mdx), o pasando las banderas `--rpc-url` y `--network-passphrase`.

:::

### Ejecuta `initialize.js`

Primero instalemos las dependencias de Javascript:

```bash
npm install
```

Y luego ejecutemos `initialize.js`:

```bash
npm ejecutar init
```

Como se mencionó anteriormente, este script intenta construir e implementar nuestros contratos, lo que ya hemos hecho. El script es lo suficientemente inteligente para comprobar si un paso ya ha sido tomado en cuenta, y es un no-op en ese caso, por lo que es seguro ejecutar más de una vez.

### Llamar al contrato desde el frontend

Ahora abramos `src/pages/index.astro` y echemos un vistazo a cómo el código del frontend se integra con el paquete NPM que creamos para nuestros contratos.

Aquí podemos ver que estamos importando nuestro cliente `helloWorld` generado desde `../contracts/hello_world`. Entonces estamos invocando el método `hola` y añadiendo el resultado a la página.

```ts title="src/pages/index.astro"
---
import Layout from "../layouts/Layout.astro";
import Card from "../components/Card.astro";
import helloWorld from ".. contracts/hello_world";
const { result } = await helloWorld.hello({ to: "you" });
const saludando = resultado. oin(" ");
---

 ...

<h1>{greeting}</h1>
```

¡Vamos a verlo en acción! Iniciar el servidor dev:

```bash
npm run dev
```

Y abre [localhost:4321](http://localhost:4321) en tu navegador. ¡Debería ver el saludo del contrato!

Puedes intentar actualizar el argumento `{ to: 'Soroban' }`. Al guardar el archivo, la página se actualizará automáticamente.

:::info

Cuando inicias el servidor dev con `npm run dev`, verás una salida similar en tu terminal como cuando ejecutaste `npm run init`. Esto es porque el script `dev` en el paquete. hijo está configurado para ejecutar `npm run init` y `astro dev`, para que pueda asegurarse de que su contrato desplegado y su paquete NPM generado están siempre sincronizados. Si desea iniciar el servidor dev sin el script initialize.js, puede ejecutar `npm run astro dev`.

:::

### ¿Qué está pasando aquí?

Si inspeccionas la página (clic derecho, inspeccionar) y actualizas, verás un par de cosas interesantes:

- La pestaña "Red" muestra que no hay peticiones Fetch/XHR hechas. Pero las llamadas RPC ocurren a través de Fetch/XHR! Entonces, ¿cómo llama el frontend al contrato?
- No hay JavaScript en la página. Pero acabamos de escribir algo de JavaScript! ¿Cómo funciona?

Esto es parte de la propaganda de Astro: el frontend debe tener el menor número de activos posible. Preferiblemente cero JavaScript. Cuando pones JavaScript en la [frontmatter](https://docs.astro. uild/es/core-concepts/astro-components/), Astro lo ejecutará en tiempo de construcción, y luego reemplazará cualquier cosa en los llaves de `{...}` con la salida.

Cuando se utiliza el servidor de desarrollo con `npm run dev`, se ejecuta el código frontmatter en el servidor, e inyecta los valores resultantes en la página del cliente.

Puedes intentar construir esto de forma más dramática:

```bash
npm run build
```

Luego revisa la carpeta `dist`. Verás que construyó un archivo HTML y CSS, pero no JavaScript. Y si miras el archivo HTML, verás un "Hola Soroban" estático en el `<h1>`.

Durante la construcción, Astro hizo una sola llamada a su contrato, luego inyectó el resultado estático en la página. Esto es ideal para métodos contractuales que no cambian, pero probablemente no funcionarán para la mayoría de los métodos contractuales. Vamos a integrar con el contrato 'incrementor' para ver cómo manejar métodos interactivos en Astro. -->

## Llamar al contrato del incrementor desde el frontend

Mientras que `hello` es un método simple de solo vista/lectura, `increment` cambia en estado de cadena. Esto significa que alguien necesita firmar la transacción. Así que necesitaremos añadir capacidades de firma de transacciones al frontend.

La forma de firmar funciona en un navegador es con un _wallet_. Las billeteras pueden ser aplicaciones web, extensiones del navegador, aplicaciones independientes o incluso dispositivos de hardware separados.

### Instalar extensión de Freighter

Ahora mismo, la cartera que mejor soporta Soroban es [Freighter](../guides/freighter/README.mdx). Está disponible como complemento de Firefox, así como extensiones para Chrome y Brave. Sigue adelante y [instálalo ahora](https://freighter.app).

Una vez instalado, ábrelo haciendo clic en el icono de la extensión. Si esta es su primera vez usando Freighter, necesitará crear una nueva cartera. Siga las instrucciones para crear una contraseña y guardar su frase de recuperación.

Vaya a Ajustes (el icono del engranaje) → Preferencias y active el interruptor para Activar el modo experimental. A continuación, vuelva a su pantalla de inicio y seleccione "Probar Net" en la lista desplegable superior derecha. Por último, si muestra el mensaje de que su dirección Stellar no está financiada, siga adelante y haga clic en el botón "Fondo con Friendbot".

Ahora todo está configurado para usar Freighter como usuario, y puedes añadirlo a tu aplicación.

### Añadir carguero

Vamos a añadir un botón de "Conectar" a la página que abre el carguero y pide al usuario que le otorgue permiso a su página web para usar el carguero. Una vez que concedan este permiso, el botón "Conectar" será reemplazado por un mensaje diciendo: "Firmado como [su clave pública]".

Primero, añade [@stellar/freighter-api](https://www.npmjs.com/package/@stellar/freighter-api) como dependencia:

```bash
npm install @stellar/freighter-api
```

Ahora vamos a añadir un nuevo componente al directorio `src/components` llamado `ConnectFreighter.astro` con el siguiente contenido:

```html title="src/components/ConnectFreighter.astro"
<div id="freighter-wrap" class="wrap" aria-live="polite">
  <div class="ellipsis">
    <button data-connect aria-controls="freighter-wrap">Conecta</button>
  </div>
</div>

<style>
  . rap {
    text-align: center;
  }

  .ellipsis {
    line-height: 2. rem;
    margen: auto;
    max-width: 12rem;
    overflow: hidden;
    text-overflow: ellipsis;
    text-align: centro;
    espacios blancos: nowrap;
  }
</style>

<script>
  import { isAllowed, setAllowed, getUserInfo } from '@stellar/freighter-api';

  const wrap = documento. uerySelector('#freighter-wrap');
  const ellipsis = document.querySelector('#freighter-wrap .ellipsis');
  const button = documento. uerySelector('[data-connect]');

  async function getPk() {
    const { publicKey } = await getUserInfo();
    return publicKey;
  }

  async function setLoggedIn(publicKey: string) {
    ellipsis. nnerHTML = `Firmado como ${publicKey}`;
    ellipsis. itle = publicKey;
  }

  if (await isAllowed()) {
    const publicKey = await getPk();
    if (publicKey) setLoggedIn(publicKey);
    else wrap. nnerHTML = 'Freighter está bloqueado.<br>Inicie sesión y actualice la página. ;
  } else {
    button.addEventListener('click', async () => {
      botón. isabled = true;
      await setAllowed();
      const publicKey = await getPk();
      await setLoggedIn(publicKey);
    });
  }
</script>
```

Algo de esto puede parecer sorprendente. `<style>` y `<script>` etiquetas en el centro de la página? Nombres de clase no creativos como `wrap`? `import` declaraciones en un `<script>`? Top-level `await`? ¿Qué está pasando aquí?

Astro alza automáticamente los estilos dentro de un componente a ese componente, así que no hay ninguna razón para que tengamos nombres inteligentes para nuestras clases.

Y todas las declaraciones de `script` se agrupan e incluyen inteligentemente en la página. Incluso si utiliza el mismo componente varias veces, el script sólo se incluirá una vez. Y sí, puedes usar el nivel superior `await`.

Puedes leer más sobre esto en [la página de Astro's sobre scripts del lado del cliente](https://docs.astro.build/en/guides/client-side-scripts/).

El código en sí es bastante autoexplicativo. Importamos algunos métodos de `@stellar/freighter-api` para comprobar si el usuario está conectado. Si ya lo son, entonces `isAllowed` devuelve `true`. Si ha pasado más de un día desde que han usado la extensión de carga, entonces la `publicKey` estará en blanco, por lo que les decimos que desbloqueen Freighter y actualicen la página. Si `isAllowed` y la `publicKey` se ven bien, reemplazamos el contenido del `div` con el mensaje de inicio de sesión, reemplazando el botón. De lo contrario, añadimos un manejador de clic al botón para pedir al usuario que conecte Freighter con `setAllowed`. Una vez que lo hacen, reemplazamos de nuevo el contenido del 'div' por el mensaje de inicio de sesión. Las [`aria`](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions) aseguran que los lectores de pantalla leerán los nuevos contenidos cuando se actualicen.

Ahora podemos importar el componente en la interfaz de `pages/index.astro`:

```diff title="pages/index.astro"
 ---
 import Layout from '../layouts/Layout.astro';
 import Card from '../components/Card.astro';
 import helloWorld from "../contracts/hello_world";
+import ConnectFreighter from '../components/ConnectFreighter.astro';
...
```

Y agrégalo justo debajo de `<h1>`:

```diff title="pages/index.astro"
<h1>{greeting}</h1>
+<ConnectFreighter />
```

Si ya no está ejecutando su servidor de desarrollo, siga adelante y reinicie:

```bash
npm run dev
```

Luego abra la página y haga clic en el botón "Conectar". Deberías ver aparecer el carguero y pedirte que inicies sesión. Una vez que lo haga, el botón debe ser reemplazado por un mensaje diciendo: "Firmado como [tu clave pública]".

¡Ahora estás listo para firmar la llamada al `incremento`!

### Llame a `increment`

Ahora podemos importar el cliente de contrato `increment` de `soroban_increment_contract` y empezar a usarlo. Volveremos a crear un nuevo componente Astro. Crea un nuevo archivo en `src/components/Counter.astro` con el siguiente contenido:

```html title="src/components/Counter.astro"
<strong>Incrementador</strong><br />
Valor actual: <strong id="current-value" aria-live="polite">???</strong><br />
<br />
<button data-increment aria-controls="current-value">Incremento</button>

<script>
  Incrementador de importación de ". /contracts/soroban_increment_contract";
  import { isAllowed, getPublicKey, signTransaction } from '@stellar/freighter-api';
  const button = documento. uerySelector("[data-increment]");
  const currentValue = documento. uerySelector("#current-value");
  if (await isAllowed()) {
    const publicKey = await getPublicKey();
    if (publicKey) incrementor. ptions.publicKey = publicKey;
  }
  button.addEventListener("click", async () => {
    botón. isabled = true;
    button.classList.add("cargando");
    currentValue.innerHTML =
      currentValue. nnerHTML +
      '<span class="visually-hidden"> – actualizar…</span>';

    const tx = await incrementor. ncrement();
    const { result } = await tx. ignAndSend({signTransaction});

    // Solo usa `innerHTML` con los valores del contrato en los que confías!
    // ¡Utilizar ciegamente los valores de un contrato no fiable abre a sus usuarios a ataques de inyección de scripts!
    currentValue. nnerHTML = result.toString();

    button.disabled = false;
    button.classList.remove("cargando");
  });
</script>
```

Esto debería ser algo familiar a estas alturas. Tenemos un `script` que, gracias al sistema de compilación de Astro, puede `importar` módulos directamente. Utilizamos `document.querySelector` para encontrar los elementos definidos arriba. Y añadimos un manejador de `click` al botón, que llama `increment` y actualiza el valor de la página. También ajusta el botón a 'desactivado' y añade una clase 'cargando' mientras la llamada está en curso para evitar que el usuario haga clic de nuevo y comunique visualmente que algo está sucediendo. Para las personas que utilizan lectores de pantalla, el estado de carga se comunica con el [visually-hidden](https://www.a11yproject. om/posts/how-to-hide-content/) extensión, que será anunciada gracias a las etiquetas `aria` que vimos anteriormente.

La mayor diferencia con la llamada a `greeter.hello` es que esta transacción se ejecuta en dos pasos. La llamada inicial al 'incremento' construye una transacción Soroban y luego hace una llamada RPC a _simulate_ ella. Para llamadas de sólo lectura como `hola`, esto es todo lo que necesitas, así que puedes obtener el `resultado` de inmediato. Para llamadas de escritura como `increment`, entonces necesitas `signAndSend` antes de que la transacción realmente se incluya en el ledger.

:::info

Destructurando `{ result }`: Si eres nuevo en JavaScript, puede que no sepa lo que está pasando con esas líneas `const { result }`. Esta es la función _destructuring_ de JavaScript. Si la cosa a la derecha del signo de iguales es un objeto, entonces puede usar este patrón para tomar rápidamente claves específicas de ese objeto y asignarlas a las variables. También puede nombrar la variable otra cosa, si lo desea. Por ejemplo, intente cambiar el código anterior a:

```ts
const { result: newValue } = ...
```

:::

Además, ten en cuenta que no necesitas especificar manualmente Freighter como el monedero en la llamada a «incremento». Esto puede cambiar en el futuro, pero mientras que Freighter es el único juego en la ciudad, estas bibliotecas generadas lo utilizan automáticamente. Si quieres anular este comportamiento, puedes pasar una opción `wallet`; revisa la última interfaz `Wallet` en [la fuente de la plantilla](https://github.com/stellar/soroban-tools/blob/main/cmd/crates/soroban-spec-typescript/src/project_template/src/method-options.ts) para más detalles.

Ahora vamos a usar este componente. En `pages/index.astro`, primero importarlo:

```diff title="pages/index.astro"
 ---
 import Layout from '../layouts/Layout.astro';
 import Card from '../components/Card.astro';
 import helloWorld from ".. contracts/hello_world";
 import ConnectFreighter from '../components/ConnectFreighter.astro';
+import Counter from '../components/Counter.astro';
...
```

Entonces utilícelo. Sustituyamos el contenido del párrafo `instructions` con él:

```diff title="pages/index.astro"
 <p class="instructions">
- Para empezar, abra el directorio <code>src/pages</code> en su proyecto.<br />
- Desafío de código  <strong>:</strong> Retire el mensaje "Bienvenido a Astro" anterior.
+  <Counter />
 </p>
```

Compruebe la página; si todavía está ejecutando su servidor dev debería haber actualizado. Haz clic en el botón "Incrementar"; deberías ver una confirmación del Transportista. Confirmar... el valor actualizado! 🎉

Obviamente, faltan algunas funciones, sin embargo. Por ejemplo, que `???` es un bummer. Pero nuestro contrato 'incremento' no nos da una manera de cuestionar el valor actual sin también actualizarlo.

Antes de intentar actualizarlo, vamos a estirar el proceso alrededor de la construcción, el despliegue y la generación de clientes para los contratos.

## Llevar más lejos

Si quieres llevarlo un poco más lejos y asegurarte de que entiendes todas las piezas aquí, prueba lo siguiente:

- Crea una carpeta `src/contracts` con un `greeter.ts` y un `incrementor.ts`. Mover el `new Contract({ ... })` lógica en esos archivos. También puedes querer extraer la variable `rpcUrl` a un archivo `src/contracts/utils.ts`.
- Añade un método `get_value` al contrato `increment` y úsalo para mostrar el valor actual en el componente `Counter`. Cuando ejecutas `npm run dev`, el script `initialize` se ejecutará y actualizará el contrato y el cliente generado.
- Añade un botón de "Decremento" al componente 'Contador'.
- [Deploy](https://docs.astro.build/en/guides/deploy/) tu frontend. Puedes hacer esto de forma rápida y gratuita [con GitHub](https://docs.astro.build/en/guides/deploy/github/). Si te quedas atascado instalando stellar-cli e implementando contratos en GitHub, revisa [cómo hicimos esto](https://github.com/AhaLabs/soroban-tutorial-project/commit/c1f4cfde1bbaf059507100767ee6b43d29b42914).
- En lugar de usar scripts NPM para todo, intenta usar un runner de scripts más elegante como [just](https://github.com/casey/just). Los `scripts` de npm existentes pueden entonces llamar a `just`, como `"setup": "just setup"`.
- Actualiza README para explicar qué es este proyecto y cómo utilizarlo a posibles colaboradores y empleadores 😉

## Solución de problemas

A veces las cosas van mal. Como primer paso cuando solucione problemas, puede que quiera [clonar nuestro repositorio de tutoriales](https://github.com/AhaLabs/soroban-tutorial-project) y ver si el problema también ocurre allí. Si ocurre allí también, puede ser un problema temporal con la red Soroban.

He aquí algunos problemas comunes y cómo resolverlos.

### Llamada a `hello` falla

A veces la llamada a `hola` puede empezar a fallar. Obviamente puedes hacer stub de la llamada y definir `result` de alguna otra forma de solución de problemas.

Uno de los problemas más comunes aquí es que el contrato se convierte en [archived](../../learn/encyclopedia/storage/state-archival.mdx). Para comprobar si este es el problema, puede volver a ejecutar `npm run init`.

Si todavía tienes problemas, únete a nuestro Discord (enlace anterior) o [abre un problema en GitHub](https://github.com/stellar/stellar-docs/issues/new/choose).

### Todas las llamadas de contrato empiezan a lanzar errores `403`

Esto significa que Testnet está caído, y probablemente sólo tenga que esperar un rato y vuelva a intentarlo.

## Limpiando

Algunas de las cosas que hicimos en esta sección:

- Aprendimos acerca del enfoque no JS-by-default de Astro's
- Agregamos componentes de Astro y aprendimos cómo funcionan sus etiquetas `script` y `style`
- Hemos visto lo fácil que es interactuar con contratos inteligentes de JavaScript generando bibliotecas de clientes usando `stellar contract bindings typescript`
- Aprendimos sobre carteras y carteras

¡En este punto, has visto un ejemplo completo de construir un contrato sobre Steller! ¿Qué sigue? ¡Elegir! Puedes:

- Vea ejemplos más complejos de contratos en la sección [Contratos de ejemplo](../smart-contracts/example-contracts/README.mdx).
- Aprenda más sobre el [diseño y arquitectura interna](../../learn/encyclopedia/contract-development/README.mdx) de Soroban.
- Echa un vistazo a una [aplicación de ejemplo](https://github.com/stellar/soroban-example-dapp), que utiliza React en lugar de vanilla JavaScript y Next.js en lugar de Astro. Esta aplicación también tiene un proceso de configuración e inicialización más complejo, con la opción de usar un [nodo RPC alojado localmente](../../data/rpc/admin-guide.mdx).

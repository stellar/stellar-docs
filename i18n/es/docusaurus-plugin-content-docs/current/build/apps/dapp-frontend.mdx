---
sidebar_position: 70
sidebar_label: Crear un frontend de dapp
title: "Crear un frontend de dapp: Conectar billeteras, manejar transacciones y m√°s"
description: Aprender a crear un frontend de dapp que se conecte a contratos inteligentes. Explorar pr√°cticas recomendadas para integrar billeteras, manejar transacciones e interactuar con la red Stellar.
---

# Crear un frontend de dapp

Esta es una continuaci√≥n del [tutorial de Comenzar](../smart-contracts/getting-started/README.mdx), donde deber√≠as haber desplegado dos contratos inteligentes en la red p√∫blica. En esta secci√≥n, crearemos una aplicaci√≥n web que interact√∫e con los contratos a trav√©s de llamadas RPC.

Vamos a comenzar.

## Inicializar una herramienta frontend

Puedes crear una aplicaci√≥n Soroban con cualquier herramienta frontend o integrarla en cualquier aplicaci√≥n de pila completa existente. Para este tutorial, vamos a usar [Astro](https://astro.build/). Astro funciona con React, Vue, Svelte, cualquier otra biblioteca de interfaz de usuario, o ninguna biblioteca de interfaz de usuario en absoluto. En este tutorial, no estamos usando una biblioteca de interfaz de usuario. Las partes espec√≠ficas de Soroban de este tutorial ser√°n similares sin importar qu√© herramienta frontend uses.

Si eres nuevo en el frontend, no te preocupes. No profundizaremos demasiado. Pero ser√° √∫til para ti ver y experimentar el proceso de desarrollo frontend utilizado por las aplicaciones Soroban. Cubriremos las partes relevantes de JavaScript y Astro, pero ense√±ar todo el desarrollo frontend y Astro est√° m√°s all√° del alcance de este tutorial.

Vamos a comenzar.

Vas a necesitar [Node.js](https://nodejs.org/en/download/package-manager/) v18.14.1 o superior. Si a√∫n no lo has hecho, inst√°lalo ahora.

Queremos crear un proyecto Astro con los contratos de la lecci√≥n anterior. Para hacer esto, podemos clonar una plantilla. Puedes encontrar plantillas de Soroban en GitHub buscando [repositorios que comiencen con "soroban-template-"](https://github.com/search?q=%22soroban-template-%22&type=repositories). Para este tutorial, usaremos [stellar/soroban-template-astro](https://github.com/stellar/soroban-template-astro). Tambi√©n utilizaremos una herramienta llamada [degit](https://github.com/Rich-Harris/degit) para clonar la plantilla sin su historial de git. Esto nos permitir√° configurarla como nuestro propio proyecto git.

Dado que tienes `node` y su administrador de paquetes `npm` instalados, tambi√©n tienes `npx`.

Vamos a crear un nuevo directorio de proyecto con esta plantilla para facilitar las cosas en este tutorial, as√≠ que aseg√∫rate de que ya no est√°s en tu directorio `soroban-hello-world` y luego ejecuta:

```sh
npx degit stellar/soroban-template-astro first-soroban-app
cd first-soroban-app
git init
git add .
git commit -m "first commit: initialize from stellar/soroban-template-astro"
```

Este proyecto tiene la siguiente estructura de directorio, que revisaremos con m√°s detalle a continuaci√≥n.

```bash
‚îú‚îÄ‚îÄ contracts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hello_world
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ increment
‚îú‚îÄ‚îÄ CONTRIBUTING.md
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ initialize.js
‚îú‚îÄ‚îÄ package-lock.json
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ packages
‚îú‚îÄ‚îÄ public
‚îú‚îÄ‚îÄ src
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ components
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ Card.astro
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ env.d.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ layouts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ Layout.astro
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ pages
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ index.astro
‚îî‚îÄ‚îÄ tsconfig.json
```

Los `contratos` son los mismos que revisaste en los pasos anteriores del tutorial. Dado que ya desplegamos estos contratos con alias, podemos reutilizar los archivos de ID de contrato generados copi√°ndolos desde el directorio `soroban-hello-world/.stellar` en este proyecto:

```sh
cp -R ../soroban-hello-world/.stellar/ .stellar
```

## Generar un paquete NPM para el contrato Hello World

Antes de abrir los nuevos archivos frontend, generemos un paquete NPM para el contrato Hello World. Esta es nuestra forma sugerida de interactuar con los contratos desde los frontend. Estas bibliotecas generadas funcionan con cualquier proyecto de JavaScript (no con una UI espec√≠fica como React), y facilitan el trabajo con algunos de los aspectos m√°s complejos de Soroban, como la codificaci√≥n de [XDR](../../learn/fundamentals/contract-development/types/fully-typed-contracts.mdx).

Esto va a utilizar el comando CLI `stellar contract bindings typescript`:

```bash
stellar contract bindings typescript \
  --network testnet \
  --contract-id hello_world \
  --output-dir packages/hello_world
```

:::tip

¬°Nota que pudimos usar el alias del contrato, `hello_world`, en lugar del ID del contrato!

:::

Este proyecto est√° configurado como un Workspace de NPM, por lo que la biblioteca cliente `hello_world` se gener√≥ en el directorio `packages` en `packages/hello_world`.

Intentamos mantener el c√≥digo en estas bibliotecas generadas legible, as√≠ que ve y observa. Abre el nuevo directorio `packages/hello_world` en tu editor. Si has construido o contribuido a proyectos de Node, todo deber√≠a parecer familiar. Ver√°s un archivo `package.json`, un directorio `src`, un `tsconfig.json`, e incluso un README.

## Generar un paquete NPM para el contrato Increment

Aunque podemos ejecutar `stellar contract bindings typescript` para cada uno de nuestros contratos individualmente, el proyecto [soroban-template-astro](https://github.com/stellar/soroban-astro-template) que usamos como plantilla incluye un script muy √∫til `initialize.js` que se encargar√° de esto para todos los contratos en nuestro directorio `contracts`.

Adem√°s de generar los paquetes NPM, `initialize.js` tambi√©n:

- Generar y financiar nuestra cuenta Stellar
- Construir todos los contratos en el directorio `contracts`
- Desplegar nuestros contratos
- Crear clientes de contrato √∫tiles para cada contrato

Ya nos hemos ocupado de los primeros tres puntos en pasos anteriores de este tutorial, por lo que esas tareas ser√°n noops cuando ejecutemos `initialize.js`.

### Configurar initialize.js

Necesitamos asegurarnos de que `initialize.js` tenga todas las variables de entorno que necesita antes de hacer nada m√°s. Copia el archivo `.env.example` a `.env`. Las variables de entorno establecidas en `.env` son utilizadas por el script `initialize.js`.

```bash
cp .env.example .env
```

Veamos el contenido del archivo `.env`:

```
# Prefix with "PUBLIC_" to make available in Astro frontend files
PUBLIC_STELLAR_NETWORK_PASSPHRASE="Standalone Network ; February 2017"
PUBLIC_STELLAR_RPC_URL="http://localhost:8000/soroban/rpc"

STELLAR_ACCOUNT="me"
STELLAR_NETWORK="standalone"
```

Este archivo `.env` est√° configurado para conectarse a una red que se ejecuta localmente, pero queremos configurar nuestro proyecto para comunicarse con Testnet, ya que ah√≠ es donde desplegamos nuestros contratos. Para hacer eso, actualicemos el archivo `.env` para que se vea as√≠:

```diff
# Prefix with "PUBLIC_" to make available in Astro frontend files
-PUBLIC_STELLAR_NETWORK_PASSPHRASE="Standalone Network ; February 2017"
+PUBLIC_STELLAR_NETWORK_PASSPHRASE="Test SDF Network ; September 2015"
-PUBLIC_STELLAR_RPC_URL="http://localhost:8000/soroban/rpc"
+PUBLIC_STELLAR_RPC_URL="https://soroban-testnet.stellar.org:443"

-STELLAR_ACCOUNT="me"
+STELLAR_ACCOUNT="alice"
-STELLAR_NETWORK="standalone"
+STELLAR_NETWORK="testnet"
```

:::info

Este archivo `.env` se utiliza en el script `initialize.js`. Al usar la CLI, a√∫n podemos utilizar la configuraci√≥n de red que establecimos en el paso de [Configuraci√≥n](../smart-contracts/getting-started/setup.mdx), o pasando las banderas `--rpc-url` y `--network-passphrase`.

:::

### Ejecutar `initialize.js`

Primero, instalemos las dependencias de JavaScript:

```bash
npm install
```

Y luego ejecutemos `initialize.js`:

```bash
npm run init
```

Como se mencion√≥ anteriormente, este script intenta construir y desplegar nuestros contratos, lo cual ya hemos hecho. El script es lo suficientemente inteligente como para comprobar si un paso ya ha sido tratado, y es un no-op en ese caso, por lo que es seguro ejecutarlo m√°s de una vez.

### Llamar al contrato desde el frontend

Ahora abramos `src/pages/index.astro` y veamos c√≥mo el c√≥digo frontend se integra con el paquete NPM que creamos para nuestros contratos.

Aqu√≠ podemos ver que estamos importando nuestro cliente `helloWorld` generado desde `../contracts/hello_world`. Luego, estamos invocando el m√©todo `hello` y agregando el resultado a la p√°gina.

```ts title="src/pages/index.astro"
---
import Layout from "../layouts/Layout.astro";
import Card from "../components/Card.astro";
import helloWorld from "../contracts/hello_world";
const { result } = await helloWorld.hello({ to: "you" });
const greeting = result.join(" ");
---

 ...

<h1>{greeting}</h1>
```

¬°Veamos esto en acci√≥n! Inicia el servidor de desarrollo:

```bash
npm run dev
```

Y abre [localhost:4321](http://localhost:4321) en tu navegador. ¬°Deber√≠as ver el saludo del contrato!

Puedes intentar actualizar el argumento `{ to: 'Soroban' }`. Cuando guardes el archivo, la p√°gina se actualizar√° autom√°ticamente.

:::info

Cuando inicies el servidor de desarrollo con `npm run dev`, ver√°s una salida similar en tu terminal a la que obtuviste cuando ejecutaste `npm run init`. Esto se debe a que el script `dev` en package.json est√° configurado para ejecutar `npm run init` y `astro dev`, para que puedas asegurarte de que tu contrato desplegado y tu paquete NPM generado est√©n siempre sincronizados. Si solo quieres iniciar el servidor de desarrollo sin el script initialize.js, puedes ejecutar `npm run astro dev`.

:::

### ¬øQu√© est√° pasando aqu√≠?

Si inspeccionas la p√°gina (clic derecho, inspeccionar) y actualizas, ver√°s un par de cosas interesantes:

- La pesta√±a "Red" muestra que no se han realizado solicitudes Fetch/XHR. ¬°Pero las llamadas RPC ocurren a trav√©s de Fetch/XHR! ¬øEntonces, c√≥mo est√° llamando el frontend al contrato?
- No hay JavaScript en la p√°gina. ¬°Pero acabamos de escribir algo de JavaScript! ¬øC√≥mo est√° funcionando?

Esta es parte de la filosof√≠a de Astro: el frontend debe enviarse con la menor cantidad de activos posible. Prefiriendo cero JavaScript. Cuando pones JavaScript en el [frontmatter](https://docs.astro.build/en/core-concepts/astro-components/), Astro lo ejecutar√° en el momento de la construcci√≥n y luego reemplazar√° cualquier cosa en los corchetes `{...}` con la salida.

Al usar el servidor de desarrollo con `npm run dev`, se ejecuta el c√≥digo del frontmatter en el servidor e inyecta los valores resultantes en la p√°gina en el cliente.

Puedes intentar construir para ver esto de manera m√°s evidente:

```bash
npm run build
```

Luego verifica la carpeta `dist`. Ver√°s que se gener√≥ un archivo HTML y CSS, pero no JavaScript. Y si miras el archivo HTML, ver√°s un "Hola Soroban" est√°tico en el `<h1>`.

Durante la construcci√≥n, Astro realiz√≥ una √∫nica llamada a tu contrato, luego inyect√≥ el resultado est√°tico en la p√°gina. Esto es genial para m√©todos de contrato que no cambian, pero probablemente no funcionar√° para la mayor√≠a de los m√©todos de contrato. Vamos a integrar con el contrato `incrementor` para ver c√≥mo manejar m√©todos interactivos en Astro. -->

## Llamar al contrato incrementor desde el frontend

Mientras `hello` es un m√©todo simple de solo lectura, `increment` cambia el estado on-chain. Esto significa que alguien necesita firmar la transacci√≥n. As√≠ que necesitaremos agregar capacidades de firma de transacciones al frontend.

La forma en que funciona la firma en un navegador es con una _billetera_. Las billeteras pueden ser aplicaciones web, extensiones de navegador, aplicaciones independientes, o incluso dispositivos de hardware separados.

### Instalar la extensi√≥n Freighter

En este momento, la billetera que mejor admite Soroban es [Freighter](../guides/freighter/README.mdx). Est√° disponible como un complemento para Firefox, as√≠ como extensiones para Chrome y Brave. Ve y [inst√°lalo ahora](https://freighter.app).

Una vez instalado, √°brelo haciendo clic en el √≠cono de la extensi√≥n. Si esta es tu primera vez usando Freighter, necesitar√°s crear una nueva billetera. Sigue las indicaciones para crear una contrase√±a y guardar tu frase de recuperaci√≥n.

Ve a Configuraci√≥n (el √≠cono de la tuerca) ‚Üí Preferencias y activa la opci√≥n para Habilitar Modo Experimental. Luego regresa a su pantalla de inicio y selecciona "Test Net" en el men√∫ desplegable de la esquina superior derecha. Finalmente, si muestra el mensaje de que tu direcci√≥n Stellar no est√° financiada, ve y haz clic en el bot√≥n "Financiar con Friendbot".

Ahora est√°s completamente configurado para usar Freighter como usuario, y puedes agregarlo a tu aplicaci√≥n.

### Agregar StellarWalletsKit y configurarlo

Aunque estamos usando Freighter para probar nuestra aplicaci√≥n, hay m√°s billeteras que admiten la firma de transacciones de contratos inteligentes. Para facilitar su integraci√≥n, estamos utilizando la biblioteca `StellarWalletsKit` que nos permite soportar todas las billeteras Stellar con una sola biblioteca.

Para instalar este kit, vamos a incluir el siguiente paquete:

```shell
npm install @creit.tech/stellar-wallets-kit
```

Con el paquete instalado, vamos a crear un nuevo archivo simple donde se encontrar√°n nuestro kit instanciado y estado simple. Crea el archivo `src/stellar-wallets-kit.ts` y pega esto:

```ts title="src/stellar-wallets-kit.ts"
import {
  allowAllModules,
  FREIGHTER_ID,
  StellarWalletsKit,
} from "@creit.tech/stellar-wallets-kit";

const SELECTED_WALLET_ID = "selectedWalletId";

function getSelectedWalletId() {
  return localStorage.getItem(SELECTED_WALLET_ID);
}

const kit = new StellarWalletsKit({
  modules: allowAllModules(),
  network: import.meta.env.PUBLIC_STELLAR_NETWORK_PASSPHRASE,
  // StellarWalletsKit forces you to specify a wallet, even if the user didn't
  // select one yet, so we default to Freighter.
  // We'll work around this later in `getPublicKey`.
  selectedWalletId: getSelectedWalletId() ?? FREIGHTER_ID,
});

export const signTransaction = kit.signTransaction.bind(kit);

export async function getPublicKey() {
  if (!getSelectedWalletId()) return null;
  const { address } = await kit.getAddress();
  return address;
}

export async function setWallet(walletId: string) {
  localStorage.setItem(SELECTED_WALLET_ID, walletId);
  kit.setWallet(walletId);
}

export async function disconnect(callback?: () => Promise<void>) {
  localStorage.removeItem(SELECTED_WALLET_ID);
  kit.disconnect();
  if (callback) await callback();
}

export async function connect(callback?: () => Promise<void>) {
  await kit.openModal({
    onWalletSelected: async (option) => {
      try {
        await setWallet(option.id);
        if (callback) await callback();
      } catch (e) {
        console.error(e);
      }
      return option.id;
    },
  });
}
```

En el c√≥digo anterior, instanciamos el kit con la configuraci√≥n deseada y lo exportamos. Tambi√©n envolvemos algunas funciones del kit y a√±adimos funcionalidad personalizada, como aumentar el kit permitiendo que recuerde qu√© opciones de billetera fueron seleccionadas entre actualizaciones de p√°gina (esa es la parte de `localStorage`). El kit requiere un `selectedWalletId` incluso antes de que el usuario seleccione uno, as√≠ que tambi√©n encontramos una soluci√≥n a esta limitaci√≥n, como explica el comentario de c√≥digo. Puedes aprender m√°s sobre c√≥mo funciona el kit en [la documentaci√≥n de StellarWalletsKit](https://stellarwalletskit.dev/)

Ahora vamos a a√±adir un bot√≥n "Conectar" a la p√°gina que abrir√° el modal incorporado del kit e invitar√° al usuario a usar su billetera preferida. Una vez que el usuario elija su billetera preferida y otorgue permiso para aceptar solicitudes del sitio web, recuperaremos la clave p√∫blica y el bot√≥n de "Conectar" ser√° reemplazado con un mensaje que dice: "Conectado como [su clave p√∫blica]".

Ahora agreguemos un nuevo componente al directorio `src/components` llamado `ConnectWallet.astro` con el siguiente contenido:

```html title="src/components/ConnectWallet.astro"
<div id="connect-wrap" class="wrap" aria-live="polite">
  &amp;nbsp;
  <div class="ellipsis"></div>
  <button style="display:none" data-connect aria-controls="connect-wrap">
    Connect
  </button>
  <button style="display:none" data-disconnect aria-controls="connect-wrap">
    Disconnect
  </button>
</div>

<style>
  .wrap {
    text-align: center;
    display: flex;
    width: 18em;
    margin: auto;
    justify-content: center;
    line-height: 2.7rem;
    gap: 0.5rem;
  }

  .ellipsis {
    overflow: hidden;
    text-overflow: ellipsis;
    text-align: center;
    white-space: nowrap;
  }
</style>

<script>
  import { getPublicKey, connect, disconnect } from "../stellar-wallets-kit";

  const ellipsis = document.querySelector(
    "#connect-wrap .ellipsis",
  ) as HTMLElement;
  const connectButton = document.querySelector("[data-connect]") as HTMLButtonElement;
  const disconnectButton = document.querySelector(
    "[data-disconnect]",
  ) as HTMLButtonElement;

  async function showDisconnected() {
    ellipsis.innerHTML = "";
    ellipsis.removeAttribute("title");
    connectButton.style.removeProperty("display");
    disconnectButton.style.display = "none";
  }

  async function showConnected() {
    const publicKey = await getPublicKey();
    if (publicKey) {
      ellipsis.innerHTML = `Signed in as ${publicKey}`;
      ellipsis.title = publicKey ?? "";
      connectButton.style.display = "none";
      disconnectButton.style.removeProperty("display");
    } else {
      showDisconnected();
    }
  }

  connectButton.addEventListener("click", async () => {
    await connect(showConnected);
  });

  disconnectButton.addEventListener("click", async () => {
    disconnect(showDisconnected);
  });

  if (await getPublicKey()) {
    showConnected();
  } else {
    showDisconnected();
  }
</script>
```

Algunas de estas cosas pueden parecer sorprendentes. ¬ø`<style>` y `<script>` en medio de la p√°gina? ¬øNombres de clase poco creativos como `wrap`? ¬øDeclaraciones de `import` en un `<script>`? ¬ø`await` de nivel superior? ¬øQu√© est√° pasando aqu√≠?

Astro autom√°ticamente delimita los estilos dentro de un componente a ese componente, as√≠ que no hay raz√≥n para que tengamos que idear nombres ingeniosos para nuestras clases.

Y todas las declaraciones de `script` se agrupan y se incluyen inteligentemente en la p√°gina. Incluso si usas el mismo componente m√∫ltiples veces, el script solo se incluir√° una vez. Y s√≠, puedes usar `await` de nivel superior.

Puedes leer m√°s sobre esto en [la p√°gina de Astro sobre scripts del lado del cliente](https://docs.astro.build/en/guides/client-side-scripts/).

El c√≥digo en s√≠ aqu√≠ es bastante autocontenido. Importamos `kit` desde el archivo que creamos anteriormente. Entonces, cuando el usuario haga clic en el bot√≥n de inicio de sesi√≥n, llamamos a la funci√≥n `connect` que creamos en nuestro archivo `stellar-wallets-kit.ts` anterior. Esto lanzar√° el modal incorporado de StellarWalletsKit, que permite al usuario elegir entre las opciones de billetera que configuramos (configuramos todas, con `allowAllModules`). Pasamos nuestra propia funci√≥n `setLoggedIn` como callback, que ser√° llamada en la funci√≥n `onWalletSelected` en `stellar-wallets-kit.ts`. Terminamos actualizando la interfaz de usuario, seg√∫n si el usuario est√° conectado o no.

Ahora podemos importar el componente en el frontmatter de `pages/index.astro`:

```diff title="pages/index.astro"
 ---
 import Layout from '../layouts/Layout.astro';
 import Card from '../components/Card.astro';
 import helloWorld from "../contracts/hello_world";
+import ConnectWallet from '../components/ConnectWallet.astro'
 ...
```

Y agregarlo justo debajo del `<h1>`:

```diff title="pages/index.astro"
 <h1>{greeting}</h1>
+<ConnectWallet />
```

Si ya no est√°s ejecutando tu servidor de dev, ve y rein√≠cialo:

```bash
npm run dev
```

Luego abre la p√°gina y haz clic en el bot√≥n "Conectar". You should see Freighter pop up and ask you to sign in. Una vez que lo hagas, el bot√≥n deber√≠a ser reemplazado con un mensaje que dice: "Conectado como [tu clave p√∫blica]".

¬°Ahora est√°s listo para firmar la llamada a `increment`!

### Llamar a `increment`

Ahora podemos importar el cliente del contrato `increment` desde `contracts/increment.ts` y comenzar a usarlo. Nuevamente, crearemos un nuevo componente Astro. Crea un nuevo archivo en `src/components/Counter.astro` con el siguiente contenido:

```html title="src/components/Counter.astro"
<strong>Incrementor</strong><br />
Current value: <strong id="current-value" aria-live="polite">???</strong><br />
<br />
<button data-increment aria-controls="current-value">Increment</button>

<script>
  import { getPublicKey, signTransaction } from "../stellar-wallets-kit";
  import incrementor from "../contracts/increment";
  const button = document.querySelector(
    "[data-increment]",
  ) as HTMLButtonElement;
  const currentValue = document.querySelector("#current-value") as HTMLElement;

  button.addEventListener("click", async () => {
    const publicKey = await getPublicKey();

    if (!publicKey) {
      alert("Please connect your wallet first");
      return;
    } else {
      incrementor.options.publicKey = publicKey;
      incrementor.options.signTransaction = signTransaction;
    }

    button.disabled = true;
    button.classList.add("loading");
    currentValue.innerHTML =
      currentValue.innerHTML +
      '<span class="visually-hidden"> ‚Äì updating‚Ä¶</span>';

    try {
      const tx = await incrementor.increment();
      const { result } = await tx.signAndSend();

      // Only use `innerHTML` with contract values you trust!
      // Blindly using values from an untrusted contract opens your users to script injection attacks!
      currentValue.innerHTML = result.toString();
    } catch (e) {
      console.error(e);
    } finally {
      button.disabled = false;
      button.classList.remove("loading");
    }
  });
</script>
```

Esto deber√≠a ser algo familiar para ahora. Tenemos un `script` que, gracias al sistema de construcci√≥n de Astro, puede `importar` m√≥dulos directamente. Usamos `document.querySelector` para encontrar los elementos definidos arriba. Y agregamos un manejador de `click` al bot√≥n, que llama a `increment` y actualiza el valor en la p√°gina. Tambi√©n establece el bot√≥n como `deshabilitado` y agrega una clase de `cargando` mientras la llamada est√° en progreso para evitar que el usuario haga clic nuevamente y comunicar visualmente que algo est√° sucediendo. Para las personas que utilizan lectores de pantalla, el estado de carga se comunica con la etiqueta [visualmente oculta](https://www.a11yproject.com/posts/how-to-hide-content/), que ser√° anunciada gracias a las etiquetas `aria` que vimos antes.

La mayor diferencia con la llamada a `greeter.hello` es que esta transacci√≥n se ejecuta en dos pasos. La llamada inicial a `increment` construye una transacci√≥n de Soroban y luego realiza una llamada RPC para _simularla_. Para llamadas de solo lectura como `hello`, esto es todo lo que necesitas, por lo que puedes obtener el `resultado` de inmediato. Para llamadas de escritura como `increment`, debes `signAndSend` antes de que la transacci√≥n sea realmente incluida en el ledger. Tambi√©n necesitas asegurarte de que establezcas un `publicKey` v√°lido y un m√©todo `signTransaction`.

:::info

Desestructuraci√≥n `{ result }`: Si eres nuevo en JavaScript, puede que no sepas lo que est√° sucediendo con esas l√≠neas `const { result }`. Esto est√° utilizando la caracter√≠stica de _desestructuraci√≥n_ de JavaScript. Si la cosa a la derecha del signo igual es un objeto, entonces puedes usar este patr√≥n para obtener r√°pidamente claves espec√≠ficas de ese objeto y asignarlas a variables. Tambi√©n puedes nombrar la variable de otra manera, si lo deseas. Por ejemplo, intenta cambiar el c√≥digo de arriba a:

```ts
const { result: newValue } = ...
```

:::

Tambi√©n, ten en cuenta que no necesitas especificar manualmente a Freighter como la billetera en la llamada a `increment`. Esto puede cambiar en el futuro, pero mientras Freighter sea la √∫nica opci√≥n disponible, estas bibliotecas generadas la utilizan autom√°ticamente. Si deseas anular este comportamiento, puedes pasar una opci√≥n `wallet`; consulta la √∫ltima interfaz `Wallet` en [la fuente de la plantilla](https://github.com/stellar/soroban-tools/blob/main/cmd/crates/soroban-spec-typescript/src/project_template/src/method-options.ts) para m√°s detalles.

Ahora, usemos este componente. En `pages/index.astro`, primero imp√≥rtalo:

```diff title="pages/index.astro"
 ---
 import Layout from '../layouts/Layout.astro';
 import Card from '../components/Card.astro';
 import helloWorld from "../contracts/hello_world";
 import ConnectFreighter from '../components/ConnectFreighter.astro';
+import Counter from '../components/Counter.astro';
 ...
```

Luego √∫salo. Reemplacemos el contenido del p√°rrafo `instrucciones` con √©l:

```diff title="pages/index.astro"
 <p class="instructions">
-  To get started, open the directory <code>src/pages</code> in your project.<br />
-  <strong>Code Challenge:</strong> Tweak the "Welcome to Astro" message above.
+  <Counter />
 </p>
```

Revisa la p√°gina; si a√∫n est√°s ejecutando tu servidor de desarrollo, deber√≠a haberse actualizado ya. Haz clic en el bot√≥n "Incrementar"; deber√≠as ver una confirmaci√≥n de Freighter. Confirma, y... ¬°el valor se actualiza! üéâ

Obviamente, falta algo de funcionalidad. Por ejemplo, ese `???` es frustrante. Pero nuestro contrato `incrementar` no nos da una manera de consultar el valor actual sin actualizarlo tambi√©n.

Antes de intentar actualizarlo, simplifiquemos el proceso de creaci√≥n, implementaci√≥n y generaci√≥n de clientes para los contratos.

## Ll√©valo m√°s all√°

Si quieres llevarlo un poco m√°s lejos y asegurarte de entender todas las piezas aqu√≠, prueba lo siguiente:

- Crea una carpeta `src/contracts` con un `greeter.ts` y un `incrementor.ts`. Mueve la l√≥gica de `new Contract({ ... })` a esos archivos. Tambi√©n querr√°s extraer la variable `rpcUrl` a un archivo `src/contracts/utils.ts`.
- Agrega un m√©todo `get_value` al contrato `incrementar`, y √∫salo para mostrar el valor actual en el componente `Contador`. Cuando ejecutes `npm run dev`, el script `initialize` se ejecutar√° y actualizar√° el contrato y el cliente generado.
- Agrega un bot√≥n "Decrementar" al componente `Contador`.
- [Implementa](https://docs.astro.build/en/guides/deploy/) tu frontend. Puedes hacerlo r√°pido y gratis [con GitHub](https://docs.astro.build/en/guides/deploy/github/). Si tienes problemas al instalar stellar-cli y desplegar contratos en GitHub, consulta [c√≥mo lo hicimos aqu√≠](https://github.com/theahaco/soroban-tutorial-project/commit/c1f4cfde1bbaf059507100767ee6b43d29b42914).
- En lugar de usar scripts de NPM para todo, intenta usar un corredor de scripts m√°s elegante como [just](https://github.com/casey/just). Los scripts de npm existentes pueden llamar a `just`, como `"setup": "just setup"`.
- Actualiza el README para explicar qu√© es este proyecto y c√≥mo usarlo a posibles colaboradores y empleadores üòâ

## Resoluci√≥n de problemas

A veces las cosas salen mal. Como primer paso para solucionar problemas, es posible que quieras [clonar nuestro repositorio tutorial](https://github.com/theahaco/soroban-tutorial-project) y ver si el problema tambi√©n ocurre all√≠. Si ocurre all√≠ tambi√©n, entonces puede ser un problema temporal con la red de Soroban.

Aqu√≠ hay algunas incidencias comunes y c√≥mo corregirlas.

### La llamada a `hello` falla

A veces la llamada a `hello` puede comenzar a fallar. Obviamente puedes simular la llamada y definir `result` de otra manera para solucionar problemas.

Uno de los problemas comunes aqu√≠ es que el contrato se vuelva [archivado](../../learn/fundamentals/contract-development/storage/state-archival.mdx). Para verificar si este es el problema, puedes ejecutar de nuevo `npm run init`.

Si sigues teniendo problemas, √∫nete a nuestro Discord (enlace de arriba) o [abre un problema en GitHub](https://github.com/stellar/stellar-docs/issues/new/choose).

### Todas las llamadas a contratos comienzan a lanzar errores `403`

Esto significa que Testnet est√° fuera de servicio, y probablemente solo necesites esperar un poco y volver a intentarlo.

## Conclusi√≥n

Algunas de las cosas que hicimos en esta secci√≥n:

- Aprendimos sobre el enfoque sin JS por defecto de Astro
- Agregamos componentes de Astro y aprendimos c√≥mo funcionan sus etiquetas `script` y `style`
- Vimos lo f√°cil que es interactuar con contratos inteligentes desde JavaScript generando bibliotecas de clientes usando `stellar contract bindings typescript`
- Aprendimos sobre billeteras y Freighter

¬°En este punto, has visto un ejemplo completo de inicio a fin de la creaci√≥n de un contrato en Stellar! ¬øQu√© sigue? ¬°T√∫ decides! Puedes:

- Ver contratos de ejemplo m√°s complejos en la secci√≥n [Contratos Ejemplo](../smart-contracts/example-contracts/README.mdx).
- Aprende m√°s sobre la [arquitectura interna y dise√±o](../../learn/fundamentals/contract-development/README.mdx) de Soroban.
- Aprende c√≥mo encontrar varias plantillas adem√°s de [stellar/soroban-template-astro](https://github.com/stellar/soroban-astro-template), y c√≥mo crear las tuyas: [Desarrollar plantillas frontend de inicializaci√≥n de contratos](../guides/dapps/soroban-contract-init-template.mdx)

---
sidebar_position: 70
title: Construir una interfaz de Dapp
description: Crea una aplicaci√≥n web frontend que interact√∫e con tus contratos inteligentes.
pagination_prev: build/smart-contracts/getting-started/deploy-increment-contract
---

Esta es una continuaci√≥n del [tutorial iniciado](../smart-contracts/getting-started/README.mdx), donde deber√≠as haber desplegado dos contratos inteligentes a la red p√∫blica. En esta secci√≥n, crearemos una aplicaci√≥n web que interact√∫a con los contratos mediante llamadas RPC.

Comencemos.

## Inicializar una toolchain del frontend

Puede construir una aplicaci√≥n Soroban con cualquier toolchain de interfaz o integrarla en cualquier aplicaci√≥n de full-stack existente. Para este tutorial, vamos a usar [Astro](https://astro.build/). Astro trabaja con React, Vue, Svelte, cualquier otra biblioteca de interfaz de usuario o ninguna biblioteca de interfaz de usuario. En este tutorial, no estamos usando una biblioteca de interfaz de usuario. Las partes espec√≠ficas de Soroban de este tutorial ser√°n similares sin importar qu√© herramienta de interfaz use.

Si eres nuevo en frontend, no te preocupes. No vamos demasiado profundo. Pero ser√° √∫til para usted ver y experimentar el proceso de desarrollo del frontend utilizado por las aplicaciones Soroban. Vamos a cubrir los bits relevantes de JavaScript y Astro, pero ense√±ar todo el desarrollo de frontend y Astro est√° m√°s all√° del alcance de este tutorial.

Comencemos.

Necesitar√°s [Node.js](https://nodejs.org/en/download/package-manager/) v18.14.1 o superior. Si a√∫n no lo has hecho, inst√°lalo ahora.

Queremos inicializar nuestro proyecto actual como un proyecto Astro. Para hacer esto, podemos volver a girar al comando `stellar contract init`, que tiene una bandera `--frontend-template` que nos permite pasar la url de un repositorio de plantillas de frontend. Como aprendimos en [Almacenando datos](../smart-contracts/getting-started/storing-data.mdx#adding-the-increment-contract), `stellar contract init` no sobreescribir√° los archivos existentes, y es seguro de usarlos para a√±adir a un proyecto existente.

Desde nuestro directorio `soroban-hello-world`, ejecuta el siguiente comando para a√±adir los archivos de plantilla de Astro.

```sh
stellar contract init ./ \
  --frontend-template https://github.com/stellar/soroban-astro-template
```

Esto a√±adir√° lo siguiente a tu proyecto, el cual iremos m√°s detallados a continuaci√≥n.

```bash
‚îú‚îÄ‚îÄ CONTRIBUTING.md
‚îú‚îÄ‚îÄ initialize.js
‚îú‚îÄ‚îÄ package-lock.json
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ packages
‚îú‚îÄ‚îÄ public
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ favicon.svg
‚îú‚îÄ‚îÄ src
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ components
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ Card.astro
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ env.d.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ layouts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ Layout.astro
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ pages
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ index.astro
‚îî‚îÄ‚îÄ tsconfig.json
```

## Generar un paquete NPM para el contrato Hola World

Antes de abrir los nuevos archivos frontend, vamos a generar un paquete de NPM para el contrato Hello World. Esta es nuestra forma sugerida de interactuar con los contratos de frontends. Estas bibliotecas generadas funcionan con cualquier proyecto JavaScript (no una interfaz espec√≠fica como React), y hacer que sea f√°cil trabajar con algunos de los bits m√°s complicados de Soroban, como la codificaci√≥n [XDR](. /../learn/encyclopedia/contract-development/types/fully-typed-contracts.mdx).

Esto va a utilizar el comando CLI `stellar contract bindings typescript`:

```bash
stellar contract bindings typescript \
  --network testnet \
  --contract-id $(cat .stellar/contract-ids/hello_world.txt) \
  --output-dir packages/hello_world
```

Este proyecto est√° configurado como un espacio de trabajo de NPM, por lo que la biblioteca de clientes `hello_world` fue generada en el directorio `packages` en `packages/hello_world`.

Intentamos mantener el c√≥digo en estas bibliotecas generadas legibles, as√≠ que sigamos adelante y miremos hacia el futuro. Abre el nuevo directorio `packages/hello_world` en tu editor. Si has construido o contribuido a proyectos de Node, todo se ver√° familiar. Ver√°s un archivo `package.json`, un directorio `src`, un `tsconfig.json`, e incluso un README.

## Generar un paquete NPM para el contrato Increment

Aunque podemos ejecutar `soroban contract bindings typescript` para cada uno de nuestros contratos individualmente, la [soroban-astro-template](https://github. om/stellar/soroban-astro-templation) que usamos como nuestra plantilla incluye un muy pr√°ctico `initialize. s` script que manejar√° esto para todos los contratos en nuestro directorio `contracts`.

Adem√°s de generar los paquetes NPM, `initialize.js` tambi√©n:

- Generar y depositar fondos en nuestra cuenta Stellar
- Construir todos los contratos en el directorio `contracts`
- Desplegar nuestros contratos
- Crear clientes de contratos pr√°cticos para cada contrato

Ya nos hemos ocupado de los tres primeros puntos de bala en pasos anteriores de este tutorial, as√≠ que esas tareas ser√°n noops cuando ejecutemos `initialize. s`.

### Configurar initialize.js

Necesitamos asegurarnos de que `initialize.js` tenga todas las variables de entorno que necesita antes de hacer cualquier otra cosa. Copia el archivo `.env.example` a `.env`. Las variables de entorno establecidas en `.env` son usadas por el script `initialize.js`.

```bash
cp .env.example .esv
```

Echemos un vistazo al contenido del archivo `.env`:

```
# Prefijo con "PUBLIC_" para poner disponible en los archivos de Astro frontend
PUBLIC_SOROBAN_NETWORK_PASSPHRASE="Red independiente ; Febrero de 2017"
PUBLIC_SOROBAN_RPC_URL="http://localhost:8000/soroban/rpc"

SOROBAN_ACCOUNT="me"
SOROBAN_NETWORK="standalone"

# vars env que comienzan con PUBLIC_ estar√°n disponibles para el cliente
PUBLIC_SOROBAN_RPC_URL=$SOROBAN_RPC_URL
```

Este `. el archivo nv` por defecto se conecta a una red que se ejecuta localmente pero queremos configurar nuestro proyecto para comunicarnos con Testnet, ya que ah√≠ es donde desplegamos nuestros contratos. Para hacer eso, vamos a actualizar el archivo `.env` para que se vea as√≠:

```diff
# Prefijo con "PUBLIC_" para poner disponible en los archivos de Astro frontend
-PUBLIC_SOROBAN_NETWORK_PASSPHRASE="Red independiente ; Febrero 2017"
+PUBLIC_SOROBAN_NETWORK_PASSPHRASE="Probar red SDF ; Septiembre de 2015"
-PUBLIC_SOROBAN_RPC_URL="http://localhost:8000/soroban/rpc"
+PUBLIC_SOROBAN_RPC_URL="https://soroban-testnet. tellar.org:443"

-SOROBAN_ACCOUNT="me"
+SOROBAN_ACCOUNT="alice"
-SOROBAN_NETWORK="standalone"
+SOROBAN_NETWORK="testnet"
```

:::info

Este archivo `.env` se utiliza en el script `initialize.js`. Al usar la CLI, todav√≠a podemos usar la configuraci√≥n de red que configuramos en la [Setup](.. paso smart-contracts/getting-started/setup.mdx), o pasando las banderas `--rpc-url` y `--network-passphrase`.

:::

### Ejecuta `initialize.js`

Primero instalemos las dependencias de Javascript:

```bash
npm install
```

Y luego ejecutemos `initialize.js`:

```bash
npm ejecutar init
```

Como se mencion√≥ anteriormente, este script intenta construir e implementar nuestros contratos, lo que ya hemos hecho. El script es lo suficientemente inteligente para comprobar si un paso ya ha sido tomado en cuenta, y es un no-op en ese caso, por lo que es seguro ejecutar m√°s de una vez.

### Llamar al contrato desde el frontend

Ahora abramos `src/pages/index.astro` y echemos un vistazo a c√≥mo el c√≥digo del frontend se integra con el paquete NPM que creamos para nuestros contratos.

Aqu√≠ podemos ver que estamos importando nuestro cliente `helloWorld` generado desde `../contracts/hello_world`. Entonces estamos invocando el m√©todo `hola` y a√±adiendo el resultado a la p√°gina.

```ts title="src/pages/index.astro"
---
import Layout from "../layouts/Layout.astro";
import Card from "../components/Card.astro";
import helloWorld from ".. contracts/hello_world";
const { result } = await helloWorld.hello({ to: "you" });
const saludando = resultado. oin(" ");
---

 ...

<h1>{greeting}</h1>
```

¬°Vamos a verlo en acci√≥n! Iniciar el servidor dev:

```bash
npm run dev
```

Y abre [localhost:4321](http://localhost:4321) en tu navegador. ¬°Deber√≠a ver el saludo del contrato!

Puedes intentar actualizar el argumento `{ to: 'Soroban' }`. Al guardar el archivo, la p√°gina se actualizar√° autom√°ticamente.

:::info

Cuando inicias el servidor dev con `npm run dev`, ver√°s una salida similar en tu terminal como cuando ejecutaste `npm run init`. Esto es porque el script `dev` en el paquete. hijo est√° configurado para ejecutar `npm run init` y `astro dev`, para que pueda asegurarse de que su contrato desplegado y su paquete NPM generado est√°n siempre sincronizados. Si desea iniciar el servidor dev sin el script initialize.js, puede ejecutar `npm run astro dev`.

:::

### ¬øQu√© est√° pasando aqu√≠?

Si inspeccionas la p√°gina (clic derecho, inspeccionar) y actualizas, ver√°s un par de cosas interesantes:

- La pesta√±a "Red" muestra que no hay peticiones Fetch/XHR hechas. Pero las llamadas RPC ocurren a trav√©s de Fetch/XHR! Entonces, ¬øc√≥mo llama el frontend al contrato?
- No hay JavaScript en la p√°gina. Pero acabamos de escribir algo de JavaScript! ¬øC√≥mo funciona?

Esto es parte de la propaganda de Astro: el frontend debe tener el menor n√∫mero de activos posible. Preferiblemente cero JavaScript. Cuando pones JavaScript en la [frontmatter](https://docs.astro. uild/es/core-concepts/astro-components/), Astro lo ejecutar√° en tiempo de construcci√≥n, y luego reemplazar√° cualquier cosa en los llaves de `{...}` con la salida.

Cuando se utiliza el servidor de desarrollo con `npm run dev`, se ejecuta el c√≥digo frontmatter en el servidor, e inyecta los valores resultantes en la p√°gina del cliente.

Puedes intentar construir esto de forma m√°s dram√°tica:

```bash
npm run build
```

Luego revisa la carpeta `dist`. Ver√°s que construy√≥ un archivo HTML y CSS, pero no JavaScript. Y si miras el archivo HTML, ver√°s un "Hola Soroban" est√°tico en el `<h1>`.

Durante la construcci√≥n, Astro hizo una sola llamada a su contrato, luego inyect√≥ el resultado est√°tico en la p√°gina. Esto es ideal para m√©todos contractuales que no cambian, pero probablemente no funcionar√°n para la mayor√≠a de los m√©todos contractuales. Vamos a integrar con el contrato 'incrementor' para ver c√≥mo manejar m√©todos interactivos en Astro. -->

## Llamar al contrato del incrementor desde el frontend

Mientras que `hello` es un m√©todo simple de solo vista/lectura, `increment` cambia en estado de cadena. Esto significa que alguien necesita firmar la transacci√≥n. As√≠ que necesitaremos a√±adir capacidades de firma de transacciones al frontend.

La forma de firmar funciona en un navegador es con un _wallet_. Las billeteras pueden ser aplicaciones web, extensiones del navegador, aplicaciones independientes o incluso dispositivos de hardware separados.

### Instalar extensi√≥n de Freighter

Ahora mismo, la cartera que mejor soporta Soroban es [Freighter](../guides/freighter/README.mdx). Est√° disponible como complemento de Firefox, as√≠ como extensiones para Chrome y Brave. Sigue adelante y [inst√°lalo ahora](https://freighter.app).

Una vez instalado, √°brelo haciendo clic en el icono de la extensi√≥n. Si esta es su primera vez usando Freighter, necesitar√° crear una nueva cartera. Siga las instrucciones para crear una contrase√±a y guardar su frase de recuperaci√≥n.

Vaya a Ajustes (el icono del engranaje) ‚Üí Preferencias y active el interruptor para Activar el modo experimental. A continuaci√≥n, vuelva a su pantalla de inicio y seleccione "Probar Net" en la lista desplegable superior derecha. Por √∫ltimo, si muestra el mensaje de que su direcci√≥n Stellar no est√° financiada, siga adelante y haga clic en el bot√≥n "Fondo con Friendbot".

Ahora todo est√° configurado para usar Freighter como usuario, y puedes a√±adirlo a tu aplicaci√≥n.

### A√±adir carguero

Vamos a a√±adir un bot√≥n de "Conectar" a la p√°gina que abre el carguero y pide al usuario que le otorgue permiso a su p√°gina web para usar el carguero. Una vez que concedan este permiso, el bot√≥n "Conectar" ser√° reemplazado por un mensaje diciendo: "Firmado como [su clave p√∫blica]".

Primero, a√±ade [@stellar/freighter-api](https://www.npmjs.com/package/@stellar/freighter-api) como dependencia:

```bash
npm install @stellar/freighter-api
```

Ahora vamos a a√±adir un nuevo componente al directorio `src/components` llamado `ConnectFreighter.astro` con el siguiente contenido:

```html title="src/components/ConnectFreighter.astro"
<div id="freighter-wrap" class="wrap" aria-live="polite">
  <div class="ellipsis">
    <button data-connect aria-controls="freighter-wrap">Conecta</button>
  </div>
</div>

<style>
  . rap {
    text-align: center;
  }

  .ellipsis {
    line-height: 2. rem;
    margen: auto;
    max-width: 12rem;
    overflow: hidden;
    text-overflow: ellipsis;
    text-align: centro;
    espacios blancos: nowrap;
  }
</style>

<script>
  import { isAllowed, setAllowed, getUserInfo } from '@stellar/freighter-api';

  const wrap = documento. uerySelector('#freighter-wrap');
  const ellipsis = document.querySelector('#freighter-wrap .ellipsis');
  const button = documento. uerySelector('[data-connect]');

  async function getPk() {
    const { publicKey } = await getUserInfo();
    return publicKey;
  }

  async function setLoggedIn(publicKey: string) {
    ellipsis. nnerHTML = `Firmado como ${publicKey}`;
    ellipsis. itle = publicKey;
  }

  if (await isAllowed()) {
    const publicKey = await getPk();
    if (publicKey) setLoggedIn(publicKey);
    else wrap. nnerHTML = 'Freighter est√° bloqueado.<br>Inicie sesi√≥n y actualice la p√°gina. ;
  } else {
    button.addEventListener('click', async () => {
      bot√≥n. isabled = true;
      await setAllowed();
      const publicKey = await getPk();
      await setLoggedIn(publicKey);
    });
  }
</script>
```

Algo de esto puede parecer sorprendente. `<style>` y `<script>` etiquetas en el centro de la p√°gina? Nombres de clase no creativos como `wrap`? `import` declaraciones en un `<script>`? Top-level `await`? ¬øQu√© est√° pasando aqu√≠?

Astro alza autom√°ticamente los estilos dentro de un componente a ese componente, as√≠ que no hay ninguna raz√≥n para que tengamos nombres inteligentes para nuestras clases.

Y todas las declaraciones de `script` se agrupan e incluyen inteligentemente en la p√°gina. Incluso si utiliza el mismo componente varias veces, el script s√≥lo se incluir√° una vez. Y s√≠, puedes usar el nivel superior `await`.

Puedes leer m√°s sobre esto en [la p√°gina de Astro's sobre scripts del lado del cliente](https://docs.astro.build/en/guides/client-side-scripts/).

El c√≥digo en s√≠ es bastante autoexplicativo. Importamos algunos m√©todos de `@stellar/freighter-api` para comprobar si el usuario est√° conectado. Si ya lo son, entonces `isAllowed` devuelve `true`. Si ha pasado m√°s de un d√≠a desde que han usado la extensi√≥n de carga, entonces la `publicKey` estar√° en blanco, por lo que les decimos que desbloqueen Freighter y actualicen la p√°gina. Si `isAllowed` y la `publicKey` se ven bien, reemplazamos el contenido del `div` con el mensaje de inicio de sesi√≥n, reemplazando el bot√≥n. De lo contrario, a√±adimos un manejador de clic al bot√≥n para pedir al usuario que conecte Freighter con `setAllowed`. Una vez que lo hacen, reemplazamos de nuevo el contenido del 'div' por el mensaje de inicio de sesi√≥n. Las [`aria`](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions) aseguran que los lectores de pantalla leer√°n los nuevos contenidos cuando se actualicen.

Ahora podemos importar el componente en la interfaz de `pages/index.astro`:

```diff title="pages/index.astro"
 ---
 import Layout from '../layouts/Layout.astro';
 import Card from '../components/Card.astro';
 import helloWorld from "../contracts/hello_world";
+import ConnectFreighter from '../components/ConnectFreighter.astro';
...
```

Y agr√©galo justo debajo de `<h1>`:

```diff title="pages/index.astro"
<h1>{greeting}</h1>
+<ConnectFreighter />
```

Si ya no est√° ejecutando su servidor de desarrollo, siga adelante y reinicie:

```bash
npm run dev
```

Luego abra la p√°gina y haga clic en el bot√≥n "Conectar". Deber√≠as ver aparecer el carguero y pedirte que inicies sesi√≥n. Una vez que lo haga, el bot√≥n debe ser reemplazado por un mensaje diciendo: "Firmado como [tu clave p√∫blica]".

¬°Ahora est√°s listo para firmar la llamada al `incremento`!

### Llame a `increment`

Ahora podemos importar el cliente de contrato `increment` de `soroban_increment_contract` y empezar a usarlo. Volveremos a crear un nuevo componente Astro. Crea un nuevo archivo en `src/components/Counter.astro` con el siguiente contenido:

```html title="src/components/Counter.astro"
<strong>Incrementador</strong><br />
Valor actual: <strong id="current-value" aria-live="polite">???</strong><br />
<br />
<button data-increment aria-controls="current-value">Incremento</button>

<script>
  Incrementador de importaci√≥n de ". /contracts/soroban_increment_contract";
  import { isAllowed, getPublicKey, signTransaction } from '@stellar/freighter-api';
  const button = documento. uerySelector("[data-increment]");
  const currentValue = documento. uerySelector("#current-value");
  if (await isAllowed()) {
    const publicKey = await getPublicKey();
    if (publicKey) incrementor. ptions.publicKey = publicKey;
  }
  button.addEventListener("click", async () => {
    bot√≥n. isabled = true;
    button.classList.add("cargando");
    currentValue.innerHTML =
      currentValue. nnerHTML +
      '<span class="visually-hidden"> ‚Äì actualizar‚Ä¶</span>';

    const tx = await incrementor. ncrement();
    const { result } = await tx. ignAndSend({signTransaction});

    // Solo usa `innerHTML` con los valores del contrato en los que conf√≠as!
    // ¬°Utilizar ciegamente los valores de un contrato no fiable abre a sus usuarios a ataques de inyecci√≥n de scripts!
    currentValue. nnerHTML = result.toString();

    button.disabled = false;
    button.classList.remove("cargando");
  });
</script>
```

Esto deber√≠a ser algo familiar a estas alturas. Tenemos un `script` que, gracias al sistema de compilaci√≥n de Astro, puede `importar` m√≥dulos directamente. Utilizamos `document.querySelector` para encontrar los elementos definidos arriba. Y a√±adimos un manejador de `click` al bot√≥n, que llama `increment` y actualiza el valor de la p√°gina. Tambi√©n ajusta el bot√≥n a 'desactivado' y a√±ade una clase 'cargando' mientras la llamada est√° en curso para evitar que el usuario haga clic de nuevo y comunique visualmente que algo est√° sucediendo. Para las personas que utilizan lectores de pantalla, el estado de carga se comunica con el [visually-hidden](https://www.a11yproject. om/posts/how-to-hide-content/) extensi√≥n, que ser√° anunciada gracias a las etiquetas `aria` que vimos anteriormente.

La mayor diferencia con la llamada a `greeter.hello` es que esta transacci√≥n se ejecuta en dos pasos. La llamada inicial al 'incremento' construye una transacci√≥n Soroban y luego hace una llamada RPC a _simulate_ ella. Para llamadas de s√≥lo lectura como `hola`, esto es todo lo que necesitas, as√≠ que puedes obtener el `resultado` de inmediato. Para llamadas de escritura como `increment`, entonces necesitas `signAndSend` antes de que la transacci√≥n realmente se incluya en el ledger.

:::info

Destructurando `{ result }`: Si eres nuevo en JavaScript, puede que no sepa lo que est√° pasando con esas l√≠neas `const { result }`. Esta es la funci√≥n _destructuring_ de JavaScript. Si la cosa a la derecha del signo de iguales es un objeto, entonces puede usar este patr√≥n para tomar r√°pidamente claves espec√≠ficas de ese objeto y asignarlas a las variables. Tambi√©n puede nombrar la variable otra cosa, si lo desea. Por ejemplo, intente cambiar el c√≥digo anterior a:

```ts
const { result: newValue } = ...
```

:::

Adem√°s, ten en cuenta que no necesitas especificar manualmente Freighter como el monedero en la llamada a ¬´incremento¬ª. Esto puede cambiar en el futuro, pero mientras que Freighter es el √∫nico juego en la ciudad, estas bibliotecas generadas lo utilizan autom√°ticamente. Si quieres anular este comportamiento, puedes pasar una opci√≥n `wallet`; revisa la √∫ltima interfaz `Wallet` en [la fuente de la plantilla](https://github.com/stellar/soroban-tools/blob/main/cmd/crates/soroban-spec-typescript/src/project_template/src/method-options.ts) para m√°s detalles.

Ahora vamos a usar este componente. En `pages/index.astro`, primero importarlo:

```diff title="pages/index.astro"
 ---
 import Layout from '../layouts/Layout.astro';
 import Card from '../components/Card.astro';
 import helloWorld from ".. contracts/hello_world";
 import ConnectFreighter from '../components/ConnectFreighter.astro';
+import Counter from '../components/Counter.astro';
...
```

Entonces util√≠celo. Sustituyamos el contenido del p√°rrafo `instructions` con √©l:

```diff title="pages/index.astro"
 <p class="instructions">
- Para empezar, abra el directorio <code>src/pages</code> en su proyecto.<br />
- Desaf√≠o de c√≥digo  <strong>:</strong> Retire el mensaje "Bienvenido a Astro" anterior.
+  <Counter />
 </p>
```

Compruebe la p√°gina; si todav√≠a est√° ejecutando su servidor dev deber√≠a haber actualizado. Haz clic en el bot√≥n "Incrementar"; deber√≠as ver una confirmaci√≥n del Transportista. Confirmar... el valor actualizado! üéâ

Obviamente, faltan algunas funciones, sin embargo. Por ejemplo, que `???` es un bummer. Pero nuestro contrato 'incremento' no nos da una manera de cuestionar el valor actual sin tambi√©n actualizarlo.

Antes de intentar actualizarlo, vamos a estirar el proceso alrededor de la construcci√≥n, el despliegue y la generaci√≥n de clientes para los contratos.

## Llevar m√°s lejos

Si quieres llevarlo un poco m√°s lejos y asegurarte de que entiendes todas las piezas aqu√≠, prueba lo siguiente:

- Crea una carpeta `src/contracts` con un `greeter.ts` y un `incrementor.ts`. Mover el `new Contract({ ... })` l√≥gica en esos archivos. Tambi√©n puedes querer extraer la variable `rpcUrl` a un archivo `src/contracts/utils.ts`.
- A√±ade un m√©todo `get_value` al contrato `increment` y √∫salo para mostrar el valor actual en el componente `Counter`. Cuando ejecutas `npm run dev`, el script `initialize` se ejecutar√° y actualizar√° el contrato y el cliente generado.
- A√±ade un bot√≥n de "Decremento" al componente 'Contador'.
- [Deploy](https://docs.astro.build/en/guides/deploy/) tu frontend. Puedes hacer esto de forma r√°pida y gratuita [con GitHub](https://docs.astro.build/en/guides/deploy/github/). Si te quedas atascado instalando stellar-cli e implementando contratos en GitHub, revisa [c√≥mo hicimos esto](https://github.com/AhaLabs/soroban-tutorial-project/commit/c1f4cfde1bbaf059507100767ee6b43d29b42914).
- En lugar de usar scripts NPM para todo, intenta usar un runner de scripts m√°s elegante como [just](https://github.com/casey/just). Los `scripts` de npm existentes pueden entonces llamar a `just`, como `"setup": "just setup"`.
- Actualiza README para explicar qu√© es este proyecto y c√≥mo utilizarlo a posibles colaboradores y empleadores üòâ

## Soluci√≥n de problemas

A veces las cosas van mal. Como primer paso cuando solucione problemas, puede que quiera [clonar nuestro repositorio de tutoriales](https://github.com/AhaLabs/soroban-tutorial-project) y ver si el problema tambi√©n ocurre all√≠. Si ocurre all√≠ tambi√©n, puede ser un problema temporal con la red Soroban.

He aqu√≠ algunos problemas comunes y c√≥mo resolverlos.

### Llamada a `hello` falla

A veces la llamada a `hola` puede empezar a fallar. Obviamente puedes hacer stub de la llamada y definir `result` de alguna otra forma de soluci√≥n de problemas.

Uno de los problemas m√°s comunes aqu√≠ es que el contrato se convierte en [archived](../../learn/encyclopedia/storage/state-archival.mdx). Para comprobar si este es el problema, puede volver a ejecutar `npm run init`.

Si todav√≠a tienes problemas, √∫nete a nuestro Discord (enlace anterior) o [abre un problema en GitHub](https://github.com/stellar/stellar-docs/issues/new/choose).

### Todas las llamadas de contrato empiezan a lanzar errores `403`

Esto significa que Testnet est√° ca√≠do, y probablemente s√≥lo tenga que esperar un rato y vuelva a intentarlo.

## Limpiando

Algunas de las cosas que hicimos en esta secci√≥n:

- Aprendimos acerca del enfoque no JS-by-default de Astro's
- Agregamos componentes de Astro y aprendimos c√≥mo funcionan sus etiquetas `script` y `style`
- Hemos visto lo f√°cil que es interactuar con contratos inteligentes de JavaScript generando bibliotecas de clientes usando `stellar contract bindings typescript`
- Aprendimos sobre carteras y carteras

¬°En este punto, has visto un ejemplo completo de construir un contrato sobre Steller! ¬øQu√© sigue? ¬°Elegir! Puedes:

- Vea ejemplos m√°s complejos de contratos en la secci√≥n [Contratos de ejemplo](../smart-contracts/example-contracts/README.mdx).
- Aprenda m√°s sobre el [dise√±o y arquitectura interna](../../learn/encyclopedia/contract-development/README.mdx) de Soroban.
- Echa un vistazo a una [aplicaci√≥n de ejemplo](https://github.com/stellar/soroban-example-dapp), que utiliza React en lugar de vanilla JavaScript y Next.js en lugar de Astro. Esta aplicaci√≥n tambi√©n tiene un proceso de configuraci√≥n e inicializaci√≥n m√°s complejo, con la opci√≥n de usar un [nodo RPC alojado localmente](../../data/rpc/admin-guide.mdx).

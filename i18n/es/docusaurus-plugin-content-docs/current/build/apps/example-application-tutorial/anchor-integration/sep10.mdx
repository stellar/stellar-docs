---
title: "SEP-10: Autenticación web estelar"
sidebar_position: 20
---

import auth_valid from "/assets/auth_valid.png";

Similar a la información SEP-1, los protocolos SEP-6 y SEP-24 hacen uso de SEP-10 para autenticación con el usuario. El usuario debe demostrar que posee la cuenta antes de poder retirar o depositar cualquier activo como parte de SEP-10: Stellar Web Authentication.

Ya que ya tenemos la información del archivo `stellar.toml`, podemos utilizarla para mostrar algunos elementos interactivos al usuario.

## Prompt para autenticación

:::note

El `/src/routes/dashboard/transfers/+page. velte` está haciendo **mucho** trabajo a lo largo de estas secciones, y lo estamos cortando de varias maneras para mostrarlo como parte de este tutorial. Para obtener una imagen completa de este archivo, por favor recuerde comprobar el código fuente.

:::

```html title=/src/routes/dashboard/transfers/+page.svelte
<script>
  // `export let data` allows us to pull in any parent load data for use here.
  /** @type {import('./$types').PageData} */
  export let data;

  // We import some of our `$lib` functions
  import { fetchStellarToml } from "$lib/stellar/sep1";

  // An object to easily and consistently class badges based on the status of
  // a user's authentication token for a given anchor.
  const authStatusClasses = {
    unauthenticated: "badge badge-error",
    auth_expired: "badge badge-warning",
    auth_valid: "badge badge-success",
  };

  // A simple function that checks whether a user has a SEP-10 authentication token stored for an anchor, and if it is expired or not.
  const getAuthStatus = (homeDomain) => {
    if ($webAuthStore[homeDomain]) {
      let token = $webAuthStore[homeDomain];
      if (webAuthStore.isTokenExpired(token)) {
        return "auth_expired";
      } else {
        return "auth_valid";
      }
    } else {
      return "unauthenticated";
    }
  };
</script>

<!-- HTML has been omitted from this tutorial. Please check the source file -->
```

**Fuente:** https://github.com/stellar/basic-payment-app/blob/main/src/routes/dashboard/transfers/+page.svelte

## Solicitando una transacción de desafío

Ahora, cuando el usuario hace clic en el botón "autenticar", activa la función `auth`.

![authenticate](/assets/autenticate.png)

```html title=/src/routes/dashboard/transfers/+page.svelte
<script>
  /* Esta etiqueta <script> ha sido abreviada por simplicidad */

  importar { getChallengeTransaction } de "$lib/stellar/sep10";

  // Importamos los componentes de Svelte que necesitaremos
  importar ConfirmationModal de "$lib/components/ConfirmationModal. velte";

  // El contexto `open` Svelte se utiliza para abrir la modal de confirmación
  importar { getContext } desde "svelte";
  const { open } = getContext("simple-modal");

  // Definir algunas variables de componentes que serán utilizadas a lo largo de la página
  let challengeXDR = "";
  let challengeNetwork = "";
  let challengeHomeDomain = "";

  // Solicita una transacción de desafío desde un servidor SEP-10, y lo presenta al usuario para la verificación de pincode
  const auth = async (homeDomain) => {
    // Solicitar la transacción de desafío, esperando la cadena XDR
    let { transaction, network_passphrase } = await getChallengeTransaction({
      publicKey: data.publicKey,
      homeDomain: homeDomain,
    });

    // Establecer las variables del componente para mantener los detalles de la transacción
    challengeXDR = transacción;
    challengeNetwork = network_passphrase;
    challengeHomeDomain = homeDomain;

    // Abre el modal de confirmación para que el usuario confirme o rechace la transacción
    // reto. Proveemos nuestra función personalizada `onAuthConfirm`
    // para ser llamada como parte del proceso de confirmación del modal.
    open(ConfirmationModal, {
      title: "SEP-10 Challenge Transaction",
      cuerpo: "Por favor, confirma tu propiedad de esta cuenta firmando esta transacción de desafío. Esta transacción ya ha sido comprobada y verificada y todo se ve bien de lo que podemos decir. Siéntase libre de comprobar que todo se alinea con la especificación del SEP-10, sin embargo. ,
      transactionXDR: challengeXDR,
      transactionNetwork: challengeNetwork,
      onConfirm: onAuthConfirm,
    });
  };

  /* . . */
</script>

<!-- HTML ha sido omitido de este tutorial. Por favor, compruebe el archivo de origen -->
```

**Fuente:** https://github.com/stellar/basic-payment-app/blob/main/src/routes/dashboard/transfers/+page.svelte

Como parte de la función `auth`, BasicPay hace una solicitud `GET` con un parámetro `account` (la clave pública del usuario) al anclaje, que envía de vuelta una transacción estelar firmada por la clave de firma del servidor (llamada transacción challenge) con un número de secuencia inválido por lo que no pudo hacer nada si se enviaba accidentalmente a la red.

```js title=/src/lib/stellar/sep10.js
importar { Utils } desde "stellar-sdk";
importar { fetchStellarToml } desde "$lib/stellar/sep1";

// Solicita, valida y devuelve una transacción de desafío SEP-10 desde un servidor de anclas.
export async function getChallengeTransaction({ publicKey, homeDomain }) {
  let { WEB_AUTH_ENDPOINT, TRANSFER_SERVER, SIGNING_KEY } =
    await fetchStellarToml(homeDomain);

  // Para que el flujo SEP-10 funcione, debemos tener al menos un servidor
  // firmando clave, y un punto final de autenticación web (que puede ser el servidor de transferencia como
  // una reserva)
  if (! EB_AUTH_ENDPOINT || !TRANSFER_SERVER || ! IGNING_KEY) {
    throw error(500, {
      mensaje:
        "could not get challenge transaction (server missing toml entry or entries)",
    });
  }

  // Solicitar una transacción de desafío para la cuenta del usuario
  let res = await fetch(
    `${WEB_AUTH_ENDPOINT || TRANSFER_SERVER}? {new URLSearchParams({
      // Los parámetros posibles son `account`, `memo`, `home_domain`, y
      // `client_domain`. Para nuestros propósitos, sólo suministramos "cuenta".
      cuenta: publicKey,
    })}`,
  );
  let json = await res. hijo();

  // Validar la transacción challenge cumple con todos los requisitos para SEP-10
  validateChallengeTransaction({
    transactionXDR: json. ransaction,
    serverSigningKey: SIGNING_KEY,
    red: json. etwork_passphrase,
    clientPublicKey: publicKey,
    homeDomain: homeDomain,
  });
  return json;
}

// Valida la estructura e información correcta en una transacción de desafío SEP-10.
function validateChallengeTransaction({
  transactionXDR,
  serverSigningKey,
  network,
  clientPublicKey,
  homeDomain,
  clientDomain,
}) {
  if (! lientDomain) {
    clientDomain = homeDomain;
  }

  try {
    // Usa la función `readChallengeTx` de Stellar SDK para leer y
    // verificar la mayor parte de la información de transacción del desafío
    let results = Utils. eadChallengeTx(
      transactionXDR,
      serverSigningKey,
      red,
      homeDomain,
      dominio de cliente,
    );
    // También asegúrese de que la transacción fue creada para el usuario correcto
    si (resultados. lientAccountID === clientPublicKey) {
      return;
    } else {
      throw error(400, {
        mensaje: "clientAccountID does not match challenge transaction",
      });
    }
  } catch (err) {
    throw error(400, { message: JSON. tringify(err) });
  }
}
```

**Fuente:** https://github.com/stellar/basic-payment-app/blob/main/src/lib/stellar/sep10.js

## Firmar y enviar la transacción de desafío

En respuesta, el usuario firma la transacción. Puede que hayas notado que presentamos esta transacción de desafío al usuario con nuestro modal de confirmación regular. Una vez que han firmado la transacción, la aplicación la envía de vuelta al anclaje con una solicitud `POST`. Si la firma revisa, la respuesta de éxito contendrá un [JSON Web Token (crwd)lbracketdwrcJWT](https://jwt. o/), que BasicPay almacena en la tienda `webAuthStore` para futuras interacciones con el fondo.

```html title=/src/routes/dashboard/transfers/+page.svelte
<script>
  /* ... */

  // Importamos cualquier tienda que necesitemos leer y/o escribir
  importar { invalidateAll } de "$app/navigation";
  importar { walletStore } de "$lib/stores/walletStore";
  importar { webAuthStore } de "$lib/stores/webAuthStore";

  // Importamos algunas de nuestras funciones `$lib`
  // resaltar-iniciar
  import {
    getChallengeTransaction,
    submitChallengeTransaction,
  } from "$lib/stellar/sep10";
  // resaltado

  // Realiza una acción después de que el usuario haya confirmado el pincode en una transacción de desafío SEP-10.
  const onAuthConfirm = async (pincode) => {
    // Firmar la transacción con el par de claves del usuario
    let signedTransaction = await walletStore. ign({
      transactionXDR: challengeXDR,
      red: challengeNetwork,
      pincode: pincode,
    });
    // Envía la tx firmada al servidor SEP-10, y obtener el token JWT de vuelta
    let token = await submitChallengeTransaction({
      transactionXDR: signedTransaction. oXDR(),
      homeDomain: challengeHomeDomain,
    });
    // Añadir el token a nuestra tienda
    webAuthStore. etAuth(challengeHomeDomain, token);
    // Recargar cualquier función `load()` relevante (i. ., refrescar la página)
    invalidateAll();
  };

  /* ... */
</script>

<!-- HTML ha sido omitido de este tutorial. Por favor, compruebe el archivo de origen -->
```

**Fuente:** https://github.com/stellar/basic-payment-app/blob/main/src/routes/dashboard/transfers/+page.svelte

La función `submitChallengeTransaction` es bastante simple. Tomamos la transacción (en formato XDR) y el nombre de dominio, y la enviamos al archivo `WEB_AUTH_ENDPOINT` relevante proporcionado por el archivo `stellar.toml` del dominio principal.

```js title=/src/lib/stellar/sep10.js
// Submits a SEP-10 challenge transaction to an authentication server and returns the SEP-10 token.
export async function submitChallengeTransaction({
  transactionXDR,
  homeDomain,
}) {
  let webAuthEndpoint = await getWebAuthEndpoint(homeDomain);

  if (!webAuthEndpoint)
    throw error(500, {
      message: "could not authenticate with server (missing toml entry)",
    });
  let res = await fetch(webAuthEndpoint, {
    method: "POST",
    mode: "cors",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ transaction: transactionXDR }),
  });
  let json = await res.json();

  if (!res.ok) {
    throw error(400, { message: json.error });
  }
  return json.token;
}
```

**Fuente:** https://github.com/stellar/basic-payment-app/blob/main/src/lib/stellar/sep10.js

## Acerca de la tienda `webAuthStore`

Como gran parte de nuestra aplicación BasicPay, los diversos tokens de autenticación que el usuario puede haber acumulado con el tiempo se almacenan en el `localStorage` del navegador. No hay mucho especial sobre esta tienda en particular, pero así es como la ponemos juntas:

```js title=/src/lib/stores/webAuthStore.js
importar { get } desde "svelte/store";
importar { persisted } desde "svelte-local-storage-store";
importar { Buffer } desde "buffer";

function createWebAuthStore() {
  const { subscribe, update } = persisted("bpa:webAuthStore", {});

  devolver {
    suscrito,

    // Guarda un token de autenticación JWT asociado con un servidor de dominio doméstico.
    setAuth: (homeDomain, token) =>
      update((store) => {
        return {
          ... tore,
          [homeDomain]: token,
        };
      }),

    // Determina si un token web JSON tiene o no una fecha de caducidad en el futuro o en el pasado.
    isTokenExpired: (homeDomain) => {
      let token = get(webAuthStore)[homeDomain];
      if (token) {
        let payload = JSON. arse(
          Buffer.from(token.split(".")[1], "base64"). oString(),
        );
        let timestamp = Matemáticas. loor(Date.now() / 1000);
        return timestamp > payload. xp;
      } else {
        return undefined;
      }
    },
  };
}

export const webAuthStore = createWebAuthStore();
```

**Fuente:** https://github.com/stellar/basic-payment-app/blob/main/src/lib/stores/webAuthStore.js

Ahora que hemos autenticado con éxito a nuestro usuario con un ancla de activos, podemos mostrar y procesar las distintas capacidades de transferencia del anclaje en cuestión. Empezaremos con SEP-6, ya que esto sentará las bases para que el SEP-24 siga el camino.

<img src={auth_valid} width="70%" />

---
title: Ruta de pago
sidebar_position: 50
---

Un pago por ruta es donde el activo enviado puede ser diferente del activo recibido. Hay dos posibles operaciones de pago en la ruta: 1) `path_payment_strict_send`, que permite al usuario especificar la cantidad del activo a enviar, y 2) `path_payment_strict_receive`, que permite al usuario especificar la cantidad del activo recibido. Lea más en la [Entrada Enciclopedia de Pagos de Precaución](../../../learn/encyclopedia/transactions-specialized/path-payments.mdx).

## Experiencia de usuario

Con BasicPay, el usuario envía una ruta de pago navegando a la página de pagos, donde pueden seleccionar a un usuario de sus contactos o introducir la clave pública de una dirección de destino. Luego seleccionan la opción Enviar y Recibir diferentes activos y determinan si quieren especificar el activo enviado o recibido. Finalmente seleccionan el activo enviado y el activo recibido y las cantidades y seleccionan el botón Previsualizar Transacción.

![Pago de ruta](/assets/path-payment.png)

A continuación, el usuario previsualizará la transacción, introducirá su código y seleccionará el botón Confirmar para firmar y enviar la transacción a la red.

## Implementación de código

### La página `/dashboard/send`

La mayor parte de esta página ha sido discutida en la [sección de pago](./payment.mdx#the-dashboardsend-page). A continuación, destacamos las piezas únicas que se añaden a BasicPay para permitir la función de pago de la ruta.

```html title="/src/routes/dashboard/send/+page.svelte"
<script>
  // We import some of our `$lib` functions
  import {
    fetchAccount,
    submit,
    fetchAccountBalances,
    // highlight-start
    findStrictSendPaths,
    findStrictReceivePaths,
    // highlight-end
  } from "$lib/stellar/horizonQueries";
  import {
    createCreateAccountTransaction,
    // highlight-start
    createPathPaymentStrictReceiveTransaction,
    createPathPaymentStrictSendTransaction,
    // highlight-end
    createPaymentTransaction,
  } from "$lib/stellar/transactions";

  /* ... */

  // Define some component variables that will be used throughout the page
  let destination = "";
  $: otherDestination = destination === "other";
  let otherPublicKey = "";
  let sendAsset = "native";
  let sendAmount = "";
  let receiveAsset = "";
  let receiveAmount = "";
  let memo = "";
  let createAccount = null;
  // highlight-start
  let pathPayment = false;
  let availablePaths = [];
  let strictReceive = false;
  // highlight-end
  let paymentXDR = "";
  let paymentNetwork = "";

  /* ... */

  // Query Horizon for available paths between a combination of source and destination assets and accounts.
  const findPaths = async () => {
    // Query the paths from Horizon
    let paths = strictReceive
      ? await findStrictReceivePaths({
          sourcePublicKey: data.publicKey,
          destinationAsset: receiveAsset,
          destinationAmount: receiveAmount,
        })
      : await findStrictSendPaths({
          sourceAsset: sendAsset,
          sourceAmount: sendAmount,
          destinationPublicKey: otherDestination ? otherPublicKey : destination,
        });
    // Fill the component variable `availablPaths` with our returned paths
    availablePaths = paths;
    // If both send and receive assets have been selected re-select the path
    // to update the relevant amount
    if (receiveAsset && sendAsset) {
      selectPath();
    }
  };

  // Select a path for use in the path payment operation, and set the component variables accordingly.
  const selectPath = () => {
    if (strictReceive) {
      // Set the `sendAmount` variable to the chosen path amount. The
      // filtering we do checks if the asset_type matches because that
      // will give us our 'native' XLM asset, otherwise we match on the
      // asset_code.
      sendAmount = availablePaths.filter(
        (path) =>
          path.source_asset_type === sendAsset ||
          sendAsset.startsWith(path.source_asset_code),
      )[0].source_amount;
    } else {
      // Set the `receiveAmount` variable to the chosen path amount. The
      // filtering we do checks if the asset_type matches because that
      // will give us our 'native' XLM asset, otherwise we match on the
      // asset_code.
      receiveAmount = availablePaths.filter(
        (path) =>
          path.destination_asset_type === receiveAsset ||
          receiveAsset.startsWith(path.destination_asset_code),
      )[0].destination_amount;
    }
  };

  /* ... */

  // Create a payment transaction depending on user selections, and present it to the user for approval or rejection.
  const previewPaymentTransaction = async () => {
    let { transaction, network_passphrase } = createAccount
      ? await createCreateAccountTransaction({
          /* ... */
        })
      : // highlight-start
        pathPayment && strictReceive
        ? await createPathPaymentStrictReceiveTransaction({
            source: data.publicKey,
            sourceAsset: sendAsset,
            sourceAmount: sendAmount,
            destination: otherDestination ? otherPublicKey : destination,
            destinationAsset: receiveAsset,
            destinationAmount: receiveAmount,
            memo: memo,
          })
        : pathPayment && !strictReceive
          ? await createPathPaymentStrictSendTransaction({
              source: data.publicKey,
              sourceAsset: sendAsset,
              sourceAmount: sendAmount,
              destination: otherDestination ? otherPublicKey : destination,
              destinationAsset: receiveAsset,
              destinationAmount: receiveAmount,
              memo: memo,
            })
          : // highlight-end
            await createPaymentTransaction({
              /* ... */
            });

    /* ... */
  };
</script>

<!-- HTML has been omitted from this tutorial. Please check the source file -->
```

**Fuente:** https://github.com/stellar/basic-payment-app/blob/main/src/routes/dashboard/send/+page.svelte

### Las funciones de transacción

En la sección anterior, usamos las funciones `createPathPaymentStrictReceiveTransaction` y `createPathPaymentStrictSendTransaction`. Estos se utilizan para crear transacciones que contengan la operación de pago de ruta real.

```js title="/src/lib/stellar/transactions.js"
// Constructs and returns a Stellar transaction that will contain a path payment strict send operation to send/receive different assets.
export async function createPathPaymentStrictSendTransaction({
  source,
  sourceAsset,
  sourceAmount,
  destination,
  destinationAsset,
  destinationAmount,
  memo,
}) {
  // First, we setup our transaction by loading the source account from the
  // network, and initializing the TransactionBuilder. This is the first step
  // in constructing all Stellar transactions.
  let server = new Server(horizonUrl);
  let sourceAccount = await server.loadAccount(source);
  let transaction = new TransactionBuilder(sourceAccount, {
    networkPassphrase: networkPassphrase,
    fee: maxFeePerOperation,
  });

  // We work out the assets to be sent by the source account and received by
  // the destination account
  let sendAsset =
    sourceAsset === "native"
      ? Asset.native()
      : new Asset(sourceAsset.split(":")[0], sourceAsset.split(":")[1]);
  let destAsset =
    destinationAsset === "native"
      ? Asset.native()
      : new Asset(
          destinationAsset.split(":")[0],
          destinationAsset.split(":")[1],
        );

  // We will calculate an acceptable 2% slippage here for... reasons?
  let destMin = ((98 * parseFloat(destinationAmount)) / 100).toFixed(7);

  // If a memo was supplied, add it to the transaction
  if (memo) {
    transaction.addMemo(Memo.text(memo));
  }

  // Add a single `pathPaymentStrictSend` operation
  transaction.addOperation(
    Operation.pathPaymentStrictSend({
      sendAsset: sendAsset,
      sendAmount: sourceAmount.toString(),
      destination: destination,
      destAsset: destAsset,
      destMin: destMin,
    }),
  );

  // Before the transaction can be signed, it requires timebounds, and it must
  // be "built"
  let builtTransaction = transaction.setTimeout(standardTimebounds).build();
  return {
    transaction: builtTransaction.toXDR(),
    network_passphrase: networkPassphrase,
  };
}

// Constructs and returns a Stellar transaction that will contain a path payment strict receive operation to send/receive different assets.
export async function createPathPaymentStrictReceiveTransaction({
  source,
  sourceAsset,
  sourceAmount,
  destination,
  destinationAsset,
  destinationAmount,
  memo,
}) {
  // First, we setup our transaction by loading the source account from the
  // network, and initializing the TransactionBuilder. This is the first step
  // in constructing all Stellar transactions.
  let server = new Server(horizonUrl);
  let sourceAccount = await server.loadAccount(source);
  let transaction = new TransactionBuilder(sourceAccount, {
    networkPassphrase: networkPassphrase,
    fee: maxFeePerOperation,
  });

  // We work out the assets to be sent by the source account and received by
  // the destination account
  let sendAsset =
    sourceAsset === "native"
      ? Asset.native()
      : new Asset(sourceAsset.split(":")[0], sourceAsset.split(":")[1]);
  let destAsset =
    destinationAsset === "native"
      ? Asset.native()
      : new Asset(
          destinationAsset.split(":")[0],
          destinationAsset.split(":")[1],
        );

  /** @todo Figure out a good number to use for slippage. And why! And how to calculate it?? */
  // We will calculate an acceptable 2% slippage here for... reasons?
  let sendMax = ((100 * parseFloat(sourceAmount)) / 98).toFixed(7);

  // If a memo was supplied, add it to the transaction
  if (memo) {
    transaction.addMemo(Memo.text(memo));
  }

  // Add a single `pathPaymentStrictSend` operation
  transaction.addOperation(
    Operation.pathPaymentStrictReceive({
      sendAsset: sendAsset,
      sendMax: sendMax,
      destination: destination,
      destAsset: destAsset,
      destAmount: destinationAmount,
    }),
  );

  // Before the transaction can be signed, it requires timebounds, and it must
  // be "built"
  let builtTransaction = transaction.setTimeout(standardTimebounds).build();
  return {
    transaction: builtTransaction.toXDR(),
    network_passphrase: networkPassphrase,
  };
}
```

**Fuente:** https://github.com/stellar/basic-payment-app/blob/main/src/lib/stellar/transactions.js

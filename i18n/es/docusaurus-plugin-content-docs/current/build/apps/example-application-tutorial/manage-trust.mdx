---
title: Gestionar confianza
sidebar_position: 30
---

Para que una cuenta mantenga y opere activos distintos de XLM, debe establecer un [trustline](../../../learn/fundamentals/stellar-data-structures/accounts.mdx#trustlines) con la cuenta emisora de ese activo en particular. Cada trustline incrementa la [reserva base](../../learn/fundamentals/stellar-data-structures/accounts.mdx#base-reserves-and-subentries) de la cuenta por 0.5 XLM, lo que significa que la cuenta tendrá que mantener más XLM en su saldo mínimo.

## Experiencia de usuario

Primero, el usuario creará una línea de confianza para un activo navegando a la página de Activos seleccionando un recurso y haciendo clic en el botón "Añadir activo".

:::info

Un activo se muestra como código de activo y dirección del emisor. Más información en nuestra [Sección de Activos](../../../learn/fundamentals/stellar-data-structures/assets.mdx).

:::

![add-assets](/assets/add-assets.png)

Esto activa un formulario modal para que el usuario confirme la transacción con su código pincode. Una vez confirmado, una transacción que contiene la operación `changeTrust` es firmada y enviada a la red, y se establece una línea de confianza entre la cuenta del usuario y la cuenta emisora del activo.

La operación `changeTrust` también puede utilizarse para modificar o eliminar líneas de confianza.

:::info

Cada transacción debe contener un número de secuencia que se utiliza para identificar y verificar el orden de las transacciones con la cuenta. El número de secuencia de una transacción siempre debe aumentar por uno. En BasicPay, obtener e incrementar el número de secuencia es manejado automáticamente por el constructor de transacciones.

:::

Las líneas de confianza mantienen los balances de todos sus activos asociados (excepto XLM, que se mantienen en el nivel de la cuenta), y puedes mostrar los diferentes saldos del usuario en tu aplicación.

![Mostrar activos](/assets/display-assets.png)

Ver en acción aquí: https://basicpay.pages.dev/dashboard/assets

## Implementación de código

Las líneas de confianza que tiene una cuenta serán necesarias para ver en varias partes de la aplicación BasicPay. En primer lugar, discutiremos cómo administramos diferentes líneas de confianza para la cuenta.

### La página `/dashboard/assets`

La página `/dashboard/assets` permite al usuario administrar los activos estelares a los que su cuenta lleva líneas de confianza. En esta página, pueden seleccionar entre varios activos pre-sugeridos o altamente clasificados, o podrían especificar su propio activo en el que confiar utilizando un código de activo y una clave pública del emisor. También pueden eliminar las líneas de confianza que ya existen en su cuenta.

El diseño de la página es muy similar a nuestra página de contactos. Tiene una tabla que muestra las líneas de confianza existentes y una sección donde se pueden agregar nuevas. La diferencia clave es que la tienda de `contacts` se mantiene en el `localStorage` del navegador, mientras que los saldos de una cuenta se mantienen en la cadena de bloques. Por lo tanto, estaremos consultando a la red para obtener esa información. Para más información sobre cómo consultamos esta información desde la red Stellar, consulta la función `fetchAccountBalances()` en [esta sección de consultas de datos].

```html title="/src/routes/dashboard/assets/+page.svelte"
<script>
  // `export let data` allows us to pull in any parent load data for use here.
  /** @type {import('./$types').PageData} */
  export let data;

  // This is where our _reactive_ array of balances is declared. The query
  // actually takes place in `/src/routes/dashboard/+layout.js`, and is
  // inherited here.
  $: balances = data.balances ?? [];

  // We import things from external packages that will be needed
  import { Trash2Icon } from "svelte-feather-icons";

  // We import any Svelte components we will need
  import ConfirmationModal from "$lib/components/ConfirmationModal.svelte";
  import TruncatedKey from "$lib/components/TruncatedKey.svelte";

  // We import any stores we will need to read and/or write
  import { walletStore } from "$lib/stores/walletStore";
  import { invalidateAll } from "$app/navigation";

  // We import some of our `$lib` functions
  import { submit } from "$lib/stellar/horizonQueries";
  import { createChangeTrustTransaction } from "$lib/stellar/transactions";
  import { fetchAssets } from "$lib/utils/stellarExpert";

  // The `open` Svelte context is used to open the confirmation modal
  import { getContext } from "svelte";
  const { open } = getContext("simple-modal");

  // Define some component variables that will be used throughout the page
  let addAsset = "";
  let customAssetCode = "";
  let customAssetIssuer = "";
  let changeTrustXDR = "";
  let changeTrustNetwork = "";
  $: asset =
    addAsset !== "custom"
      ? addAsset
      : `${customAssetCode}:${customAssetIssuer}`;

  // Takes an action after the pincode has been confirmed by the user.
  const onConfirm = async (pincode) => {
    // Use the walletStore to sign the transaction
    let signedTransaction = await walletStore.sign({
      transactionXDR: changeTrustXDR,
      network: changeTrustNetwork,
      pincode: pincode,
    });
    // Submit the transaction to the Stellar network
    await submit(signedTransaction);
    // `invalidateAll` will tell SvelteKit that it should re-run any `load`
    // functions. Since we have a new (or newly deleted) trustline, this
    // results in re-querying the network to get updated account balances.
    invalidateAll();
  };

  // Builds and presents to the user for confirmation a Stellar transaction that
  // will add/modify/remove a trustline on their account. This function is
  // called when the user clicks the "add" or "delete" trustline buttons.
  const previewChangeTrustTransaction = async (
    addingAsset = true,
    removeAsset = undefined,
  ) => {
    // Generate the transaction, expecting back the XDR string
    let { transaction, network_passphrase } =
      await createChangeTrustTransaction({
        source: data.publicKey,
        asset: removeAsset ?? asset,
        limit: addingAsset ? undefined : "0",
      });

    // Set the component variables to hold the transaction details
    changeTrustXDR = transaction;
    changeTrustNetwork = network_passphrase;

    // Open the confirmation modal for the user to confirm or reject the
    // transaction. We provide our customized `onConfirm` function, but we
    // have no need to customize and pass an `onReject` function.
    open(ConfirmationModal, {
      transactionXDR: changeTrustXDR,
      transactionNetwork: changeTrustNetwork,
      onConfirm: onConfirm,
    });
  };
</script>

<!-- HTML has been omitted from this tutorial. Please check the source file -->
```

**Fuente:** https://github.com/stellar/basic-payment-app/blob/main/src/routes/dashboard/assets/+page.svelte

### La función `createChangeTrustTransaction`

En la página anterior, hemos hecho uso de la función `createChangeTrustTransaction`. Esta función puede ser usada para añadir, eliminar o modificar líneas de confianza en una cuenta Stellar.

```js title="/src/lib/stellar/transactions.js"
import {
  TransactionBuilder,
  Networks,
  Server,
  Operation,
  Asset,
} from "stellar-sdk";
import { error } from "@sveltejs/kit";

// We are setting a very high maximum fee, which increases our transaction's
// chance of being included in the ledger. We're making this a `const` so we can
// change it on one place as and when recommendations and/or best practices
// evolve. Current recommended fee is `100_000` stroops.
const maxFeePerOperation = "100000";
const horizonUrl = "https://horizon-testnet.stellar.org";
const networkPassphrase = Networks.TESTNET;
const standardTimebounds = 300; // 5 minutes for the user to review/sign/submit

// Constructs and returns a Stellar transaction that will create or modify a
// trustline on an account.
export async function createChangeTrustTransaction({ source, asset, limit }) {
  // We start by converting the asset provided in string format into a Stellar
  // Asset() object
  let trustAsset = new Asset(asset.split(":")[0], asset.split(":")[1]);

  // Next, we setup our transaction by loading the source account from the
  // network, and initializing the TransactionBuilder.
  let server = new Server(horizonUrl);
  let sourceAccount = await server.loadAccount(source);

  // Chaning everything together from the `transaction` declaration means we
  // don't have to assign anything to `builtTransaction` later on. Either
  // method will have the same results.
  let transaction = new TransactionBuilder(sourceAccount, {
    networkPassphrase: networkPassphrase,
    fee: maxFeePerOperation,
  })
    // Add a single `changeTrust` operation (this controls whether we are
    // adding, removing, or modifying the account's trustline)
    .addOperation(
      Operation.changeTrust({
        asset: trustAsset,
        limit: limit?.toString(),
      }),
    )
    // Before the transaction can be signed, it requires timebounds
    .setTimeout(standardTimebounds)
    // It also must be "built"
    .build();

  return {
    transaction: transaction.toXDR(),
    network_passphrase: networkPassphrase,
  };
}
```

[esta sección de consulta de datos]: ./querying-data.mdx#fetchaccountbalances

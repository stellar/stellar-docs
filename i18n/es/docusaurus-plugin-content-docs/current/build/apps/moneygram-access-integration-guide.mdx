---
title: Integrar con acceso a MoneyGram
sidebar_position: 60
---

import { CodeExample } from "@site/src/components/CodeExample";

Este documento guía al lector a través de los requisitos técnicos para integrar [MoneyGram Access] en una aplicación existente. MoneyGram Access es un producto MoneyGram que permite a los usuarios de aplicaciones de terceros, tales como criptografías de bolsillos e intercambios, a cobro (depósito) y retiro de efectivo (retirada) de Stellar USDC.

MoneyGram requiere que las empresas realicen un proceso de incorporación para tener acceso a sus entornos de pruebas y producción. Para empezar con este proceso, comuníquese con partnerships@stellar.org.

## Recursos

- [Implementación MVP de MoneyGram de acceso]
  - Utilice esta implementación MVP como referencia para construir su propia integración. Muchos de los fragmentos de código compartidos en este documento son extraídos de este proyecto.
- [Stellar Wallet SDK Docs]
  - Utilice este SDK de Wallet para facilitar la construcción de su propia integración. Muchos de los fragmentos de código compartidos en este documento son extraídos del [repositorio SDK del monedero estelar].
- [Anclaje de prueba estelar]
  - Antes de acceder al entorno de pruebas de MoneyGram, puede utilizar el ancla de pruebas de SDF mientras desarrolla su integración
- [Monedero Demo Estelar]
  - Esta aplicación visualiza las llamadas de API necesarias para conectarse a un ancla estelar
- [Propuesta de ecosistema estelar 24 (SEP-24)][sep-24]
  - El protocolo estandarizado de API para Stellar on & off ramps, implementado por MoneyGram
- [Stellar Ecosystem Proposal 10 (SEP-10)][sep-10]
  - El protocolo estandarizado de API para autenticación estelar, implementado por MoneyGram

## Información del recurso

Antes de obtener acceso al entorno de pruebas de MoneyGram, debe probar su implementación con los SDF [Stellar Test Anchor]. Implementa las mismas APIs que el servicio de MoneyGram pero utiliza un activo diferente. La información de cada activo está a continuación.

### Token de referencia estelar

Este token solo está en testnet.

- **Emisión de cuenta**: [GCDNJUBQSX7AJWLJACMJ7I4BC3Z47BQUTMHEICZLE6MU4KQBRYG5JY6B]
- **Asset Code**: SRT

### Moneda USD

Testnet:

- **Emisión de cuenta**: [GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5]
- **Asset Code**: USDC

Pubnet:

- **Emisión de cuenta**: [GA5ZSEJYB37JRC5AVCIA5MOP4RHTM335X2KGX3IHOJAPP5RE34K4KZVN]
- **Asset Code**: USDC

## Introducción

Las aplicaciones que buscan integrar MoneyGram Access deben implementar el lado del cliente de [Stellar Ecosystem Proposal 24 (SEP-24)][sep-24], un protocolo estandarizado definido para que las aplicaciones se conecten a empresas como MoneyGram, más generalmente denominados anclajes, que ofrecen servicios de depósito y retiro Stellar utilizando raíles de pago local.

Este documento le guiará por los pasos necesarios para desarrollar una implementación funcional de este estándar.

La guía asumirá que su aplicación se está desarrollando primero en la red de pruebas de Stellar y utilizando la implementación de pruebas de acceso de MoneyGram, pero no hay diferencias funcionales que implementen la aplicación a la red pública de Stellar y utilicen el despliegue de la producción de MoneyGram.

### Instalar el SDK del monedero

Recomendamos encarecidamente usar el SDK de la cartera para facilitar la construcción de su integración. Encuentre más información sobre [Stellar Wallet SDK Docs].

Puedes usar `yarn` para instalarlo:

<CodeExample>

```bash
yarn añadir @stellar/typescript-wallet-sdk
```

</CodeExample>

## Aplicaciones Custodial vs. No Custodial

Algunas aplicaciones, como los intercambios centralizados, son custodiales, es decir, la aplicación tiene acceso a las claves privadas de las cuentas de actas que tienen fondos de sus usuarios en Stellar. Por lo general, las aplicaciones custodial agrupan los fondos de los usuarios en un conjunto más pequeño de cuentas Stellar, llamadas cuentas agrupadas, compartidas o omnibus.

Otras aplicaciones son no custodiales, lo que significa que la aplicación no tiene acceso a las claves privadas de las cuentas que mantienen los fondos de sus usuarios en Stellar. Por lo general, las aplicaciones no custodial crean o importan una cuenta Stellar preexistente para cada usuario.

Estos dos enfoques requieren diferencias menores pero concretas en la forma en que las aplicaciones se integran con MoneyGram Access. Las subsecciones de abajo describirán estas diferencias, pero el resto de este tutorial asumirá que la aplicación es custodial.

### Autenticación

MoneyGram necesita autenticar tanto al usuario como a la aplicación que se está utilizando a través del protocolo [SEP-10] de Stellar.

Las aplicaciones del Custodial son identificadas por la clave pública de cuenta Stellar que se registran en MoneyGram durante el proceso de incorporación. Al autenticar, la aplicación debe pasar esta clave pública como parámetro de consulta 'cuenta', y para identificar al usuario, la aplicación debe pasar un ID entero único como parámetro de consulta `memo`. MoneyGram devolverá una transacción estelar que debe ser firmada por la clave privada de la aplicación y enviada de vuelta para su verificación.

Porque cada usuario de una aplicación no custodial tiene su propia cuenta Stellar, las aplicaciones no custodial son identificadas por el dominio doméstico que se registran en MoneyGram durante el proceso de incorporación. Al autenticar, la aplicación debe pasar _la clave pública del usuario_ como el parámetro de consulta 'cuenta', y pasar su dominio principal como el parámetro de consulta 'client_dominio'. MoneyGram buscará el valor `SIGNING_KEY` en `https://<client_domain>/.well-known/stellar. oml`, y devolver una transacción estelar que requiere firmas tanto de la clave privada del usuario como de la clave privada del público `SIGNING_KEY` en el estelar [SEP-1] de la aplicación. archivo oml. Un archivo de ejemplo se puede encontrar en https://vibrantapp.com/.well-known/stellar.toml.

### Iniciación de transacción

Debido a que los usuarios de aplicaciones custodial no tienen cuentas individuales de Stellar, sólo la aplicación sabe cuánto dinero tiene que retirar un usuario. Debido a esto, MoneyGram requiere que las aplicaciones custodial siempre superen el campo `amount` en la solicitud para iniciar una nueva transacción. Las aplicaciones no custodial no necesitan hacer esto, aunque sí pueden si lo prefieren.

### Fuente y destino de los fondos

MoneyGram requiere que las aplicaciones de protección proporcionen las cuentas Stellar que pueden ser utilizadas como fuente o destino de fondos durante el proceso de incorporación. Para aplicaciones no custodiales, MoneyGram requiere que la fuente y destino de los fondos para cada transacción sea la misma cuenta que fue autenticada a través de [SEP-10].

## Flujo de aplicaciones y arquitectura

Esta guía asumirá que la aplicación tiene una arquitectura básica cliente-servidor. El cliente de la aplicación solicitará recursos e iniciará acciones con el servidor de la aplicación, que se comunicará directamente con el servidor de MoneyGram.

A continuación se muestran los 7 pasos de alto nivel a tomar para facilitar una transacción de retiro de efectivo.

![Monedero - Página de MoneyGram 1](/assets/wallet-mgi-architecture-1.png)

Después del paso 4, la aplicación debe abrir la URL proporcionada por MoneyGram en una ventana de navegador o web móvil. MoneyGram le pedirá al usuario que proporcione información de KYC y de transacciones. Una vez finalizado este flujo, el cliente de la aplicación debe cerrar la pestaña MoneyGram o webview e iniciar el desembolso de fondos.

![Monedero - Página de MoneyGram 2](/assets/wallet-mgi-architecture-2.png)

El número de referencia previsto se trasladará a cualquier agente de dinero en efectivo de MoneyGram para recibir dinero en efectivo en la moneda fiat del usuario. Estos pasos documentan el flujo de retiro de efectivo, o de retiro. El flujo del depósito es similar y se detalla en los pasos siguientes.

## Generar pares de llaves estelares

En esta sección, generará al menos dos pares de claves Stellar, que se utilizará para probar la identidad de tu aplicación al autenticarte con MoneyGram Access, y otro que mantendrá, enviará, y recibirá USDC en Stellar. Siempre debe utilizar un par de claves para la autenticación, pero la aplicación podría usar muchos pares de claves para enviar y recibir pagos. En esta guía, asumiremos que la aplicación utiliza un par de claves para cada propósito.

Esta sección asume que su aplicación no tiene soporte para la red Stellar. Si su aplicación ya soporta depósitos y retiros de XLM, ya tiene una o más cuentas estelares que pueden ser utilizadas para estos fines, aunque se recomienda utilizar un nuevo par de claves para la autenticación.

Vaya a [Stellar Lab] y genere 2 pares de claves. Las claves secretas deben manejarse de forma segura, ya que se utilizarán para autenticar y desembolsar fondos a MoneyGram.

El primer par de claves se llamará el par de claves “autenticación” (o clave pública/secreta). El segundo par de claves será el par de claves (o cuenta, clave pública o clave secreta). A diferencia del par de claves de autenticación, el par de claves de fondos hará referencia a una cuenta financiada en la red Stellar. El par de claves de autenticación no necesita ser financiado.

Proporcionar las claves públicas (comenzando con un G) de los pares de claves tanto de autenticación como de fondos a MoneyGram. Añadirán estas claves a sus listas de claves conocidas, concediéndoles acceso a su implementación.

## Get XLM & USDC

Muchos mercados de criptomonedas soportan la compra de XLM o USDC en Stellar. El SDF también mantiene un [Directorio de Anclajes] que intenta listar todos los ramps on & off-ramps para la Red Stellar.

Cuando hayas comprado XLM y / o USDC en un intercambio, puedes hacer un pago a una cuenta externa, específicamente a los fondos clave pública que generó en el paso anterior. Ten en cuenta que primero tendrás que enviar XLM para crear la cuenta, luego añadir un USDC [trustline]y luego enviar el USDC. Crear una línea de confianza al USDC se puede hacer usando [Stellar Lab] o cualquier aplicación de cartera con habilitación de Stellar, como [Lobstr].

Algunos intercambios soportan XLM pero no soportan USDC en Stellar. Esto no es un problema, porque siempre se puede vender XLM para USDC en el intercambio descentralizado (o SDEX) de Stellar.

Para ello, envíe su XLM a la clave pública de fondos desde el intercambio, añadir una línea de confianza, y vender XLM por USDC usando una [oferta de venta].

## Autenticar

Esta sección engloba los pasos 1 y 2 del diagrama que se muestran en la sección de Arquetismo. El cliente de la aplicación debe solicitar una URL de transacción de MoneyGram al servidor de la aplicación al iniciar el usuario. Esto debería desencadenar un proceso de autenticación entre el servidor de la aplicación y el servidor de MoneyGram. Este proceso está estandarizado en [SEP-10][sep-10].

Esta sección asume que el servidor de la aplicación tiene los siguientes elementos de información:

- El identificador entero del usuario (debe ser positivo y representado usando 64 bits o menos) el punto final de autenticación de MoneyGram
  - Pruebas: https://extstellar.moneygram.com/stellaradapterservice/auth
  - Producción: https://stellar.moneygram.com/stellaradapterservice/auth
- Clave pública de autenticación de MoneyGram
  - Testing: `GCSESAP5ILVM6CWIEGK2SDOCQU7PHVFYYT7JNKRDAQNVQWKD5YEE5ZJ4`
  - Producción: `GD5NUMEX7LYHXGXCAD4PGW7JDMOUY2DKRGY5XZHJS5IONVHDKCJYGVCL`
- La clave pública y secreta de autenticación de la aplicación

El flujo se puede describir con los siguientes pasos:

1. La aplicación solicita un desafío de autenticación
2. El servidor (MoneyGram) proporciona el desafío de autenticación
3. La aplicación verifica que MoneyGram ha firmado la autenticación con su SIGNING_KEY
4. La aplicación firma el desafío de autenticación con su propia clave
5. La aplicación envía el desafío de autenticación de vuelta al servidor
6. El servidor verifica que la aplicación ha firmado el desafío con la cuenta que inicialmente utilizó para solicitar el desafío
7. El servidor devuelve un token de sesión para la cuenta y memo utilizados en la solicitud de autenticación inicial

El siguiente código demuestra cómo implementar el lado de la aplicación de este flujo. Tenga en cuenta que este código no maneja reintentos en caso de problemas de conexión a la red. Tampoco maneja códigos de estado inesperados y no incluye registros ni métricas.

<CodeExample>

```ts
import { Wallet, SigningKeypair } from "@stellar/typescript-wallet-sdk";

const wallet = Wallet.TestNet();

// Testnet
const MGI_ACCESS_HOST = "extstellar.moneygram. om";
// Pubnet
// const MGI_ACCESS_HOST = "stellar.moneygram. om";

// Primero creamos un objeto anclaje con el dominio principal de MoneyGram.
const anchor = wallet. nchor({ homeDomain: MGI_ACCESS_HOST });

// Luego creamos el objeto sep10 que maneja todos los pasos de la atenticación.
const sep10 = await anchor. ep10();

// Finalmente, nos autenticamos usando el secreto SIGNING_KEY del monedero.
const authKey = SigningKeypair.fromtformat@@1 (AUTH_SECRET_KEY);
const authToken = await sep10.authate({ accountKp: authKey });
```

```python
import requests
from stellar_sdk import Network
from stellar_sdk.sep.stellar_web_authentication import read_challenge_transaction

# Testnet
MGI_ACCESS_HOST = "extstellar.moneygram. om"
# Pubnet
# MGI_ACCESS_HOST = "stellar.moneygram. om"

def get_token() -> str:
    query = f"{AUTH_URL}? ccount={AUTH_PUBLIC_KEY}&memo={USER_ID}"
    respuesta = solicitudes. et(query)
    body = respuesta. son()
    challenge = read_challenge_transaction(
        challenge_transaction=body["transacción"],
        server_account_id=MGI_ACCESS_SIGNING_KEY,
        home_domains=MGI_ACCESS_HOST,
        web_auth_domain=MGI_ACCESS_HOST,
        passphrase=Red. ESTNET_NETWORK_PASSPHRASE
    )
    challenge.transaction. ign(AUTH_SECRET_KEY)
    post_body = {
        "transaction": challenge.transacción. o_xdr()
    }
    respuesta = solicitudes. ost(f"{AUTH_URL}", json=post_body)
    response_body = response.json()
    return response_body["token"]
```

</CodeExample>

## Iniciar una transacción

Esta sección engloba los pasos 3 y 4 del diagrama de arquitectura que se muestra arriba. El servidor de la aplicación hará una solicitud de inicio de depósito o retiro al servidor de MoneyGram, y MoneyGram devolverá un ID de transacción, que se utilizará más tarde para sondear el estado de la transacción, y una URL de la transacción, que debe devolverse al cliente de la aplicación y abrirse para el usuario.

A efectos de esta guía, pasaremos por alto el caso de retirada.

_Note_: MoneyGram requiere el campo `amount` en las solicitudes de depósitos y retiros de transacciones si su solicitud es custodial.

Necesitarás las siguientes informaciones:

- El token de autenticación proporcionado por MoneyGram. Este token sólo puede ser utilizado para acciones asociadas con el usuario identificado por el ID usado en los pasos anteriores.
- La clave pública del par de claves que utilizará la aplicación para enviar fondos
- El código de idioma de MoneyGram debe mostrar el contenido de su IU
- La cantidad que el usuario desea retirar / retirar fondos en caso de que sea una cartera custodial
  - Esto debería ser recogido del usuario antes de iniciar esta transacción

El siguiente código puede ser utilizado como referencia para implementar esta lógica usted mismo.

<CodeExample>

```ts
importar { IssuedAssetId } desde "@stellar/typescript-wallet-sdk";

// Primero asegurémonos de que Anchor soporta el activo que queremos retirar.
const assetCode = "USDC";
const info = await anchor.getInfo();
const currency = info.currencies. ind(({ code }) => código === assetCode);
if (!currency?.code || !currency?. ssuer) {
  arrojar un nuevo Error(
    `Anchor no soporta el recurso ${assetCode} o no está configurado correctamente en el archivo TOML`,
  );
}

// Usar el mismo objeto "anchor" del paso anterior.
const { url, id } = await anchor.sep24(). ithdraw({
  authToken: authToken, // Usar la misma cadena "authToken" del paso anterior
  drawalAccount: FUNDS_STELAR_KEYPAIR. ublic_key,
  assetCode,
  lang: "es", // "lang" es opcional, por defecto a "en" si se omite
  extraFields: {
    // "amount" es opcional para carteras no custodiales y obligatorio para carteras custodiales
    cantidad: "<amount to withdraw / cash-out>",
  },
});
```

```python
importar solicitudes

def initiate_delet(token: str, amount: str) -> Tuple[str, str]:
    post_body = {
        "asset_code": ASSET_CODE, # USDC
        "cuenta": FUNDS_STELLAR_KEYPAIR. ublic_key,
        "lang": "es",
        "monto": cantidad
    }
    respuesta = peticiones. ost(
        MGI_ACCESS_WITHDRAW_URL,
        json=post_body,
        headers={
            "Authorization": f"Bearer {token}"
        }
    )
    body = respuesta. son()
    return body["url"], body["id"]
```

</CodeExample>

La lógica para iniciar una transacción de depósito parece muy similar. Consulte la especificación estándar [SEP-24][sep-24] para obtener información detallada.

## Escuchar notificación de cierre

El siguiente paso es abrir la URL proporcionada en el cliente de la aplicación usando una ventana web móvil, una pestaña de navegador o una ventana emergente. El usuario pasará entonces por KYC si no lo ha hecho antes en una transacción previa. En el caso de depósito, el usuario también podrá seleccionar una ubicación de agente de MoneyGram a la que acudir cuando proporcione efectivo.

Por último, cuando el usuario está hecho con la interfaz de usuario de MoneyGram, el usuario seleccionará un botón que se mostrará en la interfaz de usuario de MoneyGram y MoneyGram enviará un [postMessage] a la ventana o aplicación que abrirá su flujo inicialmente. El mensaje enviado será el objeto JSON de transacción SEP-24 que representa la transacción.

Si la transacción recibida en el mensaje [postMessage] está en estado `pending_user_transfer_start`, esto significa que el usuario se realiza con la interfaz de usuario de MoneyGram y es seguro cerrar la ventana.

A continuación se muestra un ejemplo simple de JavaScript escuchando una notificación [postMessage].

<CodeExample>

```js
webview = window.open(moneygramURL, "webview", "width=500,height=800");
window.addEventListener("message", closeWebView);

function closeWebView(e) {
  const txJson = e.data.transaction;
  console. og(`La transacción ${txJson.id} es ${txJson.status}`);

  // Si obtenemos un evento postMessage y el estado de la transacción es
  // "pending_user_transfer_start" interpretémoslo como una señal para cerrar
  // la ventana de la vista web y volver al usuario a la experiencia de la aplicación
  if (txJson. tatus === "pending_user_transfer_start") {
    webview.close();
  }
}
```

</CodeExample>

## Enviar o recibir fondos

En caso de retiro (o retiro), las aplicaciones deben enviar USDC a la cuenta Stellar especificada MoneyGram. En las transacciones de depósito (cajero), las solicitudes deben supervisar su cuenta Stellar para un pago de MoneyGram.

En cada caso, la transacción enviada a Stellar debe tener un memo adjunto. Esta nota es proporcionada por MoneyGram en el caso del retiro, y proporcionada por la solicitud en el caso del depósito. La nota es un identificador que permite a las partes vincular el pago en cadena al registro de transacciones en la base de datos de la aplicación o MoneyGram.

### Encuesta hasta que MoneyGram esté listo

Antes de que la solicitud pueda enviar fondos o ordenar al usuario que proporcione dinero en efectivo a un agente de MoneyGram, la aplicación debería confirmar con el servidor de MoneyGram que la transacción está lista para continuar, que está señalizada por el estado `pending_user_transfer_start`.

Necesitará la siguiente información para hacerlo.

- El token de autenticación proporcionado por MoneyGram
- El ID de la transacción proporcionada por MoneyGram
- El punto final de la transacción de MoneyGram (no necesitas preocuparte de ella si estás usando el SDK de Wallet Wallet)
  - Pruebas: https://extstellar.moneygram.com/stellaradapterservice/sep24/transaction
  - Producción: https://stellar.moneygram.com/stellaradapterservice/sep24/transaction

Este código utiliza un mecanismo simple de observación (encuesta) sin condición de rescate. El código de la aplicación debería ser más robótico.

<CodeExample>

```ts
// We can keep the transaction "id" from the withdraw() call,
// authToken and assetCode from previous steps.
const { url, id: transactionId } = await anchor.sep24().withdraw({
  authToken,
  assetCode,
  // ...other params
});

// First, let's initialize a watcher object from the Wallet SDK.
let watcher = anchor.sep24().watcher();

// Then we have the option to watch for a particular transaction.
let { stop, refresh } = watcher.watchOneTransaction({
  authToken,
  assetCode,
  id: transactionId,
  onMessage: (transaction) => {
    if (transaction.status === "pending_user_transfer_start") {
      // begin transfer code
    }
  },
  onSuccess: (transaction) => {
    // transaction comes back as completed / refunded / expired
  },
  onError: (transaction) => {
    // runtime error, or the transaction comes back as
    // no_market / too_small / too_large / error
  },
});

// We also have the option to watch for ALL transactions of a particular asset.
let { stop, refresh } = watcher.watchAllTransactions({
  authToken,
  assetCode,
  onMessage: (transaction) => {
    if (transaction.status === "pending_user_transfer_start") {
      // begin transfer code
    }
  },
  onError: (transaction) => {
    // runtime error, or the transaction comes back as
    // no_market / too_small / too_large / error
  },
});

// While the Watcher class offers powerful tracking capabilities, sometimes
// it's required to just fetch a transaction (or transactions) once. The Anchor
// class allows you to fetch a transaction by ID, Stellar transaction ID, or
// external transaction ID like illustrated below.

// "id" is the actual Anchor transaction id, all transactions should have it.
const transaction = await anchor.sep24().getTransactionBy({
  authToken,
  id: transactionId,
});

// "stellarTransactionId" (aka "stellar_transaction_id" on the SEP spec)
// is the hash of the Stellar network transaction payment related to this
// Anchor transaction.
// E.g. we'll only have this transaction id field AFTER the wallet sends funds
// to Anchor on the withdrawal flow or receives funds from Anchor on the
// deposit flow.
const transaction = await anchor.sep24().getTransactionBy({
  authToken,
  stellarTransactionId,
});

// "externalTransactionId" (aka "external_transaction_id" on the SEP spec)
// could refer to some ID of transaction on external network.
// E.g. for MoneyGram this is the "reference number" displayed to the user on
// the last step of MoneyGram's UI which the user should then use on a physical
// MoneyGram location to complete the cash out operation and pick-up the money.
const transaction = await anchor.sep24().getTransactionBy({
  authToken,
  externalTransactionId,
});

// It's also possible to fetch multiple transactions for an asset.
const transactions = await anchor.sep24().getTransactionsForAsset({
  authToken,
  assetCode,
});
```

```python
import requests

response_body = poll_transaction_until_status(
    transaction_id,
    token=token,
    until_status="pending_user_transfer_start"
)

def poll_transaction_until_status(
    txid: str,
    token: str,
    until_status: str
) -> dict:
    first_iteration = True
    response_body = None
    status = None
    while status != until_status:
        if first_iteration:
            first_iteration = False
        else:
            time.sleep(1)
        query = f"{MGI_ACCESS_TRANSACTION_URL}?id={txid}"
        response = requests.get(
            query,
            headers={
                "Authorization": f"Bearer {token}"
            }
        )
        response_body = response.json()
        status = response_body["transaction"]["status"]
    return response_body
```

</CodeExample>

### Enviando fondos

Una vez que MoneyGram esté listo para recibir fondos, su solicitud debe extraer la cuenta Stellar, memo y monto para usar en la transacción de pago, construir una transacción estelar y enviarla a la red Stellar. Necesitarás:

- Una copia del objeto de transacción de MoneyGram
- La solicitud financia la clave pública y secreta

El código para la presentación de las transacciones a Stellar debe desarrollarse con cuidado. El SDF tiene una página de documentación dedicada a [enviar transacciones y manejar errores con gracia]. Aquí tienes algunas cosas que debes tener en cuenta:

- Ofrecer una tarifa alta. Su comisión debe ser tan alta como usted ofrecería antes de decidir que la transacción ya no vale la pena enviar. Stellar sólo le cobrará el mínimo necesario para ser incluido en el libro -- no se le cobrará la cantidad que usted ofrece a menos que todos los demás estén ofreciendo la misma cantidad o mayor. De lo contrario, pagará la menor cuota que se ofrece en el conjunto de transacciones incluidas en el registro.
- Establecer un límite máximo de tiempo en la transacción. Esto asegura que si su transacción no está incluida en un libro de valores antes del tiempo establecido, puede reconstruir la transacción con una tarifa más alta ofrecida y enviarla de nuevo con mejores posibilidades de inclusión.
- Reenviar la transacción cuando obtenga 504 códigos de estado. 504 códigos de estado le están diciendo que su transacción todavía está pendiente -- no que haya sido cancelada o que su solicitud no sea válida. Simplemente debe hacer la solicitud de nuevo con la misma transacción para obtener un estado final (incluido o caducado).

A continuación se muestra un ejemplo de `Typescript` código para enviar una transacción de pago ("transferencia") usando el SDK Walet. Utiliza límites de tiempo y maneja códigos de estado 504 (dentro de `submitTransaction`), pero no maneja la expiración de una transacción.

Por favor, ten en cuenta que el código `Python` es muy simplificado. No utiliza límites de tiempo, maneja códigos de estado 504 o maneja la expiración de una transacción.

<CodeExample>

```ts
import { Wallet, IssuedAssetId } from "@stellar/typescript-wallet-sdk";
import { Horizon } from "@stellar/stellar-sdk";

const wallet = Wallet.TestNet();

// This creates a Stellar instance to manage the connection with Horizon.
const stellar = wallet.stellar();

// Let's make sure Anchor supports the token we want to withdraw.
const assetCode = "USDC";
const info = await anchor.getInfo();
const currency = info.currencies.find(({ code }) => code === assetCode);
if (!currency?.code || !currency?.issuer) {
  throw new Error(
    `Anchor does not support ${assetCode} asset or is not correctly configured on TOML file`,
  );
}

// This creates the Stellar asset object which we'll need while creating the
// transfer withdrawal transaction below.
const asset = new IssuedAssetId(currency.code, currency.issuer);

// This creates a transaction builder which we'll be using to assemble
// our transfer withdrawal transaction as shown below.
const txBuilder = await stellar.transaction({
  sourceAddress: FUNDS_STELLAR_KEYPAIR,
  baseFee: 10000, // this is 0.001 XLM
  timebounds: 180, // in seconds
});

// We can use the transaction object received on the onMessage callback from
// the watcher, or, we can also fetch the transaction object using either
// getTransactionBy or getTransactionsForAsset as illustrated in previous step.
onMessage: (transaction) => {
  if (transaction.status === "pending_user_transfer_start") {
    // Use the builder to assemble the transfer transaction. Behind the scenes
    // it extracts the Stellar account (withdraw_anchor_account), memo (withdraw_memo)
    // and amount (amount_in) to use in the Stellar payment transaction that will
    // be submitted to the Stellar network.
    const transferTransaction = txBuilder
      .transferWithdrawalTransaction(transaction, asset)
      .build();

    // Signs it with the source (funds) account key pair
    transferTransaction.sign(FUNDS_STELLAR_KEYPAIR);

    // Finally submits it to the stellar network. This stellar.submitTransaction()
    // function handles '504' status codes (timeout) by keep retrying it until
    // submission succeeds or we get a different error.
    try {
      const response = await stellar.submitTransaction(transferTransaction);
      console.log("Stellar-generated transaction ID: ", response.id);
    } catch (error) {
      /*
        In case it's not a 504 (timeout) error, the application could try some
        resolution strategy based on the error kind.

        On Stellar docs you can find a page dedicated to error handling:
        https://developers.stellar.org/docs/learn/encyclopedia/errors-and-debugging/error-handling

        And status/result codes:
        https://developers.stellar.org/docs/data/horizon/api-reference/errors
      */

      // Let's illustrate here how we could handle an 'invalid sequence number' error.

      // We can access all possible result codes through Horizon's API.
      const sdkResultCodes = Horizon.HorizonApi.TransactionFailedResultCodes;

      // We can access error's response data to check for useful error details.
      const errorData = error.response?.data;
      /*
        Sample of errorData object returned by the Wallet SDK:
        {
          type: 'https://stellar.org/horizon-errors/transaction_failed',
          title: 'Transaction Failed',
          status: 400,
          detail: 'The transaction failed when submitted to the stellar network.
            The `extras.result_codes` field on this response contains further details.
            Descriptions of each code can be found at:
            https://developers.stellar.org/docs/data/horizon/api-reference/errors/http-status-codes/horizon-specific/transaction-failed',
          extras: {
            envelope_xdr: 'AAAAAgAAAADBjF7n9gfByOwlnyaJH...k4BRagf/////////8AAAAAAAAAAA==',
            result_codes: { transaction: 'tx_bad_seq' },
            result_xdr: 'AAAAAAAAAGT////6AAAAAA=='
          }
        }
      */

      /*
        Example scenario: invalid sequence numbers.

        These errors typically occur when you have an outdated view of an account.
        This could be because multiple devices are using this account, you have
        concurrent submissions happening, or other reasons. The solution is relatively
        simple: retrieve the account details and try again with an updated sequence number.
      */
      if (
        errorData?.status == 400 &&
        errorData?.extras?.result_codes?.transaction ===
          sdkResultCodes.TX_BAD_SEQ
      ) {
        // Creating a new transaction builder means retrieving an updated sequence number.
        const txBuilder2 = await stellar.transaction({
          sourceAddress: FUNDS_STELLAR_KEYPAIR,
          baseFee: 10000,
          timebounds: 180,
        });

        // ...

        // Repeat all the steps until submitting the transaction again.

        // ...

        const response2 = await stellar.submitTransaction(transferTransaction);
        console.log(
          "Stellar-generated transaction ID on retry: ",
          response2.id,
        );

        // The application should take care to not resubmit the same transaction
        // blindly with an updated sequence number as it could result in more than
        // one payment being made when only one was intended.
      }
    }
  }
};
```

```python
from stellar_sdk import (
    Server, TransactionBuilder, Network, Asset, IdMemo
)

submit_payment(
   destination=response_body["transaction"]["reti_anchor_account"],
   memo=response_body["transaction"]["draw_memo"],
   amount=response_body["transaction"]["amount_in"]
)

def submit_payment(destino: str, memo: str, amount: str):
   server = Server()
   account = server. oad_account(FUNDS_STELLAR_KEYPAIR. ublic_key)
   transacción = TransactionBuilder(
       source_account=account,
       passphrase=Red. ESTNET_NETWORK_PASSPHRASE,
       base_fee=10000 # esto es 0.001 XLM
   ). ppend_payment_op(
       destinación=destino,
       asset=Asset(ASSET_CÓDIGO, ASSET_ISSUER),
       monto=monto,
   ). dd_memo(
       IdMemo(int(memo))
   ). uild()
   transaction.sign(FUNDS_STELAR_KEYPAIR)
   respuesta = servidor. ubmit_transaction(transacción)
   print(f"ID de transacción generada por estelar: {response['id']}")
```

</CodeExample>

### Recibiendo fondos

Una vez que MoneyGram esté listo para que el usuario entregue dinero en efectivo a un agente MGI (en casos de depósito o retiro), el servidor de la aplicación debe comenzar a monitorear su cuenta Stellar por un pago USDC entrante enviado por MoneyGram.

La solicitud debería haber proporcionado un memo para que MoneyGram lo utilizara cuando inició el depósito. MoneyGram adjuntará este memo a la transacción utilizada para enviar el pago a la aplicación, y la aplicación debe utilizar esta comprobación de la nota de transacciones que implican su cuenta para asociar el pago de vuelta al usuario y la transacción específica.

La mejor manera de monitorear los pagos realizados a una cuenta es transmitir eventos desde el punto final de los pagos de Stellar. El uso de los cursores de streaming puede ayudar a asegurar que nunca se pierda un evento, incluso si el proceso de streaming de su aplicación se reduce durante un período de tiempo.

Tenga en cuenta que este código no maneja [pagos de ruta] o [saldos reclamables], dos formas de pago ligeramente diferentes. En el momento de escribir MoneyGram no utiliza ninguna de estas opciones, pero puede que desee añadir soporte para ellos en caso de que lo hagan en el futuro.

<CodeExample>

```ts
// El SDK de Wallet aún no soporta streaming de pagos, así que vamos a compilar
// él usando el SDK
de Horizon subyacente { Horizon } de "@stellar/stellar-sdk";
importar { getTransactionByMemo } de ". queries";

const streamPayments = (accountt: string, cursor: string) => {
  const server = new Horizon.Server("https://parallon-testnet.stellar. rg");
  servidor
    .payments()
    .forAccount(account)
    . oin("transactions")
    .cursor(cursor)
    . tream({
      onmessage: (payment) => {
        if (
          payment["type"] ! = "pago" ||
          pago["de"] === cuenta ||
          pago["asset_type"] === "nativo" ||
          pago["asset_code"] ! = ASSET_CÓDIGO ||
          pago["asset_issuer"] ! = ASSET_ISSUER
        ) {
          return;
        }

        const transaction = getTransactionByMemo(
          payment["transaction_attr"]["memo"],
          pago["transaction_attr"]["memo_type"],
        ); // esta es su propia función de consulta DB

        if (! ransaction) {
          return;
        }

        consola. og(
          `Pago por transacción de depósito ${transaction.id}`,
          `coincide con la transacción estelar `,
          `${payment["transaction_attr"]["id"]}`,
        );
      },
      onerror: (error) => {
        // manejar error
      },
    });
};
```

```python
de stellar_sdk importar Servidor
de . ueries import get_transaction_by_memo

def stream_payments(accountt: str, cursor: str):
    s = Server()
    payments = s. ayments().for_account(account).join("transactions")
    para pago en payments.cursor(cursor). tream():
        if (
            pago["tipo"] ! "pago"
            o pago["de"] == cuenta
            o pago["asset_type"] == "nativo"
            o pago["asset_code"] ! ASSET_CÓDIGO
            o pago["asset_issuer"] ! ASSET_ISSUER
        ):
            continue
        transaction = get_transaction_by_memo(
            payment["transaction"]["memo"],
            pago["transaction"]["memo_type"]
        ) # consulta de DB
        si no transacción:
            continue
        print(
            f"Pago para transacción de depósito {transaction.id} "
            "emparejado con transacción estelar "
            f"{payment['transaction']['id']}"
)
```

</CodeExample>

## Obtener el número de referencia

Para transacciones de depósito o de ingreso, MoneyGram no proporciona números de referencia. Todo lo que el usuario necesita hacer es entregar dinero en efectivo en la ubicación del agente elegida en la interfaz de usuario de MoneyGram antes del flujo, y la aplicación debe completar la transacción cuando se detecta un pago correspondiente en Stellar.

Para operaciones de retiro o retiro de efectivo, MoneyGram proporciona un número de referencia en su interfaz de usuario y API una vez que MoneyGram detecta el pago del USDC de la aplicación en Stellar. Los usuarios deben poder utilizar la interfaz de cliente de la aplicación para ver directamente el número de referencia o encontrar la página de detalles de la transacción de MoneyGram y verla allí.

Tenga en cuenta que la página de detalles de transacciones de MoneyGram está protegida con un token JWT en la url que expira relativamente rápidamente después de ser obtenido. Esto significa que las aplicaciones deben buscar la URL en el momento en que el usuario solicita la página, potencialmente requiriendo reautenticación a través de SEP-10.

<CodeExample>

```ts
// Resolver onMessage de Watcher, ver los pasos anteriores para más información sobre este
onMessage: (transaction) => {
  if (transacción. tatus === "pending_user_transfer_complete") {
    consola. og(
      `Número de referencia de transacción ${transaction.external_transaction_id}`,
      `también se puede ver en ${transaction.more_info_url}`,
    );
  }
};
```

```python
de . pi import poll_transction_until_status

response_body = poll_transaction_until_status(
    transaction_id,
    "pending_user_transfer_complete"
)
tx_dict = response_body["transaction"]
print(
    f"Número de referencia de transacción {tx_dict['external_transaction_id']} "
    f"también se puede ver en {tx_dict['more_info_url']}"
)
```

</CodeExample>

[acceso al dinerograma]: https://stellar.org/moneygram?locale=e
[implementación de monedero mvp de acceso a dinerogramas]: https://github.com/stellar/moneygram-access-wallet-mvp
[documentos sdk de cartera estelar]: /docs/categoría/build-a-wallet-with-the-wallet-sdk
[repositorio sdk de cartera estelar]: https://github.com/stellar/typescript-wallet-sdk
[ancla de prueba estelar]: https://testanchor.stellar.org/.well-known/stellar.toml
[monedero demo estelar]: https://demo-wallet.stellar.org
[sep-1]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0001.md
[sep-24]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0024.md
[sep-10]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0010.md
[laboratorio estelar]: https://laboratory.stellar.org/
[directorio de anclaje]: https://resources.stellar.org/anchors?
[lobstáculo]: https://lobstr.co/
[línea de confianza]: ../../data/horizon/api-reference/resources/operations/object/change-trust.mdx
[oferta de venta]: ../../data/horizon/api-reference/resources/operations/object/sell-offer.mdx
[mensaje]: https://developer.mozilla.org/es-US/docs/Web/API/Window/postMessage
[enviar transacciones y manejar errores de forma elegante]: /data/horizon/api-reference/errors/error-handling.mdx
[pagos en ruta]: ../../data/horizon/api-reference/resources/operations/object/path-payment-strict-receive.mdx
[saldos cobrables]: ../../data/horizon/api-reference/resources/operations/object/create-claimable-balance.mdx
[cuestionario de detección de dinerogramas]: https://stellarquestionnaire.typeform.com/to/RD1a71wQ
[gcdnjubqsx7ajwljacmj7i4bc3z47bqutmheiczle6mu4kqbryg5jy6b]: https://stellar.expert/explorer/testnet/asset/SRT-GCDNJUBQSX7AJWLJACMJ7I4BC3Z47BQUTMHEICZLE6MU4KQBRYG5JY6B-1
[gbbd47if6lwk7p7mdevscwr7dpuwv3ny3dtqevfl4nat4aqh3zllfla5]: https://stellar.expert/explorer/testnet/asset/USDC-GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5-1
[ga5zsejyb37jrc5avcia5mop4rhtm335x2kgx3ihojapp5re34k4kzvn]: https://stellar.expert/explorer/public/asset/USDC-GA5ZSEJYB37JRC5AVCIA5MOP4RHTM335X2KGX3IHOJAPP5RE34K4KZVN-1

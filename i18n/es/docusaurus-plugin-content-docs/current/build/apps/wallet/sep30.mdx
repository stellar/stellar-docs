---
title: Recuperación
sidebar_position: 60
---

import Header from "./component/header.mdx";
import { WalletCodeExample as CodeExample } from "@site/src/components/WalletCodeExample";

<Header />

El estándar [Sep-30] define la forma estándar para que un individuo (por ejemplo, un usuario o una billetera) recupere el acceso a su cuenta Stellar después de perder su clave privada sin proporcionar ningún control de terceros sobre la cuenta. Durante este flujo, la billetera se comunica con uno o más servidores de firma de recuperación para registrar la billetera para una posible recuperación posterior si es necesario.

## Crear Cuenta Recuperable

Primero, vamos a crear una clave de cuenta, una clave de dispositivo y una clave de recuperación que estarán asociadas a la cuenta.

<CodeExample>

```typescript
const accountKp = wallet.stellar().account().createKeypair();
const deviceKp = wallet.stellar().account().createKeypair();
const recoveryKp = wallet.stellar().account().createKeypair();
```

```kotlin
  val accountKp = wallet.stellar().account().createKeyPair()
  val deviceKp = wallet.stellar().account().createKeyPair()
  val recoveryKp = wallet.stellar().account().createKeyPair()
```

```dart
var accountKp = wallet.stellar().account().createKeyPair();
var deviceKp = wallet.stellar().account().createKeyPair();
var recoveryKp = wallet.stellar().account().createKeyPair();
```

```swift
let accountKp = wallet.stellar.account.createKeyPair()
let deviceKp = wallet.stellar.account.createKeyPair()
let recoveryKp = wallet.stellar.account.createKeyPair()
```

</CodeExample>

La `accountKp` es la cuenta principal de la billetera. El `deviceKp` que vamos a agregar a la billetera como un firmante para que un dispositivo (por ejemplo, un dispositivo móvil en el que se aloja la billetera) pueda tomar control de la cuenta. Y el `recoveryKp` se utilizará para identificar la clave con los servidores de recuperación.

A continuación, identifiquemos los servidores de recuperación y creemos nuestro objeto de recuperación:

<CodeExample>

```typescript
const server1Key = "server1";
const server1 = {
  endpoint: "recovery-example.com",
  authEndpoint: "auth-example.com",
  homeDomain: "test-domain",
};

const server2Key = "server2";
const server2 = {
  endpoint: "recovery-example2.com",
  authEndpoint: "auth-example2.com",
  homeDomain: "test-domain2",
};

const recovery = wallet.recovery({
  servers: { [server1Key]: server1, [server2Key]: server2 },
});
```

```kotlin
val first = RecoveryServerKey("first")
val second = RecoveryServerKey("second")
val firstServer = RecoveryServer("recovery.example.com", "auth.example.com", "example.com")
val secondServer = RecoveryServer("recovery2.example.com", "auth2.example.com", "example.com")
val servers = mapOf(first to firstServer, second to secondServer)
val recovery = wallet.recovery(servers)
```

```dart
var first = RecoveryServerKey("first");
var second = RecoveryServerKey("second");
var firstServer = RecoveryServer("https://recovery.example1.com", "https://auth.example1.com", "recovery.example1.com");
var secondServer = RecoveryServer("https://recovery.example2.com", "https://auth.example2.com", "recovery.example2.com");
var servers = {first:firstServer, second:secondServer};
var recovery = wallet.recovery(servers);
```

```swift
let first = RecoveryServerKey(name: "first")
let second = RecoveryServerKey(name: "second")

let firstServer = RecoveryServer(endpoint:"https://recovery.example1.com",
                                authEndpoint:"https://auth.example1.com",
                                homeDomain:"recovery.example1.com")

let secondServer = RecoveryServer(endpoint:"https://recovery.example2.com",
                                  authEndpoint:"https://auth.example2.com",
                                  homeDomain:"recovery.example2.com")

let servers = [first: firstServer, second:secondServer]

let recovery = wallet.recovery(servers: servers)
```

</CodeExample>

A continuación, necesitamos definir identidades SEP-30. En este ejemplo vamos a crear una identidad para ambos servidores. Registrar una identidad le dice al servidor de recuperación qué identidades están autorizadas para acceder a la cuenta.

<CodeExample>

```typescript
const identity1 = {
  role: RecoveryRole.OWNER,
  authMethods: [
    {
      type: RecoveryType.STELLAR_ADDRESS,
      value: recoveryKp.publicKey,
    },
  ],
};

const identity2 = {
  role: RecoveryRole.OWNER,
  authMethods: [
    {
      type: RecoveryType.EMAIL,
      value: "my-email@example.com",
    },
  ],
};
```

```kotlin
  val identity1 = listOf(RecoveryAccountIdentity(
        RecoveryRole.OWNER,
        listOf(RecoveryAccountAuthMethod(RecoveryType.STELLAR_ADDRESS, recoveryKp.address))
      )
    )

    val identity2 = listOf(RecoveryAccountIdentity(
        RecoveryRole.OWNER,
        listOf(RecoveryAccountAuthMethod(RecoveryType.EMAIL, "my-email@example.com"))
      )
    )
```

```dart
var identity1 = [
  RecoveryAccountIdentity(RecoveryRole.owner, [
    RecoveryAccountAuthMethod(RecoveryType.stellarAddress, recoveryKp.address)
  ])
];

var identity2 = [
  RecoveryAccountIdentity(RecoveryRole.owner,
      [RecoveryAccountAuthMethod(RecoveryType.email, "my-email@example.com")])
];
```

```swift
let identity1 = [
    RecoveryAccountIdentity(role:RecoveryRole.owner,
                            authMethods: [RecoveryAccountAuthMethod(type:RecoveryType.stellarAddress,
                                                                    value:recoveryKp.address)])
]

let identity2 = [
    RecoveryAccountIdentity(role:RecoveryRole.owner,
                            authMethods: [RecoveryAccountAuthMethod(type:RecoveryType.email,
                                                                    value:"my-email@example.com")])
]
```

</CodeExample>

Aquí, la clave de stellar y el correo electrónico se utilizan como métodos de recuperación. Otros servidores de recuperación pueden soportar el teléfono como método de recuperación también.

Puedes leer más sobre identidades SEP-30 [aquí](https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0030.md#common-request-fields)

A continuación, creemos una cuenta recuperable:

<CodeExample>

```typescript
const config = {
  accountAddress: accountKp,
  deviceAddress: deviceKp,
  accountThreshold: { low: 10, medium: 10, high: 10 },
  accountIdentity: { [server1Key]: [identity1], [server2Key]: [identity2] },
  signerWeight: { device: 10, recoveryServer: 5 },
};
const recoverableWallet = await recovery.createRecoverableWallet(config);
```

```kotlin
  val recoverableWallet =
    recovery.createRecoverableWallet(
      RecoverableWalletConfig(
        accountKp,
        deviceKp,
        AccountThreshold(10, 10, 10),
        mapOf(first to identity1, second to identity2),
        SignerWeight(10, 5)
      )
    )
```

```dart
var recoverableWallet = await recovery.createRecoverableWallet(
    RecoverableWalletConfig(
        accountKp,
        deviceKp,
        AccountThreshold(10, 10, 10),
        {first: identity1, second: identity2},
        SignerWeight(10, 5)
    )
);
```

```swift
let config = RecoverableWalletConfig(accountAddress: accountKp,
                                    deviceAddress: deviceKp,
                                    accountThreshold: AccountThreshold(low: 10, medium: 10, high: 10),
                                    accountIdentity: [first : identity1, second: identity2],
                                    signerWeight: SignerWeight(device: 10, recoveryServer: 5))

let recoverableWallet = try await recovery.createRecoverableWallet(config: config)
```

</CodeExample>

Con los parámetros dados, esta función creará una transacción que hará:

1. Establecer `deviceKp` como la clave de cuenta principal. Ten en cuenta que la clave maestra perteneciente a `accountKp` estará bloqueada. `deviceKp` debe usarse como un firmante principal en su lugar.
2. Establecer todos los umbrales de operación en 10. Puedes leer más acerca del umbral en la [documentación](../../../learn/fundamentals/transactions/signatures-multisig.mdx#thresholds)
3. Usar identidades que se definieron antes en ambos servidores. (Eso significa, que ambos servidores aceptarán la autenticación SEP-10 a través de `recoveryKp` como un método de autenticación)
4. Establecer el peso de clave del dispositivo en 10, y el peso del servidor de recuperación en 5. Dado estos umbrales de cuenta, ambos servidores deben ser usados para recuperar la cuenta, ya que una transacción firmada por uno solo tendrá un peso de 5, el cual no es suficiente para cambiar la clave de la cuenta.

Finalmente, firma y envía la transacción a la red:

<CodeExample>

```typescript
recoverableWallet.transaction.sign(accountKp.keypair);

await stellar.submitTransaction(recoverableWallet.transaction);
```

```kotlin
  val tx = recoverableWallet.transaction.sign(accountKp)

  wallet.stellar().submitTransaction(tx)
```

```dart
var transaction = recoverableWallet.transaction;
transaction.sign(accountKp.keyPair, flutter_sdk.Network.TESTNET);
await wallet.stellar().submitTransaction(transaction);
```

```swift
let transaction = recoverableWallet.transaction
try transaction.sign(keyPair: accountKp.keyPair, network: Network.testnet)
try await wallet.stellar.submitTransaction(signedTransaction: transaction)
```

</CodeExample>

## Obtener Información de la Cuenta

Puedes obtener información de la cuenta desde uno o más servidores. Para hacerlo, primero necesitamos autenticar con un servidor de recuperación usando el método de autenticación SEP-10:

<CodeExample>

```typescript
const authToken = await recovery
  .sep10Auth(server1Key)
  .authenticate({ accountKp: recoveryKp });
```

```kotlin
  val auth1 = recovery.sep10Auth(first).authenticate(recoveryKp)
```

```dart
var sep10 = await recovery.sep10Auth(first);
var authToken = await sep10.authenticate(recoveryKp);
```

```swift
let sep10 = try await recovery.sep10Auth(key: first)
let authToken = try await sep10.authenticate(userKeyPair: recoveryKp)
```

</CodeExample>

A continuación, obtiene información de la cuenta utilizando los tokens de autenticación:

<CodeExample>

```typescript
const accountResp = await recovery.getAccountInfo(accountKp, {
  [server1Key]: authToken,
});
```

```kotlin
  val accountInfo = recovery.getAccountInfo(account, mapOf(first to auth1))

  println("Recoverable info: $accountInfo")
```

```dart
var accountInfo = await recovery.getAccountInfo(accountKp, {first: authToken.jwt});
```

```swift
let accountInfo = try await recovery.getAccountInfo(accountAddress: accountKp,
                                                    auth: [first:auth1Token.jwt])
```

</CodeExample>

Nuestra segunda identidad utiliza un correo electrónico como método de autenticación. Para eso no podemos usar un token de autenticación [SEP-10] para ese servidor. En cambio, necesitamos usar un token que vincule el correo electrónico al usuario. Por ejemplo, los tokens de Firebase son un buen caso de uso para esto. Para usar esto, el servidor de firmante de recuperación necesita estar preparado para manejar este tipo de tokens.

Obtener información de la cuenta usando estos tokens es lo mismo que antes.

<CodeExample>

```typescript
// get token from firebase
const firebaseToken = AuthToken.from(<firebase token string>)

const accountResp = await recovery.getAccountInfo(accountKp, {
  [server2Key]: firebaseToken,
});
```

```kotlin
  // get token from firebase
  val firebaseToken = AuthToken.from(<firebase token string>)

  val accountInfo = recovery.getAccountInfo(account, mapOf(second to firebaseToken))

  println("Recoverable info: $accountInfo")
```

```dart
var accountInfo = await recovery.getAccountInfo(accountKp, {second: <other token string>});
```

```swift
let accountInfo = try await recovery.getAccountInfo(accountAddress: accountKp,
                                                    auth: [second:<other token string>])
```

</CodeExample>

## Recuperar Billetera

Supongamos que hemos perdido nuestra clave de dispositivo y necesitamos recuperar nuestra billetera.

Primero, necesitamos autenticar con ambos servidores de recuperación:

<CodeExample>

```typescript
const authToken1 = await recovery
  .sep10Auth(server1Key)
  .authenticate({ accountKp: recoveryKp });

// get firebase token using firebase
const firebaseToken = AuthToken.from(<firebase token string>)
```

```kotlin
  val auth1 = recovery.sep10Auth(first).authenticate(recoveryKp)

  // get firebase token using firebase
  val firebaseToken = AuthToken.from(<firebase token string>)
```

```dart
var sep10 = await recovery.sep10Auth(first);
var authToken = await sep10.authenticate(recoveryKp);

var auth1 = authToken.jwt;
var auth2 = "..."; // get other token e.g. firebase token
```

```swift
let sep10 = try await recovery.sep10Auth(key: first)
let authToken = try await sep10.authenticate(userKeyPair: recoveryKp)

let auth1 = authToken.jwt
let auth2 = "..."; // get other token e.g. firebase token
```

</CodeExample>

Necesitamos conocer las direcciones de los firmantes de recuperación que se utilizarán para firmar la transacción. Puedes obtenerlas de la billetera recuperable que creamos antes (`recoverableWallet.signers`), o mediante la obtención de información de la cuenta desde los servidores de recuperación.

<CodeExample>

```typescript
const recoverySignerAddress1 = recoverableWallet.signers[0];
const recoverySignerAddress2 = recoverableWallet.signers[1];
```

```kotlin
  val recoverySigners = recoverableWallet.signers
```

```dart
var recoverySigners = recoverableWallet.signers;
```

```swift
let recoverySigners = recoverableWallet.signers
```

</CodeExample>

A continuación, crea una nueva clave de dispositivo y recupera una transacción firmada que reemplace la clave de dispositivo:

<CodeExample>

```typescript
const newDeviceKp = accountService.createKeypair();

const serverAuth = {
  [server1Key]: {
    signerAddress: recoverySignerAddress1,
    authToken1,
  },
  [server2Key]: {
    signerAddress: recoverySignerAddress2,
    firebaseToken,
  },
};

const recoverTxn = await recovery.replaceDeviceKey(
  accountKp,
  newDeviceKp,
  serverAuth,
);
```

```kotlin
  val newKey = wallet.stellar().account().createKeyPair()

  val serverAuth = mapOf(
    first to RecoveryServerSigning(recoverySigners[0], auth1),
    second to RecoveryServerSigning(recoverySigners[1], firebaseToken)
  )

  val signedReplaceKeyTransaction =
    recovery.replaceDeviceKey(
      accountKp,
      newKey,
      serverAuth
    )
```

```dart
var newKey = wallet.stellar().account().createKeyPair();
var serverAuth = {
  first: RecoveryServerSigning(recoverySigners[0], auth1),
  second: RecoveryServerSigning(recoverySigners[1], auth2)
};

var signedReplaceKeyTx = await recovery.replaceDeviceKey(accountKp, newKey, serverAuth);
```

```swift
let newKey = wallet.stellar.account.createKeyPair()
let serverAuth = [
    first: RecoveryServerSigning(signerAddress: recoverySigners[0] , authToken: auth1),
    second: RecoveryServerSigning(signerAddress: recoverySigners[1] , authToken: auth2),
]

let signedReplaceKeyTx = try await recovery.replaceDeviceKey(account: accountKp,
                                                             newKey: newKey,
                                                             serverAuth: serverAuth)
```

</CodeExample>

Llamar a esta función creará una transacción que bloquea la clave de dispositivo anterior y la reemplaza con tu nueva clave (teniendo el mismo peso que la antigua). Ambos firmantes de recuperación habrán firmado la transacción.

La clave de dispositivo perdida se deduce automáticamente si no se proporciona. Un firmante será considerado una clave de dispositivo, si una de estas condiciones coincide:

1. Es el único firmante que no está en `serverAuth`.
2. Todos los firmantes en `serverAuth` tienen el mismo peso, y el firmante potencial es el único que tiene un peso diferente.

Ten en cuenta que la cuenta creada arriba coincidirá con el primer criterio. Si se usara el esquema 2-3, entonces el segundo criterio coincidiría. (En el esquema 2-3, se utilizan 3 servidores y 2 de ellos son suficientes para recuperar la clave. Este es un enfoque recomendado.)

Nota: también puedes usar funciones de bajo nivel `signWithRecoveryServers` para firmar transacciones arbitrarias.

Finalmente, es hora de enviar la transacción:

<CodeExample>

```typescript
await stellar.submitTransaction(recoverTxn);
```

```kotlin
  wallet.stellar().submitTransaction(signedReplaceKeyTransaction)
```

```dart
await wallet.stellar().submitTransaction(signedReplaceKeyTx);
```

```swift
try await wallet.stellar.submitTransaction(signedTransaction: signedReplaceKeyTx)
```

</CodeExample>

[sep-30]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0030.md

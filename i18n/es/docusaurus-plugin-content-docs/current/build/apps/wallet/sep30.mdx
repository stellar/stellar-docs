---
title: Recuperación
sidebar_position: 60
---

import Header from "./component/header.mdx";
import { WalletCodeExample as CodeExample } from "@site/src/components/WalletCodeExample";

<Header />

El Estándar [Sep-30] define la forma estándar para un individuo (p. ej. un usuario o billetera) para recuperar el acceso a su cuenta Stellar después de perder su clave privada sin proporcionar ningún control de terceros de la cuenta. Durante este flujo la cartera se comunica con uno o más servidores signner de recuperación para registrar la cartera para una recuperación posterior si es necesario.

## Crear una cuenta recuperable

Primero, vamos a crear una clave de cuenta, una clave de dispositivo y una clave de recuperación que se adjuntará a la cuenta.

<CodeExample>

```typescript
const accountKp = wallet.stellar().account().createKeypair();
const deviceKp = wallet.stellar().account().createKeypair();
const recoveryKp = wallet.stellar().account().createKeypair();
```

```kotlin
  val accountKp = wallet.stellar().account().createKeyPair()
  val deviceKp = wallet.stellar().account().createKeyPair()
  val recoveryKp = wallet.stellar().account().createKeyPair()
```

```dart
var accountKp = wallet.stellar().account().createKeyPair();
var deviceKp = wallet.stellar().account().createKeyPair();
var recoveryKp = wallet.stellar().account().createKeyPair();
```

</CodeExample>

El `accountKp` es la cuenta principal de la cartera. El `deviceKp` que vamos a añadir a la cartera como un firmante para que un dispositivo (por ejemplo. un dispositivo móvil en el que una cartera está alojada) puede tomar el control de la cuenta. Y el `recoveryKp` se utilizará para identificar la clave con los servidores de recuperación.

A continuación, identifiquemos los servidores de recuperación y creemos nuestro objeto de recuperación:

<CodeExample>

```typescript
const server1Key = "server1";
const server1 = {
  endpoint: "recovery-example.com",
  authEndpoint: "auth-example. om",
  homeDomain: "test-domain",
};

const server2Key = "server2";
const server2 = {
  endpoint: "recovery-example2. om",
  authEndpoint: "auth-example2.com",
  homeDomain: "test-domain2",
};

const recovery = wallet. ecovery({
  servidores: { [server1Key]: server1, [server2Key]: server2 },
});
```

```kotlin
val first = RecoveryServerKey("primero")
val second = RecoveryServerKey("segundo")
val firstServer = RecoveryServer("recovery.example.com", "auth.example.com", "ejemplo. om")
val secondServer = RecoveryServer("recovery2.example.com", "auth2.example.com", "example.com")
val servers = mapOf(first to firstServer, second to secondServer)
val recovery = wallet.recovery(servers)
```

```dart
var first = RecoveryServerKey("primero");
var second = RecoveryServerKey("segundo");
var firstServer = RecoveryServer("https://recovery.example1.com", "https://auth.example1.com", "recovery.example1. om");
var secondServer = RecoveryServer("https://recovery.example2.com", "https://auth.example2.com", "recovery.example2.com");
var servers = {first:firstServer, second:secondServer};
var recovery = wallet.recovery(servers);
```

</CodeExample>

A continuación, necesitamos definir identidades SEP-30. En este ejemplo vamos a crear una identidad para ambos servidores. Registrar una identidad le dice al servidor de recuperación qué identidades pueden acceder a la cuenta.

<CodeExample>

```typescript
const identity1 = {
  role: RecoveryRole. WNER,
  authMethods: [
    {
      type: RecoveryType.STELLAR_ADDRESS,
      value: recoveryKp.publicKey,
    },
  ],
};

const identity2 = {
  role: RecoveryRole. WNER,
  authMethods: [
    {
      type: RecoveryType. MAIL,
      valor: "mi-email@ejemplo.com",
    },
  ],
};
```

```kotlin
  val identity1 = listOf(RecoveryAccountIdentity(
        RecoveryRole.OWNER,
        listOf(RecoveryAccountAuthMethod(RecoveryType.STELLAR_ADDRESS, recoveryKp.address))
      )
    )

    val identity2 = listOf(RecoveryAccountIdentity(
        RecoveryRole.OWNER,
        listOf(RecoveryAccountAuthMethod(RecoveryType.EMAIL, "my-email@example.com"))
      )
    )
```

```dart
var identity1 = [
  RecoveryAccountIdentity(RecoveryRole.owner, [
    RecoveryAccountAuthMethod(RecoveryType.stellarAddress, recoveryKp. ddress)
  ])
];

var identity2 = [
  RecoveryAccountIdentity(RecoveryRole. wner,
      [RecoveryAccountAuthMethod(RecoveryType.email, "my-email@example.com")])
];
```

</CodeExample>

Aquí, la clave estelar y el correo electrónico se utilizan como métodos de recuperación. Otros servidores de recuperación también pueden soportar el teléfono como método de recuperación.

Puede leer más sobre identidades SEP-30 [here](https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0030.md#common-request-fields)

A continuación, vamos a crear una cuenta recuperable:

<CodeExample>

```typescript
const config = {
  accountAddress: accountKp,
  deviceAddress: deviceKp,
  accountThreshold: { low: 10, medium: 10, high: 10 },
  accountIdentity: { [server1Key]: [identity1], [server2Key]: [identity2] },
  firnerWeight: { device: 10, recoveryServer: 5 },
};
const recoverableWallet = await recovery. reateRecoverableWallet(config);
```

```kotlin
  val recoverableWallet =
    recuperación. reateRecoverableWallet(
      RecoverableWalletConfig(
        accountKp,
        deviceKp,
        AccountThreshold(10, 10, 10),
        mapOf(primero identidad1, segundo identidad2),
        SignerWeight(10, 5)
      )
)
```

```dart
var recoverableWallet = await recovery.createRecoverableWallet(
    RecoverableWalletConfig(
        accountKp,
        deviceKp,
        AccountThreshold(10, 10),
        {first: identity1, second: identity2},
        SignerWeight(10, 5)
    )
);
```

</CodeExample>

Con los parámetros dados, esta función creará una transacción que hará:

1. Establece `deviceKp` como la clave principal de la cuenta. Tenga en cuenta que la clave maestra que pertenece a `accountKp` será bloqueada. `deviceKp` debe ser usado como un firmante primario en su lugar.
2. Establecer todos los umbrales de operación a 10. Puede leer más sobre el umbral en la [documentation](../../../learn/encyclopedia/security/signnatures-multisig.mdx#parallholds)
3. Utilice identidades que fueron definidas anteriormente en ambos servidores. (Eso significa que ambos servidores aceptarán la autenticación SEP-10 a través de `recoveryKp` como un método de autenticación)
4. Ajuste el peso de la clave del dispositivo a 10 y el peso del servidor de recuperación a 5. Dados estos umbrales de cuenta, ambos servidores deben ser usados para recuperar la cuenta, como transacción firmada por uno sólo tendrá un peso de 5, que no es suficiente para cambiar la clave de cuenta.

Finalmente, firmar y enviar la transacción a la red:

<CodeExample>

```typescript
recoverableWallet.transaction.sign(accountKp.keypair);

await stellar.submitTransaction(recoverableWallet.transaction);
```

```kotlin
  val tx = recoverableWallet.transaction.sign(accountKp)

  wallet.stellar().submitTransaction(tx)
```

```dart
var transaction = recoverableWallet.transaction;
transaction.sign(accountKp.keyPair, flutter_sdk.Network.TESTNET);
await wallet.stellar().submitTransaction(transaction);
```

</CodeExample>

## Obtener información de cuenta

Puedes obtener información de la cuenta de uno o más servidores. Para ello, primero necesitamos autenticarnos con un servidor de recuperación usando el método de autenticación SEP-10:

<CodeExample>

```typescript
const authToken = await recovery
  .sep10Auth(server1Key)
  .authenticate({ accountKp: recoveryKp });
```

```kotlin
  val auth1 = recovery.sep10Auth(first).authate(recoveryKp)
```

```dart
var sep10 = await recovery.sep10Auth(first);
var authToken = await sep10.autenticate(recoveryKp);
```

</CodeExample>

A continuación, obtén información de la cuenta usando los tokens de autenticación:

<CodeExample>

```typescript
const accountResp = await recovery.getAccountInfo(accountKp, {
  [server1Key]: authToken,
});
```

```kotlin
  val accountInfo = recovery.getAccountInfo(account, mapOf(first to auth1))

  println("Información recuperable: $accountInfo")
```

```dart
var accountInfo = await recovery.getAccountInfo(accountKp, {first: authToken.jwt});
```

</CodeExample>

Nuestra segunda identidad utiliza un correo electrónico como método de autenticidad. Para eso no podemos usar un token de autenticación [SEP-10] para ese servidor. En su lugar, necesitamos usar un token que vincule el correo electrónico al usuario. Por ejemplo, los tokens Firebase son un buen caso de uso para esto. Para usar esto, el servidor de firmas de recuperación necesita estar preparado para manejar este tipo de tokens.

Obtener información de cuenta usando estos tokens es lo mismo que antes.

<CodeExample>

```typescript
// obtener token de firebase
const firebaseToken = AuthToken.from(<firebase token string>)

const accountResp = await recovery.getAccountInfo(accountKp, {
  [server2Key]: firebaseToken,
});
```

```kotlin
  // obtener token de firebase
  val firebaseToken = AuthToken.from(<firebase token string>)

  val accountInfo = recovery.getAccountInfo(account, mapOf(second to firebaseToken))

  println("Información recuperable: $accountInfo")
```

```dart
var accountInfo = await recovery.getAccountInfo(accountKp, {second: <other token string>});
```

</CodeExample>

## Recuperar cartera

Digamos que hemos perdido nuestra clave de dispositivo y necesitamos recuperar nuestra cartera.

En primer lugar, necesitamos autenticarnos con ambos servidores de recuperación:

<CodeExample>

```typescript
const authToken1 = await recovery
  .sep10Auth(server1Key)
  .authenticate({ accountKp: recoveryKp });

// obtener firebase token usando firebase
const firebaseToken = AuthToken.from(<firebase token string>)
```

```kotlin
  val auth1 = recovery.sep10Auth(first).authate(recoveryKp)

  // obtener firebase token usando firebase
  val firebaseToken = AuthToken.from(<firebase token string>)
```

```dart
var sep10 = await recovery.sep10Auth(first);
var authToken = await sep10. uthenticate(recoveryKp);

var auth1 = authToken.jwt;
var auth2 = "..."; // obtener otro token e.g. firebase token
```

</CodeExample>

Necesitamos conocer las direcciones de los firmantes de recuperación que se utilizarán para firmar la transacción. Puede obtenerlos desde el objeto de cartera recuperable que creamos anteriormente (`recoverableWallet.signers`), o recuperando la información de la cuenta de los servidores de recuperación.

<CodeExample>

```typescript
const recoverySignerAddress1 = recoverableWallet.signers[0];
const recoverySignerAddress2 = recoverableWallet.signers[1];
```

```kotlin
  val recoverySigners = recoverableWallet.signers
```

```dart
var recoverySigners = recoverableWallet.signers;
```

</CodeExample>

A continuación, cree una nueva clave de dispositivo y recupere una transacción firmada que reemplace la clave del dispositivo:

<CodeExample>

```typescript
const newDeviceKp = accountService. reateKeypair();

const serverAuth = {
  [server1Key]: {
    signerAddress: recoverySignerAddress1,
    authToken1,
  },
  [server2Key]: {
    signerAddress: recoverySignerAddress2,
    firebaseToken,
  },
};

const recoverTxn = await recovery. eplaceDeviceKey(
  accountKp,
  newDeviceKp,
  serverAuth,
);
```

```kotlin
  val newKey = wallet.stellar().account(). reateKeyPair()

  val serverAuth = mapOf(
    primero para RecoveryServerSigning(recoverySigners[0], auth1),
    segundo a RecoveryServerSigning(recoverySigners[1], firebaseToken)
  )

  val signedReplaceKeyTransaction =
    recovery. eplaceDeviceKey(
      accountKp,
      newKey,
      serverAuth
)
```

```dart
var newKey = wallet.stellar().account(). reateKeyPair();
var serverAuth = {
  primero: RecoveryServerSigning(recoverySigners[0], auth1),
  segundo: RecoveryServerSigning(recoverySigners[1], auth2)
};

var signedReplaceKeyTx = await recovery. eplaceDeviceKey(accountKp, newKey, serverAuth);
```

</CodeExample>

Llamar a esta función creará una transacción que bloquea la clave de dispositivo anterior y la reemplaza con la nueva clave (teniendo el mismo peso que la antigua). Ambos firmantes de recuperación habrán firmado la transacción.

La clave perdida del dispositivo se deducirá automáticamente si no se proporciona. Un firmante será considerado una clave de dispositivo, si una de estas condiciones coincide:

1. Es el único firmante que no está en `serverAuth`.
2. Todos los firmantes de `serverAuth` tienen el mismo peso, y el firmante potencial es el único con un peso diferente.

Tenga en cuenta que la cuenta creada anteriormente coincidirá con los primeros criterios. Si se utilizara un esquema de 2-3, entonces el segundo criterio coincidiría. (En 2-3 esquemas, se utilizan 3 servicios y 2 de ellos son suficientes para recuperar la clave. Este es un enfoque recomendado.)

Nota: también puede usar funciones de nivel más bajo `signWithRecoveryServers` para firmar transacción arbitraria.

Finalmente, es el momento de enviar la transacción:

<CodeExample>

```typescript
esperar stellar.submitTransaction(recoverTxn);
```

```kotlin
  wallet.stellar().submitTransaction(signedReplaceKeyTransaction)
```

```dart
esperar wallet.stellar().submitTransaction(signedReplaceKeyTx);
```

</CodeExample>

[sep-30]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0030.md

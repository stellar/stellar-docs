---
title: Alojamiento de depósito y retirada
sidebar_position: 50
---

import { LanguageSpecific } from "@site/src/components/LanguageSpecific";
import KtWatcher from "./component/kt/watcher.mdx";

import { WalletCodeExample as CodeExample } from "@site/src/components/WalletCodeExample";
import Header from "./component/header.mdx";

<Header />

El Estándar [SEP-24] define la forma estándar para que los anclajes y monederos interactúen en nombre de los usuarios. Los monederos utilizan este estándar para facilitar los intercambios entre activos en cadena (como monedas estables) y activos fuera de cadena (como fiat, u otros recursos de red como BTC).

Durante el flujo, una cartera hace varias peticiones al ancla y finalmente recibe una URL interactiva para abrir en iframe. Esta URL es utilizada por el usuario para proporcionar una entrada (como KYC) directamente al fondo. Finalmente, la cartera puede obtener información de transacción usando puntos finales de consulta.

## Obtener información de ancla

Empecemos con obtener una instancia de clase `Interactive`, responsable de todas las interacciones SEP-24:

<CodeExample>

```kotlin
val sep24 = anchor.sep24()
```

```typescript
const sep24 = await anchor.sep24();
```

```dart
final sep24 = esperar anchor.sep24();
```

</CodeExample>

Primero, obtengamos la información sobre el soporte del ancla para [SEP-24]. Esta solicitud no requiere autenticación, y devolverá información genérica, como monedas soportadas, y características soportadas por el anchor. Puedes obtener una lista completa de los campos devueltos en la [especificación SEP-24](https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0024.md#info).

<CodeExample>

```kt
suspender getAnchorServices(): AnchorServiceInfo {
  return sep24.getServicesInfo()
}
```

```typescript
const getAnchorServices = async (): Promise<AnchorServiceInfo> => {
  return await anchor.getServicesInfo();
};
```

```dart
final servicesInfo = await sep24.getServiceInfo();
```

</CodeExample>

## Flujos interactivos

Antes de empezar, asegúrese de que se ha conectado al ancla y ha recibido un token de autenticación, como se describe en la guía de cartera [Stellar Authentication]. Utilizaremos el objeto `token` en los ejemplos de abajo como el token de autenticación [SEP-10] , obtenido anteriormente.

Para iniciar una operación, necesitamos conocer un activo. Puede querer codificarlo duro, o obtenerlo dinámicamente desde el archivo de información del ancla, como se muestra a continuación (para USDC):

<CodeExample>

```kt
val asset = info.currencies.first { it.code == "USDC" }.assetId
```

```typescript
import { IssuedAssetId } from "@stellar/typescript-wallet-sdk";

const assetCode = "USDC";

const info = await anchor. etInfo();

const currency = info.currencies.find(({ code }) => code === assetCode);

if (!currency?. ode || !currency?. ssuer) {
  arrojar un nuevo Error(
    `Anchor no soporta el recurso ${assetCode} o no está configurado correctamente en el archivo TOML`,
  );
}

const asset = new IssuedAssetId(currency. ode, currency.issuer);
```

```dart
activo final = info.currencies.firstWhere(((it)=>it.code=='USDC').assetId;
```

</CodeExample>

:::info

Antes de comenzar con el flujo de depósito, asegúrese de que la cuenta de usuario ha [establecido una línea de confianza](./stellar.mdx#modify-assets-trustlines) para el activo con el que está trabajando.

:::

### Flujo básico

Empecemos con un depósito básico:

<CodeExample>

```kt
depósito val = sep24.deposit(activo, token)
```

```typescript
const deposit = await sep24.deposit({
  assetCode: asset.code,
  authToken,
});
```

```dart
depósito final = espera sep24.deposit(activo, token);
```

</CodeExample>

Como resultado, obtendrás una [respuesta interactiva](https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0024.md#deposit-and-draw-shared-responses) del anchor.

Abrir la URL recibida en un iframe y depositar el ID de transacción para referencia futura:

<CodeExample>

```kt
val url = deposit.url
val id = deposit.id
```

```typescript
const url = deposit.url;
const id = deposit.id;
```

```dart
final url = deposit.url;
final id = deposit.id;
```

</CodeExample>

Del mismo modo al flujo del depósito, un flujo básico de retiro tiene la misma firma del método y reposar tipo:

<CodeExample>

```kt
retiro val = sep24.retiro (activo, token)
url val = retirada.url
val id = retiro.id
```

```typescript
const withdrawal = await sep24.withdrawal ({
  assetCode: asset.code,
  authToken,
});
const url = drawal.url;
const id = drawal.id;
```

```dart
final de retiro = await sep24.retiro (activo, token);
url final = retirada.url;
final id = retiro.id;
```

</CodeExample>

### Proporcionando información de KYC

Para mejorar la experiencia del usuario, el estándar [SEP-24] soporta pasar el usuario KYC al ancla vía [SEP-9]. A su vez, el ancla rellenará esta información en la ventana emergente interactiva.

:::info

Mientras que [SEP-9] soporta pasar datos binarios, la versión actual del SDK no ofrece tal funcionalidad.

:::

:::note

En ese momento, la [SEP-9] aceptada no está estrictamente escrita aún. Se ofrecerá un tipo mejorado en versiones futuras.

:::

<CodeExample>

```kt
val sep9 = mapOf("email_address" a "mail@example.com")

val deposit = sep24.deposit(activo, token, sep9)
```

```typescript
const deposit = await sep24.deposit({
  assetCode: asset.code,
  authToken,
  extraFields: { email_address: "mail@example.com" },
});
```

```dart
final deposit = await sep24.deposit(asset, token,
  extrafields: {"email_address": "mail@example.com"});
```

</CodeExample>

### Cambiando cuenta de transferencia estelar

De forma predeterminada, la transferencia Stellar será enviada a la cuenta autenticada (con un memo) que inició el depósito.

Aunque en la mayoría de los casos es aceptable, algunas billeteras pueden dividir sus cuentas. Para ello, pase una cuenta adicional (y opcionalmente un memo):

<CodeExample>

```kt
suspender depósito divertido DifferentAccount(): InteractiveFlowResponse {
  val recipientAccount = "G..."
  val memo = "mi memo" a MemoType. EXT
  devolver sep24.deposit(activo, token, destinationAccount = recipientAccount, destinationMemo = memo)
}
```

```typescript
import { Memo, MemoText } from "stellar-sdk";

const recipientAccount = "G... ;
const depositDifferentAccount = async (): Promise<InteractiveFlowResponse> => {
  return await sep24. eposit({
    destinationAccount: recipientAccount,
    destinationMemo: new Memo(MemoText, "some memo"),
    assetCode: asset. ode,
    authToken,
  });
};
```

```dart
final destinatarioCuenta = "G...";
depósito final = esperar sep24.deposit(activo, token, destinationAccount: recipientAccount,
  destinationMemo: "mi memo", destinationMemoType: MemoType.text);
```

</CodeExample>

De la misma manera, para un retiro, se podría cambiar la cuenta de origen de la transacción estelar:

<CodeExample>

```kt
original del val Account = "G..."
val withdrawal = sep24.withdrawal (activo, token, retirada de cuenta = origincuenta)
```

```typescript
const originAccount = "G...";
const withdrawal = await sep24.withdrawal ({
  withdrawal alAccount: originAccount,
  assetCode: asset.code,
  authToken,
});
```

```dart
final originAccount = "G...";
último retiro = esperar sep24.Remove (activo, token, retirada de cuenta: originAccount);
```

</CodeExample>

## Obteniendo información de la transacción

En el flujo típico, la cartera obtendría datos de transacción para notificar a los usuarios sobre las actualizaciones de estado. Esto se hace a través del punto final [SEP-24] `GET /transaction` y `GET /transactions`.

Alternativamente, algunos anchors soportan webhooks para notificaciones. Tenga en cuenta que esta característica aún no está ampliamente adoptada.

### Transacción de seguimiento

Veamos cómo usar el SDK de la cartera para rastrear los cambios de estado de las transacciones. Utilizaremos la clase `Watcher` para este propósito. Primero, inicialicemos el observador y empecemos a rastrear una transacción.

<CodeExample>

```kt
val watcher = sep24.watcher()
val result = watcher.watchOneTransaction(token, "transaction id")
```

```typescript
const watcher = sep24.watcher();

const { stop, refresh } = watcher.watchOneTransaction({
  authToken,
  assetCode: asset.code,
  id: successTransaction.id,
  onMessage,
  onSuccess,
  onError,
});
```

```dart
último observador = sep24.watcher();
resultado final = watcher.watchOneTransaction(token, "ID de transacción");
```

</CodeExample>

Alternativamente, podemos rastrear múltiples transacciones para el mismo activo.

<CodeExample>

```kt
val watcher = sep24.watcher()
val result = watcher.watchAsset(getAuthToken(), asset)
```

```typescript
const watcher = sep24.watcher();

const { stop, refresh } = watcher.watchAllTransactions({
  authToken,
  assetCode: asset.code,
  onMessage,
  onError,
});
```

```dart
último observador = sep24.watcher();
resultado final = watcher.watchAsset(token, asset);
```

</CodeExample>

<LanguageSpecific kt={<KtWatcher />} />

### Obteniendo transacción

Mientras que la clase `Watcher` ofrece potentes capacidades de seguimiento, a veces es necesario simplemente buscar una transacción (o transacciones) una vez. La clase `Anchor` te permite obtener una transacción por ID, ID de transacción estelar o ID de transacción externa:

<CodeExample>

```kt
val transaction = sep24.getTransactionBy(token, id = "ID de transacción")
```

```typescript
const transaction = await sep24.getTransactionBy({
  authToken,
  id: transactionId,
});
```

```dart
final transacción = await sep24.getTransaction("transaction id", token);
```

</CodeExample>

También es posible recuperar la transacción por el activo

<CodeExample>

```kt
val transactions = sep24.getTransactionsForAsset(asset, token)
```

```typescript
const transactions = await sep24.getTransactionsForAsset({
  authToken,
  assetCode: asset.code,
});
```

```dart
final de transacciones = await sep24.getTransactionsForAsset(asset, token);
```

</CodeExample>

## Enviando Transferencia de Retiro

Anteriormente, echamos un vistazo a la hora de iniciar el flujo de retirada. Ahora, echemos un vistazo a un ejemplo completo.

Primero, iniciar el retiro:

<CodeExample>

```kt
val withdrawal = sep24.withdrawal (asset, authToken = token)
```

```typescript
const withdrawal = await sep24.withdrawal ({
  assetCode: asset.code,
  authToken,
});
```

```dart
final de retiro = espera sep24.retiro (activo, token);
```

</CodeExample>

A continuación, abra una url interactiva :

<CodeExample>

```kt
val url = drawal.url
// abre la url
```

```typescript
const url = drawal.url;
// abre la url
```

```dart
final url = drawal.url
// abre la url
```

</CodeExample>

Después de eso, tenemos que esperar hasta que el anclaje esté listo para recibir fondos. Para ello, esperaremos hasta que la transacción alcance el estado `pendiente_user_transfer_start`

<CodeExample>

```kt
val retialWatcher = sep24.watcher().watchOneTransaction(token, drawal.id)
var statusChange: StatusUpdateEvent

// Espera la entrada del usuario
do {
  statusChange = withdrawal alWatcher. hannel.receive()
} while (
  (statusChange as? StatusChange) ?: throw Exception("Canal cerrado inesperadamente"))
    . tatus != TransactionStatus.PENDING_USER_TRANSFER_START
)
```

```typescript
const watcher = sep24.watcher();

const onMessage = (transaction) => {
  if (transacción. tatus === "pending_user_transfer_start") {
    // comenzar a transferir código
  }
};

const { refresh, stop } = vigilante. atchOneTransaction({
  authToken,
  assetCode: asset.code,
  id: exitosa Transacción. d,
  onMessage,
  onSuccess,
  onError,
});
```

```dart
retiro final Watcher = sep24.watcher().watchOneTransaction(token, drawal.id);
withdrawal alWatcher.controller.stream.listen(
  (event) {
    if (event is StatusChange && TransactionStatus. evento endingUserTransferStart == . tatus) {
      // comenzar a transferir
    }
  },
  onError: (error) {
    // manejar error
  },
);
```

</CodeExample>

A continuación, firma y envía la transferencia estelar:

<CodeExample>

```kt
val anchorTransaction = (statusChange.transaction as WithdrawalTransaction)
val transfer = stellar.transaction(keypair).transferWithdrawalTransaction(anchorTransaction, asset).build()

transfer.sign(keypair)

stellar.submitTransaction(transfer)
```

```typescript
const txBuilder = await stellar. ransaction({
  sourceAddress: keypair,
  baseFee: 100,
});

const transfer = txBuilder
  . ransferWithdrawalTransaction(walletTransaction, asset)
  .build();

keypair.sign(transfer);
stellar.submitTransaction(transfer);
```

```dart
final tx = event.transaction as WithdrawalTransaction;

final paymentBuilder = flutter_sdk.PaymentOperationBuilder(
  tx.withdrawal AnchorAccount!,
  flutter_sdk.Asset.createNonNativeAsset(asset.code, asset.issuer),
  tx. mountIn!,
);

final transactionBuilder = flutter_sdk.TransactionBuilder(sourceAccount)
  ..addOperation(paymentBuilder. uild());

flutter_sdk.Memo? memo;
if ("text" == tx.drawalMemoType) {
  memo = flutter_sdk. emoText(tx.drawalMemo!);
} else if ("hash" == tx.drawalMemoType) {
  memo = flutter_sdk. emoHash(base64Decode(tx.drawalMemo!));
} // ... etc.

if (memo != null) {
  transactionBuilder. ddMemo(memo);
}

flutter_sdk.KeyPair kp =
  flutter_sdk.KeyPair.froměSeed(userKeyPair.secretKey);
transacción final = transactionBuilder.build()..sign(kp, network);
final paymentResult = await sdk.submitTransaction(transaction);
```

</CodeExample>

Donde `keypair` es la cuenta autenticada SEP-10. Si quieres transferir fondos desde una dirección diferente, consulta la sección [Cambiar Cuenta de Transferencia Estelar](#changing-stellar-transfer-account).

Por último, vamos a seguir las actualizaciones del estado de la transacción. En este ejemplo simplemente comprobamos si la transacción ha sido completada:

<CodeExample>

```kt
var terminalStatus: TransactionStatus? = null

do {
  statusChange = deletalWatcher.channel. eceive()

  cuando (statusChange) {
    es StatusChange -> {
      if (statusChange. tatus.isTerminal()) {
        terminalStatus = statusChange. tatus
      }
    }
    is ChannelClosed -> println("Transaction tracking finished")
    is ExceptionHandlerExit ->
      println("Retries exhausted trying obtain transaction data, transaction data, renunciar. )
  }
} mientras (StatusChange !is ChannelClosed)

if (terminalStatus != TransactionStatus. OMPLETED) {
  println("Transaction was not completed")
}
```

```typescript
const watcher = sep24. atcher();

const onSuccess = (transaction) => {
  // la transacción volvió como completada / reembolsada / caducada
  consola. og("Transacción completada");
};

const onError = (transaction) => {
  // error de tiempo de ejecución, o la transacción vuelve como
  // no_market / too_small / too_large / error
};

const { refresh, stop } = vigilante. atchOneTransaction({
  authToken,
  assetCode: asset.code,
  id: exitosa Transacción. d,
  onMessage,
  onSuccess,
  onError,
});
```

```dart
final watcher = sep24.watcher().watchOneTransaction(token, drawal.id);
watcher.controller.stream. isten(
  (event) {
    if (event is StatusChange && event. tatus.isTerminal()) {
      if (TransactionStatus.completed != event. tatus) {
        print("¡La transacción no se completó! );
      } else {
        print("Success");
      }
    } else if (event is ExceptionHandlerExit) {
      print("Retries exhausted trying obtain transaction data, transactions data, renunciar. );
    } else if (event is StreamControllerClosed) {
      print("Transaction tracking finished");
    }
  },
  onError: (error) {
    // manejar error
  },
);
```

</CodeExample>

[sep-9]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0009.md
[sep-10]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0010.md
[sep-24]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0024.md
[autenticación estelar]: ./sep10.mdx

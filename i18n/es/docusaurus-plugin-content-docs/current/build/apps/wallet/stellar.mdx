---
title: Red de Stellar
sidebar_position: 30
---

import { LanguageSpecific } from "@site/src/components/LanguageSpecific";
import { WalletCodeExample as CodeExample } from "@site/src/components/WalletCodeExample";
import Header from "./component/header.mdx";
import CreateKeyPairInfo from "./component/ts/createKeypairInfo.mdx";

<Header />

En la sección anterior aprendimos cómo crear una billetera y un objeto `Stellar` que proporciona una conexión a Horizon. En esta sección, examinaremos los usos de esta clase.

## Cuentas

La entidad más básica en la red Stellar es una cuenta. Miremos el AccountService que proporciona la capacidad de trabajar con cuentas:

<CodeExample>

```kt
val account = wallet.stellar().account()
```

```typescript
let account = wal.stellar().account();
```

```dart
var account = wallet.stellar().account();
```

```swift
let account = wallet.stellar.account
```

</CodeExample>

Ahora podemos crear un par de claves:

<CodeExample>

```kt
val accountKeyPair = account.createKeyPair()
```

```typescript
let accountKeyPair = account.createKeypair();
```

```dart
var accountKeyPair = account.createKeyPair();
```

```swift
let accountKeyPair = account.createKeyPair()
```

</CodeExample>

<LanguageSpecific ts={<CreateKeyPairInfo />} />

## Construir Transacción

El constructor de transacciones te permite crear varias transacciones que pueden ser firmadas y enviadas a la red Stellar. Algunas transacciones pueden ser patrocinadas.

### Construyendo Transacciones Básicas

Primero, veamos cómo construir transacciones básicas.

#### Crear Cuenta

La transacción de crear cuenta activa/crea una cuenta con un saldo inicial de XLM (1 XLM por defecto).

<CodeExample>

```kotlin
suspend fun createAccount(): Transaction {
  return stellar.transaction(sourceAccountKeyPair).createAccount(destinationAccountKeyPair).build()
}
```

```typescript
const txBuilder = await stellar.transaction({
  sourceAddress: sourceAccountKeyPair,
});
const tx = txBuilder.createAccount(destinationAccountKeyPair).build();
```

```dart
var txBuilder = await stellar.transaction(sourceAccountKeyPair);
var tx = txBuilder.createAccount(destinationAccountKeyPair).build();
```

```swift
let txBuilder = try await stellar.transaction(sourceAddress: sourceAccountKeyPair)
let tx = try txBuilder.createAccount(newAccount: destinationAccountKeyPair).build()
```

</CodeExample>

#### Modificar Cuenta

Puedes bloquear la clave maestra de la cuenta estableciendo su peso en 0. Ten cuidado al bloquear la clave maestra de la cuenta. Asegúrate de haber establecido los firmantes y pesos correctos. De lo contrario, bloquearás la cuenta de forma irreversible.

<CodeExample>

```kotlin
suspend fun lockMasterKey(): Transaction {
  return stellar.transaction(sourceAccountKeyPair).lockAccountMasterKey().build()
}
```

```typescript
const txBuilder = await stellar.transaction({
  sourceAddress: sourceAccountKeyPair,
});

const tx = txBuilder.lockAccountMasterKey().build();
```

```dart
var txBuilder = await stellar.transaction(sourceAccountKeyPair);
var tx = txBuilder.lockAccountMasterKey().build();
```

```swift
let txBuilder = try await stellar.transaction(sourceAddress: sourceAccountKeyPair)
let tx = try txBuilder.lockAccountMasterKey().build()
```

</CodeExample>

Añadir un nuevo firmante a la cuenta. Ten cuidado al añadir nuevos firmantes y asegúrate de establecer el peso del firmante correcto. De lo contrario, bloquearás la cuenta de forma irreversible.

<CodeExample>

```kotlin
val newSignerKeyPair = account.createKeyPair()

suspend fun addSigner(): Transaction {
  return stellar.transaction(sourceAccountKeyPair).addAccountSigner(newSignerKeyPair, 10).build()
}
```

```typescript
const newSignerKeyPair = account.createKeypair();

const tx = txBuilder.addAccountSigner(newSignerKeyPair, 10).build();
```

```dart
var newSignerKeyPair = account.createKeyPair();

var txBuilder = await stellar.transaction(sourceAccountKeyPair);
var tx = txBuilder.addAccountSigner(newSignerKeyPair, 10).build();
```

```swift
let newSignerKeyPair = account.createKeyPair()

let txBuilder = try await stellar.transaction(sourceAddress: sourceAccountKeyPair)
let tx = try txBuilder.addAccountSigner(signerAddress: newSignerKeyPair, signerWeight: 10).build()
```

</CodeExample>

Eliminar un firmante de la cuenta.

<CodeExample>

```kotlin
suspend fun removeSigner(): Transaction {
  return stellar.transaction(sourceAccountKeyPair).removeAccountSigner(newSignerKeyPair).build()
}
```

```typescript
const tx = txBuilder.removeAccountSigner(newSignerKeyPair).build();
```

```dart
var txBuilder = await stellar.transaction(sourceAccountKeyPair);
var tx = txBuilder.removeAccountSigner(newSignerKeyPair).build();
```

```swift
let txBuilder = try await stellar.transaction(sourceAddress: sourceAccountKeyPair)
let tx = try txBuilder.removeAccountSigner(signerAddress: newSignerKeyPair).build()
```

</CodeExample>

Modificar los umbrales de la cuenta (útil cuando se asignan varios firmantes a la cuenta). Esto te permite restringir el acceso a ciertas operaciones cuando no se alcanza el límite.

<CodeExample>

```kotlin
suspend fun setThreshold(): Transaction {
  return stellar.transaction(sourceAccountKeyPair).setThreshold(low = 1, medium = 10, high = 30).build()
}
```

```typescript
const tx = txBuilder.setThreshold({ low: 1, medium: 10, high: 30 }).build();
```

```dart
var txBuilder = await stellar.transaction(sourceAccountKeyPair);
var tx = txBuilder.setThreshold(low: 1, medium: 10, high: 20).build();
```

```swift
let txBuilder = try await stellar.transaction(sourceAddress: sourceAccountKeyPair)
let tx = try txBuilder.setThreshold(low: 1, medium: 10, high: 20).build()
```

</CodeExample>

#### Modificar Activos (Trustlines)

Añadir un activo (trustline) a la cuenta. Esto permite a la cuenta recibir transferencias del activo.

<CodeExample>

```kotlin
val asset = IssuedAssetId("USDC", "GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5")

suspend fun addAsset(): Transaction {
  return stellar.transaction(sourceAccountKeyPair).addAssetSupport(asset).build()
}
```

```typescript
const asset = new IssuedAssetId(
  "USDC",
  "GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5",
);

const tx = txBuilder.addAssetSupport(asset).build();
```

```dart
var asset = IssuedAssetId(
        code: "USDC",
        issuer: "GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5");

var txBuilder = await stellar.transaction(sourceAccountKeyPair);
var tx = txBuilder.addAssetSupport(asset).build();
```

```swift
let asset = try IssuedAssetId(
    code: "USDC",
    issuer: "GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5")

let txBuilder = try await stellar.transaction(sourceAddress: sourceAccountKeyPair)
let tx = try txBuilder.addAssetSupport(asset: asset).build()
```

</CodeExample>

Eliminar un activo de la cuenta (el saldo del activo debe ser 0).

<CodeExample>

```kotlin
suspend fun removeAsset(): Transaction {
  return stellar.transaction(sourceAccountKeyPair).removeAssetSupport(asset).build()
}
```

```typescript
const tx = txBuilder.removeAssetSupport(asset).build();
```

```dart
var txBuilder = await stellar.transaction(sourceAccountKeyPair);
var tx = txBuilder.removeAssetSupport(asset).build();
```

```swift
let txBuilder = try await stellar.transaction(sourceAddress: sourceAccountKeyPair)
let tx = try txBuilder.removeAssetSupport(asset: asset).build()
```

</CodeExample>

#### Intercambiar

Intercambiar un activo de la cuenta por otro activo diferente. La cuenta debe tener una trustline para el activo de destino.

<CodeExample>

```typescript
const txBuilder = await stellar.transaction({
  sourceAddress: sourceKp,
});
const usdcAsset = new IssuedAssetId(
  "USDC",
  "GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5",
);
const txn = txBuilder.swap(new NativeAssetId(), usdcAsset, ".1").build();
```

```dart
var txBuilder = await stellar.transaction(sourceKp);

final usdcAsset = IssuedAssetId(
    code: 'USDC',
    issuer: 'GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5',
);

var txn = txBuilder.swap(
    fromAsset: NativeAssetId(),
    toAsset: usdcAsset,
    amount: "0.1",
  ).build();
```

```swift
let txBuilder = try await stellar.transaction(sourceAddress: sourceKp)

let usdcAsset = try IssuedAssetId(
    code: "USDC",
    issuer: "GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5")

let txn = try txBuilder.swap(fromAsset: NativeAssetId(),
                             toAsset: usdcAsset,
                             amount: 0.1).build()
```

</CodeExample>

#### Path Pay

Enviar un activo de la cuenta de origen y recibir un activo diferente en la cuenta de destino.

<CodeExample>

```typescript
const txBuilder = await stellar.transaction({
  sourceAddress: sourceKp,
});
const usdcAsset = new IssuedAssetId(
  "USDC",
  "GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5",
);
const txn = txBuilder
  .pathPay({
    destinationAddress: receivingKp.publicKey,
    sendAsset: new NativeAssetId(),
    destAsset: usdcAsset,
    sendAmount: "5",
  })
  .build();
```

```dart
var txBuilder = await stellar.transaction(sourceKp);

final usdcAsset = IssuedAssetId(
    code: 'USDC',
    issuer: 'GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5',
);

var txn = txBuilder.pathPay(
    destinationAddress: receivingKp.address,
    sendAsset: NativeAssetId(),
    destinationAsset: usdcAsset,
    sendAmount: "5",
  ).build();
```

```swift
let txBuilder = try await stellar.transaction(sourceAddress: sourceKp)

let usdcAsset = try IssuedAssetId(
    code: "USDC",
    issuer: "GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5")

let txn = try txBuilder.pathPay(destinationAddress: receivingKp.address,
                                sendAsset: NativeAssetId(),
                                destinationAsset: usdcAsset,
                                sendAmount: 5).build()
```

</CodeExample>

#### Establecer Memo

Establece un memo en la transacción. El objeto memo se puede importar de ["@stellar/stellar-sdk"](https://www.npmjs.com/package/@stellar/stellar-sdk).

<CodeExample>

```typescript
import { Memo } from "@stellar/stellar-sdk";

const tx = txBuilder.setMemo(new Memo("text", "Memo string")).build();
```

```dart
import 'package:stellar_flutter_sdk/stellar_flutter_sdk.dart' as flutter_sdk;

var memo = flutter_sdk.MemoText("Memo string");
var tx = txBuilder.setMemo(memo).build();
```

```swift
import stellarsdk

let memo = Memo.text("Memo string")
let tx = try txBuilder.setMemo(memo: memo).build()
```

</CodeExample>

#### Fusión de Cuentas

Fusiona la cuenta en una cuenta de destino.

<CodeExample>

```typescript
const txBuilder = await stellar.transaction({
  sourceAddress: accountKp,
  baseFee: 1000,
});
const mergeTxn = txBuilder
  .accountMerge(accountKp.publicKey, sourceKp.publicKey)
  .build();
```

```dart
var txBuilder = await stellar.transaction(accountKp, baseFee: 1000);

var mergeTxn = txBuilder.accountMerge(
    destinationAddress: accountKp.address,
    sourceAddress: sourceKp.address,
  ).build();
```

```swift
let txBuilder = try await stellar.transaction(sourceAddress: accountKp,
                                              baseFee: 1000)

let mergeTxn = try txBuilder.accountMerge(destinationAddress: accountKp.address,
                                          sourceAddress: sourceKp.address).build()
```

</CodeExample>

#### Fondos de Cuenta de Test Net

Financia una cuenta en la red de pruebas Stellar

<CodeExample>

```typescript
wallet.stellar().fundTestnetAccount(accountKp.publicKey);
```

```dart
await wallet.stellar().fundTestNetAccount(accountKp.address);
```

```swift
try await wallet.stellar.fundTestNetAccount(address: accountKp.address)
```

</CodeExample>

### Construyendo Transacciones Avanzadas

En algunos casos, es posible que no se conozca una clave privada antes de formar una transacción. Por ejemplo, se debe financiar una nueva cuenta para que exista y la billetera puede no tener la clave de la cuenta, por lo que puede solicitar que la transacción de creación de la cuenta sea patrocinada por un tercero.

<CodeExample>

```kt
// Third-party key that will sponsor creating new account
val externalKeyPair = "MySponsorAddress".toPublicKeyPair()
val newKeyPair = account.createKeyPair()
```

```typescript
// Third-party key that will sponsor creating new account
const externalKeyPair = new PublicKeypair.fromPublicKey("GC5GD...");
const newKeyPair = account.createKeypair();
```

```dart
// Third-party key that will sponsor creating new account
var externalKeyPair = PublicKeyPair.fromAccountId("GC5GD...");
var newKeyPair = account.createKeyPair();
```

```swift
// Third-party key that will sponsor creating new account
let externalKeyPair = try PublicKeyPair(accountId: "GC5GD...")
let newKeyPair = account.createKeyPair()
```

</CodeExample>

Primero, se debe crear la cuenta.

<CodeExample>

```kotlin
suspend fun makeCreateTx(): Transaction {
  return stellar.transaction(externalKeyPair).createAccount(newKeyPair).build()
}
```

```typescript
const createTxn = txBuilder.createAccount(newKeyPair).build();
```

```dart
var txBuilder = await stellar.transaction(externalKeyPair);
var createTxn = txBuilder.createAccount(newKeyPair).build();
```

```swift
let txBuilder = try await stellar.transaction(sourceAddress: externalKeyPair)
let createTxn = try txBuilder.createAccount(newAccount: newKeyPair).build()
```

</CodeExample>

Esta transacción debe enviarse al firmante externo (titular de `externalKeyPair`) para ser firmada.

<CodeExample>

```kt
suspend fun remoteSignTransaction(transaction: Transaction) {
  val xdrString = transaction.toEnvelopeXdrBase64()
  // Send xdr encoded transaction to your backend server to sign
  val xdrStringFromBackend = sendTransactionToBackend(xdrString)

  // Decode xdr to get the signed transaction
  val signedTransaction = stellar.decodeTransaction(xdrStringFromBackend)
}
```

```typescript
const xdrString = createTxn.toXDR();
// Send xdr encoded transaction to your backend server to sign
const xdrStringFromBackend = await sendTransactionToBackend(xdrString);

// Decode xdr to get the signed transaction
const signedTransaction = stellar.decodeTransaction(xdrStringFromBackend);
```

```dart
var xdrString = createTxn.toEnvelopeXdrBase64();

// Send xdr encoded transaction to your backend server to sign
var xdrStringFromBackend = await sendTransactionToBackend(xdrString);

// Decode xdr to get the signed transaction
var signedTransaction = stellar.decodeTransaction(xdrStringFromBackend);
```

```swift
let xdrString = createTxn.toEnvelopeXdrBase64()

// Send xdr encoded transaction to your backend server to sign
let xdrStringFromBackend = await sendTransactionToBackend(xdrString)

// Decode xdr to get the signed transaction
let signedTransaction = stellar.decodeTransaction(xdr: xdrStringFromBackend)
```

</CodeExample>

:::note

Puedes leer más sobre cómo enviar transacciones XDR al servidor en el [capítulo siguiente](#using-xdr-to-send-transaction-data).

:::

La transacción firmada puede ser presentada por la billetera.

<CodeExample>

```kt
suspend fun submitCreateTx(signedCreateTx: Transaction) {
  wallet.stellar().submitTransaction(signedCreateTx)
}

```

```typescript
await wallet.stellar().submitTransaction(signedTransaction);
```

```dart
bool success = await stellar.submitTransaction(signedTransaction);
```

```swift
try await stellar.submitTransaction(signedTransaction: signedTransaction)
```

</CodeExample>

Ahora, después de crear la cuenta, puede realizar operaciones. Por ejemplo, podemos desactivar el keypair maestro y reemplazarlo con uno nuevo (llamémoslo keypair del dispositivo) atómicamente en una sola transacción:

<CodeExample>

```kotlin
suspend fun addDeviceKeyPair() {
  val deviceKeyPair = account.createKeyPair()

  val modifyAccountTransaction =
    stellar
      .transaction(newKeyPair)
      .addAccountSigner(
        deviceKeyPair,
        signerWeight = 1,
      )
      .lockAccountMasterKey()
      .build()
      .sign(newKeyPair)

  wallet.stellar().submitTransaction(modifyAccountTransaction)
}
```

```typescript
const deviceKeyPair = account.createKeypair();

const txBuilder = await stellar.transaction({ sourceAddress: newKeyPair });
const modifyAccountTransaction = txBuilder
  .addAccountSigner(deviceKeyPair, 1)
  .lockAccountMasterKey()
  .build();
newKeyPair.sign(modifyAccountTransaction);

await wallet.stellar().submitTransaction(modifyAccountTransaction);
```

```dart
var deviceKeyPair = account.createKeyPair();

var txBuilder = await stellar.transaction(newKeyPair);
var modifyAccountTransaction = txBuilder
    .addAccountSigner(deviceKeyPair, 1)
    .lockAccountMasterKey()
    .build();

stellar.sign(modifyAccountTransaction, newKeyPair);

bool success = await stellar.submitTransaction(modifyAccountTransaction);
```

```swift
let deviceKeyPair = account.createKeyPair()

let txBuilder = try await stellar.transaction(sourceAddress: newKeyPair)

let modifyAccountTransaction = try txBuilder
    .addAccountSigner(signerAddress: deviceKeyPair, signerWeight: 1)
    .lockAccountMasterKey()
    .build()

stellar.sign(tx: modifyAccountTransaction,
             keyPair: newKeyPair)

try await stellar.submitTransaction(signedTransaction: modifyAccountTransaction)
```

</CodeExample>

#### Añadiendo una Operación

Agrega una Operación personalizada a una transacción. Esto puede ser cualquier [Operación](../../../learn/fundamentals/transactions/list-of-operations) admitida por la red Stellar. El objeto Operación se puede importar de ["@stellar/stellar-sdk"](https://www.npmjs.com/package/@stellar/stellar-sdk).

<CodeExample>

```typescript
import { Operation } from "@stellar/stellar-sdk";

const txBuilder = await stellar.transaction({
  sourceAddress: sourceAccountKeyPair,
});
const tx = txBuilder.addOperation(
  Operation.manageData({
    name: "web_auth_domain",
    value: new URL(authServer).hostname,
    source: sourceAccountKeyPair,
  }),
);
```

```dart
import 'package:stellar_flutter_sdk/stellar_flutter_sdk.dart' as flutter_sdk;

var txBuilder = await stellar.transaction(sourceAccountKeyPair);

var key = "web_auth_domain";
var value = "https://testanchor.stellar.org";
var valueBytes = Uint8List.fromList(value.codeUnits);

var manageDataOperation = flutter_sdk.ManageDataOperationBuilder(
    key,
    valueBytes,
  ).build();

var tx = txBuilder.addOperation(
    manageDataOperation,
  ).build();
```

```swift
import stellarsdk

let txBuilder = try await stellar.transaction(sourceAddress: sourceAccountKeyPair)
let key = "web_auth_domain"
let value = "testanchor.stellar.org"
let manageDataOperation = ManageDataOperation(sourceAccountId: sourceAccountKeyPair.address,
                                              name: key,
                                              data: value.data(using: .utf8))

let tx = try txBuilder.addOperation(operation: manageDataOperation).build()
```

</CodeExample>

### Patrocinando Transacciones

#### Operaciones de Patrocinio

Algunas operaciones, que modifican las reservas de la cuenta pueden ser [patrocinadas](../../guides/transactions/sponsored-reserves.mdx). Para las operaciones patrocinadas, la cuenta patrocinadora pagará las reservas en lugar de la cuenta que está siendo patrocinada. Esto te permite realizar algunas operaciones, incluso si la cuenta no tiene suficientes fondos para realizar tales operaciones. Para patrocinar una transacción, <LanguageSpecific kt={<span>simplemente inicia un bloque <code>sponsoring</code>:</span>} ts={<span>simplemente crea una función de construcción (describiendo qué operaciones van a ser patrocinadas) y pásala al método <code>sponsoring</code>:</span>}/>

<CodeExample>

```kotlin
suspend fun sponsorOperation() {
  val transaction =
    stellar
      .transaction(sponsoredKeyPair)
      .sponsoring(sponsorKeyPair) { addAssetSupport(asset) }
      .build()

  transaction.sign(sponsorKeyPair).sign(sponsoredKeyPair)
}
```

```typescript
const txBuilder = await stellar.transaction({
  sourceAddress: sponsoredKeyPair,
});

const buildingFunction = (bldr) => bldr.addAssetSupport(asset);
const transaction = txBuilder
  .sponsoring(sponsorKeyPair, buildingFunction)
  .build();

sponsoredKeyPair.sign(transaction);
sponsorKeyPair.sign(transaction);
```

```dart
var txBuilder = await stellar.transaction(sponsoredKeyPair);
var transaction = txBuilder
    .sponsoring(sponsorKeyPair, (builder) => builder.addAssetSupport(asset))
    .build();

stellar.sign(transaction, sponsorKeyPair);
stellar.sign(transaction, sponsoredKeyPair);
```

```swift
let txBuilder = try await stellar.transaction(sourceAddress: sponsoredKeyPair)
let transaction = try txBuilder.sponsoring(
    sponsorAccount: sponsorKeyPair,
    buildingFunction:{ (builder) in builder.addAssetSupport(asset: asset)}).build()

stellar.sign(tx: transaction, keyPair: sponsorKeyPair)
stellar.sign(tx: transaction, keyPair: sponsoredKeyPair)
```

</CodeExample>

:::info

Solo algunas operaciones pueden ser patrocinadas, y un <LanguageSpecific kt={<span>bloque</span>} ts={<span>constructor</span>} /> de patrocinio tiene un conjunto ligeramente diferente de funciones disponibles en comparación con el `TransactionBuilder` regular. Nota que una transacción debe ser firmada por ambas cuentas: la cuenta patrocinadora (`sponsoringKeyPair`) y la cuenta que está siendo patrocinada (`sponsoredKeyPair`).

:::

#### Creación de Cuenta Patrocinadora

Una de las cosas que se pueden hacer a través de patrocinio es crear una cuenta con un saldo inicial de 0. Esta creación de cuenta puede hacerse simplemente escribiendo:

<CodeExample>

```kt
suspend fun sponsorAccountCreation() {
  val newKeyPair = account.createKeyPair()

  val transaction =
    stellar
      .transaction(sponsorKeyPair)
      .sponsoring(sponsorKeyPair, sponsoredAccount = newKeyPair) { createAccount(newKeyPair) }
      .build()

  transaction.sign(sponsorKeyPair).sign(newKeyPair)
}
```

```typescript
const txBuilder = await stellar.transaction({ sourceAddress: sponsorKeyPair });

const newKeyPair = account.createKeypair();

const buildingFunction = (bldr) => bldr.createAccount(newKeyPair);
const transaction = txBuilder
  .sponsoring(sponsorKeyPair, buildingFunction, newKeyPair)
  .build();

newKeyPair.sign(transaction);
sponsorKeyPair.sign(transaction);
```

```dart
var newKeyPair = account.createKeyPair();

var txBuilder = await stellar.transaction(sponsorKeyPair);
var transaction = txBuilder
    .sponsoring(sponsorKeyPair, sponsoredAccount: newKeyPair,
        (builder) => builder.createAccount(newKeyPair))
    .build();

stellar.sign(transaction, sponsorKeyPair);
stellar.sign(transaction, newKeyPair);
```

```swift
let newKeyPair = account.createKeyPair()

let txBuilder = try await stellar.transaction(sourceAddress: sponsorKeyPair)
let transaction = try txBuilder.sponsoring(
    sponsorAccount: sponsorKeyPair,
    buildingFunction:{ (builder) in builder.createAccount(newAccount: newKeyPair)},
    sponsoredAccount: newKeyPair).build()

stellar.sign(tx: transaction, keyPair: sponsorKeyPair)
stellar.sign(tx: transaction, keyPair: newKeyPair)
```

</CodeExample>

Nota cómo en el primer ejemplo la cuenta fuente de la transacción se establece en `sponsoredKeyPair`. Debido a esto, no necesitábamos pasar un valor de cuenta patrocinada al bloque <LanguageSpecific kt={<span>sponsoring</span>} ts={<span>método</span>} />. Ya que cuando se omite, la cuenta patrocinada predetermina a la cuenta fuente de la transacción (`sponsoredKeyPair`).

Sin embargo, esta vez, la cuenta patrocinada (recientemente creada `newKeyPair`) es diferente de la cuenta fuente de la transacción. Por lo tanto, es necesario especificarla. De lo contrario, la transacción contendrá una operación mal formada. Como antes, la transacción debe ser firmada por ambas claves.

#### Creación y Modificación de Cuenta Patrocinadora

Si deseas crear una cuenta y modificarla en una sola transacción, es posible hacerlo pasando un argumento opcional `sponsoredAccount` al <LanguageSpecific kt={<span>bloque</span>} ts={<span>método patrocinador</span>} /> (`newKeyPair` abajo). Si este argumento está presente, todas las operaciones dentro del bloque patrocinado serán sourcing por esta `sponsoredAccount`. (Excepto la creación de cuenta, que siempre es sourcing por el patrocinador).

<CodeExample>

```kotlin
suspend fun sponsorAccountCreationAndModification() {
  val newKeyPair = account.createKeyPair()
  val replaceWith = account.createKeyPair()

  val transaction =
    stellar
        .transaction(sponsorKeyPair)
        .sponsoring(sponsorKeyPair, newKeyPair) {
          createAccount(newKeyPair)
          // source account for below operations will be newKeyPair
          addAccountSigner(replaceWith, 1)
          lockAccountMasterKey()
        }
        .build()

  transaction.sign(sponsorKeyPair).sign(newKeyPair)
}
```

```typescript
const txBuilder = await stellar.transaction({ sourceAddress: sponsorKeyPair });

const newKeyPair = account.createKeypair();
const replaceWith = account.createKeypair();

const buildingFunction = (bldr) =>
  bldr
    .createAccount(newKeyPair)
    // source account for below operations will be newKeyPair
    .addAccountSigner(replaceWith, 1)
    .lockAccountMasterKey();

const transaction = txBuilder
  .sponsoring(sponsorKeyPair, buildingFunction, newKeyPair)
  .build();

newKeyPair.sign(transaction);
sponsorKeyPair.sign(transaction);
```

```dart
var newKeyPair = account.createKeyPair();
var replaceWith = account.createKeyPair();

var txBuilder = await stellar.transaction(sponsorKeyPair);
var transaction = txBuilder
    .sponsoring(
    sponsorKeyPair,
    sponsoredAccount: newKeyPair,
        (builder) => builder
        .createAccount(newKeyPair)
        .addAccountSigner(replaceWith, 1)
        .lockAccountMasterKey())
    .build();

stellar.sign(transaction, sponsorKeyPair);
stellar.sign(transaction, newKeyPair);
```

```swift
let newKeyPair = account.createKeyPair()
let replaceWith = account.createKeyPair()

let txBuilder = try await stellar.transaction(sourceAddress: sponsorKeyPair)
let transaction = try txBuilder.sponsoring(
    sponsorAccount: sponsorKeyPair,
    buildingFunction:{ (builder) in builder
            .createAccount(newAccount: newKeyPair)
            .addAccountSigner(signerAddress: replaceWith, signerWeight: 1)
            .lockAccountMasterKey()
    },
    sponsoredAccount: newKeyPair).build()

stellar.sign(tx: transaction, keyPair: sponsorKeyPair)
stellar.sign(tx: transaction, keyPair: newKeyPair)
```

</CodeExample>

### Transacción Fee-Bump

Si deseas modificar una cuenta recién creada con un saldo de 0, también es posible hacerlo a través de `FeeBump`. Se puede combinar con un bloque de patrocinio <LanguageSpecific kt={<span>bloque</span>} ts={<span>método</span>} /> para lograr el mismo resultado que en el ejemplo anterior. Sin embargo, con `FeeBump`, también es posible agregar más operaciones (que no requieren patrocinio), como una transferencia.

Primero, vamos a crear una transacción que reemplazará la clave maestra de una cuenta con un nuevo keypair.

<CodeExample>

```kt
val replaceWith = account.createKeyPair()

val transaction =
  stellar
    .transaction(sponsoredKeyPair)
    .sponsoring(sponsorKeyPair) {
      lockAccountMasterKey()
      addAccountSigner(replaceWith, signerWeight = 1)
    }
    .build()

```

```typescript
const txBuilder = await stellar.transaction({
  sourceAddress: sponsoredKeyPair,
});

const replaceWith = account.createKeypair();

const buildingFunction = (bldr) =>
  bldr.lockAccountMasterKey().addAccountSigner(replaceWith, 1);
const transaction = txBuilder
  .sponsoring(sponsorKeyPair, buildingFunction)
  .build();
```

```dart
var replaceWith = account.createKeyPair();

var txBuilder = await stellar.transaction(sponsoredKeyPair);
var transaction = txBuilder
    .sponsoring(sponsorKeyPair,
        (builder) => builder.lockAccountMasterKey().addAccountSigner(replaceWith, 1))
    .build();
```

```swift
let replaceWith = account.createKeyPair()

let txBuilder = try await stellar.transaction(sourceAddress: sponsoredKeyPair)
let transaction = try txBuilder.sponsoring(
    sponsorAccount: sponsorKeyPair,
    buildingFunction:{ (builder) in builder
            .lockAccountMasterKey()
            .addAccountSigner(signerAddress: replaceWith, signerWeight: 1)
    }).build()
```

</CodeExample>

Luego, firma la transacción con ambas claves.

<CodeExample>

```kt
transaction.sign(sponsoredKeyPair).sign(sponsorKeyPair)
```

```typescript
sponsorKeyPair.sign(transaction);
sponsoredKeyPair.sign(transaction);
```

```dart
stellar.sign(transaction, sponsorKeyPair);
stellar.sign(transaction, sponsoredKeyPair);
```

```swift
stellar.sign(tx: transaction, keyPair: sponsorKeyPair)
stellar.sign(tx: transaction, keyPair: sponsoredKeyPair)
```

</CodeExample>

A continuación, crea un fee bump, apuntando a la transacción.

<CodeExample>

```kt
val feeBump = stellar.makeFeeBump(sponsorKeyPair, transaction)
feeBump.sign(sponsorKeyPair)
```

```typescript
const feeBump = stellar.makeFeeBump({
  feeAddress: sponsorKeyPair,
  transaction,
});
sponsorKeyPair.sign(feeBump);
```

```dart
var feeBump = stellar.makeFeeBump(sponsorKeyPair, transaction);
stellar.sign(feeBump, sponsorKeyPair);
```

```swift
let feeBump = try stellar.makeFeeBump(feeAddress: sponsorKeyPair,
                                      transaction: transaction)
stellar.sign(tx: transaction, keyPair: sponsorKeyPair)
```

</CodeExample>

Finalmente, presenta una transacción de fee-bump. Ejecutar esta transacción será completamente cubierto por el `sponsorKeyPair` y `sponsoredKeyPair` y puede que ni siquiera tenga fondos en XLM en su cuenta.

<CodeExample>

```kt
wallet.stellar().submitTransaction(feeBump)
```

```typescript
await wallet.stellar().submitTransaction(feeBump);
```

```dart
bool success = await stellar.submitTransaction(feeBump);
```

```swift
try await stellar.submitTransaction(signedFeeBumpTransaction: feeBump)
```

</CodeExample>

### Usando XDR para Enviar Datos de Transacción

Nota que una billetera puede no tener una clave de firma para `sponsorKeyPair`. En ese caso, es necesario convertir la transacción a XDR, enviarla al servidor, conteniendo `sponsorKey` y devolver la transacción firmada de nuevo a la billetera. Usamos el ejemplo anterior de la creación de cuenta patrocinada, pero esta vez con la clave patrocinadora desconocida para la billetera. El primer paso es definir la clave pública del keypair patrocinador:

<CodeExample>

```kt
val sponsorKeyPair = "SponsorAddress".toPublicKeyPair()
```

```typescript
const sponsorKeyPair = new PublicKeypair.fromPublicKey("GC5GD...");
```

```dart
var sponsorKeyPair = PublicKeyPair.fromAccountId("GC5GD...");
```

```swift
let sponsorKeyPair = try PublicKeyPair(accountId: "GC5GD...")
```

</CodeExample>

A continuación, crea una cuenta de la misma manera que antes y fír mala con `newKeyPair`. Esta vez, convierte la transacción a XDR:

<CodeExample>

```kt
suspend fun sponsorAccountCreation(): String {
  val newKeyPair = account.createKeyPair()

  return stellar
    .transaction(sponsorKeyPair)
    .sponsoring(sponsorKeyPair) { createAccount(newKeyPair) }
    .build()
    .sign(newKeyPair)
    .toEnvelopeXdrBase64()
}

```

```typescript
const txBuilder = await stellar.transaction({ sourceAddress: sponsorKeyPair });

const newKeyPair = account.createKeypair();

const transaction = txBuilder
  .sponsoring(sponsorKeyPair, (bldr) => bldr.createAccount(newKeyPair))
  .build();
const xdrString = newKeyPair.sign(transaction).toXDR();
```

```dart
var newKeyPair = account.createKeyPair();

var txBuilder = await stellar.transaction(sponsorKeyPair);
var transaction = txBuilder
    .sponsoring(
        sponsorKeyPair, (builder) => builder.createAccount(newKeyPair),
        sponsoredAccount: newKeyPair)
    .build();

stellar.sign(transaction, newKeyPair);

var xdrString = transaction.toEnvelopeXdrBase64();
```

```swift
let newKeyPair = account.createKeyPair()

let txBuilder = try await stellar.transaction(sourceAddress: sponsorKeyPair)
let transaction = try txBuilder.sponsoring(
            sponsorAccount: sponsorKeyPair,
            buildingFunction:{ (builder) in builder.createAccount(newAccount: newKeyPair)},
            sponsoredAccount: newKeyPair).build()

stellar.sign(tx: transaction, keyPair: newKeyPair)

let xdrString = transaction.toEnvelopeXdrBase64()
```

</CodeExample>

Ahora puede ser enviado al servidor. En el servidor, fír mala con una clave privada para la dirección del patrocinador:

<CodeExample>

```kt
// On the server
fun signTransaction(xdrString: String): String {
  val sponsorPrivateKey = SigningKeyPair.fromSecret("MySecret")

  val signedTransaction = stellar.decodeTransaction(xdrString).sign(sponsorPrivateKey)

  return signedTransaction.toEnvelopeXdrBase64()
}
```

```typescript
// On the server
const sponsorPrivateKey = SigningKeyPair.fromSecret("SD3LH4...");

const signedTransaction = sponsorPrivateKey.sign(
  stellar.decodeTransaction(xdrString),
);

return signedTransaction.toXDR();
```

```dart
String signTransaction(String xdrString) {
  var sponsorPrivateKey = SigningKeyPair.fromSecret("SD3LH4...");

  var transaction = stellar.decodeTransaction(xdrString);
  stellar.sign(transaction, sponsorPrivateKey);

  return transaction.toEnvelopeXdrBase64();
}
```

```swift
internal func signTransaction(xdr:String) throws -> String {
    let sponsorPrivateKey = try SigningKeyPair(secretKey: "SD3LH4...")

    let transactionEnum = stellar.decodeTransaction(xdr: xdr)
    switch transactionEnum {
    case .transaction(let tx):
        stellar.sign(tx: tx, keyPair: sponsorPrivateKey)
        return tx.toEnvelopeXdrBase64()
    case .feeBumpTransaction(let feeBumpTx):
        stellar.sign(feeBumpTx: feeBumpTx, keyPair: sponsorPrivateKey)
        return feeBumpTx.toEnvelopeXdrBase64()
    case .invalidXdrErr:
        throw ValidationError.invalidArgument(message: "invalid xdr")
    }
}
```

</CodeExample>

Cuando el cliente recibe la transacción completamente firmada, puede ser decodificada y enviada a la red Stellar:

<CodeExample>

```kt
suspend fun recoverSigned(xdrString: String) {
  val signedTransaction = stellar.decodeTransaction(xdrString)

  stellar.submitTransaction(signedTransaction)
}

```

```typescript
const signedTransaction = stellar.decodeTransaction(xdrString);

await wallet.stellar().submitTransaction(signedTransaction);
```

```dart
var signedTransaction = stellar.decodeTransaction(xdrStringFromBackend);

bool success = await stellar.submitTransaction(signedTransaction);
```

```swift
let signedTransactionEnum = stellar.decodeTransaction(xdr: xdrStringFromBackend)

switch signedTransactionEnum {
case .transaction(let tx):
    try await stellar.submitTransaction(signedTransaction: tx)
case .feeBumpTransaction(let feeBumpTx):
    try await stellar.submitTransaction(signedFeeBumpTransaction: feeBumpTx)
case .invalidXdrErr:
    throw ValidationError.invalidArgument(message: "invalid xdr")
}
```

</CodeExample>

## Enviar Transacción

:::info

Se recomienda encarecidamente utilizar las funciones de envío de transacciones del SDK de billetera en lugar de las alternativas de Horizon. El SDK de billetera maneja elegantemente las excepciones de tiempo de espera y fuera de tarifa.

:::

Finalmente, vamos a enviar una transacción firmada a la red Stellar. Nota que una transacción patrocinada debe ser firmada tanto por la cuenta como por el patrocinador.

La transacción se vuelve a presentar automáticamente en el error 504 de Horizon (tiempo de espera), que indica un aumento repentino en la actividad de la red.

<CodeExample>

```kotlin
suspend fun signAndSubmit() {
  val signedTxn = createAccount().sign(sourceAccountKeyPair)
  wallet.stellar().submitTransaction(signedTxn)
}
```

```typescript
const signedTxn = transaction.sign(sourceAccountKeyPair);
await wallet.stellar().submitTransaction(signedTxn);
```

```dart
stellar.sign(transaction, sourceAccountKeyPair);
bool success = await stellar.submitTransaction(transaction);
```

```swift
stellar.sign(tx: transaction, keyPair: sourceAccountKeyPair)
try await stellar.submitTransaction(signedTransaction: transaction)
```

</CodeExample>

Sin embargo, el método anterior no maneja elegantemente la fijación de precios de tarifas en aumento en la red. Si la tarifa requerida para que una transacción se incluya en el ledger se vuelve demasiado alta y la transacción caduca antes de entrar en el ledger, este método arrojará una excepción.

Así que, en su lugar, el enfoque alternativo es:

<CodeExample>

```kotlin
suspend fun submitWithFeeIncrease() {
  wallet.stellar().submitWithFeeIncrease(sourceAccountKeyPair, Duration.ofSeconds(30), 100u) {
    this.createAccount(destinationAccountKeyPair)
  }
}
```

```typescript
const buildingFunction = (builder) =>
  builder.transfer(kp.publicKey, new NativeAssetId(), "2");

await stellar.submitWithFeeIncrease({
  sourceAddress: kp,
  timeout: 30,
  baseFeeIncrease: 100,
  buildingFunction,
});
```

```dart
bool success = await stellar.submitWithFeeIncrease(
    sourceAddress: sourceAccountKeyPair,
    timeout: const Duration(seconds: 30),
    baseFeeIncrease: 100,
    maxBaseFee: 2000,
    buildingFunction: (builder) =>
    builder.transfer(destinationAccountKeyPair.address, NativeAssetId(), "10.0"));
```

```swift
try await stellar.submitWithFeeIncrease(
  sourceAddress: sourceAccountKeyPair,
  timeout: 30,
  baseFeeIncrease: 100,
  maxBaseFee: 2000,
  buildingFunction: {
      (builder) in try! builder
          .transfer(destinationAddress: destinationAccountKeyPair.address,
                    assetId: NativeAssetId(),
                    amount: 10.0)
  })
```

</CodeExample>

Esto creará y firmará la transacción que se originó desde el `sourceAccountKeyPair`. Cada 30 segundos, esta función volverá a construir esta transacción con una nueva tarifa (aumentada en 100 stroops), repitiendo la firma y la presentación. Una vez que la transacción sea exitosa, la función devolverá el cuerpo de la transacción. Nota que cualquier otro error finalizará el ciclo de reintentos y se lanzará una excepción.

## Accediendo al SDK de Horizon

Es muy sencillo utilizar el SDK de Horizon conectándose a la misma instancia de Horizon que una clase `Wallet`. Para hacerlo, simplemente llama a:

<CodeExample>

```kotlin
val server = wallet.stellar().server
```

```typescript
const server = wallet.stellar().server;
```

```dart
var server = wallet.stellar().server;
```

```swift
let server = wallet.stellar.server
```

</CodeExample>

Y puedes trabajar con la instancia del servidor Horizon:

<CodeExample>

```kt
val stellarTransaction = server.transactions().transaction("transaction_id")
```

```typescript
const stellarTransaction = server
  .transactions()
  .forAccount("account_id")
  .call();
```

```dart
var transactions = await server.transactions.forAccount("accountId").execute();
```

```swift
let transactionsEnum = await server.transactions.getTransactions(forAccount: "accountId")
switch transactionsEnum {
case .success(let page):
    let transactions = page.records
case .failure(let error):
    throw error
}
```

</CodeExample>

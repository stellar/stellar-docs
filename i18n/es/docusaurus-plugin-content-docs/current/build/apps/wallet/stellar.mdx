---
title: Red estelar
sidebar_position: 30
---

import { LanguageSpecific } from "@site/src/components/LanguageSpecific";
import { WalletCodeExample as CodeExample } from "@site/src/components/WalletCodeExample";
import Header from "./component/header.mdx";
import CreateKeyPairInfo from "./component/ts/createKeypairInfo.mdx";

<Header />

En la sección anterior aprendimos cómo crear una cartera y un objeto `Stellar` que proporciona una conexión con Horizon. En esta sección, analizaremos los usos de esta clase.

## Cuentas

La entidad más básica de la red Stellar es una cuenta. Veamos el Servicio de Cuentas que proporciona la capacidad de trabajar con cuentas:

<CodeExample>

```kt
val account = wallet.stellar().account()
```

```typescript
let cuenta = wal.stellar().account();
```

```dart
var account = wallet.stellar().account();
```

</CodeExample>

Ahora podemos crear un par de claves:

<CodeExample>

```kt
val accountKeyPair = account.createKeyPair()
```

```typescript
let accountKeyPair = account.createKeypair();
```

```dart
var accountKeyPair = account.createKeyPair();
```

</CodeExample>

<LanguageSpecific ts={<CreateKeyPairInfo />} />

## Construir transacción

El generador de transacciones le permite crear varias transacciones que pueden ser firmadas y enviadas a la red Stellar. Algunas transacciones pueden ser patrocinadas.

### Creando transacciones básicas

Primero, veamos cómo construir transacciones básicas.

#### Crear cuenta

La transacción de crear cuenta activa/crea una cuenta con un saldo inicial de XLM (1 XLM por defecto).

<CodeExample>

```kotlin
suspender divertido createAccount(): Transacción {
  return stellar.transaction(sourceAccountKeyPair).createAccount(destinationAccountKeyPair).build()
}
```

```typescript
const txBuilder = await stellar.transaction({
  sourceAddress: sourceAccountKeyPair,
});
const tx = txBuilder.createAccount(destinationAccountKeyPair).build();
```

```dart
var txBuilder = await stellar.transaction(sourceAccountKeyPair);
var tx = txBuilder.createAccount(destinationAccountKeyPair).build();
```

</CodeExample>

#### Modificar cuenta

Puede bloquear la clave maestra de la cuenta ajustando su peso a 0. Ten cuidado al bloquear la clave maestra de la cuenta. Asegúrese de que ha establecido los firmantes y pesos correctos. De lo contrario, se bloqueará la cuenta de forma irreversible.

<CodeExample>

```kotlin
suspender lockMasterKey(): Transacción {
  return stellar.transaction(sourceAccountKeyPair).lockAccountMasterKey().build()
}
```

```typescript
const txBuilder = await stellar.transaction({
  sourceAddress: sourceAccountKeyPair,
});

const tx = txBuilder.lockAccountMasterKey().build();
```

```dart
var txBuilder = await stellar.transaction(sourceAccountKeyPair);
var tx = txBuilder.lockAccountMasterKey().build();
```

</CodeExample>

Añadir un nuevo firmante a la cuenta. Tenga cuidado al añadir nuevos firmantes y asegúrese de establecer el peso correcto del firmante. De lo contrario, se bloqueará la cuenta de forma irreversible.

<CodeExample>

```kotlin
val newSignerKeyPair = account.createKeyPair()

suspender fun addSigner(): Transacción {
  return stellar.transaction(sourceAccountKeyPair).addAccountSigner(newSignerKeyPair, 10).build()
}
```

```typescript
const newSignerKeyPair = account.createKeypair();

const tx = txBuilder.addAccountSigner(newSignerKeyPair, 10).build();
```

```dart
var newSignerKeyPair = account.createKeyPair();

var txBuilder = await stellar.transaction(sourceAccountKeyPair);
var tx = txBuilder.addAccountSigner(newSignerKeyPair, 10).build();
```

</CodeExample>

Eliminar un firmante de la cuenta.

<CodeExample>

```kotlin
suspender fun removeSigner(): Transacción {
  return stellar.transaction(sourceAccountKeyPair).removeAccountSigner(newSignerKeyPair).build()
}
```

```typescript
const tx = txBuilder.removeAccountSigner(newSignerKeyPair).build();
```

```dart
var txBuilder = await stellar.transaction(sourceAccountKeyPair);
var tx = txBuilder.removeAccountSigner(newSignerKeyPair).build();
```

</CodeExample>

Modificar los umbrales de la cuenta (útil cuando se asignan varios firmantes a la cuenta). Esto le permite restringir el acceso a ciertas operaciones cuando no se alcanza el límite.

<CodeExample>

```kotlin
suspender divertido setThreshold(): Transacción {
  return stellar.transaction(sourceAccountKeyPair).setThreshold(low = 1, medium = 10, high = 30).build()
}
```

```typescript
const tx = txBuilder.setThreshold({ low: 1, medium: 10, high: 30 }).build();
```

```dart
var txBuilder = await stellar.transaction(sourceAccountKeyPair);
var tx = txBuilder.setThreshold(low: 1, medium: 10, high: 20).build();
```

</CodeExample>

#### Modificar Activos (Trustlines)

Añadir un activo (línea de confianza) a la cuenta. Esto permite a la cuenta recibir transferencias del activo.

<CodeExample>

```kotlin
val asset = IssuedAssetId("USDC", "GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5")

suspender addAsset(): Transacción {
  return stellar.transaction(sourceAccountKeyPair).addAssetSupport(asset).build()
}
```

```typescript
const asset = new IssuedAssetId(
  "USDC",
  "GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5",
);

const tx = txBuilder.addAssetSupport(asset).build();
```

```dart
var asset = IssuedAssetId(
        code: "USDC",
        issuer: "GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5");

var txBuilder = await stellar.transaction(sourceAccountKeyPair);
var tx = txBuilder.addAssetSupport(asset).build();
```

</CodeExample>

Eliminar un activo de la cuenta (el saldo del activo debe ser 0).

<CodeExample>

```kotlin
suspender fun removeAsset(): Transacción {
  return stellar.transaction(sourceAccountKeyPair).removeAssetSupport(asset).build()
}
```

```typescript
const tx = txBuilder.removeAssetSupport(asset).build();
```

```dart
var txBuilder = await stellar.transaction(sourceAccountKeyPair);
var tx = txBuilder.removeAssetSupport(asset).build();
```

</CodeExample>

### Construyendo transacciones avanzadas

En algunos casos, una clave privada puede no ser conocida antes de formar una transacción. Por ejemplo, una nueva cuenta debe ser financiada para existir y la cartera puede no tener la clave para la cuenta, así que puede solicitar que la transacción de creación de cuenta sea patrocinada por un tercero.

<CodeExample>

```kt
// Clave de terceros que patrocinará la creación de nueva cuenta
val externalKeyPair = "MySponsorAddress".toPublicKeyPair()
val newKeyPair = account.createKeyPair()
```

```typescript
// Clave de terceros que patrocinará la creación de nueva cuenta
const externalKeyPair = new PublicKeypair.fromPublicKey("GC5GD...");
const newKeyPair = account.createKeypair();
```

```dart
// Clave de terceros que patrocinará la creación de nueva cuenta
var externalKeyPair = PublicKeyPair.fromAccountId("GC5GD...");
var newKeyPair = account.createKeyPair();
```

</CodeExample>

Primero, la cuenta debe ser creada.

<CodeExample>

```kotlin
suspender fun makeCreateTx(): Transacción {
  return stellar.transaction(externalKeyPair).createAccount(newKeyPair).build()
}
```

```typescript
const createTxn = txBuilder.createAccount(newKeyPair).build();
```

```dart
var txBuilder = await stellar.transaction(externalKeyPair);
var createTxn = txBuilder.createAccount(newKeyPair).build();
```

</CodeExample>

Esta transacción debe ser enviada al firmante externo (titular de `externalKeyPair`) para ser firmada.

<CodeExample>

```kt
suspender la diversión remoteSignTransaction(transaction: Transaction: Transaction) {
  val xdrString = transacción. oEnvelopeXdrBase64()
  // Enviar transacción codificada xdr a su servidor backend para firmar
  val xdrStringFromBackend = sendTransactionToBackend(xdrString)

  // Decodifica xdr para obtener la transacción firmada
  val signedTransaction = stellar. ecodeTransaction(xdrStringFromBackend)
}
```

```typescript
const xdrString = createTxn. oXDR();
// Envía una transacción codificada en xdr a tu servidor backend para firmar
const xdrStringFromBackend = await sendTransactionToBackend(xdrString);

// Decodifica xdr para obtener la transacción firmada
const signedTransaction = stellar. ecodeTransaction(xdrStringFromBackend);
```

```dart
var xdrString = createTxn. oEnvelopeXdrBase64();

// Envía una transacción codificada en xdr a tu servidor backend para firmar
var xdrStringFromBackend = await sendTransactionToBackend(xdrString);

// Decodifica xdr para obtener la transacción firmada
var signedTransaction = stellar. ecodeTransaction(xdrStringFromBackend);
```

</CodeExample>

:::note

Puedes leer más sobre cómo pasar la transacción XDR al servidor en el [capítulo de abajo](#using-xdr-to-send-transaction-data).

:::

La cartera puede enviar la transacción firmada.

<CodeExample>

```kt
suspender el envío divertido CreateTx(signedCreateTx: Transacción) {
  wallet.stellar().submitTransaction(signedCreateTx)
}

```

```typescript
esperar wallet.stellar().submitTransaction(signedTransaction);
```

```dart
bool success = await stellar.submitTransaction(signedTransaction);
```

</CodeExample>

Ahora, después de crear la cuenta, puede realizar operaciones. Por ejemplo, podemos desactivar el par de claves maestro y reemplazarlo con uno nuevo (llamémoslo el par de teclas del dispositivo) atómicamente en una transacción:

<CodeExample>

```kotlin
suspender adDeviceKeyPair() {
  val deviceKeyPair = cuenta. reateKeyPair()

  val modifyAccountTransaction =
    estelar
      . ransaction(newKeyPair)
      . ddAccountSigner(
        deviceKeyPair,
        firmante Peso = 1,
      )
      . ockAccountMasterKey()
      . uild()
      .sign(newKeyPair)

  wallet.stellar().submitTransaction(modifyAccountTransaction)
}
```

```typescript
const deviceKeyPair = account.createKeypair();

const txBuilder = await stellar.transaction({ sourceAddress: newKeyPair });
const modifyAccountTransaction = txBuilder
  . ddAccountSigner(deviceKeyPair, 1)
  .lockAccountMasterKey()
  .build();
newKeyPair.sign(modifyAccountTransaction);

await wallet.stellar().submitTransaction(modifyAccountTransaction);
```

```dart
var deviceKeyPair = account.createKeyPair();

var txBuilder = await stellar. ransaction(newKeyPair);
var modifyAccountTransaction = txBuilder
    .addAccountSigner(deviceKeyPair, 1)
    . ockAccountMasterKey()
    .build();

stellar.sign(modifyAccountTransaction, newKeyPair);

bool success = await stellar.submitTransaction(modifyAccountTransaction);
```

</CodeExample>

### Patrocinando transacciones

#### Operaciones de patrocinador

Algunas operaciones, que modifican las reservas de la cuenta pueden ser [sponsored](../../learn/encyclopedia/transactions-specialized/sponsored-reserves.mdx#sponsored-reserves-operations). Para las operaciones patrocinadas, la cuenta de patrocinio pagará las reservas en lugar de la cuenta patrocinada. Esto le permite hacer algunas operaciones, incluso si la cuenta no tiene fondos suficientes para realizar tales operaciones. Para patrocinar una transacción, <LanguageSpecific kt={<span>simplemente inicia un bloque <code>patrocinando</code> :</span>} ts={<span>simplemente crea una función de construcción (describiendo qué operaciones deben ser patrocinadas) y pasarla al método <code>sponsoring</code> :</span>}/>

<CodeExample>

```kotlin
suspender divertido sponsorOperation() {
  val transaction =
    stellar
      .transaction(sponsoredKeyPair)
      .sponsoring(sponsorKeyPair) { addAssetSupport(asset) }
      .build()

  transaction.sign(sponsorKeyPair).sign(sponsoredKeyPair)
}
```

```typescript
const txBuilder = await stellar.transaction({
  sourceAddress: sponsoredKeyPair,
});

const buildingFunction = (bldr) => bldr. ddAssetSupport(asset);
const transaction = txBuilder
  . ponsoring(sponsorKeyPair, buildingFunction)
  .build();

sponsoredKeyPair.sign(transaction);
sponsorKeyPair.sign(transaction);
```

```dart
var txBuilder = await stellar.transaction(sponsoredKeyPair);
var transaction = txBuilder
    .sponsoring(sponsorKeyPair, (builder) => builder.addAssetSupport(asset))
    .build();

stellar.sign(transacción, sponsorKeyPair);
stellar.sign(transacción, sponsoredKeyPair);
```

</CodeExample>

:::info

Only some operations can be sponsored, and a sponsoring <LanguageSpecific kt={<span>block</span>} ts={<span>builder</span>} /> has a slightly different set of functions available compared to the regular `TransactionBuilder`. Tenga en cuenta que una transacción debe ser firmada tanto por la cuenta de patrocinador (`sponsoringKeyPair`) como por la cuenta patrocinada (`sponsoredKeyPair`).

:::

#### Patrocinando la creación de cuenta

Una de las cosas que se pueden hacer mediante el patrocinio es crear una cuenta con un saldo inicial de 0. La creación de esta cuenta se puede crear simplemente escribiendo:

<CodeExample>

```kt
suspender divertido sponsorAccountCreation() {
  val newKeyPair = cuenta. reateKeyPair()

  val transaction =
    estelar
      . ransaction(sponsorKeyPair)
      . ponsoring(sponsorKeyPair, sponsoredAccount = newKeyPair) { createAccount(newKeyPair) }
      .build()

  transaction.sign(sponsorKeyPair).sign(newKeyPair)
}
```

```typescript
const txBuilder = await stellar.transaction({ sourceAddress: sponsorKeyPair });

const newKeyPair = account.createKeypair();

const buildingFunction = (bldr) => bldr. reateAccount(newKeyPair);
const transaction = txBuilder
  .sponsoring(sponsorKeyPair, buildingFunction, newKeyPair)
  .build();

newKeyPair.sign(transaction);
sponsorKeyPair.sign(transaction);
```

```dart
var newKeyPair = account.createKeyPair();

var txBuilder = await stellar.transaction(sponsorKeyPair);
var transaction = txBuilder
    . ponsoring(sponsorKeyPair, sponsoredAccount: newKeyPair,
        (constructor) => builder.createAccount(newKeyPair))
    . uild();

stellar.sign(transacción, sponsorKeyPair);
stellar.sign(transacción, newKeyPair);
```

</CodeExample>

Tenga en cuenta cómo en el primer ejemplo la cuenta de origen de la transacción se establece en `sponsoredKeyPair`. Debido a esto, no tuvimos que pasar un valor de cuenta apaderado al `patrocinador` <LanguageSpecific kt={<span>bloque</span>} ts={<span>método</span>} />. Ya que cuando se omite, la cuenta patrocinada por defecto es la cuenta de origen de la transacción (`sponsoredKeyPair`).

Sin embargo, esta vez, la cuenta patrocinada (recién creada `newKeyPair`) es diferente de la cuenta fuente de la transacción. Por lo tanto, es necesario especificarlo. De lo contrario, la transacción contendrá una operación mal formada. Como antes, la transacción debe estar firmada por ambas claves.

#### Patrocinando la creación y modificación de la cuenta

Si quieres crear una cuenta y modificarla en una transacción, es posible hacerlo pasando un argumento opcional `sponsoredAccount` al bloque <LanguageSpecific kt={<span> patrocinado</span>} ts={<span>método sponsoring</span>} /> (`newKeyPair` abajo). Si este argumento está presente, todas las operaciones dentro del bloque patrocinado serán originadas por este `sponsoredAccount`. (Excepto la creación de una cuenta, que siempre es originada por el patrocinador).

<CodeExample>

```kotlin
suspender divertido sponsorAccountCreationAndModification() {
  val newKeyPair = account.createKeyPair()
  val replaceWith = cuenta. reateKeyPair()

  val transaction =
    estelar
        . ransaction(sponsorKeyPair)
        . patrocinador(sponsorKeyPair, newKeyPair) {
          createAccount(newKeyPair)
          // cuenta fuente para las operaciones a continuación será newKeyPair
          addAccountSigner(replaceWith, 1)
          lockAccountMasterKey()
        }
        . uild()

  transaction.sign(sponsorKeyPair).sign(newKeyPair)
}
```

```typescript
const txBuilder = await stellar.transaction({ sourceAddress: sponsorKeyPair });

const newKeyPair = account.createKeypair();
const replaceWith = account. reateKeypair();

const buildingFunction = (bldr) =>
  bldr
    . reateAccount(newKeyPair)
    // cuenta fuente para las operaciones a continuación será newKeyPair
    . ddAccountSigner(replaceWith, 1)
    .lockAccountMasterKey();

const transaction = txBuilder
  . ponsoring(sponsorKeyPair, buildingFunction, newKeyPair)
  .build();

newKeyPair.sign(transaction);
sponsorKeyPair.sign(transaction);
```

```dart
var newKeyPair = account.createKeyPair();
var replaceWith = account.createKeyPair();

var txBuilder = await stellar. ransaction(sponsorKeyPair);
var transaction = txBuilder
    . patrocinando(
    sponsorKeyPair,
    cuenta patrocinada: newKeyPair,
        (constructor) => constructor
        . reateAccount(newKeyPair)
        . ddAccountSigner(replaceWith, 1)
        .lockAccountMasterKey())
    . uild();

stellar.sign(transaction, sponsorKeyPair);
stellar.sign(transaction, newKeyPair);
```

</CodeExample>

### Transacción de tasa Bump

Si desea modificar una cuenta recién creada con un saldo 0, también es posible hacerlo a través de `FeeBump`. Se puede combinar con un patrocinador <LanguageSpecific kt={<span>bloque</span>} ts={<span>método</span>} /> para lograr el mismo resultado que en el ejemplo anterior. Sin embargo, con `FeeBump` también es posible añadir más operaciones (que no requieren patrocinio), como una transferencia.

Primero, vamos a crear una transacción que reemplazará la clave maestra de una cuenta con un nuevo par de claves.

<CodeExample>

```kt
val replaceWith = account.createKeyPair()

val transaction =
  stellar
    .transaction(sponsoredKeyPair)
    . ponsoring(sponsorKeyPair) {
      lockAccountMasterKey()
      addAccountSigner(replaceWith, signerWeight = 1)
    }
    . uild()

```

```typescript
const txBuilder = await stellar.transaction({
  sourceAddress: sponsoredKeyPair,
});

const replaceWith = account. reateKeypair();

const buildingFunction = (bldr) =>
  bldr. ockAccountMasterKey().addAccountSigner(replaceWith, 1);
const transaction = txBuilder
  .sponsoring(sponsorKeyPair, buildingFunction)
  .build();
```

```dart
var replaceWith = account.createKeyPair();

var txBuilder = await stellar.transaction(sponsoredKeyPair);
var transaction = txBuilder
    .sponsoring(sponsorKeyPair,
        (constructor) => builder.lockAccountMasterKey().addAccountSigner(replaceWith, 1))
    .build();
```

</CodeExample>

En segundo lugar, firmar transacción con ambas claves.

<CodeExample>

```kt
transaction.sign(sponsoredKeyPair).sign(sponsorKeyPair)
```

```typescript
sponsorKeyPair.sign(transaction);
sponsoredKeyPair.sign(transaction);
```

```dart
stellar.sign(transaction, sponsorKeyPair);
stellar.sign(transaction, sponsoredKeyPair);
```

</CodeExample>

A continuación, cree un bump, apuntando a la transacción.

<CodeExample>

```kt
val feeBump = stellar.makeFeeeBump(sponsorKeyPair, transacción)
feeBump.sign(sponsorKeyPair)
```

```typescript
const feeBump = stellar.makeFeeeBump({
  feeAddress: sponsorKeyPair,
  transaction,
});
sponsorKeyPair.sign(feeBump);
```

```dart
var feeBump = stellar.makeFeeeBump(sponsorKeyPair, transacción);
stellar.sign(feeBump, sponsorKeyPair);
```

</CodeExample>

Por último, presentar una transacción de cobro de tasas. Ejecutar esta transacción estará completamente cubierto por los `sponsorKeyPair` y `sponsoredKeyPair` y puede que ni siquiera tenga fondos XLM en su cuenta.

<CodeExample>

```kt
wallet.stellar().submitTransaction(feeBump)
```

```typescript
esperar wallet.stellar().submitTransaction(feeBump);
```

```dart
bool success = await stellar.submitTransaction(feeBump);
```

</CodeExample>

### Usando XDR para enviar datos de transacción

Tenga en cuenta que una cartera puede no tener una clave de firma para `sponsorKeyPair`. En ese caso, es necesario convertir la transacción a XDR, enviarla al servidor, conteniendo `sponsorKey` y devolver la transacción firmada de vuelta a la cartera. Usemos el ejemplo anterior de patrocinio de la creación de la cuenta, pero esta vez con la clave de patrocinador siendo desconocida para la cartera. El primer paso es definir la clave pública del par de claves del patrocinador:

<CodeExample>

```kt
val sponsorKeyPair = "SponsorAddress".toPublicKeyPair()
```

```typescript
const sponsorKeyPair = new PublicKeypair.fromPublicKey("GC5GD...");
```

```dart
var sponsorKeyPair = PublicKeyPair.fromAccountId("GC5GD...");
```

</CodeExample>

A continuación, cree una cuenta de la misma manera que antes y firme con `newKeyPair`. Esta vez, convertir la transacción a XDR:

<CodeExample>

```kt
suspender divertido sponsorAccountCreation(): String {
  val newKeyPair = cuenta. reateKeyPair()

  return stellar
    .transaction(sponsorKeyPair)
    . ponsoring(sponsorKeyPair) { createAccount(newKeyPair) }
    .build()
    . ign(newKeyPair)
    .toEnvelopeXdrBase64()
}

```

```typescript
const txBuilder = await stellar.transaction({ sourceAddress: sponsorKeyPair });

const newKeyPair = account.createKeypair();

const transaction = txBuilder
  . ponsoring(sponsorKeyPair, (bldr) => bldr.createAccount(newKeyPair))
  .build();
const xdrString = newKeyPair.sign(transaction).toXDR();
```

```dart
var newKeyPair = account.createKeyPair();

var txBuilder = await stellar. ransaction(sponsorKeyPair);
var transaction = txBuilder
    .sponsoring(
        sponsorKeyPair, (constructor) => constructor. reateAccount(newKeyPair),
        sponsoredAccount: newKeyPair)
    .build();

estelar. ign(transacción, newKeyPair);

var xdrString = transaction.toEnvelopeXdrBase64();
```

</CodeExample>

Ahora se puede enviar al servidor. En el servidor, firme con una clave privada para la dirección del patrocinador:

<CodeExample>

```kt
// En el servidor
divertido signTransaction(xdrString: String): String {
  val sponsorPrivateKey = SigningKeyPair.from)[video] ("MyResour")

  val signedTransaction = stellar.decodeTransaction(xdrString).sign(sponsorPrivateKey)

  return signedTransaction.toEnvelopeXdrBase64()
}
```

```typescript
// En el servidor
const sponsorPrivateKey = SigningKeyPair.from)[video] ("SD3LH4...");

const signedTransaction = sponsorPrivateKey.sign(
  stellar.decodeTransaction(xdrString),
);

return signedTransaction.toXDR();
```

```dart
Cadena signTransaction(String xdrString) {
  var sponsorPrivateKey = SigningKeyPair.from)[video] ("SD3LH4...");

  var transaction = stellar.decodeTransaction(xdrString);
  stellar.sign(transaction, sponsorPrivateKey);

  return transaction.toEnvelopeXdrBase64();
}
```

</CodeExample>

Cuando el cliente recibe la transacción completamente firmada, puede ser decodificada y enviada a la red Stellar:

<CodeExample>

```kt
suspender recoverSigned(xdrString: String) {
  val signedTransaction = stellar.decodeTransaction(xdrString)

  stellar.submitTransaction(signedTransaction)
}

```

```typescript
const signedTransaction = stellar.decodeTransaction(xdrString);

await wallet.stellar().submitTransaction(signedTransaction);
```

```dart
var signedTransaction = stellar.decodeTransaction(xdrStringFromBackend);

bool success = await stellar.submitTransaction(signedTransaction);
```

</CodeExample>

## Enviar transacción

:::info

Se recomienda encarecidamente usar las funciones de envío de transacciones SDK en lugar de alternativas Horizon. El monedero SDK maneja con elegancia las excepciones de tiempo de espera y sin cargos.

:::

Finalmente, enviemos una transacción firmada a la red Stellar. Tenga en cuenta que una transacción patrocinada debe ser firmada tanto por la cuenta como por el patrocinador.

La transacción se reenvía automáticamente en el error Horizon 504 (timeout), lo que indica un aumento repentino de la actividad de red.

<CodeExample>

```kotlin
suspender divertido signAndSubmit() {
  val signedTxn = createAccount().sign(sourceAccountKeyPair)
  wallet.stellar().submitTransaction(signedTxn)
}
```

```typescript
const signedTxn = transaction.sign(sourceAccountKeyPair);
await wallet.stellar().submitTransaction(signedTxn);
```

```dart
stellar.sign(transaction, sourceAccountKeyPair);
bool success = await stellar.submitTransaction(transaction);
```

</CodeExample>

Sin embargo, el método anterior no maneja los precios de sobretensiones en la red con gracia. Si la comisión requerida para que una transacción sea incluida en el libro de valores se vuelve demasiado alta y la transacción expira antes de convertirla en el mayor, este método lanzará una excepción.

Por lo tanto, el enfoque alternativo es:

<CodeExample>

```kotlin
suspender el envío divertido WithFeeIncrease() {
  wallet.stellar().submitWithFeeIncrease(sourceAccountKeyPair, Duration.ofSegundds(30), 100u) {
    this.createAccount(destinationAccountKeyPair)
  }
}
```

```typescript
const buildingFunction = (builder) =>
  builder.transfer(kp.publicKey, new NativeAssetId(), "2");

await stellar. ubmitWithFeeIncrease({
  sourceAddress: kp,
  timeout: 30,
  baseFeeeIncrease: 100,
  buildingFunction,
});
```

```dart
éxito del bool = espera estelar. ubmitWithFeeIncrease(
    sourceAddress: sourceAccountKeyPair,
    timeout: const Duration(seconds: 30),
    baseFeeeIncrease: 100,
    maxBaseFee: 2000,
    función de construcción: (constructor) =>
    constructor. ransfer(destinationAccountKeyPair.address, NativeAssetId(), "10.0"));
```

</CodeExample>

Esto creará y firmará la transacción que se originó a partir del `sourceAccountKeyPair`. Cada 30 segundos esta función reconstruirá esta transacción con una nueva comisión (incrementada en 100 tramos), repitiendo la firma y el envío. Una vez que la transacción sea exitosa, la función devolverá el cuerpo de la transacción. Tenga en cuenta que cualquier otro error terminará el ciclo de reintento y se lanzará una excepción.

## Accediendo a SDK Horizon

Es muy sencillo usar el Horizon SDK conectándose a la misma instancia Horizon que una clase `Wallet`. Para hacerlo, simplemente llama:

<CodeExample>

```kotlin
servidor val = wallet.stellar().server
```

```typescript
const server = wallet.stellar().server;
```

```dart
var server = wallet.stellar().server;
```

</CodeExample>

Y puede trabajar con la instancia de Horizon Servidor:

<CodeExample>

```kt
val stellarTransaction = server.transactions().transaction("transaction_id")
```

```typescript
const stellarTransaction = server
  .transactions()
  .forAccount("account_id")
  .call();
```

```dart
var transactions = await server.transactions.forAccount("accountId").execute();
```

</CodeExample>

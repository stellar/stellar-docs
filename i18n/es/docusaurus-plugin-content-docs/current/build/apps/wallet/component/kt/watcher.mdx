import { CodeExample } from "@site/src/components/CodeExample";

A continuación, vamos a obtener el canal proporcionado por `WatcherResult` para recibir eventos.

<CodeExample>

```kt
hacer {
  val event = result.channel. eceive()
  cuando (event) {
    es StatusChange ->
      println("Estado cambiado a ${event.status}. Transacción: ${event.transaction}")
    es ExceptionHandlerExit -> println("Exception handler exited the job")
    is ChannelClosed -> println("Channel closed. Trabajo realizado")
  }
} mientras (evento !is ChannelClosed)
```

</CodeExample>

Este ejemplo de código consumirá todos los eventos provenientes del canal hasta que se cierre. Hay tres tipos de eventos:

- `StatusChange`: indica que el estado de la transacción ha cambiado.
- `ExceptionHandlerExit`: indica que el gestor de excepciones ha salido del bucle de procesamiento. Con el manejador de reintento predeterminado ocurre cuando las reintentos están agotadas.
- `ChannelClosed`: indica que el canal está cerrado y no se emitirán más eventos. Este evento siempre se disparará. Si `ExceptionHandlerExit` sucedió, el canal se cerrará justo después. De lo contrario, (bajo condiciones normales) se detendrá cuando todas las transacciones lleguen al estado de la terminal.

:::info

Los eventos se almacenan en el canal hasta que son recibidos, y llamar al método `receive()` bloqueará el canal hasta que se reciba un mensaje. Puedes leer más sobre cómo funcionan los canales en la [documentación del canal](https://kotlinlang.org/docs/coroutines-and-channels.html#channels).

:::

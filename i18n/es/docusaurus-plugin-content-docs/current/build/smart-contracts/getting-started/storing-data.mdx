---
sidebar_position: 30
title: 3. Almacenando datos
description: Escribe un contrato inteligente que almacene y recupere datos.
---

<head>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="Escribe un contrato inteligente que almacene y recupere datos."
  />
  <meta
    property="og:description"
    content="Escribe un contrato simple que almacene y recupere los datos, reorganizar sus proyectos como un proyecto multicontrato utilizando espacios de trabajo de Cargo y aprender sobre diferentes tipos de almacenamiento."
  />
</head>

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

Ahora que hemos construido un contrato básico de ejemplo Hola Mundo, vamos a escribir un contrato simple que almacena y recupera datos. Esto le ayudará a ver los conceptos básicos del sistema de almacenamiento de Soroban.

Esto va a seguir junto con el [ejemplo de incremento](https://github.com/stellar/soroban-examples/tree/v20.2.0/increment), que tiene una única función que incrementa un contador interno y devuelve el valor. Si quieres ver un ejemplo funcional, [pruébalo en GitPod](https://gitpod.io/#https://github.com/stellar/soroban-examples/tree/v20.2.0).

Este tutorial asume que ya has completado los pasos anteriores en Getting Started: [Setup](./setup.mdx), [Hola Mundo](./hello-world.mdx), y [Desplegar a Testnet](./deploy-to-testnet.mdx).

## Añadir el contrato de incremento

El comando `stellar contract init` nos permite inicializar un nuevo proyecto con cualquiera de los contratos de ejemplo del [soroban-examples](https://github. om/stellar/soroban-examples) repositorio, usando la bandera `--with-example` (o `-w`).

No sobrescribirá los archivos existentes, así que también podemos usar este comando para añadir un nuevo contrato a un proyecto existente. Ejecuta el comando de nuevo con la bandera `--with-example` para agregar un contrato `increment` a nuestro proyecto. Desde dentro de nuestro directorio `soroban-hola-mundo`, corre:

```sh
stellar contrato init ./ --with-example increment
```

Esto creará un nuevo directorio `contracts/increment` con los siguientes archivos:

```
└── contracts
    ├── increment
        ├── Cargo.lock
        ├── Cargo.toml
        └── src
            ├── lib.rs
            └── test.rs
```

El siguiente código fue añadido a `contracts/increment/src/lib.rs`. Lo comentaremos con más detalle a continuación.

```rust
#![no_std]
use soroban_sdk::{contract, contractimpl, log, symbol_short, Env, Symbol};

const COUNTER: ¡Símbolo = symbol_short! "COUNTER");

#[contract]
pub struct IncrementorContract;

#[contractimpl]
impl IncrementorContract {
    /// Incrementar un contador interno; devolver el nuevo valor.
    pub fn increment(env: Env) -> u32 {
        let mut count: u32 = env. torage().instance().get(&COUNTER). nwrap_or(0);

        count += 1;

        log! &env, "count: {}", count);

        env. torage().instance().set(&COUNTER, &count);

        env.storage().instance(). xtend_ttl(100, 100);

        count
    }
}

mod test;
```

### Importaciones

Este contrato comienza de forma similar a nuestro contrato Hello World, con una anotación para excluir la biblioteca estándar de Rust, e importaciones de los tipos y macros que necesitamos de la caja `soroban-sdk`.

```rust title="contracts/increment/src/lib.rs"
#![no_std]
use soroban_sdk::{contract, contractimpl, log, symbol_short, Env, Symbol};
```

### Llave de Datos del Contrato

```rust
const COUNTER: Symbol = symbol_short!("COUNTER");
```

Los datos del contrato se asocian con una clave, que se puede utilizar en un momento posterior para buscar el valor.

`Symbol` es un tipo de cadena corto (hasta 32 caracteres) con espacio limitado (solo se permiten caracteres `a-zA-z0-9_`). Identificadores como nombres de funciones del contrato y claves de datos del contrato están representados por `Symbol`s.

La macro `symbol_short!()` es una manera conveniente de pre-calcular símbolos cortos de hasta 9 caracteres de longitud en tiempo de compilación usando `Symbol::short`. Genera una constante de compilación de tiempo que se adhiere al conjunto de caracteres válido (a-zA-Z), números (0-9), y guiones bajos (\_). Si un símbolo excede el límite de 9 caracteres, `Symbol::new` debe utilizarse para crear símbolos en tiempo de ejecución.

### Acceso a datos de contrato

```rust
let contador de mut: u32 = env
    .storage()
    .instance()
    .get(&COUNTER)
    .unwrap_or(0); // Si no se establece ningún valor, asuma 0.
```

La función `Env.storage()` se utiliza para acceder y actualizar los datos del contrato. El contrato de ejecución es el único que puede consultar o modificar los datos del contrato que ha almacenado. Los datos almacenados son visibles en el libro de contabilidad en cualquier lugar donde el libro de contabilidad sea visible, pero los contratos que se ejecuten dentro del entorno Soroban están restringidos a sus propios datos.

La función `get()` obtiene el valor actual asociado con la clave del contador.

Si no hay ningún valor actualmente almacenado, el valor dado a `unwrap_or(...)` se devuelve en su lugar.

Los valores almacenados como datos contractuales y recuperados se transmiten desde [el entorno](../../../learn/encyclopedia/contract-development/environment-concepts.mdx) y se expanden al tipo especificado. En este caso un `u32`. Si el valor puede ser ampliado, el tipo devuelto será un `u32`. De lo contrario, si un desarrollador provocara que fuera de otro tipo, se produciría un cambio en la unwrap.

```rust
env.storage()
    .instance()
    .set(&COUNTER, &count);
```

La función `set()` almacena el nuevo valor contador contra la clave, reemplazando el valor existente.

### Gestionar TTLs de Datos de Contrato con `extend_ttl()`

```rust
env.storage().instance().extend_ttl(100, 100);
```

Todos los datos del contrato tienen un Time To Live (TTL), medido en contaduras, que debe ser ampliado periódicamente. Si el TTL de una entrada no se amplía periódicamente, la entrada terminará siendo "archivada". Puedes aprender más sobre esto en el documento [Archivo de Estado](../../../learn/encyclopedia/storage/state-archival.mdx).

Por ahora, vale la pena saber que hay tres tipos de almacenamiento: `Persistent`, `Temporary`, y `Instance`. Este contrato solo utiliza el almacenamiento `Instance`: `env.storage().instance()`. Cada vez que se incrementa el contador, el TTL de este almacenamiento se extiende por 100 [ledgers](../../../learn/fundamentals/stellar-data-structures/ledgers.mdx), o alrededor de 500 segundos.

### Construir el contrato

Desde dentro de `soroban-hola-mundo`, corre:

```sh
construcción de contrato estelar
```

Comprueba que se construye:

```bash
blanco/wasm32-unknown-unknown/release/*.wasm
```

Deberías ver tanto `hello_world.wasm` como `soroban_increment_contract.wasm`.

## Tests

La siguiente prueba ha sido añadida al archivo `contracts/increment/src/test.rs`.

```rust title="contracts/incrementor/src/test.rs"
use crate::{IncrementorContract, IncrementorContractClient};
use soroban_sdk::Env;

#[test]
fn increment() {
    let env = Env::default();
    let contract_id = env. egister_contract(None, IncrementorContract);
    let client = IncrementorContractClient::new(&env, &contract_id);

    assert_eq!(cliente. ncrement(), 1);
    assert_eq!(client.increment(), 2);
    assert_eq!(client.increment(), 3);
}
```

Esto utiliza los mismos conceptos descritos en el ejemplo Hola Mundo.

Asegúrate de que pase:

```sh
prueba de carga
```

Verás que esto ejecuta pruebas para todo el espacio de trabajo; tanto el contrato Hola Mundo como el nuevo contrato de incremento.

Si quieres ver la salida de la llamada `log!`, ejecuta las pruebas con `--nocapture`:

```
carga test -- --nocapture
```

Deberías ver la salida:

```
ejecutando 1 prueba
cuenta: U32(0)
cuenta: U32(1)
cuenta: U32(2)
test test::incrementor ... ok
```

## Llevar más lejos

¿Puedes averiguar cómo añadir la función `get_current_value` al contrato? ¿Qué hay de las funciones `decrement` o `reset`?

## Summary

En esta sección, añadimos un nuevo contrato a este proyecto, que utilizó las capacidades de almacenamiento de Soroban para almacenar y recuperar datos. También aprendimos acerca de los diferentes tipos de almacenamiento y cómo gestionar sus TTLs.

A continuación aprenderemos un poco más sobre el despliegue de contratos en la red Testnet de Soroban e interactuaremos con nuestro contrato incrementor utilizando la CLI.

---
sidebar_position: 10
title: 1. Hola mundo
description: Crea tu primer contrato inteligente en Rust.
---

<head>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="Crea tu primer contrato inteligente en Rust."
  />
  <meta
    property="og:description"
    content="Escribe un simple contrato inteligente en Rust que pueda ser desplegado en una red Soroban."
  />
</head>

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

Una vez que hayas [configurado](./setup.mdx) tu entorno de desarrollo, estás listo para crear tu primer contrato inteligente.

## Crear un nuevo proyecto

Crea un nuevo proyecto usando el comando `init` para crear un proyecto `soroban-hello-world`.

```sh
estelar contrato init soroban-hola-mundo
```

El comando `init` creará un proyecto de espacio de trabajo de Rust, utilizando la estructura recomendada para incluir contratos de Soroban. Echemos un vistazo a la estructura del proyecto:

```
.
├── Cargo.lock
├── Cargo.toml
├── README.md
└── contracts
    └── hello_world
        ├── Cargo.toml
        └── src
            ├── lib.rs
            └── test.rs
```

### Mercancía

El `Cargo. oml` en la raíz del proyecto se configura como espacio de trabajo de Rust, lo que nos permite incluir múltiples contratos inteligentes en un proyecto.

#### Espacio de trabajo de oxidación

El `Cargo. oml` establece los miembros del espacio de trabajo como todos los contenidos del directorio `contracts` y establece la versión de dependencias `soroban-sdk` del espacio de trabajo, incluyendo la función `testutils`, que permitirá generar utilidades de prueba para llamar al contrato en pruebas.

```toml title="Cargo.toml"
[workspace]
resolver = "2"
members = [
  "contracts/*",
]

[workspace.dependencies]
soroban-sdk = "20.3.2"
```

:::info

Los `testutils` son habilitados automáticamente dentro de [Pruebas unitarias de Rust] dentro de la misma caja que tu contrato. Si escribes pruebas desde otra caja, necesitarás requerir la función `testutils` para esas pruebas y habilitar la función `testutils` al ejecutar tus pruebas con `cargo test --features testutils` para poder usar esas utilidades de pruebas.

:::

#### Perfil `release`

Configurar el perfil `lanzamiento` para optimizar la construcción del contrato es crucial. Los contratos sorobanos tienen un tamaño máximo de 64KB. Los programas de oxidación, incluso los pequeños, sin estas configuraciones casi siempre superan este tamaño.

El archivo `Cargo.toml` tiene el siguiente perfil de versión configurado.

```toml
[profile.release]
opt-level = "z"
overflow-checks = true
debug = 0
strip = "símbolos"
debug-assertions = false
)[video] = "abort"
codegen-units = 1
lto = true
```

#### Perfil `release-with-logs`

Configurar un perfil `release-with-logs` puede ser útil si necesitas construir un `. archivo asm` que tiene los registros habilitados para imprimir registros de depuración al usar el [`stellar-cli`]. Tenga en cuenta que esto no es necesario para acceder a los registros de depuración en pruebas o para usar un debugger.

```toml
[profile.release-with-logs]
hereda = "lanzamiento"
debug-assertions = true
```

Consulte el [ejemplo de registro] para obtener más información sobre cómo registrar.

[ejemplo de registro]: ../example-contracts/logging.mdx

### Directorio de contratos

El directorio `contracts` es donde vivirán los contratos de Soroban, cada uno en su propio directorio. Ya hay un contrato `hola_mundo` ahí para empezar.

#### Archivo Cargo.toml específico del contrato

Cada contrato debería tener su propio archivo `Cargo.toml`, que se basa en el nivel superior `Cargo.toml` que acabamos de discutir.

Aquí es donde podemos especificar la información del paquete específico del contrato.

```toml title="contracts/hello_world/Cargo.toml"
[package]
nombre = "hola-mundo"
versión = "0.0.0"
edición = "2021"
publicar = falso
```

El `crate-type` está configurado a `cdylib` que es necesario para construir contratos.

```toml
[lib]
crate-type = ["cdylib"]
doctest = false
```

También hemos incluido la dependencia soroban-sdk, configurada para usar la versión del área de trabajo Cargo.toml.

```toml
[dependencies]
soroban-sdk = { workspace = true }

[dev-dependencies]
soroban-sdk = { workspace = true, features = ["testutils"] }
```

#### Contraer código fuente

Crear un contrato Soroban implica escribir código de Rust en el archivo `lib.rs` del proyecto.

¡Todos los contratos deben comenzar con `#![no_std]` para asegurarse de que la biblioteca estándar de Rust no está incluida en la compilación. La biblioteca estándar de Rust es grande y no es adecuada para ser desplegada en programas pequeños como los desplegados en blockchains.

```rust
#![no_std]
```

El contrato importa los tipos y macros que necesita de la caja `soroban-sdk`.

```rust
use soroban_sdk::{contract, contractimpl, symbol_short, vec, Env, Symbol, Vec};
```

Muchos de los tipos disponibles en programas típicos de Rust, como `std::vec::Vec`, no están disponibles, ya que no hay asignación ni memoria acumulada en los contratos de Soroban. El `soroban-sdk` proporciona una variedad de tipos como `Vec`, `Map`, `Bytes`, `BytesN`, `Symbol`, que todos utilizan la memoria y capacidades nativas del entorno Soroban. Valores primitivos como `u128`, `i128`, `u64`, `i64`, `u32`, `i32`, y `bool` también pueden ser usados. Floats y matemáticas de punto flotante no son compatibles.

Los insumos del contrato no deben ser referencias.

El atributo \`#[contract]designa la estructura del Contrato como el tipo al que las funciones del contrato están asociadas. Esto implica que la estructura tendrá funciones contractuales implementadas para ella.

```rust
#[contract]
pub struct HelloContract;
```

Las funciones de contrato se definen dentro de un bloque `impl` para la estructura, que está anotado con `#[contractimpl]`. Es importante tener en cuenta que las funciones del contrato deben tener nombres con una longitud máxima de 32 caracteres. Además, si una función pretende ser invocada desde fuera del contrato, debe estar marcada con el modificador de visibilidad `pub`. Es común que el primer argumento de una función de contrato sea de tipo `Env`, permitir el acceso a una copia del entorno Soroban, que es típicamente necesario para varias operaciones dentro del contrato.

```rust
#[contractimpl]
impl HelloContract {
    pub fn hola(env: Env, to: Symbol) -> Vec<Symbol> {
        vec![&env, symbol_short!("Hola"), a]
    }
}
```

Colocar esas piezas en conjunto un simple contrato parece así.

```rust title="contracts/hello_world/src/lib.rs"
#![no_std]
use soroban_sdk::{contract, contractimpl, symbol_short, vec, Env, Symbol, Vec};

#[contract]
pub struct HelloContract;

#[contractimpl]
impl HelloContract {
    pub fn hola(env: Env, to: Symbol) -> Vec<Symbol> {
        vec! &env, symbol_short!("Hola"), a]
    }
}

mod test;
```

Tenga en cuenta la línea `mod test` en la parte inferior, esto le dirá a Rust que compile y ejecute el código de prueba, que veremos a continuación.

#### Pruebas Unitarias de Contrato

Escribir pruebas para contratos de Soroban implica escribir código de Rust usando las facilidades de prueba y la toolchain que usarías para probar cualquier código de Rust.

Teniendo en cuenta nuestro HelloContract, una prueba simple se verá así.

<Tabs>
<TabItem value="lib.rs" label="contracts/hello_world/src/lib.rs">

```rust
#![no_std]
use soroban_sdk::{contract, contractimpl, symbol_short, vec, Env, Symbol, Vec};

#[contract]
pub struct HelloContract;

#[contractimpl]
impl HelloContract {
    pub fn hola(env: Env, to: Symbol) -> Vec<Symbol> {
        vec! &env, symbol_short!("Hola"), a]
    }
}

mod test;
```

</TabItem>
<TabItem value="test.rs" label="contracts/hello_world/src/test.rs" default>

```rust
#![cfg(test)]

use super::*;
use soroban_sdk::{symbol_short, vec, Env};

#[test]
fn test() {
    let env = Env::default();
    let contract_id = env. egister_contract(None, HelloContract);
    let client = HelloContractClient::new(&env, &contract_id);

    let words = cliente. ello(&symbol_short!("Dev"));
    assert_eq!
        palabras,
        vec! &env, symbol_short!("Hola"), symbol_short!("Dev"),]
    );
}
```

</TabItem>
</Tabs>

En cualquier prueba, lo primero que siempre se requiere es un `Env`, que es el entorno Soroban que el contrato correrá en su interior.

```rust
let env = Env::default();
```

El contrato se registra con el entorno utilizando el tipo de contrato. Los contratos pueden especificar un ID de contrato fijo como el primer argumento, o proporcionar `Ninguno` y se generará uno.

```rust
let contract_id = env.register_contract(None, Contrato);
```

Todas las funciones públicas dentro de un bloque `impl` que está anotado con el atributo `#[contractimpl]` tienen una función correspondiente generada en un tipo de cliente generado. El tipo de cliente se nombrará igual que el tipo de contrato con `Client` adjunto. Por ejemplo, en nuestro contrato el tipo de contrato es `HelloContract`, y el cliente se llama `HelloContractClient`.

```rust
let cliente = HelloContractClient::new(&env, &contract_id);
let words = client.hello(&symbol_short!("Dev"));
```

Los valores devueltos por funciones pueden ser verificados en:

```rust
assert_eq!(
    palabras,
    vec![&env, symbol_short!("Hola"), symbol_short!("Dev"),]
);
```

## Ejecutar las Pruebas

Ejecuta `carga` y observa el funcionamiento de la prueba unitaria. Debería ver la siguiente salida:

```sh
prueba de carga
```

```
ejecutando 1 prueba
test test::test ... ok
```

Intenta cambiar los valores en la prueba para ver cómo funciona.

:::note

La primera vez que ejecuta las pruebas que puede ver la salida en el terminal de carga que compile todas las dependencias antes de ejecutar las pruebas.

:::

## Construir el contrato

Para construir un contrato inteligente para desplegar o ejecutar, utiliza el comando `stellar contract build`.

```sh
construcción de contrato estelar
```

Este es un pequeño envoltorio alrededor de `construcción de carga` que fija el objetivo a `wasm32-unknown-unknown` y el perfil a `release`. Puedes pensar en él como un acceso directo para el siguiente comando:

```sh
carga build --target wasm32-unknown-unknown --release
```

Un archivo `.wasm` será enviado en el directorio `target`, en `target/wasm32-unknown-unknown/release/hello_world.wasm`. El archivo `.wasm` es el contrato construido.

El archivo `.wasm` contiene la lógica del contrato, así como la [especificación / tipos de interfaz](../../.. Aprender/encyclopedia/contract-development/types/fully-typed-contracts.mdx), que puede ser importado a otros contratos que deseen llamarlo. Este es el único artefacto necesario para desplegar el contrato, compartir la interfaz con otros, o la prueba de integración contra el contrato.

## Optimizando construcciones

Usa `stellar contract optimize` para minimizar aún más el tamaño del `.wasm`. Primero, reinstalar stellar-cli con la característica `opt`:

```sh
carga install --locked stellar-cli --features opt
```

Luego, construye un archivo `.wasm` optimizado:

```sh
contrato estelar optimizar --wasm target/wasm32-unknown-unknown/release/hello_world.wasm
```

Esto optimizará y emitirá un nuevo archivo `hello_world.optimized.wasm` en la misma ubicación que el `.wasm` de entrada.

:::tip

Construir contratos optimizados sólo es necesario cuando se implementa en una red con honorarios o cuando se analiza y se perfila un contrato para conseguir que sea lo más pequeño posible. Si acaba de comenzar a escribir un contrato, estos pasos no son necesarios. Vea [Build](#build-the-contract) para más detalles sobre cómo construir para el desarrollo.

:::

## Summary

En esta sección, escribimos un simple contrato que puede ser desplegado en una red Soroban.

A continuación aprenderemos a desplegar el contrato HelloWorld en la red Testnet de Stellar e interactuar con él a través de RPC usando la CLI.

[pruebas de unidades de polvo]: https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html
[`stellar-cli`]: setup.mdx#install-the-stellar-cli

---
title: Asignador
description: Utilice la función de asignación para emular la memoria del montón en un contrato inteligente.
sidebar_position: 80
---

<head>
  <title>
    {`Use la función de asignación para emular memoria de pila en un contrato inteligente. }
  </title>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="Usar la función de asignación para emular memoria en el montón en un contrato inteligente."
  />
  <meta
    property="og:description"
    content="Usa la función de asignación en el SDK. El ligero adjudicador de punteros de bump puede utilizarse para emular la asignación de memoria de pila en un contrato inteligente de Wasm".
  />
</head>

El [ejemplo de asignador] demuestra cómo utilizar la función de asignación al escribir un contrato.

[![Abrir en Gitpod](https://gitpod.io/button/open-in-gitpod.svg)][oigp]

[ejemplo de asignador]: https://github.com/stellar/soroban-examples/tree/v20.0.0/alloc
[oigp]: https://gitpod.io/#https://github.com/stellar/soroban-examples/tree/v20.0.0

La caja `soroban-sdk` proporciona una ligera asignación de puntero de salto que se puede utilizar para emular la asignación de memoria de la pila en un contrato inteligente de Wasm.

## Ejecutar el ejemplo

Primero pasa por el proceso [Setup] para configurar tu entorno de desarrollo, luego clona la etiqueta `v20.0.0` del repositorio `soroban-examples`:

[configuración]: ../iniciando/setup.mdx

```
git clon -b v20.0.0 https://github.com/stellar/soroban-examples
```

O, omita la configuración del entorno de desarrollo y abre este ejemplo en [Gitpod][oigp].

Para ejecutar las pruebas para el ejemplo, navega al directorio `alloc`, y usa `cargo test`.

```
cd alloc
prueba de carga
```

Deberías ver la salida:

```
ejecutando 1 prueba
test test::test ... ok
```

## Dependencias

Este ejemplo depende de la característica `alloc` en `soroban-sdk`. Para incluirlo, añade "alloc" a la lista de "características" de `soroban-sdk` en el archivo `Cargo.toml`:

```rust title="alloc/Cargo.toml"
[dependencies]
soroban-sdk = { versión = "20.0. ", features = ["alloc"] }

[dev_dependencies]
soroban-sdk = { version = "20.0.0", features = ["testutils", "alloc"] }
```

## Código

```rust title="alloc/src/lib.rs"
#![no_std]
use soroban_sdk::{contractimpl, Env};

caja de extern alloc;

#[contract]
pub struct AllocContract;

#[contractimpl]
impl AllocContract {
    /// Aloca un valor temporal de almacenamiento vectorial (0. cuenta), luego calcula y devuelve su suma.
    pub fn sum(_env: Env, cuenta: u32) -> u32 {
        let mut v1 = alloc::vec! ];
        (0. count).for_each(|i| v1. ush(i));

        let mut sum = 0;
        for i in v1 {
            sum += i;
        }

        suma
    }
}
```

Ref: https://github.com/stellar/soroban-examples/tree/v20.0.0/alloc

## Cómo funciona

```rust
asignación de cajas externas;
```

Importa la caja `alloc`, que es necesaria para soportar la asignación bajo `no_std`. Vea [Contract Rust dialect] para más información acerca de `no_std`.

[dialecto de rust contrato]: ../../../learn/encyclopedia/contract-development/rust-dialect.mdx

```rust
let mut v1 = alloc::vec![];
```

Crea un arreglo cultivable contiguo `v1` con contenidos asignados en la memoria del montón.

:::info

La memoria acumulada en el contexto de un contrato inteligente se refiere en realidad a la memoria lineal de Wasm. El `alloc` utilizará la asignación global proporcionada por el sdk soroban para interactuar con la memoria lineal.

:::

:::caution

El uso de matriz asignada en la pila es típicamente lento y costoso en cálculos. Intenta evitarlo y en su lugar usa una matriz de tamaño fijo o `soroban_sdk::vec!` siempre que sea posible.

Este es especialmente el caso de una matriz de tamaño grande. Siempre que el tamaño de la matriz crezca más allá del tamaño actual de la memoria lineal, que es múltiple del tamaño de la página (64KB), el [`wasm32::memory_grow`](https://doc. ust-lang.org/core/arch/wasm32/fn.memory_grow.html) es invocado para que crezca la memoria lineal por más páginas cuando sea necesario, lo que es muy caro para cálculo.

:::

El código restante empuja los valores `(0..count)` a `v1`, luego calcula y devuelve su suma. Este es el ejemplo más simple para ilustrar cómo utilizar el asignador.

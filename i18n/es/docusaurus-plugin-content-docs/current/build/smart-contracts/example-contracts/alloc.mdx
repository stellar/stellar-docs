---
title: Asignador
description: Utiliza la función de asignador para emular la memoria heap en un contrato inteligente.
sidebar_position: 80
---

<head>
  <title>
    {`Utiliza la función de asignador para emular la memoria heap en un contrato inteligente.`}
  </title>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="Utiliza la función de asignador para emular la memoria heap en un contrato inteligente."
  />
  <meta
    property="og:description"
    content="Utiliza la función de asignador en el SDK. El asignador liviano de punteros de aumento se puede usar para emular la asignación de memoria heap en un contrato inteligente Wasm."
  />
</head>

El [ejemplo de asignador] demuestra cómo utilizar la función de asignador al escribir un contrato.

[![Open in Codespaces](https://github.com/codespaces/badge.svg)][open-in-github-codespaces]

[![Open in Codeanywhere](https://codeanywhere.com/img/open-in-codeanywhere-btn.svg)][open-in-code-anywhere]

[open-in-github-codespaces]: https://github.com/codespaces/new?repo=stellar/soroban-examples&editor=web
[open-in-code-anywhere]: https://app.codeanywhere.com/#https://github.com/stellar/soroban-examples
[ejemplo de asignador]: https://github.com/stellar/soroban-examples/tree/v22.0.1/alloc

El crate `soroban-sdk` proporciona un asignador liviano de punteros de aumento que se puede usar para emular la asignación de memoria heap en un contrato inteligente Wasm.

## Ejecutar el Ejemplo

Primero pasa por el proceso de [Configuración] para tener tu entorno de desarrollo configurado, luego clona la etiqueta `v22.0.1` del repositorio `soroban-examples`:

[configuración]: ../getting-started/setup.mdx

```
git clone -b v22.0.1 https://github.com/stellar/soroban-examples
```

O, omite la configuración del entorno de desarrollo y abre este ejemplo en [GitHub Codespaces][open-in-github-codespaces] o en [Code Anywhere][open-in-code-anywhere].

Para ejecutar las pruebas del ejemplo, navega al directorio `alloc`, y usa `cargo test`.

```
cd alloc
cargo test
```

Deberías ver la salida:

```
running 1 test
test test::test ... ok
```

## Dependencias

Este ejemplo depende de la función `alloc` en `soroban-sdk`. Para incluirlo, añade "alloc" a la lista de "features" de `soroban-sdk` en el archivo `Cargo.toml`:

```rust title="alloc/Cargo.toml"
[dependencies]
soroban-sdk = { version = "20.0.0", features = ["alloc"] }

[dev_dependencies]
soroban-sdk = { version = "20.0.0", features = ["testutils", "alloc"] }
```

## Código

```rust title="alloc/src/lib.rs"
#![no_std]
use soroban_sdk::{contractimpl, Env};

extern crate alloc;

#[contract]
pub struct AllocContract;

#[contractimpl]
impl AllocContract {
    /// Allocates a temporary vector holding values (0..count), then computes and returns their sum.
    pub fn sum(_env: Env, count: u32) -> u32 {
        let mut v1 = alloc::vec![];
        (0..count).for_each(|i| v1.push(i));

        let mut sum = 0;
        for i in v1 {
            sum += i;
        }

        sum
    }
}
```

Ref: https://github.com/stellar/soroban-examples/tree/v22.0.1/alloc

## Cómo Funciona

```rust
extern crate alloc;
```

Importa el crate `alloc`, que es necesario para admitir la asignación bajo `no_std`. Consulta [Dialecto Rust de Contrato] para más información sobre `no_std`.

[dialecto rust del contrato]: ../../../learn/fundamentals/contract-development/rust-dialect.mdx

```rust
let mut v1 = alloc::vec![];
```

Crea un arreglo contiguo y de tamaño creciente `v1` con contenidos asignados en la memoria heap.

:::info

La memoria heap en el contexto de un contrato inteligente se refiere en realidad a la memoria lineal Wasm. The `alloc` will use the global allocator provided by the soroban sdk to interact with the linear memory.

:::

:::caution

Usar un arreglo asignado en la memoria heap suele ser lento y costoso en términos computacionales. Intenta evitarlo y, en su lugar, usa un arreglo de tamaño fijo o `soroban_sdk::vec!` siempre que sea posible.

Este es especialmente el caso para un arreglo de gran tamaño. Cada vez que el tamaño del arreglo crece más allá del tamaño actual de la memoria lineal, que es múltiplo del tamaño de la página (64KB), se invoca [`wasm32::memory_grow`](https://doc.rust-lang.org/core/arch/wasm32/fn.memory_grow.html) para aumentar la memoria lineal por más páginas según sea necesario, lo cual es muy costoso en computación.

:::

El código restante empuja valores `(0..count)` a `v1`, luego calcula y devuelve su suma. Este es el ejemplo más simple para ilustrar cómo utilizar el asignador.

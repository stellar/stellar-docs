---
title: Aut
description: Implementar autenticación y autorización.
sidebar_position: 50
---

<head>
  <title>Implementar autenticación y autorización.</title>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="Implementar autenticación y autorización."
  />
  <meta
    property="og:description"
    content="Implementa la autenticación y autorización en tu contrato inteligente usando el marco de autenticación gestionado por Soroban Host."
  />
</head>

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { getPlatform } from "@site/src/helpers/getPlatform";

El [ejemplo de autor] demuestra cómo implementar autenticación y autorización usando el framework de autenticación gestionado por Soroban Host.

Este ejemplo es una extensión del [ejemplo de almacenamiento de datos].

[![Abrir en Gitpod](https://gitpod.io/button/open-in-gitpod.svg)][oigp]

[oigp]: https://gitpod.io/#https://github.com/stellar/soroban-examples/tree/v20.0.0
[ejemplo de almacenamiento de datos]: ../getting-started/storing-data.mdx
[ejemplo de autenticación]: https://github.com/stellar/soroban-examples/tree/v20.0.0/auth

## Ejecutar el ejemplo

Primero pasa por el proceso [Setup] para configurar tu entorno de desarrollo, luego clona la etiqueta `v20.0.0` del repositorio `soroban-examples`:

[configuración]: ../iniciando/setup.mdx

```
git clon -b v20.0.0 https://github.com/stellar/soroban-examples
```

O, omita la configuración del entorno de desarrollo y abre este ejemplo en [Gitpod][oigp].

Para ejecutar las pruebas para el ejemplo, navega al directorio `auth`, y usa `cargo test`.

```
Cd auth
prueba de carga
```

Deberías ver la salida:

```
ejecutando 1 prueba
test test::test ... ok
```

## Código

```rust title="auth/src/lib.rs"
#[contracttype]
pub enum DataKey {
    Counter(Address),
}

#[contract]
pub struct IncrementContract;

#[contractimpl]
impl IncrementContract {
    /// Increment increments a counter for the user, and returns the value.
    pub fn increment(env: Env, user: Address, value: u32) -> u32 {
        // Requires `user` to have authorized call of the `increment` of this
        // contract with all the arguments passed to `increment`, i.e. `user`
        // and `value`. This will panic if auth fails for any reason.
        // When this is called, Soroban host performs the necessary
        // authentication, manages replay prevention and enforces the user's
        // authorization policies.
        // The contracts normally shouldn't worry about these details and just
        // write code in generic fashion using `Address` and `require_auth` (or
        // `require_auth_for_args`).
        user.require_auth();

        // This call is equilvalent to the above:
        // user.require_auth_for_args((&user, value).into_val(&env));

        // The following has less arguments but is equivalent in authorization
        // scope to the above calls (the user address doesn't have to be
        // included in args as it's guaranteed to be authenticated).
        // user.require_auth_for_args((value,).into_val(&env));

        // Construct a key for the data being stored. Use an enum to set the
        // contract up well for adding other types of data to be stored.
        let key = DataKey::Counter(user.clone());

        // Get the current count for the invoker.
        let mut count: u32 = env.storage().persistent().get(&key).unwrap_or_default();

        // Increment the count.
        count += value;

        // Save the count.
        env.storage().persistent().set(&key, &count);

        // Return the count to the caller.
        count
    }
}
```

Ref: https://github.com/stellar/soroban-examples/tree/v20.0.0/auth

## Cómo funciona

El contrato de ejemplo almacena un contador por `Address` que sólo puede ser incrementado por el propietario de esa `Dirección`.

Abre el archivo `auth/src/lib.rs` o mira el código anterior para seguir aún.

### `Dirección`

```rust
#[contracttype]
pub enum DataKey {
    Counter(Address),
}
```

`Address` es un identificador de Soroban universal que puede representar una cuenta Stellar, un contrato o un 'contrato de cuenta' (un contrato que define un esquema de autenticación personalizado y políticas de autorización). Los contratos no necesitan distinguir entre estas representaciones internas. `Address` se puede utilizar en cualquier momento que alguna identidad de red necesite ser representada, como distinguir entre contadores para diferentes usuarios en este ejemplo.

:::tip Las claves Enum como `DataKey` son útiles para organizar el almacenamiento por contrato.

Diferentes valores de enumeración crean diferentes claves 'namespaces'.

En el ejemplo el contador para cada dirección se almacena en `DataKey::Counter(Address)`. Si el contrato necesita comenzar a almacenar otros tipos de datos, puede hacerlo añadiendo variantes adicionales al enum.

:::

### `require_auth`

```rust
Impl IncrementContract {
    pub fn increment(env: Env, user: Address, value: u32) -> u32 {
        user.require_auth();
```

El método `require_auth` puede ser llamado para cualquier `Address`. Semánticamente `user.require_auth()` significa que 'requiere que `usuario` tenga autorizada la función `increment` llamada de la instancia actual `IncrementContract` con los argumentos de llamada actuales, i. . el valor actual de los argumentos `user` y `value`'. En términos más sencillos, esto asegura que el `usuario` ha permitido incrementar su valor de contador y nadie más puede incrementarlo.

Cuando se usa `require_auth` la implementación del contrato no necesita preocuparse por las firmas, autenticación y prevención de repetición. Todas estas características son implementadas por el host Soroban y suceden automáticamente mientras se utilice el tipo `Address`.

`Address` tiene otro método llamado `require_auth_for_args`. Funciona de la misma manera que `require_auth`, pero permite personalizar los argumentos que necesitan ser autorizados. Tenga en cuenta, sin embargo, esto debe ser usado con cuidado para asegurar que hay un mapeo determinista entre los argumentos de invocación del contrato y los argumentos `require_auth_for_args`.

Las siguientes dos llamadas son funcionalmente equivalentes a `user.require_auth`:

```rust
// Equivalente completamente
user.require_auth_for_args((&user, value). nto_val(&env));
// Lo siguiente tiene menos argumentos pero es equivalente en la autorización
// ámbito de la llamada anterior (la dirección de usuario no tiene que ser
// incluida en argumentos ya que está garantizado ser autenticada).
user.require_auth_for_args((value,).into_val(&env));
```

### Tests

Abre el archivo [`auth/src/test.rs`] para seguir aún.

[`auth/src/test.rs`]: https://github.com/stellar/soroban-examples/tree/v20.0.0/auth/src/test.rs

```rust title="auth/src/test.rs"
fn test() {
    let env = Env::default();
    env. ock_all_auths();

    let contract_id = env. egister_contract(None, IncrementContract);
    let client = IncrementContractClient::new(&env, &contract_id);

    let user_1 = Address::random(&env);
    let user_2 = Address::random(&env);

    assert_eq! cliente. ncrement(&user_1, &5), 5);
    // Verificar que el usuario de hecho tuvo que autorizar una llamada de `increment` con
    // los argumentos esperados:
    assert_eq!
        env. uths(),
        [(
            // Dirección para la que se realiza la autenticación
            user_1. sola(),
            // Identificador del contrato llamado
            contract_id. sola(),
            // Nombre de la función llamada
            symbol_short! "incremento"),
            // Argumentos usados para llamar a `increment` (convertido al vector administrado por env-via `into_val`)
            (usuario_1. lone(), 5_u32). nto_val(&env)
        )]
    );

    // Haz más llamadas `increment`. No es necesario verificar las autorizaciones
    // por cada una de ellas, ya que no esperamos que la lógica de autenticación cambie de
    // llamada a llamar.
    assert_eq!(cliente. ncrement(&user_1, &2), 7);
    assert_eq!(client.increment(&user_2, &1), 1);
    assert_eq!(cliente. ncrement(&user_1, &3), 10);
    assert_eq!(client.increment(&user_2, &4), 5);
}

```

En cualquier prueba lo primero que siempre se requiere es un `Env`, que es el entorno Soroban en el que se ejecutará el contrato.

```rust
let env = Env::default();
```

La prueba indica al entorno que simule todos los autores. Todas las llamadas a `require_auth` o `require_auth_for_args` tendrán éxito.

```rust
env.mock_all_auths();
```

El contrato se registra con el entorno utilizando el tipo de contrato.

```rust
let contract_id = env.register_contract(None, IncrementContract);
```

Todas las funciones públicas dentro de un bloque `impl` que está anotado con el atributo `#[contractimpl]` tienen una función correspondiente generada en un tipo de cliente generado. El tipo de cliente se nombrará igual que el tipo de contrato con `Client` adjunto. Por ejemplo, en nuestro contrato el tipo de contrato es `IncrementContract`, y el cliente se llama `IncrementContractClient`.

```rust
let cliente = IncrementContractClient::new(&env, &contract_id);
```

Generar `Dirección`es para dos usuarios. Normalmente, el valor exacto de la `Dirección` no debería importar para las pruebas, así que simplemente se generan aleatoriamente.

```rust
let user_1 = Dirección::random(&env);
let user_2 = Dirección::random(&env);
```

Invoca la función `increment` para `user_1`.

```rust
assert_eq!(client.increment(&usuario_1, &5), 5);
```

Para verificar que las llamadas `require_auth` han ocurrido, usar la función `auths` que devuelve un vector de tubos que contienen las autorizaciones de la invocación de contrato más reciente.

```rust
assert_eq!(
    env.auths(),
    [(
        // Address for which auth is performed
        user_1.clone(),
        // Identifier of the called contract
        contract_id.clone(),
        // Name of the called function
        symbol_short!("increment"),
        // Arguments used to call `increment` (converted to the env-managed vector via `into_val`)
        (user_1.clone(), 5_u32).into_val(&env)
    )]
);
```

Invoca la función `increment` varias veces más para ambos usuarios. Tenga en cuenta que los valores se rastrean por separado para cada usuario.

```rust
assert_eq!(client.increment(&user_1, &2), 7);
assert_eq!(client.increment(&user_2, &1), 1);
assert_eq!(client.increment(&user_1, &3), 10);
assert_eq!(client.increment(&user_2, &4), 5);
```

## Construir el contrato

Para construir el contrato en un archivo `.wasm`, utiliza el comando `stellar contract build`.

```sh
construcción de contrato estelar
```

El archivo `.wasm` debe encontrarse en el directorio `target` después de la construcción:

```
objetivo/wasm32-unknown-unknown/release/soroban_auth_contract.wasm
```

## Ejecutar el contrato

Si tienes instalado [`stellar-cli`], puedes invocar funciones en el contrato.

Pero dado que estamos tratando con la autorización y las firmas, necesitamos establecer algunas identidades para usar para probar y obtener sus claves públicas:

```sh
las claves estelares generan llaves estelares
generan acento 2
llaves estelares dirección acc1
llaves estelares address acc2
```

Ejemplo de salida con dos claves públicas de identidades:

```
GA6S566FD3EQDUNQ4IGSLXKW3TGVSTQW3TPHPGS7NWMCEIPBOKTNCSRU
GAJGHZ44IJXYFNOVRZGBC2V62DB2KHZB7BEMYOWOLFQH4XP2TAM6B
```

Ahora se puede invocar el propio contrato. Tenga en cuenta que `--source` debe ser el nombre de identidad que coincida con la dirección pasada al argumento `--user`. Esto permite a `Stellar CLI` firmar automáticamente la carga útil necesaria para la invocación.

<Tabs groupId="platform" defaultValue={getPlatform()}>

<TabItem value="unix" label="macOS/Linux">

```sh
contrato estelar invoca \
    --source acc1 \
    --wasm target/wasm32-unknown-unknown/release/soroban_auth_contract. asm \
    --id 1 \
    -- \
    incremento \
    --user GA6S566FD3EQDUNQ4IGSLXKW3TGVSTQW3TPHPGS7NWMCEIPBOKTNCSRU \
    --value 2
```

</TabItem>

<TabItem value="windows" label="Windows (PowerShell)">

```powershell
contrato estelar invoca `
    --source acc1 `
    --wasm target/wasm32-unknown-unknown/release/soroban_auth_contract. asm `
    --id 1 `
    -- `
    incremento `
    --user GA6S566FD3EQDUNQ4IGSLXKW3TGVSTQW3TPHPGS7NWMCEIPBOKTNCSRU `
    --value 2
```

</TabItem>

</Tabs>

Ejecutar algunos incrementos más para ambas cuentas.

<Tabs groupId="platform" defaultValue={getPlatform()}>

<TabItem value="unix" label="macOS/Linux">

```sh
contrato estelar invoca \
    --source acc2 \
    --wasm target/wasm32-unknown-unknown/release/soroban_auth_contract. asm \
    --id 1 \
    -- \
    incremento \
    --user GAJGHZ44IJXYFNOVRZGBC2V62DB2KHZB7BEMYOWOLFQH4XP2TAM6B \
    --value 5
```

```sh
contrato estelar invoca \
    --source acc1 \
    --wasm target/wasm32-unknown-unknown/release/soroban_auth_contract. asm \
    --id 1 \
    -- \
    incremento \
    --user GA6S566FD3EQDUNQ4IGSLXKW3TGVSTQW3TPHPGS7NWMCEIPBOKTNCSRU \
    --value 3
```

```sh
contrato estelar invoca \
    --source acc2 \
    --wasm target/wasm32-unknown-unknown/release/soroban_auth_contract. asm \
    --id 1 \
    -- \
    incremento \
    --user GAJGHZ44IJXYFNOVRZGBC2V62DB2KHZB7BEMYOWOLFQH4XP2TAM6B \
    --value 10
```

</TabItem>

<TabItem value="windows" label="Windows (PowerShell)">

```powershell
contrato estelar invoca \
    --source acc2 \
    --wasm target/wasm32-unknown-unknown/release/soroban_auth_contract. asm \
    --id 1 \
    -- \
    incremento \
    --user GAJGHZ44IJXYFNOVRZGBC2V62DB2KHZB7BEMYOWOLFQH4XP2TAM6B \
    --value 5
```

```powershell
contrato estelar invoca \
    --source acc1 \
    --wasm target/wasm32-unknown-unknown/release/soroban_auth_contract. asm \
    --id 1 \
    -- \
    incremento \
    --user GA6S566FD3EQDUNQ4IGSLXKW3TGVSTQW3TPHPGS7NWMCEIPBOKTNCSRU \
    --value 3
```

```powershell
contrato estelar invoca \
    --source acc2 \
    --wasm target/wasm32-unknown-unknown/release/soroban_auth_contract. asm \
    --id 1 \
    -- \
    incremento \
    --user GAJGHZ44IJXYFNOVRZGBC2V62DB2KHZB7BEMYOWOLFQH4XP2TAM6B \
    --value 10
```

</TabItem>

</Tabs>

Ver los datos que han sido almacenados contra cada usuario con `stellar contract read`.

```sh
contrato estelar leer --id 1
```

```
"[""Counter"",""GA6S566FD3EQDUNQ4IGSLXKW3TGVSTQW3TPHPGS7NWMCEIPBOKTNCSRU""]",5
"[""Counter"",""GAJGHZ44IJXYFNOVRZGBC2VKC2V62DB2KHZB7BEMYOWOLFQH4XP2TAM6B]",15
```

También es posible previsualizar la carga de autorización que está siendo firmada proporcionando la bandera `--auth` a la invocación:

<Tabs groupId="platform" defaultValue={getPlatform()}>

<TabItem value="unix" label="macOS/Linux">

```sh
contrato estelar invoca \
    --source acc2 \
    --auth \
    --wasm target/wasm32-unknown-unknown/release/soroban_auth_contract. asm \
    --id 1 \
    -- \
    incremento \
    --user GAJGHZ44IJXYFNOVRZGBCVKC2V62DB2KHZB7BEMYOWOLFQH4XP2TAM6B \
    --value 123
```

</TabItem>

<TabItem value="windows" label="Windows (PowerShell)">

```powershell
contrato estelar invoca `
    --source acc2 `
    --auth `
    --wasm target/wasm32-unknown-unknown/release/soroban_auth_contract. asm `
    --id 1 `
    -- `
    incremento `
    --user GAJGHZ44IJXYFNOVRZGBCVKC2V62DB2KHZB7BEMYOWOLFQH4XP2TAM6B `
    --value 123
```

</TabItem>

</Tabs>

```json
Contract auth: [{"address_with_nonce":null,"root_invocation":{"contract_id":"0000000000000000000000000000000000000000000000000000000000000000000000000000000001","function_name":"increment","args":[{"object":{"address":{"public_key_type_ed25519":"c7bab0288753d58d3e21cc3fa68cd2546b5f78ae6635a6f1b3fe07e03ee846e9"}}}},{"u32":123}],"sub_invocations":[]},"signature_args":[]}]
```

[`stellar-cli`]: ../getting-started/setup.mdx#install-the-stellar-cli

## Lectura posterior

[Documentación de autorización](../../learn/encyclopedia/security/authorization.mdx) proporciona más detalles sobre cómo funciona el framework de autenticación de Soroban.

[Timelock](../example-contracts/timelock.mdx) y [Single Offer](../example-contracts/single-offer-sale.mdx) ejemplos demuestran operaciones de autorización de token en nombre del usuario, que pueden ser extendidas a cualquier invocación anidada del contrato.

[Atomic Swap](../example-contracts/atomic-swap.mdx) muestra la autorización de múltiples partes donde varios usuarios firman sus partes de la invocación del contrato.

[Cuenta Personalizada](../example-contracts/custom-account.mdx) ejemplo para demostrar un contrato de cuenta que define un esquema de autenticación personalizado y políticas de autorización definidas por el usuario.

---
title: Tokens
description: Escriba un contrato de token compatible con CAP-46-6.
sidebar_position: 140
---

<head>
  <title>Escriba un contrato de tokens compatible con CAP-46-6</title>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="Write a CAP-46-6 compliant token contract"
  />
  <meta
    property="og:description"
    content="Utilice la interfaz de token para construir un token de contrato inteligente que tenga una interfaz uniforme y predecible para los pagos, transferencias de saldo, consultas de saldo y mucho más."
  />
</head>

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { getPlatform } from "@site/src/helpers/getPlatform";

El [ejemplo de tokens] demuestra cómo escribir un contrato de token que implemente la [interfaz de token].

[![Abrir en Gitpod](https://gitpod.io/button/open-in-gitpod.svg)][oigp]

[oigp]: https://gitpod.io/#https://github.com/stellar/soroban-examples/tree/v20.0.0
[ejemplo de token]: https://github.com/stellar/soroban-examples/tree/v20.0.0/token
[interfaz de token]: ../../../tokens/token-interface.mdx

## Ejecutar el ejemplo

Primero pasa por el proceso [Setup] para configurar tu entorno de desarrollo, luego clona la etiqueta `v20.0.0` del repositorio `soroban-examples`:

```sh
git clon -b v20.0.0 https://github.com/stellar/soroban-examples
```

O, omita la configuración del entorno de desarrollo y abre este ejemplo en [Gitpod][oigp].

Para ejecutar las pruebas para el ejemplo, navega al directorio `hello_world`, y usa `cargo test`.

```sh
Cd token
prueba de carga
```

Deberías ver la salida:

```sh
ejecutando 8 pruebas
test test::initialize_already_initialized - debería...ok
test test::transfer_spend_deauthorized - debería*. . ok
test test::decimal_is_over_max - debería... ok
test test::test_burn ... ok
test test::transfer_receive_deauthorized - debería... ok
test test::transfer_from_insufficient_allowance - debería ser. . ok
test test::transfer_insufficient_balance - debería... ok
test test::test ... ok
```

[configuración]: ../iniciando/setup.mdx

## Código

:::note

El código fuente de este [ejemplo de tokens] se divide en varios módulos más pequeños. Este es un patrón de diseño común para contratos inteligentes más complejos.

:::

<Tabs>
<TabItem value="lib" default>

```rust title="token/src/lib.rs"
#![no_std]

mod admin;
mod allowance;
mod balance ;
mod contract;
mod event;
metadatos mod;
mod storage_types;
mod test;

pub use crate::contract::TokenClient;
```

</TabItem>
<TabItem value="admin">

```rust title="token/src/admin.rs"
use crate::storage_types::DataKey;
use soroban_sdk::{Address, Env, symbol_short};

pub fn has_administrator(e: &Env) -> bool {
    let key = DataKey::Admin;
    e. torage().instance(). as(&key)
}

pub fn read_administrator(e: &Env) -> Dirección {
    let key = DataKey::Admin;
    e. torage().instance().get(&key). nwrap()
}

pub fn write_administrator(e: &Env, id: &Address) {
    let key = DataKey::Admin;
    e. torage().instance().set(&key, id);
}
```

</TabItem>
<TabItem value="allowance">

```rust title="token/src/allowance.rs"
use crate::storage_types::{AllowanceDataKey, AllowanceValue, DataKey};
use soroban_sdk::{Address, Env};

pub fn read_allowance(e: &Env, from: Address, spender: Address) -> AllowanceValue {
    let key = DataKey::Allowance(AllowanceDataKey { from, spender });
    if let Some(allowance) = e.storage().temporary().get::<_, AllowanceValue>(&key) {
        if allowance.expiration_ledger < e.ledger().sequence() {
            AllowanceValue {
                amount: 0,
                expiration_ledger: allowance.expiration_ledger,
            }
        } else {
            allowance
        }
    } else {
        AllowanceValue {
            amount: 0,
            expiration_ledger: 0,
        }
    }
}

pub fn write_allowance(
    e: &Env,
    from: Address,
    spender: Address,
    amount: i128,
    expiration_ledger: u32,
) {
    let allowance = AllowanceValue {
        amount,
        expiration_ledger,
    };

    if amount > 0 && expiration_ledger < e.ledger().sequence() {
        panic!("expiration_ledger is less than ledger seq when amount > 0")
    }

    let key = DataKey::Allowance(AllowanceDataKey { from, spender });
    e.storage().temporary().set(&key.clone(), &allowance);

    if amount > 0 {
        e.storage().temporary().bump(
            &key,
            expiration_ledger
                .checked_sub(e.ledger().sequence())
                .unwrap(),
        )
    }
}

pub fn spend_allowance(e: &Env, from: Address, spender: Address, amount: i128) {
    let allowance = read_allowance(e, from.clone(), spender.clone());
    if allowance.amount < amount {
        panic!("insufficient allowance");
    }
    write_allowance(
        e,
        from,
        spender,
        allowance.amount - amount,
        allowance.expiration_ledger,
    );
}
```

</TabItem>
<TabItem value="balance">

```rust title="token/src/balance.rs"
use crate::storage_types::DataKey;
use soroban_sdk::{Address, Env};

pub fn read_balance(e: &Env, addr: Address) -> i128 {
    let key = DataKey::Balance(addr);
    if let Some(balance) = e. torage(). ersistent(). et::<DataKey, i128>(&clave) {
        balance
    } else {
        0
    }
}

fn write_balance(e: &Env, addr: Dirección, cantidad: i128) {
    let key = DataKey::Balance(addr);
    e. torage().persistent(). et(&key, &amount);
}

pub fn receive_balance(e: &Env, addr: Dirección, monto: i128) {
    let balance = read_balance(e, addr. lone());
    if !is_authorized(e, addr. lone()) {
        pánico! "cannot receive when deauthorized");
    }
    write_balance(e, addr, balance + monto);
}

pub fn spend_balance(e: &Env, addr: Dirección, cantidad: i128) {
    let balance = read_balance(e, addr. lone());
    if !is_authorized(e, addr. lone()) {
        pánico! "no se puede gastar cuando está desautorizado");
    }
    if balance < amount {
        de pánico! "balance insuficiente");
    }
    write_balance(e, addr, balance - monto);
}

pub fn is_authorized(e: &Env, addr: Address) -> bool {
    let key = DataKey::State(addr);
    if let Some(state) = e. torage().persistent(). et::<DataKey, bool>(&key) {
        state
    } else {
        true
    }
}

pub fn write_authorization(e: &Env, addr: Dirección, is_authorized: bool) {
    let key = DataKey::State(addr);
    e. torage().persistent().set(&key, &is_authorized);
}
```

</TabItem>
<TabItem value="contract">

```rust title="token/src/contract.rs"
//! This contract demonstrates a sample implementation of the Soroban token
//! interface.
use crate::admin::{has_administrator, read_administrator, write_administrator};
use crate::allowance::{read_allowance, spend_allowance, write_allowance};
use crate::balance::{is_authorized, write_authorization};
use crate::balance::{read_balance, receive_balance, spend_balance};
use crate::event;
use crate::metadata::{read_decimal, read_name, read_symbol, write_metadata};
use soroban_sdk::{contractimpl, Address, String, Env};
use soroban_token_sdk::TokenMetadata;

pub trait TokenTrait {
    fn initialize(e: Env, admin: Address, decimal: u32, name: String, symbol: String);

    fn allowance(e: Env, from: Address, spender: Address) -> i128;

    fn approve(e: Env, from: Address, spender: Address, amount: i128, expiration_ledger: u32);

    fn balance(e: Env, id: Address) -> i128;

    fn spendable_balance(e: Env, id: Address) -> i128;

    fn authorized(e: Env, id: Address) -> bool;

    fn transfer(e: Env, from: Address, to: Address, amount: i128);

    fn transfer_from(e: Env, spender: Address, from: Address, to: Address, amount: i128);

    fn burn(e: Env, from: Address, amount: i128);

    fn burn_from(e: Env, spender: Address, from: Address, amount: i128);

    fn clawback(e: Env, from: Address, amount: i128);

    fn set_authorized(e: Env, id: Address, authorize: bool);

    fn mint(e: Env, to: Address, amount: i128);

    fn set_admin(e: Env, new_admin: Address);

    fn decimals(e: Env) -> u32;

    fn name(e: Env) -> String;

    fn symbol(e: Env) -> String;
}

fn check_nonnegative_amount(amount: i128) {
    if amount < 0 {
        panic!("negative amount is not allowed: {}", amount)
    }
}

#[contract]
pub struct Token;

#[contractimpl]
impl TokenTrait for Token {
    fn initialize(e: Env, admin: Address, decimal: u32, name: String, symbol: String) {
        if has_administrator(&e) {
            panic!("already initialized")
        }
        write_administrator(&e, &admin);
        if decimal > u8::MAX.into() {
            panic!("Decimal must fit in a u8");
        }

        write_metadata(
            &e,
            TokenMetadata {
                decimal,
                name,
                symbol,
            },
        )
    }

    fn allowance(e: Env, from: Address, spender: Address) -> i128 {
        read_allowance(&e, from, spender)
    }

    fn approve(e: Env, from: Address, spender: Address, amount: i128, expiration_ledger: u32) {
        from.require_auth();

        check_nonnegative_amount(amount);

        write_allowance(&e, from.clone(), spender.clone(), amount, expiration_ledger);
        event::approve(&e, from, spender, amount, expiration_ledger);
    }

    fn balance(e: Env, id: Address) -> i128 {
        read_balance(&e, id)
    }

    fn spendable_balance(e: Env, id: Address) -> i128 {
        read_balance(&e, id)
    }

    fn authorized(e: Env, id: Address) -> bool {
        is_authorized(&e, id)
    }

    fn transfer(e: Env, from: Address, to: Address, amount: i128) {
        from.require_auth();

        check_nonnegative_amount(amount);
        spend_balance(&e, from.clone(), amount);
        receive_balance(&e, to.clone(), amount);
        event::transfer(&e, from, to, amount);
    }

    fn transfer_from(e: Env, spender: Address, from: Address, to: Address, amount: i128) {
        spender.require_auth();

        check_nonnegative_amount(amount);
        spend_allowance(&e, from.clone(), spender, amount);
        spend_balance(&e, from.clone(), amount);
        receive_balance(&e, to.clone(), amount);
        event::transfer(&e, from, to, amount)
    }

    fn burn(e: Env, from: Address, amount: i128) {
        from.require_auth();

        check_nonnegative_amount(amount);
        spend_balance(&e, from.clone(), amount);
        event::burn(&e, from, amount);
    }

    fn burn_from(e: Env, spender: Address, from: Address, amount: i128) {
        spender.require_auth();

        check_nonnegative_amount(amount);
        spend_allowance(&e, from.clone(), spender, amount);
        spend_balance(&e, from.clone(), amount);
        event::burn(&e, from, amount)
    }

    fn clawback(e: Env, from: Address, amount: i128) {
        check_nonnegative_amount(amount);
        let admin = read_administrator(&e);
        admin.require_auth();
        spend_balance(&e, from.clone(), amount);
        event::clawback(&e, admin, from, amount);
    }

    fn set_authorized(e: Env, id: Address, authorize: bool) {
        let admin = read_administrator(&e);
        admin.require_auth();
        write_authorization(&e, id.clone(), authorize);
        event::set_authorized(&e, admin, id, authorize);
    }

    fn mint(e: Env, to: Address, amount: i128) {
        check_nonnegative_amount(amount);
        let admin = read_administrator(&e);
        admin.require_auth();
        receive_balance(&e, to.clone(), amount);
        event::mint(&e, admin, to, amount);
    }

    fn set_admin(e: Env, new_admin: Address) {
        let admin = read_administrator(&e);
        admin.require_auth();
        write_administrator(&e, &new_admin);
        event::set_admin(&e, admin, new_admin);
    }

    fn decimals(e: Env) -> u32 {
        read_decimal(&e)
    }

    fn name(e: Env) -> Bytes {
        read_name(&e)
    }

    fn symbol(e: Env) -> Bytes {
        read_symbol(&e)
    }
}
```

</TabItem>
<TabItem value="event">

```rust title="token/src/event.rs"
usar soroban_sdk::{Dirección, Env, Symbol, symbol_short};

pub(cris) fn approve(e: &Env, desde: Dirección, a: dirección, cantidad: i128, expiration_ledger: u32) {
    let topics = (Symbol::new(e, "approve"), from, to);
    e. venta(). ublish(temas, (cantidad, caducidad_ledger));
}

pub(cris) fn transfer(e: &Env, de: Dirección, importe: i128) {
    let topics = (symbol_short! "transfer"), de, a);
    e. venta(). ublish(temas, cantidad);
}

pub(cris) fn mint(e: &Env, admin: Dirección, to: Dirección, cantidad: i128) {
    let topics = (symbol_short! "mint"), admin, a);
    e. venta(). ublish(temas, cantidad);
}

pub(cris) fn clawback(e: &Env, admin: Dirección, de: Dirección, cantidad: i128) {
    let topics = (symbol_short! "clawback"), admin, de);
    e. venta(). ublish(temas, cantidad);
}

pub(cris) fn set_authorized(e: &Env, admin: Dirección, id: Dirección, authorize: bool) {
    let topics = (Symbol::new(e, "set_authorized"), admin, id);
    e. venta(). ublish(topics, authorize);
}

pub(cris) fn set_admin(e: &Env, admin: Dirección, new_admin: Dirección) {
    let topics = (symbol_short! "set_admin"), admin);
    e. venta(). ublish(topics, new_admin);
}

pub(cris) fn burn(e: &Env, de: Dirección, cantidad: i128) {
    let topics = (symbol_short! "burn"), desde);
    e. vents().publish(temas, cantidad);
}
```

</TabItem>
<TabItem value="metadata">

```rust title="token/src/metadata.rs"
use soroban_sdk::{Bytes, Env};
use soroban_token_sdk::{TokenMetadata, TokenUtils};

pub fn read_decimal(e: &Env) -> u32 {
    let util = TokenUtils::new(e);
    util. et_metadata_unchecked().unwrap(). ecimal
}

pub fn read_name(e: &Env) -> Bytes {
    let util = TokenUtils::new(e); Utilidad
    et_metadata_unchecked(). nwrap(). ame
}

pub fn read_symbol(e: &Env) -> Bytes {
    let util = TokenUtils::new(e);
    utilidades. et_metadata_unchecked().unwrap(). ymbol
}

pub fn write_metadata(e: &Env, metadata: TokenMetadata) {
    let util = TokenUtils::new(e);
    utilidades. et_metadata(&metadata);
}
```

</TabItem>
<TabItem value="storage_types">

```rust title="token/src/storage_types.rs"
usar soroban_sdk::{contracttype, Address};

#[derive(Clone)]
#[contracttype]
pub struct AllowanceDataKey {
    pub de: Dirección,
    pub pender: Dirección,
}

#[contracttype]
pub struct AllowanceValue {
    pub amount: i128,
    pub expiration_ledger: u32,
}

#[derive(Clone)]
#[contracttype]
pub enum DataKey {
    Allowance(AllowanceDataKey),
    Saldo(Dirección),
    Nonce(Dirección),
    Estado(Dirección),
    Administradores,
}
```

</TabItem>
</Tabs>

Ref: https://github.com/stellar/soroban-examples/tree/v20.0.0/token

## Cómo funciona

Las fichas creadas en una plataforma de contratos inteligentes pueden tomar muchas formas diferentes, incluyen una variedad de funcionalidades diferentes y satisfacer necesidades o casos de uso muy diferentes. Mientras que cada token puede cumplir con un atractivo único, hay algunas características "normales" que casi todos los tokens necesitarán para hacer uso (e. ., pagos, transferencias, consultas de saldo, etc.). En un esfuerzo por minimizar los despliegue de tokens de repetición y streamline, Soroban implementa la [interfaz de token], que proporciona una interfaz uniforme y predecible para desarrolladores y usuarios.

Crear un contrato compatible con un token Soroban a partir de un activo Stellar existente es muy fácil, requiere desplegar el [Contrato de activos estelares].

Este contrato de ejemplo, sin embargo, demuestra cómo un token de contrato inteligente puede ser construido que no se aprovecha del Contrato de Activos Estelares, pero sigue satisfaciendo la interfaz de Token comúnmente usada para maximizar la interoperabilidad.

[contrato de activos estelar]: ../../../tokens/stellar-asset-contract.mdx

### Separación de la funcionalidad

Es probable que haya notado que este ejemplo de contrato se rompe en módulos discretos, cada uno de ellos responsable de un conjunto silenciado de funcionalidad. Esta práctica común ayuda a organizar el código y a hacerlo más mantenible.

Por ejemplo, la mayor parte de la lógica del token existe en el módulo `contract.rs`. Funciones como `mint`, `burn`, `transfer`, etc. están escritas y programadas en ese archivo. La interfaz de Token describe cómo algunas de estas funciones deben emitir eventos cuando ocurren. Sin embargo, mantener toda esa lógica de emisión de eventos incluida en el resto del código del contrato podría hacer más difícil el seguimiento de lo que está ocurriendo en el código, y esa confusión podría conducir en última instancia a errores.

En su lugar, tenemos un módulo `events.rs` separado que elimina todo el dolor de cabeza de emitir eventos cuando se ejecutan otras funciones. Esta es la función para emitir un evento cada vez que el token es mintado:

```rust
pub(cris) fn mint(e: &Env, admin: Dirección, a: Dirección, cantidad: i128) {
    let topics = (symbol_short!("mint"), admin, a);
    e.events().publish(topics, amount);
}
```

Hay que reconocer que este es un ejemplo simple, pero la construcción del contrato de esta manera deja muy claro al desarrollador lo que está sucediendo y dónde. Esta función es utilizada por el módulo `contract.rs` cada vez que se invoca la función `mint`:

```rust
// antes en `contract. s`
use crate::event;

fn mint(e: Env, to: Dirección, monto: i128) {
    check_nonnegative_amount(amount);
    let admin = read_administrator(&e);
    administrador. equire_auth();
    receive_balance(&e, a. lone(), amount);
    // resaltado
    event::mint(&e, admin, to, amount);
}
```

Esta misma convención se utiliza para separar del código de contrato "principal" los metadatos para el token, las definiciones de tipo de almacenamiento, etc.

### Interfaz estandarizada, Comportamiento Personalizado

Este contrato de ejemplo sigue la [Interfaz de Token estandarizada], implementando todas las mismas funciones que el [Contrato de Activos Estelares]. Esto da a carteras, usuarios, desarrolladores, etc. una interfaz predecible para interactuar con el token. Aunque estamos implementando la misma _interface_ de funciones, eso no significa que tengamos que implementar el mismo _comportamiento_ dentro de esas funciones. Mientras que este contrato de ejemplo no modifica ninguna de las funciones que estarían presentes en una instancia desplegada del Contrato de Activos Estelares, esta posibilidad sigue abierta al desarrollador del contrato.

A modo de ejemplo, tal vez tenga un proyecto NFT, y el artista quiere que se pague un pequeño canto cada vez que su token transfiere las manos:

```rust
// Esta es principalmente la función `transfer` de `src/contract. s`
fn transfer(e: Env, de: Dirección, a: dirección, monto: i128) {
    de. equire_auth();

    check_nonnegative_amount(monto);
    spend_balance(&e, de. solo(), monto);
    // resaltar-iniciar
    // Calculamos algunas nuevas cantidades para el pago y la realeza
    let payment = (cantidad * 997) / 1000;
    let royalty = amount - pago
    receive_balance(&e, artista. lone(), royalty);
    // resaltado
    receive_balance(&e, to. sola(), pago);
    event::transfer(&e, de, a, monto);
}
```

La interfaz `transfer` todavía está en uso, y sigue siendo la misma que otras fichas, pero hemos personalizado el comportamiento para atender una necesidad específica. Otro caso de uso podría ser un token estrictamente controlado que requiere autenticación de un administrador antes de que cualquier función `transfer`, `allowance`, etc. pueda ser invocada.

:::tip

Por supuesto, querrá que su token se comporte de una manera _intuitiva_ y _transparente_. Si un usuario está invocando una `transfer`, esperará que los tokens se muevan. Si un emisor de activos necesita invocar un `clawback` probablemente _requiera_ el tipo correcto de comportamiento a realizar.

:::

## Tests

Abre el archivo `token/src/test.rs` para seguir la instrucción.

```rust title="token/src/test.rs"
#![cfg(test)]
extern crate std;

use crate::{contract::Token, TokenClient};
use soroban_sdk::{testutils::Address as _, Address, Env, IntoVal, Symbol};

fn create_token<'a>(e: &Env, admin: &Address) -> TokenClient<'a> {
    let token = TokenClient::new(e, &e.register_contract(None, Token {}));
    token.initialize(admin, &7, &"name".into_val(e), &"symbol".into_val(e));
    token
}

#[test]
fn test() {
    let e = Env::default();
    e.mock_all_auths();

    let admin1 = Address::random(&e);
    let admin2 = Address::random(&e);
    let user1 = Address::random(&e);
    let user2 = Address::random(&e);
    let user3 = Address::random(&e);
    let token = create_token(&e, &admin1);

    token.mint(&user1, &1000);
    assert_eq!(
        e.auths(),
        std::vec![(
            admin1.clone(),
            AuthorizedInvocation {
                function: AuthorizedFunction::Contract((
                    token.address.clone(),
                    symbol_short!("mint"),
                    (&user1, 1000_i128).into_val(&e),
                )),
                sub_invocations: std::vec![]
            }
        )]
    );
    assert_eq!(token.balance(&user1), 1000);

    token.approve(&user2, &user3, &500, &200);
    assert_eq!(
        e.auths(),
        std::vec![(
            user2.clone(),
            AuthorizedInvocation {
                function: AuthorizedFunction::Contract((
                    token.address.clone(),
                    symbol_short!("approve"),
                    (&user2, &user3, 500_i128, 200_u32).into_val(&e),
                )),
                sub_invocations: std::vec![]
            }
        )]
    );
    assert_eq!(token.allowance(&user2, &user3), 500);

    token.transfer(&user1, &user2, &600);
    assert_eq!(
        e.auths(),
        std::vec![(
            user1.clone(),
            AuthorizedInvocation {
                function: AuthorizedFunction::Contract((
                    token.address.clone(),
                    symbol_short!("transfer"),
                    (&user1, &user2, 600_i128).into_val(&e),
                )),
                sub_invocations: std::vec![]
            }
        )]
    );
    assert_eq!(token.balance(&user1), 400);
    assert_eq!(token.balance(&user2), 600);

    token.transfer_from(&user3, &user2, &user1, &400);
    assert_eq!(
        e.auths(),
        std::vec![(
            user3.clone(),
            AuthorizedInvocation {
                function: AuthorizedFunction::Contract((
                    token.address.clone(),
                    Symbol::new(&e, "transfer_from"),
                    (&user3, &user2, &user1, 400_i128).into_val(&e),
                )),
                sub_invocations: std::vec![]
            }
        )]
    );
    assert_eq!(token.balance(&user1), 800);
    assert_eq!(token.balance(&user2), 200);

    token.transfer(&user1, &user3, &300);
    assert_eq!(token.balance(&user1), 500);
    assert_eq!(token.balance(&user3), 300);

    token.set_admin(&admin2);
    assert_eq!(
        e.auths(),
        std::vec![(
            admin1.clone(),
            AuthorizedInvocation {
                function: AuthorizedFunction::Contract((
                    token.address.clone(),
                    symbol_short!("set_admin"),
                    (&admin2,).into_val(&e),
                )),
                sub_invocations: std::vec![]
            }
        )]
    );

    token.set_authorized(&user2, &false);
    assert_eq!(
        e.auths(),
        std::vec![(
            admin2.clone(),
            AuthorizedInvocation {
                function: AuthorizedFunction::Contract((
                    token.address.clone(),
                    Symbol::new(&e, "set_authorized"),
                    (&user2, false).into_val(&e),
                )),
                sub_invocations: std::vec![]
            }
        )]
    );
    assert_eq!(token.authorized(&user2), false);

    token.set_authorized(&user3, &true);
    assert_eq!(token.authorized(&user3), true);

    token.clawback(&user3, &100);
    assert_eq!(
        e.auths(),
        std::vec![(
            admin2.clone(),
            AuthorizedInvocation {
                function: AuthorizedFunction::Contract((
                    token.address.clone(),
                    symbol_short!("clawback"),
                    (&user3, 100_i128).into_val(&e),
                )),
                sub_invocations: std::vec![]
            }
        )]
    );
    assert_eq!(token.balance(&user3), 200);

    // Set allowance to 500
    token.approve(&user2, &user3, &500, &200);
    assert_eq!(token.allowance(&user2, &user3), 500);
    token.approve(&user2, &user3, &0, &200);
    assert_eq!(
        e.auths(),
        std::vec![(
            user2.clone(),
            AuthorizedInvocation {
                function: AuthorizedFunction::Contract((
                    token.address.clone(),
                    symbol_short!("approve"),
                    (&user2, &user3, 0_i128, 200_u32).into_val(&e),
                )),
                sub_invocations: std::vec![]
            }
        )]
    );
    assert_eq!(token.allowance(&user2, &user3), 0);
}

#[test]
fn test_burn() {
    let e = Env::default();
    e.mock_all_auths();

    let admin = Address::random(&e);
    let user1 = Address::random(&e);
    let user2 = Address::random(&e);
    let token = create_token(&e, &admin);

    token.mint(&user1, &1000);
    assert_eq!(token.balance(&user1), 1000);

    token.approve(&user1, &user2, &500, &200);
    assert_eq!(token.allowance(&user1, &user2), 500);

    token.burn_from(&user2, &user1, &500);
    assert_eq!(
        e.auths(),
        std::vec![(
            user2.clone(),
            AuthorizedInvocation {
                function: AuthorizedFunction::Contract((
                    token.address.clone(),
                    symbol_short!("burn_from"),
                    (&user2, &user1, 500_i128).into_val(&e),
                )),
                sub_invocations: std::vec![]
            }
        )]
    );

    assert_eq!(token.allowance(&user1, &user2), 0);
    assert_eq!(token.balance(&user1), 500);
    assert_eq!(token.balance(&user2), 0);

    token.burn(&user1, &500);
    assert_eq!(
        e.auths(),
        std::vec![(
            user1.clone(),
            AuthorizedInvocation {
                function: AuthorizedFunction::Contract((
                    token.address.clone(),
                    symbol_short!("burn"),
                    (&user1, 500_i128).into_val(&e),
                )),
                sub_invocations: std::vec![]
            }
        )]
    );

    assert_eq!(token.balance(&user1), 0);
    assert_eq!(token.balance(&user2), 0);
}

#[test]
#[should_panic(expected = "insufficient balance")]
fn transfer_insufficient_balance() {
    let e = Env::default();
    e.mock_all_auths();

    let admin = Address::random(&e);
    let user1 = Address::random(&e);
    let user2 = Address::random(&e);
    let token = create_token(&e, &admin);

    token.mint(&user1, &1000);
    assert_eq!(token.balance(&user1), 1000);

    token.transfer(&user1, &user2, &1001);
}

#[test]
#[should_panic(expected = "can't receive when deauthorized")]
fn transfer_receive_deauthorized() {
    let e = Env::default();
    e.mock_all_auths();

    let admin = Address::random(&e);
    let user1 = Address::random(&e);
    let user2 = Address::random(&e);
    let token = create_token(&e, &admin);

    token.mint(&user1, &1000);
    assert_eq!(token.balance(&user1), 1000);

    token.set_authorized(&user2, &false);
    token.transfer(&user1, &user2, &1);
}

#[test]
#[should_panic(expected = "can't spend when deauthorized")]
fn transfer_spend_deauthorized() {
    let e = Env::default();
    e.mock_all_auths();

    let admin = Address::random(&e);
    let user1 = Address::random(&e);
    let user2 = Address::random(&e);
    let token = create_token(&e, &admin);

    token.mint(&user1, &1000);
    assert_eq!(token.balance(&user1), 1000);

    token.set_authorized(&user1, &false);
    token.transfer(&user1, &user2, &1);
}

#[test]
#[should_panic(expected = "insufficient allowance")]
fn transfer_from_insufficient_allowance() {
    let e = Env::default();
    e.mock_all_auths();

    let admin = Address::random(&e);
    let user1 = Address::random(&e);
    let user2 = Address::random(&e);
    let user3 = Address::random(&e);
    let token = create_token(&e, &admin);

    token.mint(&user1, &1000);
    assert_eq!(token.balance(&user1), 1000);

    token.approve(&user1, &user3, &100, &200);
    assert_eq!(token.allowance(&user1, &user3), 100);

    token.transfer_from(&user3, &user1, &user2, &101);
}

#[test]
#[should_panic(expected = "already initialized")]
fn initialize_already_initialized() {
    let e = Env::default();
    let admin = Address::random(&e);
    let token = create_token(&e, &admin);

    token.initialize(&admin, &10, &"name".into_val(&e), &"symbol".into_val(&e));
}

#[test]
#[should_panic(expected = "Decimal must fit in a u8")]
fn decimal_is_over_max() {
    let e = Env::default();
    let admin = Address::random(&e);
    let token = TokenClient::new(&e, &e.register_contract(None, Token {}));
    token.initialize(
        &admin,
        &(u32::from(u8::MAX) + 1),
        &"name".into_val(&e),
        &"symbol".into_val(&e),
    );
}
```

El ejemplo del token implementa ocho pruebas diferentes para cubrir una amplia gama de potenciales comportamientos y problemas. Sin embargo, todas las pruebas comienzan con unas pocas piezas comunes. En cualquier prueba, lo primero que siempre se requiere es un `Env`, que es el entorno Soroban en el que se ejecutará el contrato.

```rust
let e = Env::default();
```

Fusionamos las comprobaciones de autenticación en las pruebas, lo que permite que las pruebas procedan como si todos los usuarios/direcciones/contratos/etc. se hubieran autenticado correctamente.

```rust
mock_all_auths();
```

También estamos usando una función `create_token` para facilitar la repetición de tener que registrar e inicializar nuestro contrato de token. El cliente `token` resultante se utiliza para invocar el contrato durante cada prueba.

```rust
// Se define en la parte superior del archivo...
fn create_token<'a>(e: &Env, admin: &Address) -> TokenClient<'a> {
    let token = TokenClient::new(e, &e. egister_contract(None, Token {})); Token
    token. nitialize(admin, &7, &"name".into_val(e), &"symbol".into_val(e));
    token
}

// . . y se usa dentro de cada prueba
let token = create_token(&e, &admin);
```

Todas las funciones públicas dentro de un bloque `impl` que ha sido anotado con el atributo `#[contractimpl]` tendrán una función correspondiente en el tipo de cliente generado por la prueba. El tipo de cliente se nombrará igual que el tipo de contrato con `Client` adjunto. Por ejemplo, en nuestro contrato, el tipo de contrato se llama `Token`, y el tipo de cliente se llama `TokenClient`.

Las ocho pruebas creadas para este ejemplo de contrato prueban una serie de posibles condiciones y aseguran que el contrato responda adecuadamente a cada una:

- **`test()`** - Esta función hace uso de una variedad de funciones de token incorporadas para probar la forma "predictable" con la que un activo podría ser interactuado por un usuario, así como un administrador.
- **`test_burn()`** - Esta función asegura que la invocación `burn()` disminuya el saldo del usuario, y que una invocación `burn_from()` disminuye el balance de un usuario así como consumiendo la autorización de otro usuario de ese equilibrio.
- **`transfer_insufficient_balance()`** - Esta función asegura un pánico de invocación `transfer()` cuando el usuario `from` no tiene el balance para cubrirlo.
- **`transfer_receive_deauthorized()`** - Esta función asegura que un usuario que está específicamente desautorizado para contener el token no puede ser el beneficiario de una invocación `transfer()`.
- **`transfer_spend_deauthorized()`** - Esta función asegura que un usuario con un saldo de tokens, quien posteriormente es des-autorizado no puede ser la fuente de una invocación `transfer()`.
- **`transfer_from_insufficient_allowance()`** - Esta función asegura que un usuario con un permiso existente para el saldo de otra persona no puede hacer que `transfer()` sea mayor que ese permiso.
- **`initialize_already_initialized()`** - Esta función comprueba que el contrato no puede tener una función `initialize()` invocada por segunda vez.
- **`decimal_is_over_max()`** - Esta función prueba que invocar `initialize()` con una precisión decimal demasiado alta no tendrá éxito.

## Construir el contrato

Para construir el contrato, utilice el comando `stellar contract build`.

```sh
construcción de contrato estelar
```

Un archivo `.wasm` debe ser enviado en el directorio `target`:

```sh
objetivo/wasm32-unknown-unknown/release/soroban_token_contract.wasm
```

## Ejecutar el contrato

Si tienes instalado [`stellar-cli`], puedes invocar las funciones del contrato utilizándolo.

<Tabs groupId="platform" defaultValue={getPlatform()}>

<TabItem value="unix" label="macOS/Linux">

```sh
contrato estelar invoca \
    --wasm target/wasm32-unknown-unknown/release/soroban_token_contract.wasm \
    --id 1 \
    -- \
    balance \
    --id GBZV3NONYSUDVTEHATQO4BCJVFXJO3XQU5K32X3XREVZKSMMOZFO4ZXR
```

</TabItem>

<TabItem value="windows" label="Windows (PowerShell)">

```powershell
contrato estelar invoca `
    --wasm target/wasm32-unknown-unknown/release/soroban_token_contract.wasm `
    --id 1 `
    -- `
    balance `
    --id GBZV3NONYSUDVTEHATQO4BCJVFXJO3XQU5K32X3XREVZKSMMOZFO4ZXR
```

</TabItem>

</Tabs>

[`stellar-cli`]: ../../../tools/developer-tools/README.mdx#cli

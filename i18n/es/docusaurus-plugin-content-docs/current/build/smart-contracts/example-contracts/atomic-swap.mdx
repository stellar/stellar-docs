---
title: Intercambio atómico
description: Intercambiar tokens atómicamente entre usuarios autorizados.
sidebar_position: 90
---

<head>
  <title>Intercambia tokens atómicamente entre usuarios autorizados.</title>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="Intercambia tokens atómicamente entre usuarios autorizados."
  />
  <meta
    property="og:description"
    content="Intercambia dos tokens entre dos partes autorizadas atómicamente usando el marco de autor; el precio mínimo solicitado debe ser respetado por ambas partes."
  />
</head>

El [ejemplo de intercambio atómico] cambia dos fichas entre dos partes autorizadas atómicamente mientras siguen los límites que establecieron.

Este es un ejemplo que demuestra el uso avanzado del framework de autenticación de Soroban y asume que el lector está familiarizado con el [ejemplo de autor](../example-contracts/auth.mdx) y con el uso del token de Soroban.

[![Abrir en Gitpod](https://gitpod.io/button/open-in-gitpod.svg)][oigp]

[oigp]: https://gitpod.io/#https://github.com/stellar/soroban-examples/tree/v20.0.0
[ejemplo de intercambio atómico]: https://github.com/stellar/soroban-examples/tree/v20.0.0/atomic_swap

## Ejecutar el ejemplo

Primero pasa por el proceso [Setup] para configurar tu entorno de desarrollo, luego clona la etiqueta `v20.0.0` del repositorio `soroban-examples`:

[configuración]: ../iniciando/setup.mdx

```
git clon -b v20.0.0 https://github.com/stellar/soroban-examples
```

O, omita la configuración del entorno de desarrollo y abre este ejemplo en [Gitpod][oigp].

Para ejecutar las pruebas para el ejemplo use `cargo test`.

```
prueba de carga -p soroban-atómica-contrato de intercambio
```

Deberías ver la salida:

```
ejecutando 1 prueba
test test::test_atomic_swap ... ok
```

## Código

```rust title="atomic_swap/src/lib.rs"
#[contract]
pub struct AtomicSwapContract;

#[contractimpl]
impl AtomicSwapContract {
    // Swap token A for token B atomically. Settle for the minimum requested price
    // for each party (this is an arbitrary choice to demonstrate the usage of
    // allowance; full amounts could be swapped as well).
    pub fn swap(
        env: Env,
        a: Address,
        b: Address,
        token_a: Address,
        token_b: Address,
        amount_a: i128,
        min_b_for_a: i128,
        amount_b: i128,
        min_a_for_b: i128,
    ) {
        // Verify preconditions on the minimum price for both parties.
        if amount_b < min_b_for_a {
            panic!("not enough token B for token A");
        }
        if amount_a < min_a_for_b {
            panic!("not enough token A for token B");
        }
        // Require authorization for a subset of arguments specific to a party.
        // Notice, that arguments are symmetric - there is no difference between
        // `a` and `b` in the call and hence their signatures can be used
        // either for `a` or for `b` role.
        a.require_auth_for_args(
            (token_a.clone(), token_b.clone(), amount_a, min_b_for_a).into_val(&env),
        );
        b.require_auth_for_args(
            (token_b.clone(), token_a.clone(), amount_b, min_a_for_b).into_val(&env),
        );

        // Perform the swap by moving tokens from a to b and from b to a.
        move_token(&env, &token_a, &a, &b, amount_a, min_a_for_b);
        move_token(&env, &token_b, &b, &a, amount_b, min_b_for_a);
    }
}

fn move_token(
    env: &Env,
    token: &Address,
    from: &Address,
    to: &Address,
    max_spend_amount: i128,
    transfer_amount: i128,
) {
    let token = token::Client::new(env, token);
    let contract_address = env.current_contract_address();
    // This call needs to be authorized by `from` address. It transfers the
    // maximum spend amount to the swap contract's address in order to decouple
    // the signature from `to` address (so that parties don't need to know each
    // other).
    token.transfer(from, &contract_address, &max_spend_amount);
    // Transfer the necessary amount to `to`.
    token.transfer(&contract_address, to, &transfer_amount);
    // Refund the remaining balance to `from`.
    token.transfer(
        &contract_address,
        from,
        &(&max_spend_amount - &transfer_amount),
    );
}
```

Ref: https://github.com/stellar/soroban-examples/tree/v20.0.0/atomic_swap

## Cómo funciona

El contrato de ejemplo requiere dos `Dirección`-es para autorizar sus partes de la operación de intercambio: una `Dirección` quiere vender una cantidad determinada de ficha A para el token B a un precio dado y otra `Dirección` quiere vender el token B para el token A a un precio determinado. El contrato cambia las fichas atómicamente, pero sólo si el precio mínimo solicitado es respetado por ambas partes.

Abre el archivo `atomic_swap/src/lib.rs` o ve el código anterior para seguir al pie de la letra.

### Autorización de intercambio

```rust
...
a.require_auth_for_args(
    (token_a.clone(), token_b.clone(), amount_a, min_b_for_a).into_val(&env),
);
b.require_auth_for_args(
    (token_b.clone(), token_a.clone(), amount_b, min_a_for_b).into_val(&env),
);

```

La autorización de la función `swap` aprovecha la función Soroban `require_auth_for_args`. Tanto `a` como `b` necesitan autorizar argumentos simétricos: token que venden, token que compran, cantidad de ficha que venden, cantidad mínima de ficha que quieren recibir. Esto significa que `a` y `b` pueden intercambiarse libremente en los argumentos de invocación (siempre y cuando los respectivos argumentos también sean cambiados).

### Moviendo las fichas

```rust
...
// Perform the swap via two token transfers.
move_token(&env, token_a, &a, &b, amount_a, min_a_for_b);
move_token(&env, token_b, &b, &a, amount_b, min_b_for_a);
...
fn move_token(
    env: &Env,
    token: &Address,
    from: &Address,
    to: &Address,
    max_spend_amount: i128,
    transfer_amount: i128,
) {
    let token = token::Client::new(env, token);
    let contract_address = env.current_contract_address();
    // This call needs to be authorized by `from` address. It transfers the
    // maximum spend amount to the swap contract's address in order to decouple
    // the signature from `to` address (so that parties don't need to know each
    // other).
    token.transfer(from, &contract_address, &max_spend_amount);
    // Transfer the necessary amount to `to`.
    token.transfer(&contract_address, to, &transfer_amount);
    // Refund the remaining balance to `from`.
    token.transfer(
        &contract_address,
        from,
        &(&max_spend_amount - &transfer_amount),
    );
}
```

El propio intercambio se implementa a través de dos movimientos de token: de `a` a `b` y de `b` a `a`. El movimiento del token se implementa mediante permiso: los usuarios no necesitan conocerse entre sí para realizar el intercambio, y en su lugar autorizan al contrato de intercambio a gastar la cantidad necesaria de token en su nombre a través de `transfer`. El framework de autenticación Soroban se asegura de que las firmas de `transfer` tengan el contexto adecuado, y no serán usables fuera de la invocación de contrato de `swap`.

### Tests

Abre el archivo [`atomic_swap/src/test.rs`] para seguir al lado.

[`atomic_swap/src/test.rs`]: https://github.com/stellar/soroban-examples/tree/v20.0.0/atomic_swap/src/test.rs

Consulte otros ejemplos de información general sobre la configuración de pruebas.

La parte interesante de este ejemplo es la verificación de la autorización de 'swap':

```rust
contract.swap(
    &a,
    &b,
    &token_a.address,
    &token_b.address,
    &1000,
    &4500,
    &5000,
    &950,
);

assert_eq!(
    env.auths(),
    std::vec![
        (
            a.clone(),
            AuthorizedInvocation {
                function: AuthorizedFunction::Contract((
                    contract.address.clone(),
                    symbol_short!("swap"),
                    (
                        token_a.address.clone(),
                        token_b.address.clone(),
                        1000_i128,
                        4500_i128
                    )
                        .into_val(&env),
                )),
                sub_invocations: std::vec![AuthorizedInvocation {
                    function: AuthorizedFunction::Contract((
                        token_a.address.clone(),
                        symbol_short!("transfer"),
                        (a.clone(), contract.address.clone(), 1000_i128,).into_val(&env),
                    )),
                    sub_invocations: std::vec![]
                }]
            }
        ),
        (
            b.clone(),
            AuthorizedInvocation {
                function: AuthorizedFunction::Contract((
                    contract.address.clone(),
                    symbol_short!("swap"),
                    (
                        token_b.address.clone(),
                        token_a.address.clone(),
                        5000_i128,
                        950_i128
                    )
                        .into_val(&env),
                )),
                sub_invocations: std::vec![AuthorizedInvocation {
                    function: AuthorizedFunction::Contract((
                        token_b.address.clone(),
                        symbol_short!("transfer"),
                        (b.clone(), contract.address.clone(), 5000_i128,).into_val(&env),
                    )),
                    sub_invocations: std::vec![]
                }]
            }
        ),
    ]
);
```

`env.auths()` devuelve todas las autorizaciones. En el caso de 'swap' se esperan cuatro autorizaciones. Dos por cada autorización de dirección, porque cada dirección autoriza no sólo el swap, sino el `approve` todo en el token siendo enviado.

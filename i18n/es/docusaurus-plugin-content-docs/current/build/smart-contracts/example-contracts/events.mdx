---
title: Eventos
description: Publicar eventos de un contrato inteligente.
sidebar_position: 10
---

<head>
  <title>Publica eventos de un contrato inteligente.</title>
  <meta charSet="utf-8" />
  <meta property="og:title" content="Publica eventos de un contrato inteligente." />
  <meta
    property="og:description"
    content="Publicar eventos de un contrato inteligente. Los eventos de contrato permiten que los contratos emitan información sobre lo que está haciendo el contrato utilizando la función de publicar eventos del entorno."
  />
</head>

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { getPlatform } from "@site/src/helpers/getPlatform";

El [ejemplo de eventos] demuestra cómo publicar eventos de un contrato. Este ejemplo es una extensión del [ejemplo de almacenamiento de datos].

[![Abrir en Gitpod](https://gitpod.io/button/open-in-gitpod.svg)][oigp]

[oigp]: https://gitpod.io/#https://github.com/stellar/soroban-examples/tree/v20.0.0
[ejemplo de eventos]: https://github.com/stellar/soroban-examples/tree/v20.0.0/events
[ejemplo de almacenamiento de datos]: ../getting-started/storing-data.mdx

## Ejecutar el ejemplo

Primero pasa por el proceso [Setup] para configurar tu entorno de desarrollo, luego clona la etiqueta `v20.0.0` del repositorio `soroban-examples`:

[configuración]: ../iniciando/setup.mdx

```
git clon -b v20.0.0 https://github.com/stellar/soroban-examples
```

O, omita la configuración del entorno de desarrollo y abre este ejemplo en [Gitpod][oigp].

Para ejecutar las pruebas para el ejemplo, navega al directorio `events`, y usa `cargo test`.

```
eventos de cd
prueba de carga
```

Deberías ver la salida:

```
ejecutando 1 prueba
test test::test ... ok
```

## Código

```rust title="events/src/lib.rs"
const COUNTER: ¡Símbolo = symbol_short! "COUNTER");

#[contract]
pub struct IncrementContract;

#[contractimpl]
impl IncrementContract {
    /// Incrementar incrementa un contador interno y devuelve el valor.
    pub fn increment(env: Env) -> u32 {
        // Obtener el recuento actual.
        dejar contador de mut: u32 = env.storage().instance(). et(&COUNTER).unwrap_or(0); // Si no se establece ningún valor, asuma 0.

        // Incremente el contador.
        count += 1;

        // Guardar el conteo.
        env.storage().instance(). et(&COUNTER, &count);

        // Publica un evento sobre el incremento ocurrido.
        // El evento tiene dos temas:
        // - El símbolo "COUNTER".
        // - El símbolo "increment".
        // Los datos del evento son el conteo.
        env.events()
            . ublish((COUNTER, symbol_short!("increment")), count);

        // Devuelve el recuento al llamante.
        cuenta
    }
}
```

Ref: https://github.com/stellar/soroban-examples/tree/v20.0.0/events

## Cómo funciona

Este contrato de ejemplo extiende el ejemplo de incremento publicando un evento cada vez que el contador se incrementa.

Los eventos de contrato permiten que los contratos emitan información sobre lo que hace su contrato.

Los contratos pueden publicar eventos usando la función de publicación de eventos en entornos.

```rust
env.events().publish(temas, datos);
```

### Temas del evento

Un evento puede contener hasta cuatro temas.

Los temas se definen convenientemente usando una tupla. En el código de muestra se utilizan dos temas del tipo `Symbol`.

```rust
env.events().publish((COUNTER, symbol_short!("incremento")), ...);
```

:::tip

Los temas no tienen que estar hechos del mismo tipo. Puede mezclar diferentes tipos siempre y cuando el número total de temas permanezca por debajo del límite.

:::

### Datos del evento

Un evento también contiene un objeto de datos de cualquier valor o tipo incluyendo tipos definidos por contratos usando `#[contracttype]`. En el ejemplo los datos son el recuento `u32`.

```rust
env.events().publish(..., count);
```

### Publicación

Publicar un evento se hace llamando a la función 'publicar' y dándole los temas y datos. La función no devuelve nada sobre el éxito y el pánico sobre el fracaso. Las posibles razones de fallo pueden incluir entradas mal formadas (por ejemplo, el recuento de temas supera el límite) y sobrepasar el presupuesto de recursos (TBD). Una vez publicado con éxito, el nuevo evento estará disponible para las aplicaciones que consuman los eventos.

```rust
env.events().publish((COUNTER, symbol_short!("increment")), cuenta);
```

:::caution

Los eventos publicados se descartan si una invocación del contrato falla debido a un pánico, agotamiento del presupuesto, o cuando el contrato devuelve un error.

:::

## Tests

Abre el archivo `events/src/test.rs` para seguir al lado.

```rust title="events/src/test.rs"
#[test]
fn test() {
    let env = Env::default();
    let contract_id = env.register_contract(None, IncrementContract);
    let client = IncrementContractClient::new(&env, &contract_id);

    assert_eq!(client.increment(), 1);
    assert_eq!(client.increment(), 2);
    assert_eq!(client.increment(), 3);

    assert_eq!(
        env.events().all(),
        vec![
            &env,
            (
                contract_id.clone(),
                (symbol_short!("COUNTER"), symbol_short!("increment")).into_val(&env),
                1u32.into_val(&env)
            ),
            (
                contract_id.clone(),
                (symbol_short!("COUNTER"), symbol_short!("increment")).into_val(&env),
                2u32.into_val(&env)
            ),
            (
                contract_id,
                (symbol_short!("COUNTER"), symbol_short!("increment")).into_val(&env),
                3u32.into_val(&env)
            ),
        ]
    );
}
```

En cualquier prueba lo primero que siempre se requiere es un `Env`, que es el entorno Soroban en el que se ejecutará el contrato.

```rust
let env = Env::default();
```

El contrato se registra con el entorno utilizando el tipo de contrato.

```rust
let contract_id = env.register_contract(None, IncrementContract);
```

Todas las funciones públicas dentro de un bloque `impl` que está anotado con el atributo `#[contractimpl]` tienen una función correspondiente generada en un tipo de cliente generado. El tipo de cliente se nombrará igual que el tipo de contrato con `Client` adjunto. Por ejemplo, en nuestro contrato el tipo de contrato es `IncrementContract`, y el cliente se llama `IncrementContractClient`.

```rust
let cliente = IncrementContractClient::new(&env, &contract_id);
```

El ejemplo invoca el contrato varias veces.

```rust
assert_eq!(client.increment(), 1);
```

El ejemplo confirma que los eventos fueron publicados.

```rust
assert_eq!(
    env.events().all(),
    vec![
        &env,
        (
            contract_id.clone(),
            (symbol_short!("COUNTER"), symbol_short!("increment").into_val(&env),
            1u32.into_val(&env)
        ),
        // ...
    ]
);
```

## Construir el contrato

Para construir el contrato, utilice el comando `stellar contract build`.

```sh
construcción de contrato estelar
```

Un archivo `.wasm` debe ser enviado en el directorio `target`:

```
objetivo/wasm32-unknown-unknown/release/soroban_events_contract.wasm
```

## Ejecutar el contrato

Si tienes instalado [`stellar-cli`], puedes invocar funciones de contrato en el usarlo.

<Tabs groupId="platform" defaultValue={getPlatform()}>

<TabItem value="unix" label="macOS/Linux">

```sh
contrato estelar invoca \
    --wasm target/wasm32-unknown-unknown/release/soroban_events_contract.wasm \
    --id 1 \
    -- \
    incremento
```

</TabItem>

<TabItem value="windows" label="Windows (PowerShell)">

```powershell
contrato estelar invoca `
    --wasm target/wasm32-unknown-unknown/release/soroban_events_contract.wasm `
    --id 1 `
    -- ` Incremento

```

</TabItem>

</Tabs>

La siguiente salida debería ocurrir usando el código anterior.

```json
1
#0: event: {"ext":"v0","contractId":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],"type":"contract","body":{"v0":{"topics":[{"symbol":[67,79,85,78,84,69,82]},{"symbol":[105,110,99,101,110,110,116]}],"data":{"u32":1}}}}
```

Un solo evento `#0` es salido, que es el evento del contrato publicado. El evento contiene los dos temas, cada uno un `symbol` (mostrado como bytes), y el objeto de datos que contiene el `u32`.

[`stellar-cli`]: ../getting-started/setup.mdx#install-the-stellar-cli

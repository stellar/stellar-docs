---
title: Llamadas de contrato cruzado
description: Llame a un contrato inteligente de otro contrato inteligente.
sidebar_position: 60
---

<head>
  <title>Llame a un contrato inteligente de otro contrato inteligente.</title>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="Llamar un contrato inteligente de otro contrato inteligente."
  />
  <meta
    property="og:description"
    content="Realizar una llamada a través del contrato invocando otro contrato usando su ID del contrato."
  />
</head>

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { getPlatform } from "@site/src/helpers/getPlatform";

El [ejemplo de llamada cruzada] demuestra cómo llamar a un contrato de otro contrato.

[![Abrir en Gitpod](https://gitpod.io/button/open-in-gitpod.svg)][oigp]

:::info

En este ejemplo hay dos contratos compilados por separado, desplegados por separado y probados juntos. Hay varias maneras de desarrollar y probar contratos con dependencias de otros contratos, y el Soroban SDK y las herramientas todavía están construyendo las herramientas para apoyar estos flujos de trabajo. Feedback apreció [here](https://github.com/stellar/rs-soroban-sdk/issues/new/choose).

:::

[oigp]: https://gitpod.io/#https://github.com/stellar/soroban-examples/tree/v20.0.0
[ejemplo de llamada transversal]: https://github.com/stellar/soroban-examples/tree/v20.0.0/cross_contract

## Ejecutar el ejemplo

Primero pasa por el proceso [Setup] para configurar tu entorno de desarrollo, luego clona la etiqueta `v20.0.0` del repositorio `soroban-examples`:

[configuración]: ../iniciando/setup.mdx

```
git clon -b v20.0.0 https://github.com/stellar/soroban-examples
```

O, omita la configuración del entorno de desarrollo y abre este ejemplo en [Gitpod][oigp].

Para ejecutar las pruebas para el ejemplo, vaya al directorio `cross_contract/contract_b` y use `cargo test`.

```
cd cross_contract/contract_b
prueba de carga
```

Deberías ver la salida:

```
ejecutando 1 prueba
test test::test ... ok
```

## Código

```rust title="cross_contract/contract_a/src/lib.rs"
#[contract]
pub struct ContractA;

#[contractimpl]
impl ContractA {
    pub fn add(x: u32, y: u32) -> u32 {
        x. hecked_add(y).expect("no hay desbordamiento")
    }
}
```

```rust title="cross_contract/contract_b/src/lib.rs"
mod contract_a {
    soroban_sdk::contractimport!(
        file = "../contract_a/target/wasm32-unknown-unknown/release/soroban_cross_contract_a_contract. asm"
    );
}

#[contract]
pub struct ContractB;

#[contractimpl]
impl ContractB {
    pub fn add_with(env: Env, contract: Dirección, x: u32, y: u32) -> u32 {
        let client = contract_a::Client::new(&env, &contract);
        clientes. dd(&x, &y)
    }
}
```

Ref: https://github.com/stellar/soroban-examples/tree/v20.0.0/cross_contract

## Cómo funciona

Las llamadas contractuales cruzadas se hacen invocando otro contrato mediante su ID del contrato.

Los contratos para invocar pueden ser importados en su contrato con el uso de `contractimport!(file = "...")`. La importación generará código:

- Un tipo de `ContractClient` que puede ser utilizado para invocar funciones en el contrato.
- Cualquier tipo de contrato que fueron anotados con `#[contracttype]`.

:::tip

¡El `contractimport! macro generará los tipos en el módulo que se utiliza, así que es una buena idea para usar la macro dentro de un `mod { ... }\` bloquear, o dentro de su propio archivo, de modo que los nombres de los tipos generados no colisionen con nombres de tipos en su propio contrato.

:::

Abre los archivos de arriba para seguirlos .

### Contrato A: El contrato a ser llamado

El contrato a llamar es el Contrato A. Es un contrato simple que acepta los parámetros `x` y `y`, los agrega juntos y devuelve el resultado.

```rust title="cross_contract/contract_a/src/lib.rs"
#[contract]
pub struct ContractA;

#[contractimpl]
impl ContractA {
    pub fn add(x: u32, y: u32) -> u32 {
        x. hecked_add(y).expect("no hay desbordamiento")
    }
}
```

:::tip

El contrato utiliza el método `checked_add` para asegurarse de que no hay desbordamiento, y si hay desbordamiento, el pánico en lugar de devolver un valor desbordado. Todos los tipos de enteros primitivos de Rust han comprobado las operaciones disponibles como funciones con el prefijo `checked_`.

:::

### Contrato B: El Contrato haciendo la Llamada

El contrato que hace la llamada es el Contrato B. Acepta un ID de contrato que llamará, así como los mismos parámetros para pasar. En muchos contratos el contrato a llamar podría haber sido almacenado como datos del contrato y ser recuperado, pero en este ejemplo simple se está pasando como un parámetro cada vez.

El contrato importa el Contrato A en el módulo `contract_a`.

El `contract_a::Client` está construido apuntando al ID del contrato pasado.

El cliente se utiliza para ejecutar la función `add` con los parámetros `x` y `y` en Contract A.

```rust title="cross_contract_calls/src/a.rs"
mod contract_a {
    soroban_sdk::contractimport!(
        file = "../contract_a/target/wasm32-unknown-unknown/release/soroban_cross_contract_a_contract. asm"
    );
}

#[contract]
pub struct ContractB;

#[contractimpl]
impl ContractB {
    pub fn add_with(env: Env, contract: Dirección, x: u32, y: u32) -> u32 {
        let client = contract_a::Client::new(&env, &contract);
        clientes. dd(&x, &y)
    }
}
```

### Tests

Abre el archivo `cross_contract/contract_b/src/test.rs` para seguir la instrucción .

```rust title="cross_contract/contract_b/src/test.rs"
#[test]
fn test() {
    let env = Env::default();

    // Registrar contrato A usando el Wasm importado.
    let contract_a_id = env. egister_contract_wasm(None, contract_a::Wasm);

    // Registrar el contrato B definido en esta caja.
    let contract_b_id = env. egister_contract(None, ContractB);

    // Crear un cliente para llamar al contrato B.
    let client = ContractBClient::new(&env, &contract_b_id);

    // Invocar contrato B a través de su cliente. El contrato B invocará el contrato A.
    let sum = cliente. dd_with(&contract_a_id, &5, &7);
    assert_eq!(sum, 12);
}
```

En cualquier prueba lo primero que siempre se requiere es un `Env`, que es el entorno Soroban en el que se ejecutará el contrato.

```rust
let env = Env::default();
```

El contrato A está registrado en el medio ambiente utilizando el Wasm importado.

```rust
let contract_a_id = env.register_contract_wasm(None, contract_a::Wasm);
```

El contrato B se registra en el entorno utilizando el tipo de contrato.

```rust
let contract_b_id = env.register_contract(None, ContractB);
```

Todas las funciones públicas dentro de un bloque `impl` que está anotado con el atributo `#[contractimpl]` tienen una función correspondiente generada en un tipo de cliente generado. El tipo de cliente se nombrará igual que el tipo de contrato con `Client` adjunto. Por ejemplo, en nuestro contrato el tipo de contrato es `ContractB`, y el cliente se llama `ContractBClient`. El cliente puede ser construido y utilizado de la misma manera que el cliente generado para el Contrato A.

```rust
let cliente = ContractBClient::new(&env, &contract_b_id);
```

El cliente se utiliza para invocar la función `add_with` en el Contrato B. El contrato B invocará el Contrato A, y el resultado será devuelto.

```rust
let suma = client.add_with(&contract_a_id, &5, &7);
```

La prueba confirma que el resultado que se devuelve es el que esperamos.

```rust
assert_eq!(sum, 12);
```

## Construir los contratos

Para construir el contrato en un archivo `.wasm`, utiliza el comando `stellar contract build`. Tanto `contract_call/contract_a` como `contract_call/contract_b` deben construirse, con `contract_a` en primer lugar.

```sh
construcción de contrato estelar
```

Ambos archivos `.wasm` deben encontrarse en ambos directorios `target` del contrato después de construir ambos contratos:

```
objetivo/wasm32-unknown-unknown/release/soroban_cross_contract_a_contract.wasm
```

```
objetivo/wasm32-unknown-unknown/release/soroban_cross_contract_b_contract.wasm
```

## Ejecutar el contrato

Si tienes instalado [`stellar-cli`], puedes invocar las funciones de contrato. Ambos contratos deben ser desplegados.

<Tabs groupId="platform" defaultValue={getPlatform()}>

<TabItem value="unix" label="macOS/Linux">

```sh
despliegue de contrato estelar \
    --wasm target/wasm32-unknown-unknown/release/soroban_cross_contract_a_contract.wasm \
    --id a
```

```sh
despliegue de contrato estelar \
    --wasm target/wasm32-unknown-unknown/release/soroban_cross_contract_b_contract.wasm \
    --id b
```

</TabItem>

<TabItem value="windows" label="Windows (PowerShell)">

```powershell
despliegue de contrato estelar `
    --wasm target/wasm32-unknown-unknown/release/soroban_cross_contract_a_contract.wasm `
    --id a
```

```powershell
despliegue de contrato estelar `
    --wasm target/wasm32-unknown-unknown/release/soroban_cross_contract_b_contract.wasm `
    --id b
```

</TabItem>

</Tabs>

Invoca la función `add_with` de B, pasando los valores para `x` y `y` (e. . como `5` y `7`), y luego pasar el ID del contrato de contrato A.

<Tabs groupId="platform" defaultValue={getPlatform()}>

<TabItem value="unix" label="macOS/Linux">

```sh
contrato estelar invoca \
    --id b \
    -- \
    add_with \
    --contract_id a \
    --x 5 \
    --y 7
```

</TabItem>

<TabItem value="windows" label="Windows (PowerShell)">

```powershell
contrato estelar invoca `
    --id b `
    -- `
    add_with `
    --contract_id a `
    --x 5 `
    --y 7
```

</TabItem>

</Tabs>

La siguiente salida debería ocurrir usando el código anterior.

```json
12
```

La función `add_with` del contrato B invocó la función `add` del contrato A para hacer la adición.

[`stellar-cli`]: ../getting-started/setup.mdx#install-the-stellar-cli

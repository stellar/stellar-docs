---
title: Cuenta personalizada
description: Implementar un contrato de cuenta soportando políticas de autorización múltiple y personalizada.
sidebar_position: 150
---

<head>
  <title>
    {`Implementar un contrato de cuenta apoyando políticas de autorización múltiple y personalizada
    . }
  </title>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="Implementar un contrato de cuenta apoyando políticas de autorización múltiple y personalizadas."
  />
  <meta
    property="og:description"
    content="Implementar un contrato simple que soporte políticas de autorización multiplicables y personalizables; las cuentas personalizadas se pueden utilizar con el marco de autenticación y son exclusivas de Soroban."
  />
</head>

El [ejemplo de cuenta personalizada] demuestra cómo implementar un contrato de cuenta simple que soporta políticas de autorización multisig y personalizables. Este contrato de cuenta puede ser utilizado con el framework de autenticación Soroban, para que en cualquier momento en que se utilice una 'Dirección' que apunta a esta instancia del contrato, se aplique la lógica personalizada implementada aquí.

Las cuentas personalizadas son exclusivas de Soroban y no se pueden utilizar para realizar otras operaciones estelares.

:::danger

Implementar un contrato de cuenta personalizado requiere una muy buena comprensión de la autenticación y autorización y requiere pruebas y revisión rigurosas. El ejemplo aquí es _no_ un contrato de cuenta completo - úsalo como referencia de la API.

:::

:::caution

Mientras que las cuentas personalizadas están soportadas por el protocolo Stellar y Soroban SDK, el soporte completo del cliente (como simulación de transacciones) todavía está en desarrollo.

:::

[![Abrir en Gitpod](https://gitpod.io/button/open-in-gitpod.svg)][oigp]

[oigp]: https://gitpod.io/#https://github.com/stellar/soroban-examples/tree/v20.0.0
[ejemplo de cuenta personalizada]: https://github.com/stellar/soroban-examples/tree/v20.0.0/account

## Ejecutar el ejemplo

Primero pasa por el proceso [Setup] para configurar tu entorno de desarrollo, luego clona la etiqueta `v20.0.0` del repositorio `soroban-examples`:

[configuración]: ../iniciando/setup.mdx

```
git clon -b v20.0.0 https://github.com/stellar/soroban-examples
```

O, omita la configuración del entorno de desarrollo y abre este ejemplo en [Gitpod][oigp].

Para ejecutar las pruebas para el ejemplo use `cargo test`.

```
prueba de carga -p soroban-contrato de cuenta
```

Deberías ver la salida:

```
ejecutando 1 prueba
test test::test_token_auth ... ok
```

## Cómo funciona

Abre el archivo `account/src/lib.rs` para seguir la sección.

Los contratos de cuenta implementan una función especial `__check_auth` que toma el contexto de carga de firmas, firmas y autorización. La función debe tener un error si la autenticación es rechazada, de lo contrario la autenticación será aprobada.

Este contrato de ejemplo utiliza ed25519 claves para la verificación de firmas y soporta múltiples firmantes igualmente ponderados. También implementa una política que permite establecer límites por token en las transferencias. El token sólo se puede gastar más allá del límite si se proporciona cada firma.

Por ejemplo, el usuario puede inicializar este contrato con 2 claves e introducir un límite de gasto de 100 USDC. De esta manera pueden usar una sola clave para firmar sus invocaciones de contrato y asegurarse de que incluso si firman una transacción maliciosa no gastarán más de 100 USDC.

### Inicialización

```rust
#[contracttype]
#[derive(Clone)]
enum DataKey {
    SignerCnt,
    Signer(BytesN<32>),
    SpendLimit(BytesN<32>),
}
...
// Inicializa el contrato con una lista de ed25519 clave pública ('signners').
pub fn init(env: Env, signers: Vec<BytesN<32>>) {
    // En realidad esto necesitaría alguna validación adicional en los firmantes
    // (deduplicación, etc. .
    para firmante en signers.iter() {
        env.storage(). nstance().set(&DataKey::Signer(signer), &());
    }
    env. torage()
        .instance()
        .set(&DataKey::SignerCnt, &signers.len());
}
```

Este contrato de cuenta necesita trabajar con las claves públicas explícitamente. Aquí inicializamos el contrato con ed25519 llaves.

### Modificación de la política

```rust
// Agrega un límite en cualquier transferencia de token que no esté firmada por cada firmante.
pub fn add_limit(env: Env, token: BytesN<32>, límite: i128) {
    // La dirección actual del contrato es la dirección del contrato de cuenta y tiene
    // la misma semántica para la llamada `require_auth` que cualquier otra cuenta
    // dirección del contrato.
    // Observe que si un contrato *invoca * otro contrato, entonces
    // autorizaría la llamada en su propio nombre y eso no requeriría ninguna verificación
    // del lado del usuario.
    env.current_contract_address(). equire_auth();
    env.storage()
            . nstance()
            .set(&DataKey::SpendLimit(token), &limit);
}
```

Esta función permite a los usuarios establecer y modificar el límite de gasto por token descrito anteriormente. El truco aquí es que `require_auth` puede ser usado para el `current_contract_address()`, i.e. el contrato de cuenta puede ser utilizado para verificar la autorización de sus propias funciones administrativas. De esta manera no hay necesidad de escribir la lógica de autorización y autenticación duplicada.

### `__check_auth`

```rust
pub fn __check_auth(
    env: Env,
    signature_payload: BytesN<32>,
    signatures: Vec<Signature>,
    auth_context: Vec<Context>,
) -> Result<(), AccError> {
    // Perform authentication.
    authenticate(&env, &signature_payload, &signatures)?;

    let tot_signers: u32 = env
        .storage()
        .instance()
        .get::<_, u32>(&DataKey::SignerCnt)
        .unwrap();
    let all_signed = tot_signers == signatures.len();

    let curr_contract = env.current_contract_address();

    // This is a map for tracking the token spend limits per token. This
    // makes sure that if e.g. multiple `transfer` calls are being authorized
    // for the same token we still respect the limit for the total
    // transferred amount (and not the 'per-call' limits).
    let mut spend_left_per_token = Map::<Address, i128>::new(&env);
    // Verify the authorization policy.
    for context in auth_context.iter() {
        verify_authorization_policy(
            &env,
            &context,
            &curr_contract,
            all_signed,
            &mut spend_left_per_token,
        )?;
    }
    Ok(())
}
```

`__check_auth` es una función especial que implementan los contratos de la cuenta. Será llamado por el entorno Soroban cada vez que `require_auth` o `require_auth_for_args` sea llamado para la dirección del contrato de cuenta.

Aquí se aplica en dos pasos. Primero, la autenticación se realiza utilizando el payload de firma y un vector de firmas. En segundo lugar, la política de autorización se aplica usando el vector `auth_context`. Este vector contiene todas las llamadas de contrato que están siendo autorizadas por las firmas proporcionadas.

`__check_auth` es una función reservada y sólo puede ser llamada por el entorno Soroban en respuesta a una llamada a `require_auth`. Cualquier llamada directa a `__check_auth` fallará. Esto hace que sea seguro escribir en el almacenamiento del contrato de cuenta desde `__check_auth`, ya que está garantizado que no sea llamado en un contexto inesperado. En este ejemplo es posible persistir en los límites de gasto sin preocuparse de que se agoten a través de un mal actor llamando a `__check_auth` directamente.

### Autenticación

```rust
fn authenticate(
    env: &Env,
    signature_payload: &BytesN<32>,
    signatures: &Vec<Signature>,
) -> Result<(), AccError> {
    for i in 0..signatures.len() {
        let signature = signatures.get_unchecked(i);
        if i > 0 {
            let prev_signature = signatures.get_unchecked(i - 1);
            if prev_signature.public_key >= signature.public_key {
                return Err(AccError::BadSignatureOrder);
            }
        }
        if !env
            .storage()
            .instance()
            .has(&DataKey::Signer(signature.public_key.clone()))
        {
            return Err(AccError::UnknownSigner);
        }
        env.crypto().ed25519_verify(
            &signature.public_key,
            &signature_payload.clone().into(),
            &signature.signature,
        );
    }
    Ok(())
}
```

La autenticación aquí simplemente comprueba que las firmas proporcionadas son válidas dado el payload y también que pertenecen a los firmantes de este contrato de cuenta.

### Política de autorización

```rust
fn verify_authorization_policy(
    env: &Env,
    context: &Context,
    curr_contract: &Dirección,
    all_signed: bool,
    spend_left_per_token: &mut Map<Address, i128>,
) -> Resultado<(), AccError> {
    // Para el control de la cuenta cada firmante debe firmar la invocación.
    let contract_context = match context {
        Context::Contract(c) => {
            if &c. ontract == curr_contract {
                if ! ll_signed {
                    return Error(AccError::NotEnoughSigners);
                }
            }
            c
        }
        Context::CreateContractHostFn(_) => return Error(AccError::InvalidContext),
};
```

Verificamos la política por `Context`. ej. Por una llamada `require_auth`. La póliza para el contrato de cuenta misma obliga a cada firmante a haber firmado la llamada de método.

```rust
// Otherwise, we're only interested in functions that spend tokens.
if contract_context.fn_name != TRANSFER_FN
    && contract_context.fn_name != Symbol::new(env, "approve")
{
    return Ok(());
}

let spend_left: Option<i128> =
    if let Some(spend_left) = spend_left_per_token.get(contract_context.contract.clone()) {
        Some(spend_left)
    } else if let Some(limit_left) = env
        .storage()
        .instance()
        .get::<_, i128>(&DataKey::SpendLimit(contract_context.contract.clone()))
    {
        Some(limit_left)
    } else {
        None
    };

// 'None' means that the contract is outside of the policy.
if let Some(spend_left) = spend_left {
    // 'amount' is the third argument in both `approve` and `transfer`.
    // If the contract has a different signature, it's safer to panic
    // here, as it's expected to have the standard interface.
    let spent: i128 = contract_context
        .args
        .get(2)
        .unwrap()
        .try_into_val(env)
        .unwrap();
    if spent < 0 {
        return Err(AccError::NegativeAmount);
    }
    if !all_signed && spent > spend_left {
        return Err(AccError::NotEnoughSigners);
    }
    spend_left_per_token.set(contract_context.contract.clone(), spend_left - spent);
}
Ok(())
```

Luego comprobamos los nombres estándar de las funciones de tokens y verificamos que para estas funciones no excedamos los límites de gasto.

### Tests

Abre el archivo [`account/src/test.rs`] para seguir al pie de la letra.

[`cuenta/src/test.rs`]: https://github.com/stellar/soroban-examples/tree/v20.0.0/account/src/test.rs

Consulte otros ejemplos de información general sobre la configuración de pruebas.

Aquí sólo observamos algunos puntos específicos de los contratos de cuenta.

```rust
fn sign(e: &Env, signer: &Keypair, payload: &BytesN<32>) -> RawVal {
    Signature {
        public_key: signer_public_key(e, signer),
        signature: signer
            .sign(payload.to_array().as_slice())
            .to_bytes()
            .into_val(e),
    }
    .into_val(e)
}
```

A diferencia de la mayoría de los contratos que pueden usar simplemente 'Dirección', los contratos de cuenta tratan con la verificación de la firma y por lo tanto necesitan firmar realmente las cargas útiles.

```rust
let payload = BytesN::random(&env);
let token = BytesN::random(&env);
env.try_invoke_contract_check_auth::<AccError>(
    &account_contract.address.contract_id(),
    &payload,
    &vec![&env, sign(&env, &signers[0], &payload)],
    &vec![
        &env,
        token_auth_context(&env, &token, Symbol::new(&env, "transfer"), 1000),
    ],
)
.unwrap();
```

`__check_auth` no puede ser llamado directamente como funciones regulares del contrato, por lo tanto necesitamos usar la utilidad de prueba `try_invoke_contract_check_auth` que emula ser llamada por el host Soroban durante una llamada `require_auth`.

```rust
// Agrega un límite de gasto de 1000 por 1 firmante.
account_contract. dd_limit(&token, &1000);
// Verificar que esta llamada necesita ser autorizada.
assert_eq!(
    env. uths(),
    std::vec![(
        account_contract.address. sola(),
        AuthorizedInvocation {
            funtion: AuthorizedFunction::Contract((
                account_contract. ddress. sola(),
                simbolo corto! "add_limit"),
                (token. sola(), 1000_i128). nto_val(&env),
            )),
            sub_invocations: std::vec! ]
        }
    )]
);
```

La verificación del error específico del contrato a `try_invoke_contract_check_auth` permite verificar el código de error exacto y se asegura de que la verificación ha fallado debido a que no tiene suficientes firmas y no por ninguna otra razón.

Es una buena idea que el contrato de cuenta tenga códigos de error detallados y verifique que son devueltos cuando se esperan.

```rust
assert_eq!(
    env.try_invoke_contract_check_auth::<AccError>(
        &account_contract.address.contract_id(),
        &payload,
        &vec![&env, sign(&env, &signers[0], &payload)],
        &vec![
            &env,
            token_auth_context(&env, &token, Symbol::new(&env, "transfer"), 1001)
        ],
    )
    .err()
    .unwrap()
    .unwrap(),
    AccError::NotEnoughSigners
);
```

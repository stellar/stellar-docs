---
title: Desplegador
description: Despliegue e inicialice un contrato inteligente utilizando otro contrato inteligente.
sidebar_position: 70
---

<head>
  <title>
    {`Despliega e inicializa un contrato inteligente usando otro contrato inteligente. }
  </title>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="Despliega e inicializa un contrato inteligente utilizando otro contrato inteligente."
  />
  <meta
    property="og:description"
    content="Despliega un contrato inteligente en nombre de cualquier otra dirección usando el SDK `deployer()` e inicialízalo atómico."
  />
</head>

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { getPlatform } from "@site/src/helpers/getPlatform";

El [ejemplo de despliegue] demuestra cómo desplegar contratos utilizando un contrato.

Aquí desplegamos un contrato en nombre de cualquier dirección e inicializarlo atómicamente.

[![Abrir en Gitpod](https://gitpod.io/button/open-in-gitpod.svg)][oigp]

:::info

En este ejemplo hay dos contratos que se compilan por separado, y las pruebas utilizan uno con el otro.

:::

[oigp]: https://gitpod.io/#https://github.com/stellar/soroban-examples/tree/v20.0.0
[ejemplo del desplegador]: https://github.com/stellar/soroban-examples/tree/v20.0.0/deployer

## Ejecutar el ejemplo

Primero pasa por el proceso [Setup] para configurar tu entorno de desarrollo, luego clona la etiqueta `v20.0.0` del repositorio `soroban-examples`:

[configuración]: ../iniciando/setup.mdx

```
git clon -b v20.0.0 https://github.com/stellar/soroban-examples
```

O, omita la configuración del entorno de desarrollo y abre este ejemplo en [Gitpod][oigp].

Para ejecutar las pruebas para el ejemplo, vaya al directorio `deployer/deployer`, y use `cargo test`.

```
Cd desplegador/despliegue
prueba de carga
```

Deberías ver la salida:

```
ejecutando 1 prueba
test test::test ... ok
```

## Código

```rust title="deployer/deployer/src/lib.rs"
#[contract]
pub struct Deployer;

#[contractimpl]
impl Deployer {
    /// Despliega el contrato Wasm y después de implementar invoca la función init
    /// del contrato con los argumentos dados.
    ///
    /// Esto tiene que ser autorizado por `deployer` (a menos que la instancia `Deployer`
    /// en sí misma sea usada como deployer). De esta manera toda la operación es atómica
    /// y no es posible iniciar el contrato.
    ///
    /// Devuelve la dirección del contrato y el resultado de la función init.
    pub desplegado (
        env: Env,
        desplegador: Dirección,
        wasm_hash: BytesN<32>,
        sal: BytesN<32>,
        init_fn: Symbol,
        init_args: Vec<Val>,
    ) -> (Dirección, Val) {
        // Omitir autorización si el deployer es el contrato actual.
        si el desplegador != env. urrent_contract_address() {
            deployer. equire_auth();
        }

        // Despliega el contrato usando el Wasm subido con un hash dado.
        let deployed_address = env
            . eployer()
            . ith_address(deployer, salt)
            . eploy(wasm_hash);

        // Invoca la función init con los argumentos dados.
        let res: Val = env. nvoke_contract(&deployed_address, &init_fn, init_args);
        // Devuelve el ID del contrato desplegado y el resultado de
        // invocando el resultado inicial.
        (deployed_address, res)
    }
}
```

Ref: https://github.com/stellar/soroban-examples/tree/v20.0.0/deployer

## Cómo funciona

Los contratos pueden desplegar otros contratos utilizando el método SDK `deployer()`.

La dirección del contrato del contrato desplegado es determinista y se deriva de la dirección del despliegue. El despliegue también tiene que ser autorizado por el desplegador.

Abre el archivo `deployer/deployer/src/lib.rs` para seguir aún.

### Subida de Contrato de Wasm

Antes de desplegar las nuevas instancias de contrato, el código Wasm necesita ser cargado en cadena. Entonces se puede utilizar para desplegar un número arbitrario de instancias contractuales. La carga debería ocurrir típicamente fuera del contrato del desplegador, ya que tiene que suceder una sola vez. Sin embargo, es posible usar la función `env.deployer().upload_contract_wasm()` para subir Wasm de un contrato también.

Vea la [tests](#tests) para ver un ejemplo de subida del código del contrato de forma programada. Para la instalación actual en cadena vea la implementación general [tutorial](../../smart-contracts/getting-started/deploy-to-testnet.mdx).

### Autorización

:::info

Esta sección puede ser omitida para contratos de fábrica que implementan otro contrato desde su propia dirección (\`deployer == env.current_contract_address()\`\`).

:::

:::info

Para la introducción de la autorización de Soroban vea el [tutorial de auth](./auth.mdx).

:::

Comenzamos con la verificación de la autorización del «despliegue», a menos que su contrato actual (en cuyo punto se implique la autorización).

```rust
if deployer != env.current_contract_address() {
    deployer.require_auth();
}
```

Mientras que `deployer(). ith_address()` también realiza la autorización, queremos asegurarnos de que `deployer` también ha autorizado toda la operación, además del despliegue también realiza la inicialización atómica del contrato. Si no requerimos autorización del despliegue aquí, entonces sería posible dirigir la operación de despliegue realizada por `deployer` e inicializarla de forma diferente, rompiendo así la promesa de la inicialización atómica.

Ver más detalles sobre las cargas útiles de autorización en [tests](#tests).

### `deployer()`

La función SDK `deployer()` viene con unas cuantas utilidades relacionadas con el despliegue . Aquí usamos el tipo de implementador más genérico `with_address(deployer_address, salt)`.

```rust
let deployed_address = env
    .deployer()
    .with_address(deployer, salt)
    .deploy(wasm_hash);
```

`with_address()` acepta la dirección `deployer` y sal. Ambos se utilizan para derivar la dirección del contrato desplegado de forma determinada. No es posible volver a desplegar un contrato ya existente.

La función `deploy()` realiza el despliegue real usando el `wasm_hash` proporcionado. La implementación del nuevo contrato es definida por el archivo Wasm subido bajo `wasm_hash`.

:::tip

Sólo el `wasm_hash` en sí mismo se almacena por documento de identidad, ahorrando así el espacio y las comisiones del notario.

:::

Cuando sólo desplegar el contrato en nombre del contrato actual, es decir, cuando la dirección `deployer` es siempre `env. urrent_contract_address()` es posible usar la función `deployer().with_current_contract(salt)` para brevedad.

### Inicialización

El contrato puede llamarse inmediatamente después del despliegue, lo que es útil para la inicialización.

```rust
let res: Val = env.invoke_contract(&deployed_address, &init_fn, init_args);
```

`invoke_contract` puede llamar a cualquier función de contrato definido con cualquier argumento. Pasamos la función real a llamar y los argumentos de las entradas `deploy`. El resultado puede ser cualquier valor, dependiendo del valor devuelto de `init_fn`.

Si la inicialización falla, entonces toda la llamada `deploy` cae y por lo tanto el contrato no se desplegará. Este comportamiento es necesario también para la garantía de inicialización atómica.

El contrato devuelve la dirección del contrato desplegado y el resultado de la ejecución de la función de inicialización.

```rust
 (dirección_desplegada, res)
```

### Tests

Abre el archivo `deployer/deployer/src/test.rs` para seguir aún.

Importe el contrato de prueba Wasm para ser desplegado.

```rust
// El contrato que será desplegado por el contrato de despliegue.
contracto mod {
    soroban_sdk::contractimport!
        archivo =
            ". /contract/target/wasm32-unknown-unknown/release/soroban_deployer_test_contract.wasm"
    );
}
```

Ese contrato contiene el siguiente código que exporta dos funciones: la función de inicialización que toma un valor y una función getter para el valor inicializado almacenado.

```rust title="deployer/contract/src/lib.rs"
#[contract]
pub struct Contract;

const KEY: Symbol = symbol_short! "valor");

#[contractimpl]
impl Contract {
    pub fn init(env: Env, value: u32) {
        env. torage().instance(). et(&KEY, &value);
    }
    pub fn value(env: Env) -> u32 {
        env. torage().instance().get(&KEY).unwrap()
    }
}
```

Este contrato de prueba se utilizará cuando se pruebe el implementador. El contrato de despliegue desplegará el contrato de prueba e invocará su función 'init'.

Hay dos pruebas: despliegue desde el contrato actual sin autorización y despliegue desde una dirección arbitraria con autorización. Además de la autorización, estas pruebas son muy similares.

#### Despliegue de contrato actual

En la primera prueba desplegamos el contrato de la instancia del contrato `Desployer`.

```rust
#[test]
fn test_deploy_from_contract() {
    let env = Env::default();
    let deployer_client = DeployerClient::new(&env, &env. egister_contract(None, Deployer));

    // Subir el Wasm para ser desplegado desde el contrato del deployer.
    // Esto también se puede llamar desde dentro de un contrato si es necesario.
    let wasm_hash = env.deployer(). pload_contract_wasm(contract::WASM);

    // Despliega el contrato usando el deployer, e incluye una función init para llamar.
    let sal = BytesN::from_array(&env, &[0; 32]);
    let init_fn = symbol_short! "init");
    let init_fn_args: Vec<Val> = (5u32,). nto_val(&env);
    let (contract_id, init_result) = deployer_client.deploy(
        &deployer_client. ddress,
        &wasm_hash,
        &sal,
        &init_fn,
        &init_fn_args,
    ); ¡

    de aserto! resultado_inicio. s_void());
    // No se necesitan autorizaciones - el contrato actúa como una fábrica.
    assert_eq!(env.auths(), vec![]);

    // Invocar contrato para verificar que está inicializado.
    let client = contract::Client::new(&env, &contract_id);
    let sum = cliente. alue();
    assert_eq!(sum, 5);
}
```

En cualquier prueba lo primero que siempre se requiere es un `Env`, que es el entorno Soroban en el que se ejecutará el contrato.

```rust
let env = Env::default();
```

Registre el contrato de implementación con el entorno y cree un cliente para él.

```rust
let deployer_client = DeployerClient::new(&env, &env.register_contract(None, Deployer));
```

Suba el código del contrato de prueba que hemos importado anteriormente a través de `contractimport!` y obtenga el hash del código Wasm subido.

```rust
let wasm_hash = env.deployer().upload_contract_wasm(contract::WASM);
```

El cliente se utiliza para invocar la función `deploy`. El contrato desplegará el contrato de prueba utilizando el hash de su código Wasm, llamará a la función `init` y pasará en un solo argumento `5u32`. El valor de retorno esperado de la función `init` es sólo `void` (es decir, sin valor).

```rust
let salt = BytesN::from_array(&env, &[0; 32]);
let init_fn = symbol_short!("init");
let init_fn_args: Vec<Val> = (5u32,).into_val(&env);
let (contract_id, init_result) = deployer_client. eploy(
    &deployer_client. ddress,
    &wasm_hash,
    &sal,
    &init_fn,
    &init_fn_args,
);
```

La prueba comprueba que el contrato de prueba fue desplegado usando su cliente para invocarlo y recuperar el valor establecido durante la inicialización.

```rust
let client = contract::Client::new(&env, &contract_id);
let sum = client.value();
assert_eq!(sum, 5);
```

#### Despliegue externo

La segunda prueba es muy similar a la primera.

```rust
#[test]
fn test_deploy_from_address() {
    let env = Env::default();
    let deployer_client = DeployerClient::new(&env, &env.register_contract(None, Deployer));

    // Upload the Wasm to be deployed from the deployer contract.
    // This can also be called from within a contract if needed.
    let wasm_hash = env.deployer().upload_contract_wasm(contract::WASM);

    // Define a deployer address that needs to authorize the deployment.
    let deployer = Address::random(&env);

    // Deploy contract using deployer, and include an init function to call.
    let salt = BytesN::from_array(&env, &[0; 32]);
    let init_fn = symbol_short!("init");
    let init_fn_args: Vec<Val> = (5u32,).into_val(&env);
    env.mock_all_auths();
    let (contract_id, init_result) =
        deployer_client.deploy(&deployer, &wasm_hash, &salt, &init_fn, &init_fn_args);

    assert!(init_result.is_void());

    let expected_auth = AuthorizedInvocation {
        // Top-level authorized function is `deploy` with all the arguments.
        function: AuthorizedFunction::Contract((
            deployer_client.address,
            symbol_short!("deploy"),
            (
                deployer.clone(),
                wasm_hash.clone(),
                salt,
                init_fn,
                init_fn_args,
            )
                .into_val(&env),
        )),
        // From `deploy` function the 'create contract' host function has to be
        // authorized.
        sub_invocations: vec![AuthorizedInvocation {
            function: AuthorizedFunction::CreateContractHostFn(CreateContractArgs {
                contract_id_preimage: ContractIdPreimage::Address(ContractIdPreimageFromAddress {
                    address: deployer.clone().try_into().unwrap(),
                    salt: Uint256([0; 32]),
                }),
                executable: xdr::ContractExecutable::Wasm(xdr::Hash(wasm_hash.into_val(&env))),
            }),
            sub_invocations: vec![],
        }],
    };
    assert_eq!(env.auths(), vec![(deployer, expected_auth)]);

    // Invoke contract to check that it is initialized.
    let client = contract::Client::new(&env, &contract_id);
    let sum = client.value();
    assert_eq!(sum, 5);
}
```

La principal diferencia es que el contrato está desplegado en nombre de la dirección arbitraria.

```rust
// Define una dirección de despliegue que necesita autorizar el despliegue.
let deployer = Address::random(&env);
```

Antes de invocar el contrato necesitamos habilitar la autorización simulada para obtener la carga útil de autorización registrada que podamos verificar.

```rust
env.mock_all_auths();
let (contract_id, init_result) =
        deployer_client.deploy(&deployer, &wasm_hash, &salt, &init_fn, &init_fn_args);
```

El árbol de autorización esperado para el `deployer` se ve como sigue.

```rust
let expected_auth = AuthorizedInvocation {
    // Top-level authorized function is `deploy` with all the arguments.
    function: AuthorizedFunction::Contract((
        deployer_client.address,
        symbol_short!("deploy"),
        (
            deployer.clone(),
            wasm_hash.clone(),
            salt,
            init_fn,
            init_fn_args,
        )
            .into_val(&env),
    )),
    // From `deploy` function the 'create contract' host function has to be
    // authorized.
    sub_invocations: vec![AuthorizedInvocation {
        function: AuthorizedFunction::CreateContractHostFn(CreateContractArgs {
            contract_id_preimage: ContractIdPreimage::Address(ContractIdPreimageFromAddress {
                address: deployer.clone().try_into().unwrap(),
                salt: Uint256([0; 32]),
            }),
            executable: xdr::ContractExecutable::Wasm(xdr::Hash(wasm_hash.into_val(&env))),
        }),
        sub_invocations: vec![],
    }],
};
```

En el nivel superior tenemos la función `deploy` en sí misma con todos los argumentos que le hemos pasado. Desde la función `deploy` el `CreateContractHostFn` tiene que ser autorizado. Este es el payload de autorización que tiene que ser autorizado por cualquier desplegador en cualquier contexto. Contiene la dirección del despliegue, la sal y el ejecutable.

Este árbol de autorización demuestra que el despliegue y la inicialización están autorizados atómicamente: el despliegue real ocurre dentro del contexto de `deploy` y todo de sal, , y los argumentos de inicialización son autorizados juntos (i. . Hay una firma para autorizar esta combinación exacta).

Luego nos aseguramos de que el desplegador ha autorizado el árbol esperado y que el valor esperado ha sido almacenado.

```rust
assert_eq!(env.auths(), vec![(deployer, expected_auth)]);

let client = contract::Client::new(&env, &contract_id);
let sum = client.value();
assert_eq!(sum, 5);
```

## Construir los contratos

Para construir el contrato en un archivo `.wasm`, utiliza el comando `stellar contract build`. Construya tanto el contrato de despliegue como el contrato de prueba.

```sh
construcción de contrato estelar
```

Ambos archivos `.wasm` deben encontrarse en ambos directorios `target` del contrato después de construir ambos contratos:

```
objetivo/wasm32-unknown-unknown/release/soroban_deployer_contract.wasm
```

```
objetivo/wasm32-unknown-unknown/release/soroban_deployer_test_contract.wasm
```

## Ejecutar el contrato

Si tienes instalado [`stellar-cli`], puedes invocar la función de contrato para desplegar el contrato de prueba.

Antes de implementar el contrato de prueba con el implementador, instale el contrato de prueba Wasm usando el comando `install`. El comando `install` imprimirá el hash derivado del archivo Wasm (no es sólo el hash del archivo Wasm en sí mismo) que debe ser usado por el implementador.

```sh
stellar contract install --wasm contract/target/wasm32-unknown-unknown/release/soroban_deployer_test_contract.wasm
```

El comando imprime el hash como hex. Se verá algo como `7792a624b562b3d9414792f5fb5d72f53b9838fef2ed9a901471253970bc3b15`.

También necesitamos desplegar el contrato `Desployer`:

```sh
stellar contract deploy --wasm deployer/target/wasm32-unknown-unknown/release/soroban_deployer_contract.wasm --id 1
```

Esto devolverá la dirección del desplegador: `CAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD2KM`.

Entonces el contrato de despliegue puede ser invocado con el valor hash de Wasm arriba.

<Tabs groupId="platform" defaultValue={getPlatform()}>

<TabItem value="unix" label="macOS/Linux">

```sh
stellar contract invoke --id 1 -- deploy \
    --deployer CAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKM
    --salt 123 \
    --wasm_hash 7792a624b562b3d9414792f5fb5d72f53b9838fef2ed9a901471253970bc3b15 \
    --init_fn init \
    --init_args '[{"u32":5}]'
```

</TabItem>

<TabItem value="windows" label="Windows (PowerShell)">

```powershell
contrato estelar invoca --id 1 -- despliegue `
    --deployer CAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKM
    --salt 123 `
    --wasm_hash 7792a624b562b3d9414792f5fb5d72f53b9838fef2ed9a901471253970bc3b15 `
    --init_fn init `
    --init_args '[{"u32":5}]'
```

</TabItem>

</Tabs>

Y luego invocar el contrato de prueba desplegado usando el identificador devuelto desde el comando anterior.

<Tabs groupId="platform" defaultValue={getPlatform()}>

<TabItem value="unix" label="macOS/Linux">

```sh
contrato estelar invoca \
    --id ead19f55aec09bfcb555e09f230149ba7f72744a5fd639804ce1e934e8fe9c5d \
    -- valor \

```

</TabItem>

<TabItem value="windows" label="Windows (PowerShell)">

```powershell
contrato estelar invoca `
    --id ead19f55aec09bfcb555e09f230149ba7f72744a5fd639804ce1e934e8fe9c5d `
    -- ` Valor

```

</TabItem>

</Tabs>

La siguiente salida debería ocurrir usando el código anterior.

```json
5
```

[`stellar-cli`]: ../getting-started/setup.mdx#install-the-stellar-cli

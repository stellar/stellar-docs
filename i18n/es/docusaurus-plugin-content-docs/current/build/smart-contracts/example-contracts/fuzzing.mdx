---
title: Prueba de Fuzz
description: Aumenta la confianza en la exactitud de un contrato con pruebas de fuzz.
sidebar_position: 160
---

<head>
  <title>
    {`Aumenta la confianza en la corrección de un contrato con pruebas de fuzz. }
  </title>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="Incrementar la confianza en la corrección de un contrato con las pruebas de fuzzz."
  />
  <meta
    property="og:description"
    content="Fuzz prueba contratos inteligentes con cargo-fuzz y personaliza el input para pruebas de fuzz con crates arbitrarios; demostrar cómo adaptar las pruebas de fuzz a las pruebas de propiedades reutilizables."
  />
</head>

El [ejemplo difuso] demuestra cómo probar los contratos de Soroban con [`cargo-fuzz`] y personalizar la entrada a las pruebas de fuzz con la caja [`arbitrary`]. También demuestra cómo adaptar las pruebas de fuzz a las pruebas de propiedad reutilizable con las cajas [`proptest`] y [`proptest-arbitrary-interop`]. Se basa en el [ejemplo de timelock].

[![Abrir en Gitpod](https://gitpod.io/button/open-in-gitpod.svg)][oigp]

[oigp]: https://gitpod.io/#https://github.com/stellar/soroban-examples/tree/v20.0.0
[ejemplo de fuzzing]: https://github.com/stellar/soroban-examples/tree/v20.0.0/fuzzing
[`cargo-fuzz`]: https://docs.rs/cargo-fuzz
[`arbitrario`]: https://docs.rs/arbitrario
[`probeta`]: https://docs.rs/proptest
[`proptest-arbitrary-interop`]: https://docs.rs/proptest-arbitrary-interop
[ejemplo de timelock]: https://github.com/stellar/soroban-examples/tree/v20.0.0/timelock

## Ejecutar el ejemplo

Primero pasa por el proceso [setup] para configurar tu entorno de desarrollo, luego clona la etiqueta `v20.0.0` del repositorio `soroban-examples`:

[configuración]: ../iniciando/setup.mdx

```sh
git clon -b v20.0.0 https://github.com/stellar/soroban-examples
```

También necesitarás la herramienta `cargo-fuzz`, y para ejecutar `cargo-fuzz` necesitarás una toolchain de Rust nocturna:

```sh
carga instalar cargo-fuzz
rustup instalar de forma nocturna
```

Para ejecutar una de las pruebas de fuzz, navega al directorio `fuzzing` y ejecuta el subcomando `cargo fuzz` con la toolchain `nightly`:

```sh
cd fuzzing
carga +nightly fuzz run fuzz_target_1
```

:::info

Si estás desarrollando en MacOS, puede que necesites añadir la bandera `--sanitizer=thread` para corregir algunos [errores de enlace conocidos](https://github.com/stellar/rs-soroban-sdk/issues/1056).

:::

Deberías ver la salida que comienza así:

```console
$ carga +nightly fuzz run fuzz_target_1
   Compilación soroban-fuzzing-contract v0.0.0 (/home/azureuser/data/stellar/soroban-examples/fuzzing)
   Compilación soroban-fuzzing-contract-fuzzer v0. .0 (/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz)
    Finalizada versión [optimizada + debuginfo] objetivo(s) en 23. 4s
    Finalizada versión [optimizada + debuginfo] objetivo(s) en 0. 7s
     Ejecutando `fuzz/target/x86_64-unknown-linux-gnu/release/fuzz_target_1 ...`
INFO: Ejecutar con programa de potencia entropica (0xFF, 100).
INFO: Semilla: 886588732
INFO: módulos cargados 1 (1093478 contadores en línea de 8-bits): 1093478 [0x55eb8e2c7620, 0x55eb8e3d2586),
INFO: 1 tablas de PC cargadas (1093478 PCs): 1093478 [0x55eb8e3d2588, x55eb8f481be8),
INFO: 105 archivos encontrados en /home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/corpus/fuzz_target_1
INFO: -max_len no es proporcionado; libFuzzer no generará entradas mayores de 4096 bytes
INFO: seed corpus: files: 105 min: 32b max: 61b total: 3558b rss: 86Mb
#2 pulse ft: 8355 exec/s: 1 rss: 307Mb
#4 pulse cov: 8354 ft: 11014 cadáver: 1/32b exec/s: 2 rss: 313Mb
#8 pulse cov: 8495 ft: 12420 corp: 4/128b exec/s: 4 rss: 315Mb
```

El resto de este tutorial explicará cómo configurar esta prueba fuzz, interpretar esta salida y remediar fallas difusas.

## Fondo de fondo: Prueba Fuzz y Rust

Fuzzing es una especie de prueba donde las nuevas entradas se alimentan repetidamente en un programa con la esperanza de encontrar errores inesperados. Este estilo de prueba se utiliza comúnmente para aumentar la confianza en la exactitud del software sensible a la seguridad.

En Rust, el fuzzing se realiza más a menudo con la herramienta [`cargo-fuzz`], que maneja LLVM [`libfuzzer`], aunque otras herramientas de difuminación están disponibles.

[`libfuzzer`]: https://llvm.org/docs/LibFuzzer.html

Soroban tiene soporte incorporado para la eliminación de contratos de Soroban con `cargo-fuzz`.

`cargo-fuzz` es un fuzzer basado en mutación: ejecuta un programa de prueba, pasando la entrada generada; mientras el programa se está ejecutando, los monitoreos difusos que toman las ramas del programa, y qué funciones ejecuta; después de la ejecución, el fuzzer utiliza esta información para tomar decisiones sobre cómo _mutate_ la entrada usada anteriormente para crear una nueva entrada que podría descubrir más ramas y funciones; entonces ejecuta la prueba de nuevo con nueva entrada, repitiendo este proceso para potencialmente millones de iteraciones. De esta manera `cargo-fuzz` es capaz de explorar automáticamente las rutas de ejecución a través del programa que puede nunca ser visto por otros tipos de pruebas.

Si un fuzz prueba pánicos o choques duros, `cargo-fuzz` lo considera un fallo y proporciona instrucciones para repetir la prueba con las entradas fallidas.

Las pruebas Fuzz son típicamente un proceso exploratorio e interactivo, con el programador devising esquemas para producir entradas que enfatizarán el programa de maneras interesantes. observando el comportamiento de la prueba fuzz, e iterando en la propia prueba.

Resolver un fallo de prueba de fuzz normalmente implica capturar la entrada problemática en una prueba unitaria. La prueba de fuzz en sí misma puede ser o no, dependiendo de las determinaciones sobre el costo de mantener el fuzzer vs la probabilidad de que continúe encontrando errores en el futuro.

Mientras que la difuminación de software no seguro para la memoria tiende a ser más lucrativa que la difuminación de software Rust todavía es relativamente común encontrar el pánico y otros errores lógicos en Rust a través de la difusión.

En Rust, varios fuzzers son mantenidos por la organización [`rust-fuzz`] de GitHub, que también mantiene un "caso trofeo" de errores de Rust encontrados a través de difusión.

[`fuzz`]: https://github.com/rust-fuzz

## Sobre el ejemplo

El ejemplo utilizado para este tutorial se basa en el programa de ejemplo [`timelock`], con algunos cambios para demostrar la difusión.

[`timelock`]: https://github.com/stellar/soroban-examples/tree/v20.0.0/timelock

El contrato, `ClaimableBalanceContract`, permite a una parte depositar una cantidad arbitraria de una ficha al contrato, especificando adicionalmente: los `reclamantes`, direcciones que pueden retirarse del contrato; y el `time_bound`, una especificación de cuándo estos reclamantes pueden retirarse de la cuenta.

El tipo `TimeBound` se ve como

```rust
#[derive(Clone)]
#[contracttype]
pub struct TimeBound {
    pub kind: TimeBoundKind,
    hora del pub: u64,
}

#[derive(Clone)]
#[contracttype]
pub enum TimeBoundKind {
    Antes,
    Después,
}
```

`ClaimableBalanceContract` tiene dos métodos, `deposit` y `claim`:

```rust
    pub fn deposit(
        env: Env,
        desde: Dirección,
        token: Dirección,
        monto: i128,
        reclamantes: Vec<Address>,
        time_limund: TimeBound,
    );

    reclamo de pub fn (
        env: Env,
        reclamante: Dirección,
        monto: i128,
);
```

`depit` sólo puede llamarse una vez con éxito, después de lo cual `reclamar` puede ser llamado varias veces hasta que el saldo esté completamente borrado, En ese momento el contrato se vuelve inactivo y ya no se puede utilizar.

## Configuración de Prueba Fuzz

Para estos ejemplos, se han creado las pruebas de fuzz para ti, pero normalmente usarías el comando `cargo fuzz init` para crear un proyecto difuminado como un subdirectorio del contrato bajo prueba.

Para hacer eso navegaría al directorio del contrato, en este caso, `soroban-examples/fuzzing`, y ejecutaría

```sh
init carga fuzz
```

Un proyecto `cargo-fuzz` es su propia caja, que vive en el subdirectorio `fuzz` de la caja que se está probando. Esta caja tiene su propio `Cargo.toml` y `Cargo.lock`, y otro subdirectorio, `fuzz_targets`, que contiene programas de Rust, cada uno de ellos su propia prueba fuzz.

Nuestro directorio `soroban-examples/fuzzing` parece

- `Cargo.toml` - este es el manifiesto del contrato
- `Carga.lock`
- `src`
  - `lib.rs` - este es el código del contrato
- `fuzz` - esta es la caja difusa
  - `Cargo.toml` - esto es el manifiesto de la cuna difusa
  - `Carga.lock`
  - `fuzz_targets`
    - `fuzz_target_1.rs` - esta es una única prueba de fuzz
    - `fuzz_target_2.rs`

Hay consideraciones especiales que hay que tener en cuenta en la configuración del [manifiesto del contrato] y del [manifiesto de la caja difusa].

[manifiesto del contrato]: https://github.com/stellar/soroban-examples/tree/v20.0.0/fuzzing/Cargo.toml
[manifiesto de la caja difuminada]: https://github.com/stellar/soroban-examples/tree/v20.0.0/fuzzing/fuzz/Cargo.toml

Dentro del manifiesto del contrato se debe especificar el tipo de caja como "cdylib" y "rlib":

```toml
[package]
nombre = "soroban-fuzzing-contract"
versión = "0.0.0"
autores = ["Stellar Development Foundation <info@stellar.org>"]
licencia = "Apache-2. "
edition = "2021"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]
doctest = false

[features]
testutils = []
```

En la mayoría de los ejemplos, un contrato de Soroban sólo será una "cdylib", una caja de Rust que se compile a un módulo de lavado cargado dinámicamente. Sin embargo, para la difusión, la caja difusa necesita ser capaz de enlazar con la caja del contrato como una biblioteca de Rust, una "rlib".

:::note

Ten en cuenta que la carga tiene una [función/error que inhibe LTO][lto] de cdylibs cuando una caja es tanto "cdylib" como "rlib". Esto se puede trabajar construyendo el contrato con `soroban contract build` o `carga rustc --crate-type cdylib` en lugar de la típica `carga build`.

:::

[lto]: https://github.com/stellar/soroban-docs/pull/476

La caja del contrato también debe proporcionar la función "testutils". Cuando se activa "testutils", la macro Soroban SDK [`contracttype`] emite código adicional necesario para ejecutar pruebas fuzz.

[`contracttype`]: https://docs.rs/soroban-sdk/latest/soroban_sdk/attr.contracttype.html

Dentro del manifiesto de la caja difusa se deben activar las características de "testutils" tanto en la caja del contrato como en la caja `soroban-sdk`:

```toml
[package]
name = "soroban-fuzzing-contract-fuzzer"
versión = "0.0. "
publish = false
edition = "2021"

[package.metadata]
cargo-fuzz = true

[dependencies]
libfuzzer-sys = "0. "
soroban-sdk = { version = "20.0.0", features = ["testutils"] }

[dependencies.soroban-fuzzing-contract]
path = ".."
features = ["testutils"]
```

## Prueba de Fuzz Simple

Primero veamos [`fuzz_target_1.rs`]. Esta prueba fuzz hace dos cosas: primero deposita una cantidad arbitraria, luego reclama una cantidad arbitraria.

[`fuzz_target_1.rs`]: https://github.com/stellar/soroban-examples/tree/v20.0.0/fuzzing/fuzz/fuzz_targets/fuzz_targets/fuzz_target_1.rs

De nuevo, puedes ejecutar este fuzzer desde el directorio `soroban-examples/fuzzing` con el siguiente comando:

```sh
carga + fuzz nocturno ejecutar fuzz_target_1
```

El punto de entrada y el código de configuración para las pruebas fuzz del contrato de Soroban normalmente se verán como:

```rust
#[derive(Arbitrary, Debug)]
struct Input {
    deposit_amount: i128,
    claim_amount: i128,
}

fuzz_target! |input: Input| {
    let env = Env::default();

    env. ock_all_auths();

    env.ledger(). et(LedgerInfo {
        timestamp: 12345,
        protocol_version: 1,
        sequence_number: 10,
        network_id: Por defecto (),
        base_reserve: 10,
    });

    // Desactiva el presupuesto de CPU/memoria para pruebas.
    env.budget().reset_unlimited();

    // ... hacer fuzzing aquí ...
}
```

En lugar de una función `main`, `cargo-fuzz` utiliza un punto de entrada especial definido por la macro [`fuzz_target!`]. Esta macro acepta un cierre de Rust que acepta `input`, cualquier tipo de Rust que implemente el rasgo [`Arbitrary`]. Aquí hemos definido una estructura, `Input`, que deriva `Arbitrary`.

[`fuzz_target!`]: https://docs.rs/libfuzzer-sys/latest/libfuzzer_sys/macro.fuzz_target.html
[`arbitrario`]: https://docs.rs/arbitrary/latest/arbitrary/trait.Arbitrary.html

`cargo-fuzz` será responsable de generar `input` y llamar repetidamente a este cierre.

Para probar un contrato de Soroban, debemos establecer un [`Env`]. Tenga en cuenta que hemos desactivado el presupuesto de CPU y memoria: esto nos permitirá generar rutas de código arbitrariamente complejas sin preocuparse por quedarse sin presupuesto; podemos asumir que el agotamiento del presupuesto durante una transacción siempre falla, cancelando la transacción; no es algo que debamos alimentar.

[`env`]: https://docs.rs/soroban-sdk/latest/soroban_sdk/struct.Env.html

Consulte el [`fuzz_target_1.rs`] código fuente para configuración adicional para este contrato.

Este fuzzer realiza dos pasos: depósito, luego reclamar:

```rust
    // Deposit, then assert invariants.
    {
        let _ = fuzz_catch_panic(|| {
            timelock_client.deposit(
                &depositor_address,
                &token_contract_id,
                &input.deposit_amount,
                &vec![
                    &env,
                    claimant_address.clone(),
                ],
                &TimeBound {
                    kind: TimeBoundKind::Before,
                    timestamp: 123456,
                },
            );
        });

        assert_invariants(
            &env,
            &timelock_contract_id,
            &token_client,
            &input
        );
    }

    // Claim, then assert invariants.
    {
        let _ = fuzz_catch_panic(|| {
            timelock_client.claim(
                &claimant_address,
                &input.claim_amount,
            );
        });

        assert_invariants(
            &env,
            &timelock_contract_id,
            &token_client,
            &input
        );
    }
```

Hay una serie de estrategias potenciales para escribir pruebas de fuzz. La estrategia de esta prueba es hacer llamadas arbitrarias, posiblemente extrañas y poco realistas, al contrato, ignorar si esas llamadas tienen éxito o fracasan, y luego hacer afirmaciones sobre el estado del contrato.

Debido a que hay muchos casos potenciales de fallo para cualquier llamada contractual, no queremos escribir una prueba de fuzz intentando interpretar el éxito o fracaso de una llamada dada: esa ruta lleva a duplicar la lógica del contrato dentro de la prueba fuzz. En su lugar, sólo queremos asegurarnos de que, independientemente de lo ocurrido durante la ejecución, el contrato nunca se quede en un estado inválido.

Tenga en cuenta el uso de la función [`fuzz_catch_panic`] para invocar el contrato: Esta es una función especial en el SDK Soroban para interceptar pánicos de una manera que funciona con `cargo-fuzz`, y es necesario para llamar a funciones de contrato que podrían fallar. Sin `fuzz_catch_panic` una persona dentro de un contrato causará inmediatamente que la prueba fuzz falle, pero en la mayoría de los casos una persona dentro de un contrato no indica un fallo - es simplemente cómo un contrato de Soroban cancela una transacción. `fuzz_catch_panic` devuelve un `Result`, pero aquí lo descartamos.

[`fuzz_catch_panic`]: https://docs.rs/soroban-sdk/latest/soroban_sdk/testutils/arbitrary/fn.fuzz_catch_panic.html

Finalmente, la función `assert_invariants` es donde hacemos cualquier afirmación que podamos sobre el estado del contrato:

```rust
/// Directly inspect the contract state and make assertions about it.
fn assert_invariants(
    env: &Env,
    timelock_contract_id: &Address,
    token_client: &TokenClient,
    input: &Input,
) {
    // Configure the environment to access the timelock contract's storage.
    env.as_contract(timelock_contract_id, || {
        let storage = env.storage();

        // Get the two datums owned by the timelock contract.
        let is_initialized = storage.has(&DataKey::Init);
        let claimable_balance = storage.get::<_, ClaimableBalance>(&DataKey::Balance);

        // Call the token client to get the balance held in the timelock contract.
        // This consumes contract execution budget.
        let actual_token_balance = token_client.balance(timelock_contract_id);

        // There can only be a claimaible balance after the contract is initialized,
        // but once the balance is claimed there is no balance,
        // but the contract remains initialized.
        // This is a truth table of valid states.
        assert!(match (is_initialized, claimable_balance.is_some()) {
            (false, false) => true,
            (false, true) => false,
            (true, true) => true,
            (true, false) => true,
        });

        assert!(actual_token_balance >= 0);

        if let Some(claimable_balance) = claimable_balance {
            let claimable_balance = claimable_balance.expect("balance");

            assert!(claimable_balance.amount > 0);
            assert!(claimable_balance.amount <= input.deposit_amount);
            assert_eq!(claimable_balance.amount, actual_token_balance);

            assert!(claimable_balance.claimants.len() > 0);
        }
    });
}
```

## Interpretando la salida `cargo-fuzz`

Si ejecutas `cargo-fuzz` con `fuzz_target_1`, desde dentro del directorio `soroban-examples/fuzzing`, verás una salida similar a:

```console
$ cargo +nightly fuzz run fuzz_target_1
   Compiling soroban-fuzzing-contract v0.0.0 (/home/azureuser/data/stellar/soroban-examples/fuzzing)
   Compiling soroban-fuzzing-contract-fuzzer v0.0.0 (/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz)
    Finished release [optimized + debuginfo] target(s) in 25.18s
    Finished release [optimized + debuginfo] target(s) in 0.08s
     Running `fuzz/target/x86_64-unknown-linux-gnu/release/fuzz_target_1 -artifact_prefix=/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/artifacts/fuzz_target_1/ /home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/corpus/fuzz_target_1`
INFO: Running with entropic power schedule (0xFF, 100).
INFO: Seed: 1384064486
INFO: Loaded 1 modules   (1122058 inline 8-bit counters): 1122058 [0x561f6ecd4fc0, 0x561f6ede6eca),
INFO: Loaded 1 PC tables (1122058 PCs): 1122058 [0x561f6ede6ed0,0x561f6ff05f70),
INFO:      173 files found in /home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/corpus/fuzz_target_1
INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes
INFO: seed corpus: files: 173 min: 32b max: 61b total: 6039b rss: 83Mb
#4      pulse  cov: 4848 ft: 10214 corp: 1/32b exec/s: 2 rss: 313Mb
#8      pulse  cov: 8507 ft: 11743 corp: 4/128b exec/s: 4 rss: 315Mb
#16     pulse  cov: 8512 ft: 12393 corp: 10/320b exec/s: 8 rss: 319Mb
thread '<unnamed>' panicked at 'assertion failed: claimable_balance.amount > 0', fuzz_targets/fuzz_target_1.rs:130:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
==6102== ERROR: libFuzzer: deadly signal
    #0 0x561f6ae3a431  (/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/target/x86_64-unknown-linux-gnu/release/fuzz_target_1+0x1c80431) (BuildId: 6a95a932984a405ebab8171dddc9f812fdf16846)
    #1 0x561f6e3855b0  (/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/target/x86_64-unknown-linux-gnu/release/fuzz_target_1+0x51cb5b0) (BuildId: 6a95a932984a405ebab8171dddc9f812fdf16846)
    #2 0x561f6e35c08a  (/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/target/x86_64-unknown-linux-gnu/release/fuzz_target_1+0x51a208a) (BuildId: 6a95a932984a405ebab8171dddc9f812fdf16846)
    #3 0x7fce05f5e08f  (/lib/x86_64-linux-gnu/libc.so.6+0x4308f) (BuildId: 1878e6b475720c7c51969e69ab2d276fae6d1dee)
    #4 0x7fce05f5e00a  (/lib/x86_64-linux-gnu/libc.so.6+0x4300a) (BuildId: 1878e6b475720c7c51969e69ab2d276fae6d1dee)
    #5 0x7fce05f3d858  (/lib/x86_64-linux-gnu/libc.so.6+0x22858) (BuildId: 1878e6b475720c7c51969e69ab2d276fae6d1dee)
    ...
    #27 0x561f6e3847b9  (/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/target/x86_64-unknown-linux-gnu/release/fuzz_target_1+0x51ca7b9) (BuildId: 6a95a932984a405ebab8171dddc9f812fdf16846)
    #28 0x561f6ad98346  (/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/target/x86_64-unknown-linux-gnu/release/fuzz_target_1+0x1bde346) (BuildId: 6a95a932984a405ebab8171dddc9f812fdf16846)
    #29 0x7fce05f3f082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 1878e6b475720c7c51969e69ab2d276fae6d1dee)
    #30 0x561f6ad9837d  (/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/target/x86_64-unknown-linux-gnu/release/fuzz_target_1+0x1bde37d) (BuildId: 6a95a932984a405ebab8171dddc9f812fdf16846)

NOTE: libFuzzer has rudimentary signal handlers.
      Combine libFuzzer with AddressSanitizer or similar for better crash reports.
SUMMARY: libFuzzer: deadly signal
MS: 0 ; base unit: 0000000000000000000000000000000000000000
0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5d,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff,0x5f,0x5f,0x52,0xff,
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000]\000\000\000\000\000\000\000\000\377__R\377
artifact_prefix='/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/artifacts/fuzz_target_1/'; Test unit written to /home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/artifacts/fuzz_target_1/crash-04704b1542f61a21a4649e39023ec57ff502f627
Base64: AAAAAAAAAAAAAAAAAAAAAAAAXQAAAAAAAAAA/19fUv8=

────────────────────────────────────────────────────────────────────────────────

Failing input:

        fuzz/artifacts/fuzz_target_1/crash-04704b1542f61a21a4649e39023ec57ff502f627

Output of `std::fmt::Debug`:

        Input {
            deposit_amount: 0,
            claim_amount: -901525218878596739118967460911579136,
        }

Reproduce with:

        cargo fuzz run fuzz_target_1 fuzz/artifacts/fuzz_target_1/crash-04704b1542f61a21a4649e39023ec57ff502f627

Minimize test case with:

        cargo fuzz tmin fuzz_target_1 fuzz/artifacts/fuzz_target_1/crash-04704b1542f61a21a4649e39023ec57ff502f627

────────────────────────────────────────────────────────────────────────────────

Error: Fuzz target exited with exit status: 77
```

Esto es un fallo difuso, indicando un error en el fuzzer o en el programa. Los detalles serán diferentes.

Aquí está la misma salida, con líneas menos importantes recortadas:

```
thread '<unnamed>' pánico en 'asertion failed: claimable_balance.amount > 0', fuzz_targets/fuzz_target_1.rs:130:13
...
Entrada fallida:

        fuzz/artifacts/fuzz_target_1/crash-04704b1542f61a21a4649e39023ec57ff502f627

Salida de `std::fmt::Debug`:

        Entrada {
            deposit_amount: 0,
            claim_amount: -901525218878596739118967460911579136,
        }

Reproduce con:

        cargamento fuzz run fuzz_target_1 fuzz/artifacts/fuzz_target_1/crash-04704b1542f61a4649e39023ec57ff502f627

Minimiza caso de prueba con:

        cargo fuzz tmin fuzz_target_1 fuzz/artifacts/fuzz_target_1/crash-04704b1542f61a21a4649e39023ec57ff50
```

La primera línea aquí está impresa por nuestro programa Rust e indica exactamente dónde el pánico fuzzer. Las líneas posteriores indican cómo reproducir este caso fallido.

Lo primero que hay que hacer cuando se obtiene un fallo difuminado es copiar el comando para reproducir el fallo, para que puedas usarlo para depurar:

```sh
carga +fuzz fuzz_target_1 fuzz/artifacts/fuzz_target_1/crash-04704b1542f61a21a4649e39023ec57ff502f627
```

Observe sin embargo que necesitamos decirle a `cargo` que use la toolchain nocturno con la bandera `+nightly`, algo que `cargo-fuzz` no imprime en su versión del comando.

Otra cosa a notar es que por defecto, `cargo-fuzz` / `libfuzzer` no imprime los nombres de las funciones en su salida, como en el stack trace:

```
==6102== ERROR: libFuzzer: señal mortal
    #0 0x561f6ae3a431 (/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/target/x86_64-unknown-linux-gnu/release/fuzz_target_1+0x1c80431) (BuildId: 6a95a932984a405ebab8171dddc9f812fdf16846)

    #28 0x561f6ad98346 (/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzzing/fuzz/target/x86_64-unknown-linux-gnu/release/fuzz_target_1+0x1bde346) (BuildId: 6a95a932984a405ebab8171dddc9f812fdf16846)
    #29 0x7fce05f3f082 (/lib/x86_64-linux-gnu/libc. o.6+0x24082) (BuildId: 1878e6b475720c7c51969e69ab2d276fae6d1dee)
    #30 0x561f6ad9837d (/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/target/x86_64-unknown-linux-gnu/release/fuzz_target_1+0x1bde37d) (BuildId: 6a952984a405ebab8171dddc9f812fdf16846)
```

Dependiendo de cómo esté configurado su sistema, puede o no tener este problema. Para imprimir stack traces, `libfuzzer` necesita el programa `llvm-symbolizer`. En sistemas basados en Ubuntu, esto se puede instalar con el paquete `llvm-dev`:

```sh
sudo apt install llvm-dev
```

Después de lo cual `libfuzzer` imprimirá nombres de función desglosados en lugar de direcciones:

```
==6323== ERROR: libFuzzer: señal mortal
    #0 0x557c9da6a431 en __sanitizer_print_stack_trace /rustc/llvm/src/llvm-project/compiler-rt/lib/asan/asan_stack.cp:87:3
    #1 0x557ca0fb55b0 en fuzzer::PrintStackTrace() /home/azureuser/.cargo/registry/src/index. rates.io-6f17d22bba15001f/libfuzzer-sys-0.4.5/libfuzzer/FuzzerUtil.cp:210:38
    #2 0x557ca0f8c08a in fuzzer::Fuzzer::CrashCallback() /home/azureuser/.cargo/registry/src/index.crates.io-6f17d22bba15001f/libfuzzer-sys-0.4.5/libfuzzer/FuzzerLoop. pp:233:18
    #3 0x557ca0f8c08a in fuzzer::Fuzzer::CrashCallback() /home/azureuser/.cargo/registry/src/index.crates.io-6f17d22bba15001f/libfuzzer-sys-0.4.5/libfuzzer/FuzzerLoop.cpp:228:6
    #4 0x7ff19e84d08f (/lib/x86_64-linux-gnu/libc.so. +0x4308f) (BuildId: 1878e6b475720c7c51969e69ab2d276fae6d1dee)
    #5 0x7ff19e84d00a en __libc_signal_restore_set /build/glibc-SzIz7B/glibc-2.31/signal/../sysdeps/unix/sysv/linux/internal-signals.h:86:3
    #6 0x7ff19e84d00a en raise /build/glibc-SzIz7B/glibc-2.31/signal/../sysdeps/unix/sysv/linux/raise. :48:3
    #7 0x7ff19e82c858 in abort /build/glibc-SzIz7B/glibc-2.31/stdlib/abort.c:79:7
    ...
    #23 0x557c9daee89a en fuzz_target_1::assert_invariants::hd6d4f9549b01c31c /home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/fuzz_targets/fuzz_target_fuzz_target_1. s:103:5
    #24 0x557c9daee89a in fuzz_target_1::_::run::hac1117cb3dfecb2b /home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/fuzz_targets/fuzz_target_1.rs:69:9
    #25 0x557c9daecea6 en rust_fuzzer_test_input /home/azureuser/.cargo/registry/src/index. rates.io-6f17d22bba15001f/libfuzzer-sys-0.4.5/src/lib.rs:297:60
    ...
    #37 0x557c9d9c8346 en main /home/azureuser/.cargo/registry/src/index. rates.io-6f17d22bba15001f/libfuzzer-sys-0.4.5/libfuzzer/FuzzerMain.cp:20:30
    #38 0x7ff19e82e082 en __libc_start_main /build/glibc-SzIz7B/glibc-2. 1/csu/../csu/libc-start.c:308:16
    #39 0x557c9d9c837d en _start (/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzzing/fuzz/target/x86_64-unknown-linux-gnu/release/fuzz_target_1+0x1bde37d) (BuildId: 6a95a932984a405ebab8171dddc9f812fdf16846)
```

Para continuar, nuestro programa tiene un error que debería ser fácil de arreglar inspeccionando el error y haciendo una ligera modificación de la fuente.

Una vez solucionado el error, el fuzzer se ejecutará continuamente, produciendo salida que parece

```console
$ cargo +nightly fuzz run fuzz_target_1
   Compiling soroban-fuzzing-contract v0.0.0 (/home/azureuser/data/stellar/soroban-examples/fuzzing)
   Compiling soroban-fuzzing-contract-fuzzer v0.0.0 (/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz)
    Finished release [optimized + debuginfo] target(s) in 24.91s
    Finished release [optimized + debuginfo] target(s) in 0.08s
     Running `fuzz/target/x86_64-unknown-linux-gnu/release/fuzz_target_1 -artifact_prefix=/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/artifacts/fuzz_target_1/ /home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/corpus/fuzz_target_1`
INFO: Running with entropic power schedule (0xFF, 100).
INFO: Seed: 1619748028
INFO: Loaded 1 modules   (1122061 inline 8-bit counters): 1122061 [0x5647a55b9080, 0x5647a56caf8d),
INFO: Loaded 1 PC tables (1122061 PCs): 1122061 [0x5647a56caf90,0x5647a67ea060),
INFO:      173 files found in /home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/corpus/fuzz_target_1
INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes
INFO: seed corpus: files: 173 min: 32b max: 61b total: 6039b rss: 85Mb
#2      pulse  ft: 8067 exec/s: 1 rss: 312Mb
#4      pulse  cov: 8068 ft: 10709 corp: 1/32b exec/s: 2 rss: 315Mb
#8      pulse  cov: 8476 ft: 11498 corp: 5/160b exec/s: 4 rss: 317Mb
#16     pulse  cov: 8512 ft: 12362 corp: 9/288b exec/s: 8 rss: 320Mb
#32     pulse  cov: 8516 ft: 13290 corp: 19/608b exec/s: 10 rss: 326Mb
#64     pulse  cov: 8516 ft: 13311 corp: 27/864b exec/s: 21 rss: 340Mb
#128    pulse  cov: 8540 ft: 13536 corp: 37/1196b exec/s: 25 rss: 365Mb
#175    INITED cov: 8540 ft: 13580 corp: 42/1387b exec/s: 29 rss: 382Mb
#177    NEW    cov: 8545 ft: 13821 corp: 43/1419b lim: 48 exec/s: 29 rss: 384Mb L: 32/48 MS: 1 ChangeASCIIInt-
#178    NEW    cov: 8545 ft: 13824 corp: 44/1451b lim: 48 exec/s: 29 rss: 384Mb L: 32/48 MS: 1 ChangeBinInt-
#229    NEW    cov: 8545 ft: 13826 corp: 45/1483b lim: 48 exec/s: 38 rss: 401Mb L: 32/48 MS: 1 ChangeByte-
#256    pulse  cov: 8545 ft: 13826 corp: 45/1483b lim: 48 exec/s: 36 rss: 410Mb
#361    NEW    cov: 8545 ft: 13830 corp: 46/1521b lim: 48 exec/s: 40 rss: 451Mb L: 38/48 MS: 5 ShuffleBytes-CMP-EraseBytes-CopyPart-ChangeBinInt- DE: "\005\000\000\000"-
        NEW_FUNC[1/1]: 0x5647a2964640 in rand::rngs::adapter::reseeding::ReseedingCore$LT$R$C$Rsdr$GT$::reseed_and_generate::ha760ded93293681c /home/azureuser/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rand-0.7.3/src/rngs/adapter/reseeding.rs:235
#368    NEW    cov: 8557 ft: 13842 corp: 47/1566b lim: 48 exec/s: 40 rss: 454Mb L: 45/48 MS: 2 CrossOver-InsertRepeatedBytes-
#512    pulse  cov: 8557 ft: 13842 corp: 47/1566b lim: 48 exec/s: 46 rss: 502Mb
#850    NEW    cov: 8557 ft: 13843 corp: 48/1610b lim: 48 exec/s: 53 rss: 591Mb L: 44/48 MS: 2 CopyPart-ChangeBit-
#1024   pulse  cov: 8557 ft: 13843 corp: 48/1610b lim: 48 exec/s: 56 rss: 645Mb
#1796   NEW    cov: 8557 ft: 13863 corp: 49/1642b lim: 53 exec/s: 71 rss: 669Mb L: 32/48 MS: 1 ChangeBinInt-
#1913   NEW    cov: 8557 ft: 13864 corp: 50/1675b lim: 53 exec/s: 73 rss: 669Mb L: 33/48 MS: 2 ShuffleBytes-InsertByte-
#3749   REDUCE cov: 8557 ft: 13864 corp: 50/1670b lim: 68 exec/s: 98 rss: 669Mb L: 39/48 MS: 1 EraseBytes-
...
```

Y esta salida continuará hasta que el fuzzer sea asesinado con `Ctrl-C`.

A continuación, veamos una sola línea de salida difusor:

```
#177 NUEVA cov: 8545 pies: 13821 cadáver: 43/1419b lim: 48 exec/s: 29 rss: 384Mb L: 32/48 MS: 1 ChangeASCIIInt-
```

La columna más importante aquí es `cov`. Esta es una medida acumulativa de ramas cubiertas por el fuzzer. Cuando este número deja de aumentar el fuzzer probablemente haya explorado tanto del programa como pueda. Las otras columnas se describen en la [`libfuzzer` documentation][lfout].

[lfout]: https://llvm.org/docs/LibFuzzer.html#salida

Por último, veamos esta advertencia:

```
INFO: no se proporciona -max_len; libFuzzer no generará entradas mayores de 4096 bytes.
```

Por defecto, `libfuzzer` sólo genera entrada de hasta 4096 bytes. En muchos casos, esto es probablemente razonable, pero `cargo-fuzz` puede aumentar el `max_len` añadiendo el argumento después de `--`:

```sh
carga + fuzz nocturno ejecutar fuzz_target_1 -- -max_len=20000
```

Todas las opciones de libfuzzer pueden ser listadas con

```sh
carga + fuzz nocturno ejecutar fuzz_target_1 -- -help=1
```

Vea la [documentación de libfuzzer`] para más.

[documentación de `libfuzzer`]: https://llvm.org/docs/LibFuzzer.html#salida

## Aceptando tipos de Soroban como entrada con el rasgo `SorobanArbitrary`

Las entradas a la macro `fuzz_target!` deben implementar el rasgo [`Arbitrary`], que acepta bytes del controlador fuzzer y los convierte en valores de Rust. Los tipos de soroban sin embargo son gestionados por el entorno anfitrión, y así debe ser creado a partir de un valor [`Env`] que no está disponible para el controlador de fuzzer. El rasgo [`SorobanArbitrary`], implementado para todos los tipos de contratos de Soroban, existe para cerrar esta brecha: define un patrón _prototype_ por el cual la macro `fuzz_target` crea valores prototipos que el programa fuzz puede convertir a valores contractuales con los rasgos de conversión de soroban estándar, [`DeVal`] o [`IntoVal`].

[`sorobanarbitrary`]: https://docs.rs/soroban-sdk/latest/soroban_sdk/testutils/arbitrary/trait.SorobanArbitrary.html
[`dededeval`]: https://docs.rs/soroban-sdk/latest/soroban_sdk/trait.FromVal.html
[`intoval`]: https://docs.rs/soroban-sdk/latest/soroban_sdk/trait.IntoVal.html

Los tipos de prototipos son identificados por el tipo asociado, `SorobanArbitrary::Prototype`:

```rust
rasgo de pub SorobanArbitrary:
    TryFromVal<Env, Self::Prototype> + IntoVal<Env, Val> + TryFromVal<Env, Val>
{
    type Prototype: for <'a> Arbitrary<'a>;
}
```

Los tipos que implementan `SorobanArbitrary` incluyen:

- `i32`, `u32`, `i64`, `u64`, `i128`, `u128`, [`I256`], [`U256`], `()`y `bool`,
- [`Error`],
- [`Bytes`], [`BytesN`], [`Vec`], [`Map`],
- [`Dirección`], [`Símbolo`],
- [`Val`],

[`i256`]: https://docs.rs/soroban-sdk/latest/soroban_sdk/struct.I256.html
[`u256`]: <https://docs.rs/soroban-sdk/latest/soroban_sdk/struct► 256.html>
[`error`]: https://docs.rs/soroban-sdk/latest/soroban_sdk/xdr/enum.Error.html
[`bytes`]: https://docs.rs/soroban-sdk/latest/soroban_sdk/struct.Bytes.html
[`bytesn`]: https://docs.rs/soroban-sdk/latest/soroban_sdk/struct.BytesN.html
[`vec`]: https://docs.rs/soroban-sdk/latest/soroban_sdk/struct.Vec.html
[`map`]: https://docs.rs/soroban-sdk/latest/soroban_sdk/struct.Map.html
[`dirección`]: https://docs.rs/soroban-sdk/latest/soroban_sdk/struct.Address.html
[`símbolo`]: https://docs.rs/soroban-sdk/latest/soroban_sdk/struct.Symbol.html
[`val`]: https://docs.rs/soroban-sdk/latest/soroban_sdk/struct.Val.html

Todos los tipos de contrato definidos por el usuario, aquellos con el atributo [`contracttype`], derivan automáticamente `SorobanArbitrary`. Tenga en cuenta que `SorobanArbitrary` sólo se deriva cuando la función de Carga de "testutils" está activa. Esto implica que, en general, para hacer difusible un contrato Soroban, la caja del contrato debe definir una característica de Carga "testutils", esa característica debería activar la función "soroban-sdk/testutils", y la prueba fuzz, que es su propia caja, debe encender esa función.

## Prueba de Fuzz más compleja

El ejemplo [`fuzz_target_2.rs`] demuestra el uso de `SorobanArbitrary`, el avance del tiempo y técnicas de difusión.

[`fuzz_target_2.rs`]: https://github.com/stellar/soroban-examples/tree/v20.0.0/fuzzing/fuzz/fuzz_targets/fuzz_targets/fuzz_target_2.rs

Esta prueba fuzz toma una entrada mucho más compleja, donde algunos de los valores son tipos definidos por el usuario exportados del contrato bajo prueba. Esta prueba está estructurada como un simple intérprete, donde el arnés difuso proporciona "pasos" generados arbitrariamente". donde cada paso es un comando `deposit` o un comando `claim`. La prueba trata cada uno de estos pasos como una transacción separada: mantiene una instantánea del estado de la cadena de bloques y para cada paso crea un entorno fresco en el que ejecutar la llamada al contrato, simulando el avance del tiempo entre cada paso. Como en el ejemplo anterior, las afirmaciones se hacen después de cada paso.

La entrada al fuzzer mira, en parte, como:

```rust
#[derive(Arbitrary, Debug)]
struct Input {
    addresses: [<Address as SorobanArbitrary>::Prototype; NUM_ADDRESSES],
    #[arbitrary(with = |u: &mut Unstructured| u.int_in_range(0..=i128::MAX))]
    token_mint: i128,
    steps: RustVec<Step>,
}

#[derive(Arbitrary, Debug)]
struct Step {
    #[arbitrary(with = |u: &mut Unstructured| u.int_in_range(1..=u64::MAX))]
    advance_time: u64,
    command: Command, // `Command` not shown here - see the full source.
}
```

Esto muestra cómo utilizar el tipo asociado `SorobanArbitrary::Prototype` para definir las entradas al fuzzer. Un Soroban [`Address`] sólo puede ser creado con un [`Env`], así que no puede ser generado directamente por el rasgo `Arbitrary`. En su lugar, utilizamos el nombre completo del prototipo `Address`, `<Address as SorobanArbitrary>::Prototype`, para pedir el prototipo de `Address`. Luego, cuando nuestro fuzzer necesita la `Address` la instanciamos con el rasgo [`FromVal`]\:

```rust
let depositor_address = Address::from_val(&env, &input.addresses[cmd.depositor_index]);
```

---

El contrato que estamos eliminando es un contrato _timelock_ en el que el cálculo del tiempo es crucial para la corrección. Por lo tanto, nuestras pruebas deben tener en cuenta el avance del tiempo.

El contrato define un tipo `TimeBound` y lo acepta en el método `deposit`:

```rust
#[derive(Clone, Debug)]
#[contracttype]
pub struct TimeBound {
    pub kind: TimeBoundKind,
    hora del pub: u64,
}

#[contractimpl]
impl ClaimableBalanceContract {
    pub fn deposit(
        env: Env,
        desde: Dirección,
        token: Dirección,
        cantidades: i128,
        reclamantes: Vec<Address>,
        time_limund: TimeBound,
    ) {
        ...
    }
}
```

En nuestro fuzzer, uno de los comandos posibles emitidos cada paso es un `DepositCommand`:

```rust
#[derive(Arbitrary, Debug)]
struct DepositCommand {
    #[arbitrary(with = |u: &mut Unstructured| u.int_in_range(0.. NUM_ADDRESES - 1))]
    depositor_index: usar,
    monto: i128,
    // Esta es una forma fea de obtener un vector de enteros en el rango
    #[arbitrary(with = |u: &mut Unstructured| {
        u. rbitrary_len::<usize>().map(|len| {
            (0. len).map(|_| {
                u. nt_in_range(0..=NUM_ADDRESES - 1)
            }). ollect::<Result<RustVec<usize>, _>>()
        }). nd_then(|inner_result| inner_result)
    })]
    claimant_indexes: RustVec<usize>,
    veces_límite: <TimeBound as SorobanArbitrary>::Prototipo,
}
```

Tenga en cuenta que este comando utiliza de nuevo el tipo asociado `SorobanArbitrary::Prototype` para aceptar un `TimeBound` como entrada.

Para avanzar en el tiempo mantenemos una caja [`LedgerSnapshot`], definida en el cajón [`soroban-ledger-snapshot`]. Para cada paso llamamos a [`Env::from_snapshot`] para crear un entorno fresco para ejecutar el paso, luego [`Env::to_snapshot`] para crear una nueva instantánea para usar en el siguiente paso.

[`ledgersnapshot`]: https://docs.rs/soroban-ledger-snapshot/latest/soroban_ledger_snapshot/struct.LedgerSnapshot.html
[`soroban-ledger-snapshot`]: https://docs.rs/soroban-ledger-snapshot
[`env::desde_snapshot`]: https://docs.rs/soroban-sdk/latest/soroban_sdk/struct.Env.html#method.from_snapshot
[`env::to_snapshot`]: https://docs.rs/soroban-sdk/latest/soroban_sdk/struct.Env.html#method.to_snapshot

He aquí un esquema simplificado de cómo funciona esto. Vea el código fuente completo para más detalles.

```rust
let init_snapshot = {
    let init_ledger = LedgerInfo {
        timestamp: 12345,
        protocol_version: 1,
        secuencia_número: 10,
        network_id: Predeterminado::default(),
        base_reserve: 10,
        min_temp_entry_ttl: u32::MAX,
        min_persistent_entry_ttl: u32::MAX,
    };

    LedgerSnapshot::from(init_ledger, Ninguno)
};

let mut prev_env = Env::from_snapshot(init_snapshot);

for step in &config. en palabra. teps {
    // Avanza el tiempo y crea un nuevo env desde snapshot.
    let curr_env = {
        let mut snapshot = prev_env. o_snapshot();
        snapshot.sequence_number += 1;
        snapshot.timestamp = snapshot.timestamp. aturating_add(step.advance_time);
        let env = Env::from_snapshot(snapshot(snapshot);
        env.budget(). eset_unlimited();
        env
    };

    pasos. ommand.exec(&config, &curr_env);
    prev_env = curr_env;
}
```

## Convirtiendo un test de Fuzz a un test de propiedad

Además de pruebas de fuzz, Soroban soporta pruebas de propiedad en el estilo de chequeo rápido, usando las cajas [`proptest`] y [`proptest-arbitrary-interop`] junto con el rasgo `SorobanArbitrary`.

Las pruebas de propiedad son similares a las pruebas de fuzz en la medida en que generan entradas aleatorias. Las pruebas de propiedad sin embargo no instrumentan sus casos de prueba ni mutan su entrada basándose en la retroalimentación de las pruebas anteriores. Por lo tanto, son una forma de prueba más débil.

Sin embargo, el gran beneficio de las pruebas de propiedad es que pueden ser incluidas en las suites de pruebas estándar de Rust y que no requieren herramientas extra para ejecutar. Uno podría aprovecharse de esto al difuminar interactivamente para descubrir errores profundos, luego convertir las pruebas de fuzz en pruebas de propiedad para ayudar a prevenir regresiones.

El archivo [`proptest.rs`] es una traducción de `fuzz_target_1.rs` a una prueba de propiedad.

[`proptest.rs`]: https://github.com/stellar/soroban-examples/tree/v20.0.0/fuzzing/src/proptest.rs

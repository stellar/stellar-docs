---
title: Herramienta de liquidez
description: Escriba un contrato de liquidez de producto constante.
sidebar_position: 130
---

<head>
  <title>Escriba un contrato de reserva de liquidez de producto constante.</title>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="Escriba un contrato de reserva de liquidez de producto constante."
  />
  <meta
    property="og:description"
    content="Escribe un contrato inteligente de liquidez del grupo de productos constantes."
  />
</head>

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { getPlatform } from "@site/src/helpers/getPlatform";

El [ejemplo de la piscina de liquidez] demuestra cómo escribir un contrato de liquidez de producto constante. Una piscina de liquidez es una forma automatizada de añadir liquidez para un conjunto de fichas que facilitarán la conversión de activos entre ellas. Los usuarios pueden depositar cierta cantidad de cada ficha en la piscina, recibiendo un número proporcional de "fichas compartidas". El usuario recibirá entonces una porción de las comisiones de conversión acumuladas cuando en última instancia "intercambie" sus acciones de token para recibir sus fichas originales.

Las piscinas de liquidez sorobana son exclusivas de Soroban y no pueden interactuar con las piscinas de liquidez Stellar AMM.

:::caution

La implantación de una piscina de liquidez personalizada debe hacerse con cautela. Se trata de fondos de usuarios, por lo que hay que tener mucho cuidado para garantizar la seguridad y la transparencia. El ejemplo aquí _no_ debe considerarse un contrato listo para su uso. Por favor, úselo sólo como referencia.

La red Stellar ya cuenta con la funcionalidad de la piscina de liquidez integrada directamente en el protocolo del núcleo. [Más información aquí](../../../learn/encyclopedia/sdex/liquidity-on-stellar-sdex-liquidity-pools.mdx).

:::

[![Abrir en Gitpod](https://gitpod.io/button/open-in-gitpod.svg)][oigp]

[oigp]: https://gitpod.io/#https://github.com/stellar/soroban-examples/tree/v20.0.0
[ejemplo del pool de liquidez]: https://github.com/stellar/soroban-examples/tree/v20.0.0/liquidity_pool
[código fuente]: https://github.com/stellar/soroban-examples/blob/v20.0.0/liquidity_pool/src/lib.rs#L143

## Ejecutar el ejemplo

Primero pasa por el proceso [Setup] para configurar tu entorno de desarrollo, luego clona la etiqueta `v20.0.0` del repositorio `soroban-examples`:

```sh
git clon -b v20.0.0 https://github.com/stellar/soroban-examples
```

O, omita la configuración del entorno de desarrollo y abre este ejemplo en [Gitpod][oigp].

Para ejecutar las pruebas por ejemplo, navega al directorio `liquidity_pool`, y usa `cargo test`.

```sh
Cd liquidity_pool
prueba de carga
```

Deberías ver la salida:

```sh
ejecutando 1 prueba
test test::test ... ok
```

[configuración]: ../iniciando/setup.mdx

## Código

:::info

Dado que nuestra piscina de liquidez emitirá su propio token para establecer el nuber de acciones en el fondo de la dirección hemos creado un `token. s` módulo en este proyecto para mantener la lógica que controla el contrato de token para esas acciones.

:::

<Tabs>
<TabItem value="lib.rs" default>

```rust title=liquidity_pool/src/lib.rs
#![no_std]

mod test;
mod token;

use num_integer::Roots;
use soroban_sdk::{
    contract, contractimpl, contractmeta, Address, BytesN, ConversionError, Env, IntoVal,
    TryFromVal, Val,
};
use token::create_contract;

#[derive(Clone, Copy)]
#[repr(u32)]
pub enum DataKey {
    TokenA = 0,
    TokenB = 1,
    TokenShare = 2,
    TotalShares = 3,
    ReserveA = 4,
    ReserveB = 5,
}

impl TryFromVal<Env, DataKey> for Val {
    type Error = ConversionError;

    fn try_from_val(_env: &Env, v: &DataKey) -> Result<Self, Self::Error> {
        Ok((*v as u32).into())
    }
}

fn get_token_a(e: &Env) -> Address {
    e.storage().instance().get(&DataKey::TokenA).unwrap()
}

fn get_token_b(e: &Env) -> Address {
    e.storage().instance().get(&DataKey::TokenB).unwrap()
}

fn get_token_share(e: &Env) -> Address {
    e.storage().instance().get(&DataKey::TokenShare).unwrap()
}

fn get_total_shares(e: &Env) -> i128 {
    e.storage().instance().get(&DataKey::TotalShares).unwrap()
}

fn get_reserve_a(e: &Env) -> i128 {
    e.storage().instance().get(&DataKey::ReserveA).unwrap()
}

fn get_reserve_b(e: &Env) -> i128 {
    e.storage().instance().get(&DataKey::ReserveB).unwrap()
}

fn get_balance(e: &Env, contract: Address) -> i128 {
    token::Client::new(e, &contract).balance(&e.current_contract_address())
}

fn get_balance_a(e: &Env) -> i128 {
    get_balance(e, get_token_a(e))
}

fn get_balance_b(e: &Env) -> i128 {
    get_balance(e, get_token_b(e))
}

fn get_balance_shares(e: &Env) -> i128 {
    get_balance(e, get_token_share(e))
}

fn put_token_a(e: &Env, contract: Address) {
    e.storage().instance().set(&DataKey::TokenA, &contract);
}

fn put_token_b(e: &Env, contract: Address) {
    e.storage().instance().set(&DataKey::TokenB, &contract);
}

fn put_token_share(e: &Env, contract: Address) {
    e.storage().instance().set(&DataKey::TokenShare, &contract);
}

fn put_total_shares(e: &Env, amount: i128) {
    e.storage().instance().set(&DataKey::TotalShares, &amount)
}

fn put_reserve_a(e: &Env, amount: i128) {
    e.storage().instance().set(&DataKey::ReserveA, &amount)
}

fn put_reserve_b(e: &Env, amount: i128) {
    e.storage().instance().set(&DataKey::ReserveB, &amount)
}

fn burn_shares(e: &Env, amount: i128) {
    let total = get_total_shares(e);
    let share_contract = get_token_share(e);

    token::Client::new(e, &share_contract).burn(&e.current_contract_address(), &amount);
    put_total_shares(e, total - amount);
}

fn mint_shares(e: &Env, to: Address, amount: i128) {
    let total = get_total_shares(e);
    let share_contract_id = get_token_share(e);

    token::Client::new(e, &share_contract_id).mint(&to, &amount);

    put_total_shares(e, total + amount);
}

fn transfer(e: &Env, token: Address, to: Address, amount: i128) {
    token::Client::new(e, &token).transfer(&e.current_contract_address(), &to, &amount);
}

fn transfer_a(e: &Env, to: Address, amount: i128) {
    transfer(e, get_token_a(e), to, amount);
}

fn transfer_b(e: &Env, to: Address, amount: i128) {
    transfer(e, get_token_b(e), to, amount);
}

fn get_deposit_amounts(
    desired_a: i128,
    min_a: i128,
    desired_b: i128,
    min_b: i128,
    reserve_a: i128,
    reserve_b: i128,
) -> (i128, i128) {
    if reserve_a == 0 && reserve_b == 0 {
        return (desired_a, desired_b);
    }

    let amount_b = desired_a * reserve_b / reserve_a;
    if amount_b <= desired_b {
        if amount_b < min_b {
            panic!("amount_b less than min")
        }
        (desired_a, amount_b)
    } else {
        let amount_a = desired_b * reserve_a / reserve_b;
        if amount_a > desired_a || desired_a < min_a {
            panic!("amount_a invalid")
        }
        (amount_a, desired_b)
    }
}

// Metadata that is added on to the WASM custom section
contractmeta!(
    key = "Description",
    val = "Constant product AMM with a .3% swap fee"
);

pub trait LiquidityPoolTrait {
    // Sets the token contract addresses for this pool
    fn initialize(e: Env, token_wasm_hash: BytesN<32>, token_a: Address, token_b: Address);

    // Returns the token contract address for the pool share token
    fn share_id(e: Env) -> Address;

    // Deposits token_a and token_b. Also mints pool shares for the "to" Identifier. The amount minted
    // is determined based on the difference between the reserves stored by this contract, and
    // the actual balance of token_a and token_b for this contract.
    fn deposit(e: Env, to: Address, desired_a: i128, min_a: i128, desired_b: i128, min_b: i128);

    // If "buy_a" is true, the swap will buy token_a and sell token_b. This is flipped if "buy_a" is false.
    // "out" is the amount being bought, with in_max being a safety to make sure you receive at least that amount.
    // swap will transfer the selling token "to" to this contract, and then the contract will transfer the buying token to "to".
    fn swap(e: Env, to: Address, buy_a: bool, out: i128, in_max: i128);

    // transfers share_amount of pool share tokens to this contract, burns all pools share tokens in this contracts, and sends the
    // corresponding amount of token_a and token_b to "to".
    // Returns amount of both tokens withdrawn
    fn withdraw(e: Env, to: Address, share_amount: i128, min_a: i128, min_b: i128) -> (i128, i128);

    fn get_rsrvs(e: Env) -> (i128, i128);
}

#[contract]
struct LiquidityPool;

#[contractimpl]
impl LiquidityPoolTrait for LiquidityPool {
    fn initialize(e: Env, token_wasm_hash: BytesN<32>, token_a: Address, token_b: Address) {
        if token_a >= token_b {
            panic!("token_a must be less than token_b");
        }

        let share_contract = create_contract(&e, token_wasm_hash, &token_a, &token_b);
        token::Client::new(&e, &share_contract).initialize(
            &e.current_contract_address(),
            &7u32,
            &"Pool Share Token".into_val(&e),
            &"POOL".into_val(&e),
        );

        put_token_a(&e, token_a);
        put_token_b(&e, token_b);
        put_token_share(&e, share_contract.try_into().unwrap());
        put_total_shares(&e, 0);
        put_reserve_a(&e, 0);
        put_reserve_b(&e, 0);
    }

    fn share_id(e: Env) -> Address {
        get_token_share(&e)
    }

    fn deposit(e: Env, to: Address, desired_a: i128, min_a: i128, desired_b: i128, min_b: i128) {
        // Depositor needs to authorize the deposit
        to.require_auth();

        let (reserve_a, reserve_b) = (get_reserve_a(&e), get_reserve_b(&e));

        // Calculate deposit amounts
        let amounts = get_deposit_amounts(desired_a, min_a, desired_b, min_b, reserve_a, reserve_b);

        let token_a_client = token::Client::new(&e, &get_token_a(&e));
        let token_b_client = token::Client::new(&e, &get_token_b(&e));

        token_a_client.transfer(&to, &e.current_contract_address(), &amounts.0);
        token_b_client.transfer(&to, &e.current_contract_address(), &amounts.1);

        // Now calculate how many new pool shares to mint
        let (balance_a, balance_b) = (get_balance_a(&e), get_balance_b(&e));
        let total_shares = get_total_shares(&e);

        let zero = 0;
        let new_total_shares = if reserve_a > zero && reserve_b > zero {
            let shares_a = (balance_a * total_shares) / reserve_a;
            let shares_b = (balance_b * total_shares) / reserve_b;
            shares_a.min(shares_b)
        } else {
            (balance_a * balance_b).sqrt()
        };

        mint_shares(&e, to, new_total_shares - total_shares);
        put_reserve_a(&e, balance_a);
        put_reserve_b(&e, balance_b);
    }

    fn swap(e: Env, to: Address, buy_a: bool, out: i128, in_max: i128) {
        to.require_auth();

        let (reserve_a, reserve_b) = (get_reserve_a(&e), get_reserve_b(&e));
        let (reserve_sell, reserve_buy) = if buy_a {
            (reserve_b, reserve_a)
        } else {
            (reserve_a, reserve_b)
        };

        // First calculate how much needs to be sold to buy amount out from the pool
        let n = reserve_sell * out * 1000;
        let d = (reserve_buy - out) * 997;
        let sell_amount = (n / d) + 1;
        if sell_amount > in_max {
            panic!("in amount is over max")
        }

        // Transfer the amount being sold to the contract
        let sell_token = if buy_a {
            get_token_b(&e)
        } else {
            get_token_a(&e)
        };
        let sell_token_client = token::Client::new(&e, &sell_token);
        sell_token_client.transfer(&to, &e.current_contract_address(), &sell_amount);

        let (balance_a, balance_b) = (get_balance_a(&e), get_balance_b(&e));

        // residue_numerator and residue_denominator are the amount that the invariant considers after
        // deducting the fee, scaled up by 1000 to avoid fractions
        let residue_numerator = 997;
        let residue_denominator = 1000;
        let zero = 0;

        let new_invariant_factor = |balance: i128, reserve: i128, out: i128| {
            let delta = balance - reserve - out;
            let adj_delta = if delta > zero {
                residue_numerator * delta
            } else {
                residue_denominator * delta
            };
            residue_denominator * reserve + adj_delta
        };

        let (out_a, out_b) = if buy_a { (out, 0) } else { (0, out) };

        let new_inv_a = new_invariant_factor(balance_a, reserve_a, out_a);
        let new_inv_b = new_invariant_factor(balance_b, reserve_b, out_b);
        let old_inv_a = residue_denominator * reserve_a;
        let old_inv_b = residue_denominator * reserve_b;

        if new_inv_a * new_inv_b < old_inv_a * old_inv_b {
            panic!("constant product invariant does not hold");
        }

        if buy_a {
            transfer_a(&e, to, out_a);
        } else {
            transfer_b(&e, to, out_b);
        }

        put_reserve_a(&e, balance_a - out_a);
        put_reserve_b(&e, balance_b - out_b);
    }

    fn withdraw(e: Env, to: Address, share_amount: i128, min_a: i128, min_b: i128) -> (i128, i128) {
        to.require_auth();

        // First transfer the pool shares that need to be redeemed
        let share_token_client = token::Client::new(&e, &get_token_share(&e));
        share_token_client.transfer(&to, &e.current_contract_address(), &share_amount);

        let (balance_a, balance_b) = (get_balance_a(&e), get_balance_b(&e));
        let balance_shares = get_balance_shares(&e);

        let total_shares = get_total_shares(&e);

        // Now calculate the withdraw amounts
        let out_a = (balance_a * balance_shares) / total_shares;
        let out_b = (balance_b * balance_shares) / total_shares;

        if out_a < min_a || out_b <TabItem min_b {
            panic!("min not satisfied");
        }

        burn_shares(&e, balance_shares);
        transfer_a(&e, to.clone(), out_a);
        transfer_b(&e, to, out_b);
        put_reserve_a(&e, balance_a - out_a);
        put_reserve_b(&e, balance_b - out_b);

        (out_a, out_b)
    }

    fn get_rsrvs(e: Env) -> (i128, i128) {
        (get_reserve_a(&e), get_reserve_b(&e))
    }
}
```

</TabItem>
<TabItem value="token.rs">

```rust title=liquidity_pool/src/token.rs
#![allow(unused)]
use soroban_sdk::{xdr::ToXdr, Dirección, Bytes, BytesN, Env};

soroban_sdk::contractimport!(
    file = "../token/target/wasm32-unknown-unknown/release/soroban_token_contract. asm"
);

pub fn create_contract(
    e: &Env,
    token_wasm_hash: BytesN<32>,
    token_a: &Address,
    token_b: &Address,
) -> Dirección {
    let mut salt = Bytes::new(e);
    sal. ppend(&token_a.to_xdr(e));
    salt.append(&token_b.to_xdr(e));
    let salt = e.crypto().sha256(&salt);
    e. eployer()
        .with_current_contract(salt)
        .deploy(token_wasm_hash)
}
```

</TabItem>
</Tabs>

Ref: https://github.com/stellar/soroban-examples/tree/v20.0.0/liquidity_pool

## Cómo funciona

Cada activo creado en Stellar comienza con una liquidez cero. Lo mismo ocurre con los tokens creados en Soroban (a menos que un activo Stellar con el token de liquidez existente sea "envuelto" para su uso en Soroban). En términos simples, "liquidez" significa cuánto de un activo en un mercado está disponible para ser comprado o vendido. En los "viejos tiempos", usted podría generar liquidez en un mercado creando órdenes de compra/venta en un libro de pedidos.

Los grupos de liquidez automatizan este proceso sustituyendo las órdenes por matemáticas. Los depósitos en el fondo de liquidez ganan comisiones de transacciones de 'swap'. ¡No se requieren pedidos!

Abre el archivo `liquidity_pool/src/lib.rs` o lee el código anterior para seguir al pie de la página.

### Inicializar el contrato

Cuando este contrato es desplegado por primera vez, podría crear una piscina de liquidez para _any_ dos tokens disponibles en Soroban. Primero debe inicializarse con la siguiente información:

- **`token_wasm_hash`:** El contrato terminará [creando su propia ficha `POOL`] así como [interactuando con contratos para `token_a` y `token_b`]. La forma en que funciona este ejemplo es usando el [contrato de ejemplo `token`] para ambos trabajos. Cuando nuestro contrato de reserva de liquidez está inicializado, quiere que pasemos el hash de lavado del contrato de tokens **ya instalado**. Luego desplegará un contrato que ejecutará el bytecode WASM almacenado en ese hash como un nuevo contrato de token para los tokens `POOL`.
- **`token_a`:** El contrato `Addres` para un token **ya desplegado** (o envuelto) que se guardará en reserva por el fondo de liquidez.
- **`token_b`:** El contrato `Address` para un token **ya desplegado** (o envuelto) que será sostenido en reserva por el fondo de liquidez.

Ten en cuenta que qué token es `token_a` y que es `token_b` **no** es una distinción arbitraria. De acuerdo con las piscinas de liquidez Stellar incorporadas, este contrato sólo puede hacer una sola piscina de liquidez para un conjunto determinado de fichas. Por lo tanto, las direcciones del token deben ser proporcionadas en [orden lexicográfico] en el momento de la inicialización.

```rust title=liquidity_pool/src/lib.rs
fn initialize(e: Env, token_wasm_hash: BytesN<32>, taken_a: Dirección, token_b: Dirección) {
    if token_a >= token_b {
        ¡pánico! "token_a debe ser menor que token_b");
    }

    // La función de inicialización también almacena información importante en el almacenamiento de instancias del contrato
    put_token_a(&e, token_a);
    put_token_b(&e, token_b);
    put_token_share(&e, share_contract. ry_into().unwrap());
    put_total_shares(&e, 0);
    put_reserve_a(&e, 0);
    put_reserve_b(&e, 0);
}
```

[creando su propio token `pool`]: #creando-a-custom-pool-token-for-lp-shares
[interactuando con contratos para `token_a` y `token_b`]: #token-transfers-tofrom-the-lp-contract
[contrato de ejemplo `token`]: ./tokens.mdx
[orden lexicográfico]: <../../../learn/encyclopedia/sdex/liquidity-on-stellar-sdex-liquidity-pools.mdx#participación de liquididad-pool->

### Un producto de liquidez "constante"

El _type_ de la batería de liquidez de este ejemplo implementa este contrato se llama una piscina de liquidez de "producto constante". Si bien este no es el único tipo de piscina de liquidez, es la variedad más común. Estas baterías de liquidez están diseñadas para mantener el valor _total_ de cada activo en equilibrio _relativo_. El "producto" en el producto constante (también llamado "invariante") cambiará cada vez que la piscina de liquidez se interactúe con (depósito, retiro o swaps de ficha). Sin embargo, el invariante **debe** sólo aumentar con cada interacción.

Durante un intercambio, lo que debe tenerse en cuenta es que para cada retiro del lado de `token_a`. debes "rellenar" el lado `token_b` con una cantidad suficiente para mantener el precio de la batería de liquidez. Las matemáticas son predecibles, pero no lineales. Cuanto más tome de un lado, más debe dar en el sitio opuesto _exponentially_.

Dentro de la función `swap`, la matemática se hace así (esta es una versión simplificada, sin embargo):

```rust title=liquidity_pool/src/lib.rs
fn swap(e: Env, to: Dirección, buy_a: bool, out: i128, in_max: i128) {
    // Obtener los saldos actuales de ambas fichas en la piscina de liquidez
    let (reserve_sell, reserve_buy) = (get_reserve_a(&e), get_reserve_b(&e));

    // Calcula cuánto necesita ser
    let n = reserve_sell * out * 1000;
    let d = (reserve_buy - out) * 997;
    let sell_amount = (n / d) + 1;
}
```

Tenemos información mucho más detallada sobre cómo funciona este tipo de piscina de liquidez está disponible en [Quest Stellar: Serie 3, Quest 5]. Esta es una forma realmente útil e interactiva de aprender más sobre cómo funcionan las piscinas de liquidez Stellar incorporadas. Gran parte del conocimiento que puede obtener de allí se traducirá fácilmente a este contrato de ejemplo.

[misión estelar: serie 3, misión 5]: https://quest.stellar.org/learn/series/3/quest/5

### Interactuando con los contratos de Token en otro contrato

Este contrato de la piscina de liquidez funcionará con un total de tres fichas Soroban diferentes:

- **`POOL`:** Este token es un token único que se da a los depósitos de activos a cambio de su depósito. Estos tokens son "intercambiados" por el usuario cuando retira una cantidad de su depósito original (más cualquier comisión de swap ganada). Este contrato de ejemplo implementa el mismo [`token` ejemplo contract] para este token.
- **`token_a`** y **`token_b`**: serán las dos "fichas de reserva" que los usuarios depositarán en el albergue. Estos pueden ser fichas "envueltas" de activos estelares preexistentes, o pueden ser fichas autóctonas sorobanas. A este contrato no le importa, siempre y cuando las funciones que necesita de la Interfaz de Token común estén disponibles en el contrato de token.

[interfaz de token]: ../../../tokens/token-interface.mdx

#### Creando un token personalizado `POOL` para LP Shares

Estamos utilizando el contrato de ejemplo compilado `token` como nuestro contrato de activos para el token `POOL`. Esto significa que sigue todas las convenciones de la [Interfaz de Token], y puede ser tratada como cualquier otro token. Podrían ser transferidas, quemadas, mintadas, etc. También significa que el desarrollador de LP _podría_ aprovechar las características administrativas tales como clawbacks, autorización y más.

El archivo `token.rs` contiene una función `create_contract` que usaremos para desplegar este contrato de token en particular.

```rust title="src/token.rs"
pub fn create_contract(
    e: &Env,
    token_wasm_hash: BytesN<32>,
    token_a: &Dirección,
    token_b: &Address,
) -> Dirección {
    let mut sal = Bytes::new(e);
    de sal. ppend(&token_a.to_xdr(e));
    salt.append(&token_b.to_xdr(e));
    let salt = e.crypto().sha256(&salt);
    e. eployer()
        .with_current_contract(salt)
        .deploy(token_wasm_hash)
}
```

Este contrato de token `POOL` se crea dentro de la función `initialize`.

```rust title=liquidity_pool/src/lib.rs
fn initialize(e: Env, token_wasm_hash: BytesN<32>, token_a: Address, token_b: Address) {
    let share_contract = create_contract(&e, token_wasm_hash, &token_a, &token_b);
    token::Client::new(&e, &share_contract).initialize(
        &e.current_contract_address(),
        &7u32,
        &"Pool Share Token".into_val(&e),
        &"POOL".into_val(&e),
    );
}
```

Luego, durante un `depósito`, una cantidad calculada de fichas `POOL` son `mint`ed a la dirección de depósito.

```rust title=liquidity_pool/src/lib.rs
fn mint_shares(e: &Env, to: Dirección, monto: i128) {
    let total = get_total_shares(e);
    let share_contract_id = get_token_share(e);

    token::Client::new(e, &share_contract_id). int(&to, &monto);

    put_total_shares(e, total + monto);
}
```

¿Cómo se calcula ese número de acciones, se pregunta? Excelente pregunta! Si es el primer depósito (ver arriba), es sólo la raíz cuadrada del producto de las cantidades de `token_a` y `token_b` depositado. Muy simple.

Sin embargo, si ya ha habido depósitos en la piscina de líquidos, y el usuario está añadiendo más fichas en la piscina, hay un poco más de matemáticas. Sin embargo, el punto principal es que cada deposito recibe la misma proporción de fichas `POOL` para su depósito que cualquier otro depósito.

```rust title=liquidity_pool/src/lib.rs
fn deposit(e: Env, to: Dirección, deseos_a: i128, min_a: i128, desired_b: i128, min_b: i128) {
    let zero = 0;
    let new_total_shares = if reserve_a > zero && reserve_b > zero {
        // Nota balance_a y balance_b en este punto de la función incluyen
        // los tokens que el usuario está actualmente depositando, Mientras que reserve_a y
        // reserve_b aún no lo hacen.
        let shares_a = (balance_a * total_shares) / reserve_a;
        let shares_b = (balance_b * total_shares) / reserve_b;
        compartidas_a. in(shares_b)
    } else {
        (balance_a * balance_b). qrt()
    };
}
```

#### Transferencias de fichas hacia/desde el contrato LP

Como ya hemos discutido, el contrato de la batería de liquidez hará uso de la [Interfaz de fichas] disponible en los contratos de fichas que fueron suministrados como argumentos `token_a` y `token_b` en el momento de la inicialización. Durante el resto del contrato, la piscina de liquidez hará uso de esa interfaz para hacer transferencias de esos tokens hacia/desde sí misma.

Lo que está sucediendo es que como un usuario deposita fichas en la piscina, y el contrato invoca la función `transfer` para mover los tokens de la dirección `a` (el depósito) a ser sostenida por la dirección del contrato. Los tokens `POOL` son luego mintados para depositar (ver sección anterior). Pretty simple, ¿verdad!?

```rust title=liquidity_pool/src/lib.rs
fn deposit(e: Env, to: Dirección, deseos_a: i128, min_a: i128, deseado_b: i128, min_b: i128) {
    // El Depositor necesita autorizar el depósito
    a. equire_auth();

    let token_a_client = token::Client::new(&e, &get_token_a(&e));
    let token_b_client = token::Client::new(&e, &get_token_b(&e));

    token_a_client. ransfer(&to, &e.current_contract_address(), &amounts.0);
    token_b_client.transfer(&to, &e.current_contract_address(), &amounts.1);

    mint_shares(&e, to, new_total_shares - total_shares);
}
```

En contraste, cuando un usuario retira sus fichas depositadas, se trata de más implicado, y el siguiente procedimiento sucede.

1. Parte de la cantidad del token `POOL` se transfiere del deposito a la dirección del contrato. Esta es una forma temporal de rastrear cuántos tokens de `POOL` están siendo canjeados. El contrato no mantendrá este saldo de `POOL` durante mucho tiempo.
2. Los importes de retiro de los tokens de reserva se calculan en base al saldo actual del contrato de tokens `POOL`.
3. Los tokens `POOL` se queman ahora que se han calculado las cantidades de retiro y ya no se necesitan.
4. Las cantidades respectivas de `token_a` y `token_b` son transferidas _de_ la dirección del contrato a la dirección `to` (el depósito).

```rust title=liquidity_pool/src/lib.rs
fn withdraw(e: Env, to: Address, share_amount: i128, min_a: i128, min_b: i128) -> (i128, i128) {
    to.require_auth();

    // First transfer the pool shares that need to be redeemed
    let share_token_client = token::Client::new(&e, &get_token_share(&e));
    share_token_client.transfer(&to, &e.current_contract_address(), &share_amount);

    // Now calculate the withdraw amounts
    let out_a = (balance_a * balance_shares) / total_shares;
    let out_b = (balance_b * balance_shares) / total_shares;

    burn_shares(&e, balance_shares);
    transfer_a(&e, to.clone(), out_a);
    transfer_b(&e, to, out_b);
}
```

Notarás que manteniendo el saldo de `token_a` y `token_b` en el contrato de la piscina de liquidez mismo que hace, es muy fácil para nosotros realizar cualquiera de las acciones de [Interfaz de Token] dentro del contrato. Como bonificación, cualquier observador externo podría consultar los saldos de `token_a` o `token_b` en el contrato para verificar que las reservas están realmente en línea con los valores que reporta el contrato cuando se invoca su propia función `get_rsvs`.

## Tests

Abre el archivo [`liquidity_pool/src/test.rs`] para seguir al pie de la letra.

```rust title=liquidity_pool/src/test.rs
#![cfg(test)]
extern crate std;

use crate::{token, LiquidityPoolClient};

use soroban_sdk::{
    symbol_short,
    testutils::{Address as _, AuthorizedFunction, AuthorizedInvocation},
    Address, BytesN, Env, IntoVal,
};

fn create_token_contract<'a>(e: &Env, admin: &Address) -> token::Client<'a> {
    token::Client::new(e, &e.register_stellar_asset_contract(admin.clone()))
}

fn create_liqpool_contract<'a>(
    e: &Env,
    token_wasm_hash: &BytesN<32>,
    token_a: &Address,
    token_b: &Address,
) -> LiquidityPoolClient<'a> {
    let liqpool = LiquidityPoolClient::new(e, &e.register_contract(None, crate::LiquidityPool {}));
    liqpool.initialize(token_wasm_hash, token_a, token_b);
    liqpool
}

fn install_token_wasm(e: &Env) -> BytesN<32> {
    soroban_sdk::contractimport!(
        file = "../token/target/wasm32-unknown-unknown/release/soroban_token_contract.wasm"
    );
    e.deployer().upload_contract_wasm(WASM)
}

#[test]
fn test() {
    let e = Env::default();
    e.mock_all_auths();

    let mut admin1 = Address::random(&e);
    let mut admin2 = Address::random(&e);

    let mut token1 = create_token_contract(&e, &admin1);
    let mut token2 = create_token_contract(&e, &admin2);
    if &token2.address < &token1.address {
        std::mem::swap(&mut token1, &mut token2);
        std::mem::swap(&mut admin1, &mut admin2);
    }
    let user1 = Address::random(&e);
    let liqpool = create_liqpool_contract(
        &e,
        &install_token_wasm(&e),
        &token1.address,
        &token2.address,
    );

    let token_share = token::Client::new(&e, &liqpool.share_id());

    token1.mint(&user1, &1000);
    assert_eq!(token1.balance(&user1), 1000);

    token2.mint(&user1, &1000);
    assert_eq!(token2.balance(&user1), 1000);

    liqpool.deposit(&user1, &100, &100, &100, &100);
    assert_eq!(
        e.auths(),
        std::vec![(
            user1.clone(),
            AuthorizedInvocation {
                function: AuthorizedFunction::Contract((
                    liqpool.address.clone(),
                    symbol_short!("deposit"),
                    (&user1, 100_i128, 100_i128, 100_i128, 100_i128).into_val(&e)
                )),
                sub_invocations: std::vec![
                    AuthorizedInvocation {
                        function: AuthorizedFunction::Contract((
                            token1.address.clone(),
                            symbol_short!("transfer"),
                            (&user1, &liqpool.address, 100_i128).into_val(&e)
                        )),
                        sub_invocations: std::vec![]
                    },
                    AuthorizedInvocation {
                        function: AuthorizedFunction::Contract((
                            token2.address.clone(),
                            symbol_short!("transfer"),
                            (&user1, &liqpool.address, 100_i128).into_val(&e)
                        )),
                        sub_invocations: std::vec![]
                    }
                ]
            }
        )]
    );

    assert_eq!(token_share.balance(&user1), 100);
    assert_eq!(token_share.balance(&liqpool.address), 0);
    assert_eq!(token1.balance(&user1), 900);
    assert_eq!(token1.balance(&liqpool.address), 100);
    assert_eq!(token2.balance(&user1), 900);
    assert_eq!(token2.balance(&liqpool.address), 100);

    liqpool.swap(&user1, &false, &49, &100);
    assert_eq!(
        e.auths(),
        std::vec![(
            user1.clone(),
            AuthorizedInvocation {
                function: AuthorizedFunction::Contract((
                    liqpool.address.clone(),
                    symbol_short!("swap"),
                    (&user1, false, 49_i128, 100_i128).into_val(&e)
                )),
                sub_invocations: std::vec![AuthorizedInvocation {
                    function: AuthorizedFunction::Contract((
                        token1.address.clone(),
                        symbol_short!("transfer"),
                        (&user1, &liqpool.address, 97_i128).into_val(&e)
                    )),
                    sub_invocations: std::vec![]
                }]
            }
        )]
    );

    assert_eq!(token1.balance(&user1), 803);
    assert_eq!(token1.balance(&liqpool.address), 197);
    assert_eq!(token2.balance(&user1), 949);
    assert_eq!(token2.balance(&liqpool.address), 51);

    e.budget().reset_unlimited();
    liqpool.withdraw(&user1, &100, &197, &51);

    assert_eq!(
        e.auths(),
        std::vec![(
            user1.clone(),
            AuthorizedInvocation {
                function: AuthorizedFunction::Contract((
                    liqpool.address.clone(),
                    symbol_short!("withdraw"),
                    (&user1, 100_i128, 197_i128, 51_i128).into_val(&e)
                )),
                sub_invocations: std::vec![AuthorizedInvocation {
                    function: AuthorizedFunction::Contract((
                        token_share.address.clone(),
                        symbol_short!("transfer"),
                        (&user1, &liqpool.address, 100_i128).into_val(&e)
                    )),
                    sub_invocations: std::vec![]
                }]
            }
        )]
    );

    assert_eq!(token1.balance(&user1), 1000);
    assert_eq!(token2.balance(&user1), 1000);
    assert_eq!(token_share.balance(&user1), 0);
    assert_eq!(token1.balance(&liqpool.address), 0);
    assert_eq!(token2.balance(&liqpool.address), 0);
    assert_eq!(token_share.balance(&liqpool.address), 0);
}
```

[`liquidity_pool/src/test.rs`]: https://github.com/stellar/soroban-examples/blob/v20.0.0/liquidity_pool/src/test.rs

En cualquier prueba lo primero que siempre se requiere es un `Env`, que es el entorno Soroban en el que se ejecutará el contrato.

```rust title=liquidity_pool/src/test.rs
let e = Env::default();
```

Fusionamos las comprobaciones de autenticación en las pruebas, lo que permite que las pruebas procedan como si todos los usuarios/direcciones/contratos/etc. se hubieran autenticado correctamente.

```rust title=liquidity_pool/src/test.rs
mock_all_auths();
```

Hemos abstraído en unas cuantas funciones las tareas de crear contratos de tokens, desplegando un contrato de reserva de liquidez e instalando el código de byte WASM en nuestro entorno de pruebas. Cada uno de ellos se usa dentro de la prueba.

```rust title=liquidity_pool/src/test.rs
fn create_token_contract<'a>(e: &Env, admin: &Address) -> token::Client<'a> {
    token::Client::new(e, &e.register_stellar_asset_contract(admin. lone()))
}

fn create_liqpool_contract<'a>(
    e: &Env,
    token_wasm_hash: &BytesN<32>,
    token_a: &Address,
    token_b: &Address,
) -> LiquidityPoolClient<'a> {
    let liqpool = LiquidityPoolClient::new(e, &e. egister_contract(None, crate::LiquidityPool {}));
    liqpool. nitialize(token_wasm_hash, token_a, token_b);
    liqpool
}

fn install_token_wasm(e: &Env) -> BytesN<32> {
    soroban_sdk::contractimport!
        archivo = ". /token/target/wasm32-unknown-unknown/release/soroban_token_contract.wasm"
    );
    e.deployer().upload_contract_wasm(WASM)
}
```

Todas las funciones públicas dentro de un bloque `impl` que está anotado con el atributo `#[contractimpl]` tienen una función correspondiente generada en un tipo de cliente generado. El tipo de cliente se nombrará igual que el tipo de contrato con `Client` adjunto. Por ejemplo, en nuestro contrato el tipo de contrato es `LiquidityPool`, y el cliente se llama `LiquidityPoolClient`.

Estas pruebas examinan el caso de uso "típico" de una piscina de liquidez, asegurando que los balances, vueltas, etc. sean apropiados en varios puntos durante la prueba.

1. En primer lugar, la prueba establece todo con un `Env`, dos direcciones de administración, dos fichas de reserva, una dirección generada aleatoriamente para actuar como usuario de la piscina de liquidez, la piscina de liquidez misma, un token de piscina comparte contrato, y remueve los activos de reserva a la dirección del usuario.
2. El usuario deposita entonces parte de cada activo en el pozo de liquidez. En este momento, se realizan las siguientes comprobaciones:
   - Existen autorizaciones apropiadas para depósitos y transferencias,
   - los balances se comprueban para cada token (`token_a`, `token_b` y `POOL`) tanto desde la perspectiva del usuario como desde la perspectiva del contrato `liqpool`
3. El usuario realiza un swap, comprando `token_b` a cambio de `token_a`. Las mismas comprobaciones que el paso anterior se hacen ahora, exceptuando los saldos de `POOL`, ya que un intercambio no tiene efecto en las fichas `POOL`.
4. El usuario retira todos los depósitos que realizó, intercambiando todos sus tokens `POOL` en el proceso. Los mismos cheques se hacen aquí como se hicieron en el paso `depósito`.

## Construir el contrato

Para construir el contrato, utilice el comando `stellar contract build`.

```sh
construcción de contrato estelar
```

Un archivo `.wasm` debe ser enviado en el directorio `target`:

```sh
objetivo/wasm32-unknown-unknown/release/soroban_liquidity_pool_contract.wasm
```

## Ejecutar el contrato

Si tienes instalado [`stellar-cli`], puedes invocar las funciones del contrato utilizándolo.

<Tabs groupId="platform" defaultValue={getPlatform()}>

<TabItem value="unix" label="macOS/Linux">

```sh
contrato estelar invoca \
    --wasm target/wasm32-unknown-unknown/release/soroban_liquidity_pool_contract. asm \
    --id 1 \
    -- \
    depósito \
    --to GBZV3NONYSUDVTEHATQO4BCJVFXJO3XQU5K32X3XREVZKSMMOZFO4ZXR \
    --desired_a 100 \
    --min_a 98 \
    --desired_be 200 \
    --min_b 196
```

</TabItem>

<TabItem value="windows" label="Windows (PowerShell)">

```powershell
contrato estelar invoca `
    --wasm target/wasm32-unknown-unknown/release/soroban_liquidity_pool_contract. asm `
    --id 1 `
    -- `
    depositar `
    --to GBZV3NONYSUDVTEHATQO4BCJVFXJO3XQU5K32X3XREVZKSMMOZFO4ZXR `
    --desired_a 100 `
    --min_a 98 `
    --desired_be 200 `
    --min_b 196
```

</TabItem>

</Tabs>

[`stellar-cli`]: ../../../tools/developer-tools/README.mdx#cli

---
title: Errores
description: Definir y generar errores en un contrato inteligente.
sidebar_position: 30
---

<head>
  <title>Definir y generar errores en un contrato inteligente.</title>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="Definir y generar errores en un contrato inteligente."
  />
  <meta
    property="og:description"
    content="Definir y generar errores en un contrato inteligente que los invocadores del contrato pueden entender y manejar."
  />
</head>

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { getPlatform } from "@site/src/helpers/getPlatform";

El [ejemplo de errores] demuestra cómo definir y generar errores en un contrato que los invocadores del contrato pueden entender y manejar. Este ejemplo es una extensión del [ejemplo de almacenamiento de datos].

[![Abrir en Codespaces](https://github.com/codespaces/badge.svg)][open-in-github-codespaces]

[![Abrir en Codeanywhere](https://codeanywhere.com/img/open-in-codeanywhere-btn.svg)][open-in-code-anywhere]

[open-in-github-codespaces]: https://github.com/codespaces/new?repo=stellar/soroban-examples&editor=web
[open-in-code-anywhere]: https://app.codeanywhere.com/#https://github.com/stellar/soroban-examples
[ejemplo de errores]: https://github.com/stellar/soroban-examples/tree/v23.0.0/errors
[ejemplo de almacenamiento de datos]: ../getting-started/storing-data.mdx

## Ejecutar el ejemplo

Primero completa el proceso de [Configuración] para preparar tu entorno de desarrollo y luego clona la etiqueta `v23.0.0` del repositorio `soroban-examples`:

[configuración]: ../getting-started/setup.mdx

```sh
git clone -b v23.0.0 https://github.com/stellar/soroban-examples
```

O, omite la configuración del entorno de desarrollo y abre este ejemplo en [GitHub Codespaces][open-in-github-codespaces] o en [Code Anywhere][open-in-code-anywhere].

Para ejecutar las pruebas del ejemplo, navega al directorio `errors`, y usa `cargo test`.

```sh
cd errors
cargo test
```

Deberías ver una salida que comienza así:

```
running 2 tests
test test::test ... ok
test test::test_panic - should panic ... ok

[Diagnostic Event] contract:CAAA..., topics:[log], data:["count: {}", 0]
[Diagnostic Event] contract:CAAA..., topics:[log], data:["count: {}", 1]
[Diagnostic Event] contract:CAAA..., topics:[log], data:["count: {}", 2]
[Diagnostic Event] contract:CAAA..., topics:[log], data:["count: {}", 3]
[Diagnostic Event] contract:CAAA..., topics:[log], data:["count: {}", 4]
[Diagnostic Event] contract:CAAA..., topics:[log], data:["count: {}", 5]
[Failed Diagnostic Event (not emitted)] contract:CAAA..., topics:[log], data:["count: {}", 5]

thread 'test::test_panic' panicked at .../src/host.rs: HostError: Error(Contract, #1)

Event log (newest first):
   0: [Diagnostic Event] topics:[error, Error(Contract, #1)], data:"escalating error to panic"
   1: [Diagnostic Event] topics:[error, Error(Contract, #1)], data:["contract call failed", increment, []]
   2: [Failed Diagnostic Event (not emitted)] contract:CAAA..., topics:[error, Error(Contract, #1)], data:"escalating Ok(ScErrorType::Contract) frame-exit to Err"
   3: [Failed Diagnostic Event (not emitted)] contract:CAAA..., topics:[fn_return, increment], data:Error(Contract, #1)
   4: [Failed Diagnostic Event (not emitted)] contract:CAAA..., topics:[log], data:["count: {}", 5]
   5: [Diagnostic Event] topics:[fn_call, CAAA..., increment], data:Void
...

successes:
    test::test
    test::test_panic

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.16s
```

## Código

```rust title="errors/src/lib.rs"
#[contracterror]
#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]
#[repr(u32)]
pub enum Error {
    LimitReached = 1,
}

const COUNTER: Symbol = symbol_short!("COUNTER");
const MAX: u32 = 5;

#[contract]
pub struct IncrementContract;

#[contractimpl]
impl IncrementContract {
    /// Increment increments an internal counter, and returns the value. Errors
    /// if the value is attempted to be incremented past 5.
    pub fn increment(env: Env) -> Result<u32, Error> {
        // Get the current count.
        let mut count: u32 = env.storage().instance().get(&COUNTER).unwrap_or(0); // If no value set, assume 0.
        log!(&env, "count: {}", count);

        // Increment the count.
        count += 1;

        // Check if the count exceeds the max.
        if count <= MAX {
            // Save the count.
            env.storage().instance().set(&COUNTER, &count);

            // Return the count to the caller.
            Ok(count)
        } else {
            // Return an error if the max is exceeded.
            Err(Error::LimitReached)
        }
    }
}
```

Ref: https://github.com/stellar/soroban-examples/tree/v23.0.0/errors

## Cómo funciona

Abre el archivo [`errors/src/lib.rs`](https://github.com/stellar/soroban-examples/tree/v23.0.0/errors/src/lib.rs) para seguir el ejemplo.

### Definiendo un error

Los errores de contrato son enumeraciones Rust u32 donde cada variante de la enumeración tiene un valor entero asignado. El atributo `#[contracterror]` se utiliza para configurar el error para que pueda ser utilizado en el valor de retorno de las funciones del contrato.

La enumeración tiene algunas restricciones:

- Debe tener el atributo `#[repr(u32)]`.
- Debe tener el atributo `#[derive(Copy)]`.
- Cada variante debe tener un valor entero explícito asignado.

```rust
#[contracterror]
#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]
#[repr(u32)]
pub enum Error {
    LimitReached = 1,
}
```

Los errores de contrato no pueden ser almacenados como datos de contrato y, por lo tanto, no pueden ser usados como tipos en campos de tipos de contrato.

:::tip

Si se devuelve un error de una función, todo lo que la función ha hecho es revertido. Si las entradas del ledger han sido alteradas o se han almacenado datos del contrato, todos esos cambios son revertidos y no serán persistidos.

:::

### Devolviendo un error

Los errores pueden ser devueltos desde las funciones de contrato devolviendo `Result<_, E>`.

La función de incremento devuelve un `Result<u32, Error>`, lo que significa que devuelve `Ok(u32)` en el caso exitoso y `Err(Error)` en el caso de error.

```rust
pub fn increment(env: Env) -> Result<u32, Error> {
    // ...
    if count <= MAX {
        // ...
        Ok(count)
    } else {
        // ...
        Err(Error::LimitReached)
    }
}
```

### Entrando en pánico con un error

Los errores también pueden provocarse en lugar de ser devueltos desde la función.

La función de incremento también podría ser escrita como sigue con un valor de retorno `u32`. El error puede ser pasado al entorno usando el macro `panic_with_error!`.

```rust
pub fn increment(env: Env) -> u32 {
    // ...
    if count <= MAX {
        // ...
        count
    } else {
        // ...
        panic_with_error!(&env, Error::LimitReached)
    }
}
```

:::caution

Las funciones que no devuelven un tipo `Result<_, E>` no especifican cuáles son los posibles valores de error. Esto hace que sea más difícil para otros contratos y clientes integrarse con el contrato. Sin embargo, esto podría ser ideal si los errores son diagnósticos y de depuración, y no están destinados a ser manejados.

:::

## Pruebas

Abre el archivo [`errors/src/test.rs`](https://github.com/stellar/soroban-examples/tree/v23.0.0/errors/src/test.rs) para seguir el ejemplo.

```rust title="errors/src/test.rs"
#[test]
fn test() {
    let env = Env::default();
    let contract_id = env.register(IncrementContract, ());
    let client = IncrementContractClient::new(&env, &contract_id);

    assert_eq!(client.try_increment(), Ok(Ok(1)));
    assert_eq!(client.try_increment(), Ok(Ok(2)));
    assert_eq!(client.try_increment(), Ok(Ok(3)));
    assert_eq!(client.try_increment(), Ok(Ok(4)));
    assert_eq!(client.try_increment(), Ok(Ok(5)));
    assert_eq!(client.try_increment(), Err(Ok(Error::LimitReached)));

    std::println!("{}", env.logs().all().join("\n"));
}

#[test]
#[should_panic(expected = "HostError: Error(Contract, #1)")]
fn test_panic() {
    let env = Env::default();
    let contract_id = env.register(IncrementContract, ());
    let client = IncrementContractClient::new(&env, &contract_id);

    assert_eq!(client.increment(), 1);
    assert_eq!(client.increment(), 2);
    assert_eq!(client.increment(), 3);
    assert_eq!(client.increment(), 4);
    assert_eq!(client.increment(), 5);
    client.increment();
}
```

En cualquier prueba, lo primero que siempre se requiere es un `Env`, que es el entorno de Soroban en el que el contrato se ejecutará.

```rust
let env = Env::default();
```

El contrato se registra con el entorno usando el tipo de contrato.

```rust
let contract_id = env.register(IncrementContract, ());
```

Todas las funciones públicas dentro de un bloque `impl` que está anotado con el atributo `#[contractimpl]` tienen una función correspondiente generada en un tipo de cliente generado. El tipo de cliente tendrá el mismo nombre que el tipo de contrato con `Client` añadido. Por ejemplo, en nuestro contrato, el tipo de contrato es `IncrementContract`, y el cliente se llama `IncrementContractClient`.

```rust
let client = IncrementContractClient::new(&env, &contract_id);
```

Se generan dos funciones para cada función de contrato, una que devuelve un `Result<>`, y la otra que no maneja errores y se bloquea si ocurre un error.

### `try_increment`

En la primera prueba, se llama a la función `try_increment` y devuelve `Result<Result<u32, _>, Result<Error, InvokeError>>`.

```rust
assert_eq!(client.try_increment(), Ok(Ok(5)));
assert_eq!(client.try_increment(), Err(Ok(Error::LimitReached)));
```

- Si la llamada a la función es exitosa, se devuelve `Ok(Ok(u32))`.
- Si la llamada a la función es exitosa pero devuelve un valor que no es `u32`, se devuelve `Ok(Err(_))`.
- Si la llamada a la función no tiene éxito y falla con un error en el enum `Error`, se devuelve `Err(Ok(Error))`.
- Si la llamada a la función no tiene éxito, pero devuelve un código de error que no está en el enum `Error`, o devuelve un código de error del sistema, se devuelve `Err(Err(InvokeError))` y se puede inspeccionar el `InvokeError`.

### `increment`

En la segunda prueba, se llama a la función `increment` y devuelve `u32`. Cuando se realiza la última llamada, la función tiene un pánico.

```rust
assert_eq!(client.increment(), 5);
client.increment();
```

- Si la llamada a la función es exitosa, se devuelve `u32`.
- Si la llamada a la función es exitosa pero devuelve un valor que no es `u32`, se produce un pánico.
- Si la llamada a la función no tiene éxito, se produce un pánico.

## Crear el contrato

Para crear el contrato, usa el comando `stellar contract build`.

```sh
stellar contract build
```

Un archivo `.wasm` debería ser generado en el directorio `target`:

```
target/wasm32v1-none/release/soroban_errors_contract.wasm
```

## Ejecutar el contrato

Despliegue el contrato en Testnet para que podamos ejecutarlo. El valor proporcionado como `--source-account` se configuró en nuestra guía Comenzar; por favor, cámbialo en consecuencia si creaste una identidad diferente.

<Tabs groupId="platform" defaultValue={getPlatform()}>
<TabItem value="unix" label="macOS/Linux">

```sh
stellar contract deploy \
  --wasm target/wasm32v1-none/release/soroban_errors_contract.wasm \
  --source-account alice \
  --network testnet
```

</TabItem>
<TabItem value="windows" label="Windows (PowerShell)">

```powershell
stellar contract deploy `
  --wasm target/wasm32v1-none/release/soroban_errors_contract.wasm `
  --source-account alice `
  --network testnet
```

</TabItem>
</Tabs>

El comando anterior mostrará el ID del contrato, que en nuestro caso es `CA4KWO3HL6M5F5MZ5ITVFLCQ6ZM2GDSP2NOTNXOT4GIRECQOVX3I6CXL`.

Ahora que hemos desplegado el contrato, podemos invocarlo.

<Tabs groupId="platform" defaultValue={getPlatform()}>
<TabItem value="unix" label="macOS/Linux">

```sh
stellar contract invoke \
    --id CA4KWO3HL6M5F5MZ5ITVFLCQ6ZM2GDSP2NOTNXOT4GIRECQOVX3I6CXL \
    --network testnet \
    --source-account alice \
    -- \
    increment
```

</TabItem>
<TabItem value="windows" label="Windows (PowerShell)">

```powershell
stellar contract invoke `
    --id CA4KWO3HL6M5F5MZ5ITVFLCQ6ZM2GDSP2NOTNXOT4GIRECQOVX3I6CXL `
    --network testnet `
    --source-account alice `
    -- `
    increment
```

</TabItem>
</Tabs>

Ejecuta el comando varias veces y en la sexta invocación deberías ver un error como este:

```
❌ error: transaction simulation failed: HostError: Error(Contract, #1)

Event log (newest first):
   0: [Diagnostic Event] contract:CA4KWO3HL6M5F5MZ5ITVFLCQ6ZM2GDSP2NOTNXOT4GIRECQOVX3I6CXL, topics:[error, Error(Contract, #1)], data:"escalating Ok(ScErrorType::Contract) frame-exit to Err"
   1: [Diagnostic Event] topics:[fn_call, CA4KWO3HL6M5F5MZ5ITVFLCQ6ZM2GDSP2NOTNXOT4GIRECQOVX3I6CXL, increment], data:Void
```

Para recuperar el valor actual del contador, usa el comando `stellar contract read`.

<Tabs groupId="platform" defaultValue={getPlatform()}>
<TabItem value="unix" label="macOS/Linux">

```sh
stellar contract read \
  --id CA4KWO3HL6M5F5MZ5ITVFLCQ6ZM2GDSP2NOTNXOT4GIRECQOVX3I6CXL \
  --network testnet \
  --source-account alice \
  --durability persistent \
  --output json
```

</TabItem>
<TabItem value="windows" label="Windows (PowerShell)">

```powershell
stellar contract read `
  --id CA4KWO3HL6M5F5MZ5ITVFLCQ6ZM2GDSP2NOTNXOT4GIRECQOVX3I6CXL `
  --network testnet `
  --source-account alice `
  --durability persistent `
  --output json
```

</TabItem>
</Tabs>

[`stellar-cli`]: ../getting-started/setup.mdx#install-the-stellar-cli

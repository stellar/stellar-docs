---
title: Errores
description: Definir y generar errores en un contrato inteligente.
sidebar_position: 30
---

<head>
  <title>Defina y genera errores en un contrato inteligente.</title>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="Define y genera errores en un contrato inteligente."
  />
  <meta
    property="og:description"
    content="Definir y generar errores en un contrato inteligente que invokers del contrato pueden entender y manejar."
  />
</head>

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { getPlatform } from "@site/src/helpers/getPlatform";

El [ejemplo de errores] demuestra cómo definir y generar errores en un contrato que los invasores del contrato pueden entender y manejar. Este ejemplo es una extensión del [ejemplo de almacenamiento de datos].

[![Abrir en Gitpod](https://gitpod.io/button/open-in-gitpod.svg)][oigp]

[oigp]: https://gitpod.io/#https://github.com/stellar/soroban-examples/tree/v20.0.0
[ejemplo de errores]: https://github.com/stellar/soroban-examples/tree/v20.0.0/errors
[ejemplo de almacenamiento de datos]: ../getting-started/storing-data.mdx

## Ejecutar el ejemplo

Primero pasa por el proceso [Setup] para configurar tu entorno de desarrollo, luego clona la etiqueta `v20.0.0` del repositorio `soroban-examples`:

[configuración]: ../iniciando/setup.mdx

```
git clon -b v20.0.0 https://github.com/stellar/soroban-examples
```

O, omita la configuración del entorno de desarrollo y abre este ejemplo en [Gitpod][oigp].

Para ejecutar las pruebas para el ejemplo, vaya al directorio `errors`, y use `cargo test`.

```
errores de cd
prueba de carga
```

Deberías ver la salida que comienza así:

```
ejecutando 2 pruebas

cuenta: U32(0)
count: U32(1)
count: U32(2)
count: U32(3)
count: U32(4)
count: U32(5)
Status(ContractError(1))
invocación de llamada de contrato resultó en error Status(ContractError(1))
test test::test ... ok

thread 'test::test_panic' pánico en 'llamado 'Result::unwrap()` en un valor de `Error: HostError
Valor: Status(ContractError(1))

eventos de depuración (más reciente):
   0: "Status(ContractError(1))"
   1: "count: U32(5)"
   2: "count: U32(4)"
   3: "count: U32(3)"
. .
test test::test_► - debería estar en caso... ok

resultados de la prueba: ok. 2 pasados; 0 fallidos; 0 ignorado; 0 medidos; 0 filtrados; terminado en 0.33s
```

## Código

```rust title="errors/src/lib.rs"
#[contracterror]
#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]
#[repr(u32)]
pub enum Error {
    LimitReached = 1,
}

const COUNTER: Symbol = symbol_short!("COUNTER");
const MAX: u32 = 5;

#[contract]
pub struct IncrementContract;

#[contractimpl]
impl IncrementContract {
    /// Increment increments an internal counter, and returns the value. Errors
    /// if the value is attempted to be incremented past 5.
    pub fn increment(env: Env) -> Result<u32, Error> {
        // Get the current count.
        let mut count: u32 = env.storage().instance().get(&COUNTER).unwrap_or(0); // If no value set, assume 0.
        log!(&env, "count: {}", count);

        // Increment the count.
        count += 1;

        // Check if the count exceeds the max.
        if count <= MAX {
            // Save the count.
            env.storage().instance().set(&COUNTER, &count);

            // Return the count to the caller.
            Ok(count)
        } else {
            // Return an error if the max is exceeded.
            Err(Error::LimitReached)
        }
    }
}
```

Ref: https://github.com/stellar/soroban-examples/tree/v20.0.0/errors

## Cómo funciona

Abre el archivo `errors/src/lib.rs` para seguir al pie de la letra.

### Definiendo un Error

Los errores de contrato son enums de Rust u32 donde cada variante de la enum se le asigna un entero. El atributo `#[contracterror]` se utiliza para establecer el error para que pueda ser utilizado en el valor devuelto de las funciones contractuales.

La enum tiene algunas restricciones:

- Debe tener el atributo `#[repr(u32)]`.
- Debe tener el atributo `#[derive(Copia)]`.
- Cada variante debe tener un valor entero explícito asignado.

```rust
#[contracterror]
#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]
#[repr(u32)]
pub enum Error {
    LimitReached = 1,
}
```

Los errores de contrato no pueden almacenarse como datos del contrato y, por lo tanto, no pueden utilizarse como tipos en los campos de los tipos de contrato.

:::tip

Si se devuelve un error desde una función, se deshace cualquier cosa que la función haya hecho. Si se han alterado las entradas del libro mayor, o se almacenan los datos del contrato, todos esos cambios serán revertidos y no persistirán.

:::

### Devolviendo un error

Los errores pueden ser devueltos desde las funciones de contrato devolviendo `Result<_, E>`.

La función de incremento devuelve un `Result<u32, Error>`, lo que significa que devuelve `Ok(u32)` en el caso exitoso, y `Error(Error)` en el caso de error.

```rust
pub fn increment(env: Env) -> Result<u32, Error> {
    // . .
    if count <= MAX {
        // ...
        Ok(count)
    } else {
        // ..
        Error (Error::LimitAlcanzado)
    }
}
```

### Panelado con un error

Los errores también pueden ser pánico en lugar de ser devueltos de la función.

La función increment también se puede escribir de la siguiente manera con un valor de retorno `u32`. El error puede pasarse al entorno usando la macro `panic_with_error!`.

```rust
pub fn increment(env: Env) -> u32 {
    // ...
    if count <= MAX {
        // ...
        contar
    } else {
        // ...
        panic_with_error!(&env, Error::LimitReached)
    }
}
```

:::caution

Las funciones que no devuelven un tipo `Result<_, E>` no incluyen en su especificación cuáles son los posibles valores de error. Esto dificulta la integración de otros contratos y clientes con el contrato. Sin embargo, esto podría ser ideal si los errores se diagnostican y depuran, y no se pretende tratar.

:::

## Tests

Abre el archivo `errors/src/test.rs` para seguir la sección.

```rust title="errors/src/test.rs"
#[test]
fn test() {
    let env = Env::default();
    let contract_id = env. egister_contract(None, IncrementContract);
    let client = IncrementContractClient::new(&env, &contract_id);

    assert_eq!(client.try_increment(), Ok(Ok(1)));
    assert_eq!(cliente. ry_increment(), Ok(Ok(2)));
    assert_eq!(client.try_increment(), Ok(3)));
    assert_eq!(client.try_increment(), Ok(4));
    assert_eq!(client. ry_increment(), Ok(5)));
    assert_eq!(client.try_increment(), Error(Error::LimitReached));

    std::println!("{}", env.logs().all(). oin("\n"));
}

#[test]
#[should_panic(expected = "Status(ContractError(1)))")]
#E3256B
fn test_panic() {
    let env = Env::default();
    let contract_id = env. egister_contract(None, IncrementContract);
    let client = IncrementContractClient::new(&env, &contract_id);

    assert_eq!(cliente. ncrement(), 1);
    assert_eq!(client.increment(), 2);
    assert_eq!(client.increment(), 3);
    assert_eq!(client. ncrement(), 4);
    assert_eq!(client.increment(), 5);
    client.increment();
}
```

En cualquier prueba lo primero que siempre se requiere es un `Env`, que es el entorno Soroban en el que se ejecutará el contrato.

```rust
let env = Env::default();
```

El contrato se registra con el entorno utilizando el tipo de contrato.

```rust
let contract_id = env.register_contract(None, IncrementContract);
```

Todas las funciones públicas dentro de un bloque `impl` que está anotado con el atributo `#[contractimpl]` tienen una función correspondiente generada en un tipo de cliente generado. El tipo de cliente se nombrará igual que el tipo de contrato con `Client` adjunto. Por ejemplo, en nuestro contrato el tipo de contrato es `IncrementContract`, y el cliente se llama `IncrementContractClient`.

```rust
let cliente = IncrementContractClient::new(&env, &contract_id);
```

Se generan dos funciones para cada función de contrato, una que devuelve un `Resultado<>`, y el otro que no maneja errores y pánico si ocurre un error.

### `intentar_increment`

En la primera prueba se llama la función `try_increment` y devuelve `Result<Result<u32, _>, Result<Error, Status>>`.

```rust
assert_eq!(client.try_increment(), Ok(Ok(5)));
assert_eq!(client.try_increment(), Error(Ok(Error::LimitReach)));
```

- Si la llamada a la función es correcta, se devuelve `Ok(u32)`.

- Si la llamada de función es exitosa pero devuelve un valor que no es un `u32`, se devuelve `Ok(Err(_))`.

- Si la llamada a función no es exitosa, se devuelve `Err(Ok(Error)`.

- Si la llamada a función no se ha realizado correctamente pero devuelve un código de error no en el campo `Error`, o devuelve un código de error del sistema, se devuelve `Err(Err(Status)` y se puede inspeccionar el `Status`.

### `incremento`

En la segunda prueba se llama la función `increment` y devuelve `u32`. Cuando se hace la última llamada el pánico de la función.

```rust
assert_eq!(client.increment(), 5);
client.increment();
```

- Si la llamada a la función es correcta, se devuelve `u32`.

- Si la llamada a la función es exitosa pero devuelve un valor que no es un `u32`, ocurre.

- Si la llamada a la función no tiene éxito, se produce un aviso.

## Construir el contrato

Para construir el contrato, utilice el comando `stellar contract build`.

```sh
construcción de contrato estelar
```

Un archivo `.wasm` debe ser enviado en el directorio `target`:

```
objetivo/wasm32-unknown-unknown/release/soroban_errors_contract.wasm
```

## Ejecutar el contrato

Vamos a desplegar el contrato en Testnet para que podamos ejecutarlo. El valor proporcionado como `--source` fue configurado en nuestra guía de inicio; por favor cambie en consecuencia si usted creó una identidad diferente.

<Tabs groupId="platform" defaultValue={getPlatform()}>

<TabItem value="unix" label="macOS/Linux">

```sh
stellar contract deploy \
  --wasm target/wasm32-unknown-unknown/release/soroban_errors_contract.wasm \
  --source alice \
  --network testnet
```

</TabItem>

<TabItem value="windows" label="Windows (PowerShell)">

```powershell
despliegue de contrato estelar `
  --wasm target/wasm32-unknown-unknown/release/soroban_errors_contract.wasm `
  --source alice `
  --network testnet
```

</TabItem>

</Tabs>

El comando anterior mostrará el id del contrato, que en nuestro caso es `C3UMHVTIEH6GGDBW7MM72Q545HBDCXGU3GMIXP23PQVSBFKNZRWT37X`.

Ahora que hemos desplegado el contrato, podemos invocarlo.

<Tabs groupId="platform" defaultValue={getPlatform()}>

<TabItem value="unix" label="macOS/Linux">

```sh
stellar contract invoke \
    --id C3UMHVTIEH6GGDBW7M72Q545HBDCXGU3GMIXP23PQVSBFKNZRWT37X \
    --network testnet \
    --source alice \
    -- \
    incremento
```

</TabItem>

<TabItem value="windows" label="Windows (PowerShell)">

```powershell
contrato estelar invoca `
    --id CC3UMHVTIEH6GGDBW7M72Q545HBDCXGU3GMIXP23PQVSBFKNZRWT37X `
    --network testnet `
    --source alice `
    -- `
    incremento
```

</TabItem>

</Tabs>

Ejecuta el comando varias veces y en la 6ª invocación deberías ver un error como este:

```
...
error: la simulación de transacción falló: la invocación de host falló

Causado por:
    HostError: Error(Contrato, #1)

    Registro de eventos (primero más reciente):
       0: [Evento de diagnóstico] contrato:<your contract id>, temas:[error, Error(Contrato, #1)], data:"escalating Ok(ScErrorType::Contract) frame-exit to Err"
       1: [Diagnostic Event] temas:[fn_call, Bytes(b7461eb3410fe31861b7d8cfea1de74e118ae6a6ccc45dfadbe15904aa6e6369), increment], data:Void
...
```

Para recuperar el valor del contador actual, utilice el comando `stellar contract read`.

<Tabs groupId="platform" defaultValue={getPlatform()}>

<TabItem value="unix" label="macOS/Linux">

```sh
stellar contract read \
  --id C3UMHVTIEH6GGDBW7MM72Q545HBDCXGU3GMIXP23PQVSBFKNZRWT37X \
  --network testnet \
  --source alice \
  --durabilidad persistente \
  --output json
```

</TabItem>

<TabItem value="windows" label="Windows (PowerShell)">

```powershell
contrato estelar leer `
  --id C3UMHVTIEH6GGDBW7MM72Q545HBDCXGU3GMIXP23PQVSBFKNZRWT37X `
  --network testnet `
  --source alice `
  --durabilidad persistente `
  --output json
```

</TabItem>

</Tabs>

[`stellar-cli`]: ../getting-started/setup.mdx#install-the-stellar-cli

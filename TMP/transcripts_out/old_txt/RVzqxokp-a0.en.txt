welcome everyone we're trying out
something new by holding the Stellar
protocol meeting here on the Stellar
stage in the Stellar dev discord
we've been experimenting a bit with
platforms the goal is to try to have
these meetings in public so that people
can see what's going on and can ask
questions and can understand the
thought process behind changes to the
Stellar protocol but we also want to
make sure that the platform is not buggy
that it works that it's easy to
reproduce the meetings and it's that
it's easy to attend them and so we're
hoping that this works we've tried a
few different things if this doesn't
work we'll keep trying things until we
get the right
fit
but we'll see what happens today so
bear with us
I will say that these meetings the
Stellar protocol meetings are designed
so that we can discuss upcoming changes
to upcoming versions of the Stellar
protocol in order to advance the
protocol to meet ecosystem needs so a
lot of the times what we discuss are
caps core advancement proposals and this
is where sort of new features that we're
going to add to Stellar are big changes
to the Stellar protocol start right
and they are essentially technical specs
that outline changes that we plan to
make to the Stellar protocol and
anyone can read these caps they're in a
public github repo the discussion for
these caps happens on a public mailing
list and some of them also here in the
Stellar dev discord again if anyone is
interested in this process or in
understanding the caps or in leaving
feedback about them or asking questions
we encourage you to do so and in fact if
you're going to follow along with this
meeting it's a very technical meeting so
I would suggest taking a look at the
caps
in question
at the moment we're focused on project
jump cannon which will bring smart
contracts to Stellar and there are
actually we've sort of modularized our
approach to this we're taking different
segments
of the engineering work that needs to be
done to make changes to the protocol to
allow for smart contracts and created a
series of caps each of which sort of
addresses a specific portion of that
work and so at the moment there are
actually five caps that relate to smart
contracts
we have 46 47 48 49 and now 50.
and over the past week there have been
some changes to cap 46 and 47
and cap 50 is a new cap today we're
going to start to continue the
discussion about these things and
you know as part of that we we certainly
again encourage you to take a look at
the caps encourage you to take a look at
the mailing list and we in these
meetings try to address some some
questions synchronously that are
important to discuss together but a lot
of the work also happens asynchronously
so I encourage everyone to follow along
with that and so today
it's a fairly open-ended meeting
and I think
I I don't know I I'm not even sure the
exact best place to start I know that
there may be some stuff to discuss on
cap 47
I don't know if we're ready to discuss
cap 50 yet or if we still have open
questions about cap 48 and cap 49

so I guess the the first question I have
I guess lee is not here I know that
there were a few questions about cap 46
but it looks like sid you may have
addressed those questions

maybe we can get a quick review by john
over cap 50 and the latest changes made
there
perfect thank you let's do that
done
great
we can open up there although I do
think we probably should go back and
talk about 47 what's in earth later i
don't think we've actually spoken about
it much in any of these meetings but
let's let's start with some overview of
what's going on on 50.
so cap 50 is if you saw the the first
draft that came out I don't know about a
week ago
maybe a little more than a week ago
it was really focused on just like
the question of like what does it mean
to sign smart contract transactions on
Stellar
the scope of it over the course of the
week as I thought about it and talk to
people a lot of people a lot of times
really change from just like what does
it mean to sign but more of what does it
mean to do and what is the ownership
model that
we think should be like the default
basically
of owning it like basically like what
does it mean to take an account take
an action where your action affects some
assets that you probably own
and so basically like
in terms of what's in cap 50 and what
has changed in the most recent
edition
basically it opens up with
with let me actually look at it while
I'm talking about it
it opens up with some comparisons
against like
why the model that is used in ethereum
is really effective the model being
basically like
you can take actions in general for
message.sender in ethereum

there are some exceptions you know where
you use signed messages and stuff but
you know prc-20 tokens for example kind
of a bedrock aspect of ethereum
are based on this notion of like if
you're a message.sender you control the
assets and you can do whatever you want
if you need to delegate that control you
use transfer from which works via an
approval message where first you were
message.sender to commit that approval
so this is the same kind of model that i
then propagate to Stellar
and so we introduce some new types of
transactions basically
which I'm talking about here is like an
invoke contract transaction
this transaction starts off looking
just like a classic seller transaction
source account sequence number fee all
the stuff you're expecting to see
then the next set of parameters are
basically like
what contract do you want to interact
with what symbol are you looking up what
parameters are you going to pass that
function that corresponds to that symbol
if it exists
and then a read write set which I don't
talk about at all and has nothing to do
with this cap and it's really more to do
with cat 46 I'm not going to talk about
it
then the next thing that introduces like
okay well like who is running this
transaction like when I ask who is
message.sender or the terms I'm using is
like this get invoker function
host function
what is it going to return when I run
that contract
and so basically there's a new signature
slot that basically identifies that
that person that key

and then there's one more layer outside
of that which has your normal Stellar
decorated signatures
and there's a ton of justification about
like why that's a good model

why certain things are done like this
like why do you have this like three
deep nesting of structure and all this
other stuff why shouldn't you you know
just do signature verification in every
contract why shouldn't you do replay
perfect prevention every contract all
the stuff kind of ties into it but

that's kind of what's in here
so john one thing that strikes me here
is that it's a fundamental shift from
the Stellar the current Stellar account
model
in the sense that
you know it doesn't have
the all the kind of like the high level
stuff that you get in a Stellar
account it really boils down to like a
single signer account right
yeah exactly
and I think there's like a lot of merit
to this model
mostly because like
one of the things you get from like
having a Stellar account is this like
ability to have multiple signers
but like in reality we use like 80 25
519 and you can do a threshold scheme
for that anyway so like
you can just sign with a signal signal a
single signature on chain
that is like produced to be a
multi-party communication
multi-party computation off chain
get a lot of the same results as you
know having an account with multiple
signers
the other things that are on the
account

there is like when you're running
a smart contract you don't have access
the way that I'm proposing that we've
been talking about things right now you
don't really have access to like your
native balance your native trust line
directly
so there's no need to have an account
to store that balance instead you would
potentially do like a cat 49 wrapped xlm
type of thing

you don't
like you can use a different account
sequence number you don't need like if
you want to have a sequence number you
with the same key you can but you
don't need to so
basically this is just like a strictly
more flexible model that's going to be
more efficient on chain because
everything boils down to a single
signature
that's my stance at least
yeah it's worth mentioning that even if
you use threshold signatures if you want
to rotate keys you still need to modify
the the key which is basically not an
option here

that is
sort of true
there are two ways you could do
threshold signatures I'm like not an
expert on photography but like
if you want to rotate the underlying key
like for example if you're like
underlying secret key was compromised
then yeah
you definitely don't have that option
here but if you just want to rotate the
key shares
that's actually possible in a re-deal in
like a in a threshold system that
supports redealing
so
it depends what what level of security
you're looking for here
interesting and what's the relationship
between
the
classic Stellar accounts and these new
jump cannon accounts
none whatsoever
like
you might have an account that's like
gabc
and you know you might want to sign
for
you know your smart contract
interactions as like gtomer
assuming that you actually had the
secret key for that

vanity
basically like
in terms of running like in terms of
becoming the invoker the message.sender
you don't need a seller account to exist
for that purpose
it it's totally completely logically
separate I guess as long as you control
the key you can become message.sender
I think the distinction is not the jump
cannon there are jump cannon accounts
and there are Stellar accounts I think
the distinction is that there are
Stellar accounts and john cannon doesn't
actually have accounts jump cannon just
has
signers or signatures
that's a really good way of putting it
lee
well
you you still have a concept of an
account on
on the jumpcat side but it's more of an
like it's like an emergent behavior
thing right it's like the sum of
everything that this signer
you know owns in different contracts
becomes the account it's like an
abstracted
yeah I mean you you couldn't describe it
like that

but I think there's no physical
representation
yeah I think there's like what the
protocol defines and the protocol
doesn't actually define an account
in the encounter in the cap50 proposal
so I mean the ecosystem
and tooling can all refer to these
things as account they can treat them
like accounts they can display them in
that way but the protocol doesn't
actually
enforce that
like it does today
in principle if everybody hated this get
invoker mechanism even though it's like
very it's exactly parallel to the
message.sender
mechanism in ethereum but suppose that
everybody in the Stellar ecosystem
totally hated it
the proposal actually described so
you could just completely ignore it and
like everything would work because oh
that's actually that's one thing i
should point out compared to the earlier
version that you and I have discussed
tomer this version actually makes the
invoker signature optional
which was something that came up when
I was talking to nico
about like there are lots of times when
you just like
don't need an invoker signature like the
contract will never ask who the invoker
is
because it's not relevant and the
invoker's saying friends in ed25519
where you need to reveal the key also
ends up being like 96 bytes
and you just like y sign with some
random key for no reason you could just
do nothing so if people don't like this
mechanism ignore it
I'm still trying to wrap my head around
the interaction between like from the
user perspective
you know they have like a an account on
the Stellar side

and like what happens when they move you
know let's say we're in the world of cap
49 not that I'm suggesting we should do
that let's say we're there and I move an
asset to the smart side
and let's say that my my classic side
has some sort of like multi-sig
baked multi-sig scheme
like what would be like the the the
behavior here the expected behavior
that's a really good question I think it

it depends on what the wallet kind of
wants to do
for me the kind of same thing to do
would basically be to let's say this is
the first time you're interacting with
smart the wallet generates a new key for
you or it asks you if you want to use
some key that you have

but probably it should just generate a
new key for you
and then like somewhere in this
proposal
there's like a lot of stuff here now
in the like
compatible with cap 49 section wrap

it basically what you end up doing is
you end up signing with the whole
multi-sig configuration on classic that
you need
you run this rap and it'll be at the
medium threshold I should say you run
this wrap operation
it wraps it up into a smart asset in the
cap 49 cents
and it sends it to that address whatever
address you specify now that's the
address that owns it on the smart site
so I'm expected to migrate to
a new
account id
if you don't have multisig setup you
don't need to

if you do have multi-sig setup and you
like you uniquely control the key you
don't need to
like for example like imagine that i
have like you know three hardware
wallets
and I need two out of three of them
to sign to do anything on my account
well it's perfectly fine for me to do
the public for me to use the master key
I'm the only one who knows it
but like if I'm not the only one who
knows the master key then that's not
going to work
so it really depends a lot on the
configuration of your account but you
should propose
address is going to be the same no
do we propose a new stir key for the
jumpcat inside for these account ids
I don't know
that's a good question homer
they're
maybe maybe we should yeah
I mean you will need
yeah you will need that anyways for yeah
if you want to deposit into contracts
so I think the like the dangerous thing
here is that I have an account on the
classic side it's a it's a account
it's a multi-sig and let's say that the
the master signer is is nullified
and now I ask someone to send over an
asset on the smart side
they use that
like the public account id
and now
I don't have that and so I'm screwed
indeed if that happens you are
completely screwed
sounds like a pretty big footcon
I mean in general on smart
and this is like this is not unique to
Stellar this is like true on ethereum
with the rc20s too if you send money to
the wrong address
bye bye money
like it's not like seller where we're
just like oh that account doesn't exist
sorry

yeah but if the wrong address is the
right address and it's on classic that's
that's problematic
yeah that's that's the big problem the
fact that they're like two domains and
you have like these addresses that are
valid in both domains but actually mean
different things that's that's like a
a huge foot gun so I do think
if we're going down this route I would
definitely say that we need a new
sturkey for accounts on
john cannon
well and or a new way a new
new type of
account on classic right the people
should create deterministic accounts on
classic that don't have a master signer
so you can't accidentally use the master
signer
but yeah having a different circuit i
guess would
would mostly do the same thing
huh that's actually not a terrible idea
it just seems kind of wasteful to me to
require a classic manifestation
of an account to do stuff on smart
there's there's actually no dependence
on that thing having any physical
manifestation so like requiring it to
come from a deterministic account just
seems like
super unnecessarily fast like a lot of
them you know I'm just saying then you
can't interpret a deterministic account
as a
you know because like a deterministic
account would have a difference turkey
right and so people kind of moved over
to that I mean I guess the question is
is the plan to kind of like completely
junk classic and get ready for is is
a plan that like
you know classic will form the basis of
like a super low cost like high
performance decks and payment network
right so in the latter case
it seems worth it to like say that
because these smart contracts are
designed to interoperate with classic we
should like make use of the
you know this author did the we should
have like a single
sign-on if you will for both
sides of the network but if the plan is
eventually
to deprecate classic then maybe it makes
sense not to have single sign-on
I mean like single sign-on is a myth no
matter what in the world of smart
contracts what if I just build a smart
contract that doesn't use the same
scheme like what if I wrote a smart
contract that actually just does
the same thing
as the current get invoker scheme you
know it does it by you know you submit a
single signature I validate that
signature and that's that yeah I mean
you know of course you can you can
implement crypto schemes that aren't
even supported in classic or whatever
you can do anything it's a smart
contract well the question is what are
we going to make like super easy and
what are the idioms that we're going to
kind of train our our developers to
use effectively
yeah john I definitely agree with with
david here because
if you look at both cap 50 and cap 49
there is
you know they kind of imply
that you know we expect everything to
kind of like move to
the smart side in reality if we want
them to coexist
then you know cap 49 cap 50 are I would
say
simple from a protocol perspective
but they introduce
downstream complexities across the
ecosystem of having you know two types
of accounts and two types of
of balances
so the question is
you know does it actually make sense
if we do think that they'll coexist you
know what david proposes like for like
having this like
another new account that you can migrate
to
it's a minimal it's a different type of
account it's a minimal it's a single
signer account but it actually has
representation on both sides

that might be
you know something that that's worth
considering if we expect classic and
jump cannon to coexist
yeah I actually just want to jump on
that and just just emphasize this you
know that two sets of keys like two sets
of accounts I think we have to
evaluate this in the context of the goal
of

equitable access
so this is a like
all of this complexity for users
is maybe easy for someone who is
immersed in the crypto
like in the blockchain space
but
for for your average user who is an
immersed in in blockchain technology
that's a pretty high bar
of complexity to to navigate
yeah and it's not it's not just the
absolute complexity but kind of the the
shape of the curve leading there like in
an ideal world the sort of the the
expert there's kind of a smooth line of
like the amount of expressivity you gain
versus like your expertise right and so
like if you start just using classic and
you want to write your first smart
contract it's actually there's like a
relatively gentle on-ramp to get get
you
doing that right versus okay now create
a new account type and whatever and i
don't know
what I don't understand is david's
proposal doesn't eliminate the need for
having
two sets of keys
like you just end up with like okay like
now I have a classic account a normal
one a g account i'll call it
in the in the terminology we're using
an eternity ago when we were talking
about deterministic accounts
and now I'm going to create another
account that's a d account that has a
different key
and I'm right back where I was
so I don't know
my interpretation of david's proposal
is not
to maintain these in parallel but you
know you get an option to migrate to
this new account type you know the
account this d account
is a single signer account that's valid
on both sides
and from that point on the user the
user doesn't actually interact with with
the g account anymore like they they
have like this one time migration
and presumably new accounts are this d
type but by the way I don't actually
think this is necessarily better right
like I think that
our
you know maybe the concept of
just like you know account authority
is is something that
makes
sense to just kind of expose in the
smart contract world right and say like
well these aren't smart contracts and
avoid their smart contracts intended to
interoperate with the legacy

Stellar accounts and so to just kind of
like
expose that
the way
you know we expose single sign-on across
multiple services is is a useful thing
is there is there like
again what's the driving force for
like why we can't have this key
signature be the decorator signatures we
have today
and
instead of
having the source account be
message.sender so like the account the
classic account id
being message.sender which means
contracts still are only dealing with a
single
identifier like you know they're dealing
with
account id or contract id as the message
message.sender
and then the protocol just hiding the
fact that
you know for the most of the time that's
going to be the master key
but sometimes there might be a
multi-seek key but contracts don't
actually get exposed to that so from the
contract from the jump cannon side it's
the same experience
it's an account id
or it's a contract id and that's it
and like I think
if I understand correctly the thing we
were going for with key signatures is
that accounts don't have to exist
and then we just say that
an account id doesn't have to actually
exist on the classic side for it to be
usable on the
well I guess it does doesn't it okay
sorry
no it doesn't like it's this it's
actually the same in classic right like
you you don't have the account doesn't
need to exist to use it
like you you can if it's a single
key
like you know like you can always
reference it and use it in different
schemes like you know as a signer for
example it's just a key
so i'd intended to write about this
before this meeting today there wasn't
enough time it's on my list of things to
talk about like why it should work this
way and not be just the account signers
signing for it but at the end of the day
my justification just comes back to
pre-signed messages
all the time for this
which is that if we don't expose what
the account signers are what does it
mean to have a pre-signed message let me
give you an example imagine that you're
writing an erc20 token
which is all my examples nowadays
because it's like super fundamental
token that we're all familiar with
you have these these operations
you know you have
balance of and allowance and approve and
transfer and transfer from and blah blah
blah blah blah blah blah
and in this model everything still works
based off of message.sender
so now what I do is I sign with my
account let's say that I have a two out
of three multisig account like I was
talking about before with like you know
I own three hardware wallets I sign with
two of them that's how I do stuff
the account only gets message.sender
which is my source account in this model
okay but now I want to implement eip2612
permit
how do I do that
like how would you even default
how would I even define either 2612
permit
also I'm seeing people
complaining about my mic volume

okay david then you should just adjust
your
just my volume for you everyone sounds
good it's just some people are much much
louder than others so I have to like
constantly adjust my volume which is
annoying but
if you
right click on me you can adjust my
volume to you
anyway
oh awesome thank you yeah I got you
so how would you even do eip2612 permit

like the way that that works is it works
based off of signing a message
for the public key and that was
message.sender
okay so basic and like what
signatures do I use now
like do I use the account signatures
then it's not transparent
I have to go and actually look up the
account find its signature find the
designers check them against that blah
blah blah blah blah blah
or do I just use the single signature
for the public key which is the very
much more computationally efficient
thing to do
but it would be wrong it wouldn't convey
the right access controls
can we maybe like I think there are
like two problems that we are that we
are trying to deal with here there's one
around I think
and I think this one exists even in the
current version of cap50 like regardless
that is
when I give somebody my address right
like my public address

how does it look like if I decide to
upgrade my account you know when I say
upgrade to my account to a smart wallet
like I really want to move all my
balances and stuff right under my wallet
so how would that look like I don't
think the current
proposal kind of allows you to deal with
this type of situation

and then for the
for the signature scheme like like
why not so right now we have keyed
signature now that it's actually inside
I think what we can do is actually make
add a new case
that would be like classic scheme or
something right that
that is just account id
and then threshold and then and then
and then the decorated signatures
and that's it
and then you can actually use your
like the invoker can be an a classic
account id
which means you can actually
use that as a
you know when you
as a recipient for
anything really and then you have the
threshold
like you do on classic
great but then right back to the eip2612
permit like you still have to go and act
like if I'm a contractor implementing
the ip2612 permit
I have to actually go and read the
account look at all the signers check
the signal no no you do you wouldn't do
that like
you
because you never sign like to sign
something like when you sign a a payload
what you the the statement that you have
is
here's a binary blob right that you want
to sign as a specific invoker right

and then here the signature is fresh
like like basically you have to sign
a statement that says those
signatures when you add them to

when you yeah like
evaluate them in the context of this
account you reach this threshold you
cannot guarantee that
I don't understand how the account could
not go and like could avoid going and
checking
the contract could avoid going and
checking I just I don't see how that
yeah yeah well it's the same like
well that you mean verification wise is
that what you're asking that's that code
is yeah that would be like like we
need a a function of source that is like
verify right that is
suppose the classic scheme I think
that's kind of all there is to it
but that has quadratic complexity
yeah
that's okay like
it's really not
no like it's all about
what is it
no
no like it's gas codes right like if
people want to do that they're not
blocked from doing it
but it's like really really expensive
whereas like just checking a single
signature
I'm not saying to remove the single
signature I'm saying that you you have a
way out of the like
my public address is g whatever and i
I don't
if somebody you know like sees my public
address and decides to send me funds
using smart
I want that to not go to the devnet and
then you want the contract in you
want the contract implementer to go and
implement both verification methods
I mean what you think is we could also
have like a
you know like a parameter type or
something like a signed blob
or an account authenticated blob that
would that would be you know it would
be checked
independent before executing the
contract basically like maybe we don't
need to verify dynamic data like all the
signatures can be checked statically
we're getting into the area of being
like super parental and telling people
how to write their contracts when as a
matter of fact you know they already
have especially things like the the type
of bridging applications that need this
type of capability they already have
implementations on other networks we
don't want to be to
parental i
I think
I'm on I'm on john's side with regards
to
keeping simplicity
you know as a core value and and
really like zooming in on these like
single signer
accounts

but I'm really concerned about the
interoperability aspect you know
for the ecosystem and I do think that
having migrating to some sort of like a
new account that is a single sign or
simple account
that you obviously you can only
migrate to you know if you if you
have a single sign or a current account
but having that
being existing on both sides
is something that the ecosystem can
tolerate
it's a little bit more complicated than
that tumer it's not just that you can
only migrate if you have a single signer
it's that you can only migrate if the
only signer is the master key
and that means lots of accounts will be
locked out
yeah so I so what I see is you know
like your wallet can you know
obviously there's like a migration thing
and your wallet can tell you hey
if you want to work on smart you need
to migrate to this new account
most accounts by the way are just you
know like single signers and they do
have a hundred percent of the of the
like master weights so I don't actually
think that's a problem but you know
your wallet can tell you hey like this
is
you know this is like the new type of
account if you still want to maintain
your multisig these are like other ways
you know you can do multi-sig in like
this brand new world
but but the thing is that that migration
happens once right I don't have to
actually as a user as a well while
developer need to I don't even think
about about this every time I move
between sites
yeah I think it makes it pretty
difficult for wallets either today or
that are developing for standards like
sub 30 for example to be able to to then
it will also interact with this world
like we're still sending people down
this track of like
you need to have two sets of keys

because the migration path is not
particularly clear I think
otherwise
or we're saying like you have to migrate
all the way to this only smart only jump
cannon
construct
like how how like how would you have
multisig on jump cannon and multisig off
on classic at the same time with the
same account is that doable
I'm I'm proposing
like not to actually ever like having
just a single migration and then you're
in this other world which is both
classic and jump canon but it's on a
simplified account model now if you have
a multi-sig account on
right now on Stellar
then
we can think about ways to either
you know either do threshold signatures
or just actually deploy a multisig
contract the same way that multisig
contracts are on
you know ethereum and other ecosystems
what you're describing is every account
that exists on the network today that
uses multisig deploying their own
contract on jump cannon
that is one option again that's only if
you want to interact to interact with
jump cannon right so if you're a vibrant
user and you don't you know you're not
using any smart contract
like these are not things that we
need to have figured out like the first
you know like
at launch
and yeah it does not have to be like
one contract per per wallet right it can
be
obviously the parity wallet is not a
great example but the parity wallet was
like a single contract that provided
multi-sig for a lot of a lot of accounts
right
you hear that while it's super secure in
fact nobody's ever been able to get
their money out of it
yes it is super secure I mean I still
don't understand the whole like I call
immigration thing how does that I mean
like if if you look at some of the
interesting accounts that are multisig
right issuers like are we saying that
changing the issue are probably key
no I'm not saying
I'm not saying that at all I'm saying
you only need to
to
migrate to a new type of account if you
want to interact with
with jump cannon and cap 49
proposes that exactly but like to a much
greater extent right you need to every
time you move
between between the like I'm I'm talking
about the issuer
why would the issue where needs to need
to migrate
well
they don't want to have like any
presence in jump cannon
they will have to use a different
account I guess
I think like there will need to be a
distribution account
potentially that if they want to
interact with smart contracts they need
to be on
on smart but i
you know I think that depends a lot on
the the asset interoperability story
which
you know we still need to think about
can you just tell me what this migration
looks like like I want to mic
you know I want to migrate from my
classic account to a smart account
what is what has to happen
I actually have to like somehow move
balances or does it just like transmute
balances
and annihilate the classic key
the
very simple happy path for something
like this is that
you log into your wallet your wallet
tells you hey we have a lot of new
functionality on smart contracts but
for that to work you need to migrate to
a new account let's call it a d account
it takes you through the process and
once you end it
you know effectively like merges your
account and and I'm saying happy path
meaning that it's there's just a single
signer and it's a and it's the master
signer
and then you know now you have a d
account and you can either
operate on regular Stellar classic
you know make classic payments and such
or you can operate on smart contracts
but it's a simple account you cannot you
can never actually do on-chain multi-sig
the way that you did with your
previous account
I don't know if we need to explore
necessarily like yeah like in this
meeting like the
actual
this actual migration flow
it sounds like it will have a lot of
edge
cases like I'm thinking like
from a kyc point of view right like you
have a bunch of trust lines
like you probably I mean
you need those d accounts to have the
exact same
public key because that's what got kyc
all you you deauthorize trust lines you
know that's another option
but you know
things like that
yeah again like happy path constitutes
of accounts that are very simple they
have a single
master signer and and assets that are
for the most part you know the
overwhelming majority are
not asset not auth required or and
and can can easily be moved
cool yeah just that that's all I was
hoping for was a very quick explanation
to like help clarify in my mind what it
was that we were talking about
thanks
I mean like
I need to think about it more
i
I'm like
i'd really what I really would need to
do is go and like look at what the
current like configuration of accounts
network wide is you know there's like
6.7 million accounts or something like
that
can most people actually just migrate to
a new public key
meaning that like their master weight
has weight one
all the thresholds are equal to one
if that's the case
or I said migrate to a new publication
migrate to only their public key
if that is what most accounts are like
then like maybe this is reasonable
if most accounts aren't like that or
even if many accounts aren't like that
then I don't think it actually gets us
anything there's no worth there's no
worth poking holes in it because it's
just like
not general enough to be worth
considering
so I need to go and like you know hit up
hubble and figure out what the
situation is
wait hold on quick
I think the alternative people
still can't use
smart except now they could lose
money if people accidentally send the
money on smart
i'd rather have a world where most
people can't use smart than one where
most people can't use smart but it looks
like they can and so money gets
destroyed
yeah I also just want to point out like
we can research this with hubble but
what we should also evaluate is
there may be a lot of accounts on hubble
that are not actually meaningful and
whereas we should also have a look at
products that are getting developed
either recently or in the future that we
know of that are getting developed on
Stellar are they using multisig are they
using things like sep 30 how are
those
products like what's the story going to
be for products that are that are just
setting out now with multisig
because
if we do just have a look at just hubble
we may find a large number of accounts
that only use a master key they also may
be inactive accounts maybe accounts from
the past accounts that are not actually
relevant to

where we're going from here
yeah but lee like we're not saying we're
not annihilating the idea of multi-sig
right we're just saying
that like
these you know we need to find like a
different
multisig construction for these accounts
moving to this new account type
well it sounds like
on some level at least though doing some
research is is a good idea to understand
how people are using multisit currently
right
any other thoughts on this issue I mean
we have about 14 minutes left and we can
stay here or we can move on
now i'd like
to go back to like the first thing
because maybe that's what that would be
a different approach to this problem
that is like the the question i
I was asking earlier that is how do we
think about
like I don't know how this is solving
ethereum like if you if you have this
flexible
invoker thing like
if I decide to
to take my account and move my assets
into a smart
wallet
my smart wallet becomes my public
address in a way
I think right
so
how does the money gets routed if
somebody sends money sends funds to
my
old key
if you have the address
and sorry if you have the key and only
you have the key you just go grab it
public key no no what I mean is that
well it's kind of funny right like does
it mean I have to even though I decided
to upgrade my you know my setup to a
smart wallet
I still have to keep this kind of
single key setup around forever upgrade
to a smart wallet you also have a smart
wallet

welcome
there's no way to stop using that
address other than to tell everybody to
stop sending money there
like
I mean it's no different from when you
move houses right like people will keep
sending mail to your old address much to
usps's display
unless you tell them not to so you can
do forwarding right in that case so
that's kind of what I'm getting through
there's no way we're going to do that
probably
like no but like for like if we had
to support those type of scenarios some
way to do forwarding you could do
forwarding for
those multisig accounts
why do forwarding though just keep the
key around until you don't want to
forward anymore and go and collect the
money
like we don't need to be
you know we don't need to be dad for
these people if they know if they want
to switch to a smart smart wallet they
should know what to do
no I'm just trying to kind of compare
the complexity of like migrating to
those d you know whatever accounts
to
having a way to
to kind of
make it easy for people to change their
keys basically and
even in smart
if you make it easy for people to change
your keys you're just gonna end up right
back at the okay well now I have to go
and read this other thing and check the
signatures based off of that and
everything becomes less efficient like
do we care about performance or not
if we don't care about performance let's
just glue on the evm and get 13 tps i
don't understand why we're working so
hard if we care about performance we
can't do that and we have to do better
but that means we should be making
decisions that matter
I mean it's it's not just about
performance right it's about like the
whole reason we are talking about this
is for usability right like making it
that people don't have those food guns
you know everywhere
but I mean I think that we
we care not so much about performance in
absolute terms as the the scalability of
performance in terms of cores so if we
can kind of split it up into work that
can be parallelized and work that can't
be then as long as there's a way to do
the signature checking such that it can
be paralyzed I don't care if it's you
know i'd rather have it be four times as
expensive but embarrassingly parallel as
like you know four times faster and like
it's competing for like the same cpu
core as like all the other logic and all
the
transactions
sure but i'd also rather it just be
embarrassingly parallel and not four
times slower and like what I'm saying is
like these the discussion we're having
right now doesn't change the
parallelization well it probably makes
it a little worse because there'll be
more contention
but it doesn't like it definitely
doesn't make it better that's definitely
like nico's proposal will not make it
better but it does mean there's more
work for everybody to do so it's
definitely going to be slower
should we just add bls signatures the
other thing is like do we have a
particular it seems like
not all implementations of threshold
schnorr
like people like cut some corners like
do things that like
we don't know how to attack but they
don't
they prevent the proofs from growing
through
so
there's the fact that like
the multi-state we have now is it may be
slow but it is
very simple and very easy to understand
the security
and if you want this level of security
you can still use a smart a smart model
you just pay for it
and if you trust the threshold schemes
you use the threshold schemes and if
you're happy having a single key you use
a single key
same thing I said before
like I don't need to to tell people
what to do in the land of smart
contracts because
in a land of smart contracts if they
don't like the thing that I told them to
do you know what they're going to do
they're just going to do it slower
differently right anyway you can make it
easy for them to do right so you can
make it very easy for someone to use it
in a smart contract to check that
something's been authorized by a
particular classic account right and if
that is something that's easy to do then
people will use it where it's
appropriate and there'll be more
coherence across the two worlds
do we want to talk a bit about contract
lifecycle today
we have we have like eight minutes
but I mean there are some open questions
that came up during the
in the dev mailing list that I can talk
about
if we think
we have enough time
I think
I think we should start on it and if we
run out of time we can bring it back up
at the next meeting
okay
so one of the questions we're
still discussing discussing is if the
contract

code vector should be
like the size should be fixed in the xdr
it should be configurable by the
validators
and you know the advantage of having it
configured by the validators is if for
some reason we think it's
you know if there's an issue the
validators can
if there's an overlay issue for
example
and fix it through the values instead of
you know updating the xdr which would
require a I believe require a protocol
upgrade

does anyone have any thoughts on this i
think john is john's advocating for it
to be fixed in the xcr and nico was
advocating for it to be configurable
well you need a parameter upgrade either
way right or are you suggesting that
different validators have different
thresholds
no so yeah you yeah so you would need

you need to be a parameter upgrade
and like an upgrade to the validators
or a protocol upgrade
right so either way it goes to a
consensus in one
you don't need to recompile
that seems reasonable to not have to
recompile I guess
or to pick maybe maybe we don't pick
like four gigabytes but we pick
something that's much larger
than we think people should need in the
xdr and then we enforce a lower limit
in validators
that's what I was thinking
yeah I I'm just like my big concern
about this is like it's not safe to ever
make the number lower you can only ever
make it bigger
and I'm just like
what is the point of this work
like why why shouldn't we just choose a
number
that makes sense
and
basically if we want people if people
want to write bigger contracts just
split your logic up among two contracts
I mean it's not a big deal
like
do we really want people uploading this
upload like a gigabyte 100 megabytes
like what's what's the number that we're
happy with people uploading in a single
operation
choose that number and call today
likewise what's the number that we're
happy loading up into the vm as a single
operation we'll call it a day
great and I can see you're talking i
can't hear you at all I don't know if
anybody else can
hey can you hear me now
yes
cool yeah I just wanted to point out
we have the same
issue basically with like there's
gonna be quite a lot of fixed numeric
parameters in the system it's it's
really not just one although the cost
factor is all the memory limits all the
parallelization factor when we get to
parallel parallel execution there's
there's
there's gonna be a big bucket of numbers
that are just constants that the system
runs on and
there's gonna be
this is this is a cap coming at some
point we haven't got to it yet but
there's going to be a a parameters block
we're not we're not going to have a a
single parameter in the ledger header
for every single one of these because
the ledger header will get gigantic
a new magic ledger entry called smart
contract numeric parameters
and people are going to have to vote on
that on a regular basis so
I I would just say
it is a number
but we would have to agree it's a number
that can only go up then
never forget
no I don't agree or or it can go down
with we have to
have a policy that like we'll give you
two months notice before we reduce it or
something but no I don't agree with
that it cannot go down you can break
somebody's smart contract by making it
go down even if you say like I'm still
willing to run a smart contract that's
that's longer than this was uploaded
before
what if that smart contract itself is a
factory which deploys new smart
contracts
no no no no there's there's no question
that there's going to be perimeter
changes that will break existing smart
contracts that is that's guaranteed
because if we if we change gas limits at
all in any direction

some smart contracts will will begin
passing that didn't or and and that
implicitly means some will fail that
didn't because they were expecting the
other one to pass there there are ways
in which you break people's code by
changing parameters guaranteed there's
there's no way to just make it one-sided
that's not going to work
I'm not clear on why changing the gas
factors would
break people's code like you could
always just run it with more gas right
right but like
it's something that you expect to work
on one set of parameters will work
differently on another set of parameters
sure that's fine as long as I can figure
out how to still run it it is fine but
like if you lower the size fact that you
can like fundamentally break never to be
recoverable a factory contract
it's totally recoverable you just have
to convince everyone to raise the number
again
so right so it's only possible to go up
as a consequence without breaking
people's okay no this
no no I just know I completely disagree
with your premise these numbers
affect
whether
I mean
seriously suppose your contract relies
on on
you call two contracts in order and it's
really important that the first one
fails for some reason because you you
didn't notice that it fails but it's
part of the semantics of your system
working that the first call fails we
increase the element now that now it
succeeds
your system stops working like people
can rely on things in the wrong order if
there's no
and there's no fix for that if you want
the numbers to only ever go up right
like yeah you sometimes you have to
redeploy things sometimes you have to
change things back if you want to fix
them because there's no other there's no
other way you've set a specific set of
parameters
that you've defined as the ones that my
thing works in and if the parameters
change it is possible everything will
work
I mean I think it's it's
when it comes to all those yeah like
weird parameters I think they're like
especially when it comes to any kind of
limit
I think they will will always have like
you know when it comes to coming down
right like from those limits like
if you're close to that limit
yeah I would say like you may get broken
like by some
some
weird tweaks like that like if you
want to be safe just play in a much
smaller you know much further from the
limit
well I think it's I think it's totally
reasonable to expect that that something
like code size is not gonna like there's
no there's no pay-per-view reason why
we're going to start reducing that over
time it's probably the case that would
stay the same and go up and I think it's
a reasonable assumption but it's
it's no different than saying you know
that
your your
set of pre-signed transactions
that you know
can only have a certain
fee that they work under and and they
won't work if the base fees increase or
something like that like there's
there's ways we were actually concerned
about that problem grading yeah and we
were so concerned about it that nobody
wanted to raise the base fee and we
actually did cap 15 fee bump
transactions to fix that problem
so like that's actually like an example
that like proves the point that this is
a problem
I'm
it will continue to be a pro there's i
just there's absolutely no way you can
fix this by saying it can only move in
one direction that doesn't fix the
problem so
as far as I can tell you're you're
demanding that we fix a problem that
can't be fixed
I think we need to just set expectations
appropriately right if we tell people
your contract we promise never to break
your smart contracts it's going to be a
problem right because we will end up
breaking them and we'll also end up not
innovating in ways that we should have
innovated
and so
you know
like
people
validators may vote that they they're
not interested in seeing a particular
parameter upgrade that's that's fair
right it's not it's not like us making
parameter changes it's like
us collectively the entire network right
it's not just sf making these changes
but if a change happens and all the
validators vote for it the validators
could vote to to to migrate to a new
protocol version that turns off smart
contract
you know there's there's there's changes
that can be made among the validators
that will break existing functionality
I guess the core of my argument here is
there are things that we should
that are like worth promising not sorry
that are worth not promising to break
and there are things where we it's like
completely reasonable to make a promise
not to break your stuff
and I think code size is definitely an
example where it is completely
reasonable to promise not to break
people's stuff
you said it yourself you can't foresee a
reason why we would want to make the
code size smaller
not a really simple one but I mean if
you give me a couple of minutes I could
probably come up with something I i
just don't think it's I don't I don't
think it's lightly but you know there's
a difference between likely and what i
think we should be promising I don't see
why that promise I guess I don't see why
that promise is more important than any
other problem there are so many other
promises we could be making that are
also not reasonable this is just another
one that
this really feels like we're bike
shedding at this point like let's get a
thing built and then like
how hard or easy we make it to tweak one
number like that's something we can
figure out it's just not an important
thing
at this point
I think david gets the final word in
this meeting because we're out of time
but
we'll reconvene next week and obviously
there's still activity happening here on
the
Stellar dev discord and on the
mailing list and so anyone who's
watching
obviously feel free to jump in there or
to see what what the discussion where
it's tending anyone in this meeting
obviously will also
talk on those lists and get back
together here next week but we're out of
time for now
you

Okay, I'll get started. , hi everyone.
Okay, I'll get started. , hi everyone.
Today, , we are going to be talking
Today, , we are going to be talking
Today, , we are going to be talking
about CAP 75, which is a proposal to add
about CAP 75, which is a proposal to add
about CAP 75, which is a proposal to add
two new host functions to support
two new host functions to support
two new host functions to support
Poseidon and Poseidon 2 head functions.
Poseidon and Poseidon 2 head functions.
Poseidon and Poseidon 2 head functions.
, so the cap itself is fairly
, so the cap itself is fairly
, so the cap itself is fairly
straightforward. , two new host
straightforward. , two new host
straightforward. , two new host
functions. it it's pretty standalone
functions. it it's pretty standalone
functions. it it's pretty standalone
doesn't involve any of the previous
doesn't involve any of the previous
doesn't involve any of the previous
protocols mostly except using the
protocols mostly except using the
protocols mostly except using the
BLS and BN field. but I want to spend
BLS and BN field. but I want to spend
BLS and BN field. but I want to spend
a little bit time on the approaches that
a little bit time on the approaches that
a little bit time on the approaches that
we decided on and the rationale behind
we decided on and the rationale behind
we decided on and the rationale behind
this approach. So first of all just a
this approach. So first of all just a
this approach. So first of all just a
quick introduction on on the
quick introduction on on the
quick introduction on on the
motivation why do we want the Poseidon
motivation why do we want the Poseidon
motivation why do we want the Poseidon
and Poseidon 2 hatches. so so
and Poseidon 2 hatches. so so
and Poseidon 2 hatches. so so
the Poseidon and Poseidon 2 they are
the Poseidon and Poseidon 2 they are
the Poseidon and Poseidon 2 they are
I'll call them Poseidon family. So they
I'll call them Poseidon family. So they
I'll call them Poseidon family. So they
are they are family of hashes basically
are they are family of hashes basically
are they are family of hashes basically
it accept a range of parameters and then
it accept a range of parameters and then
it accept a range of parameters and then
you can configure it to to compute
you can configure it to to compute
you can configure it to to compute
output. So what it what it is is it's a
output. So what it what it is is it's a
output. So what it what it is is it's a
sponge based
sponge based
sponge based
hash function which means it consists
hash function which means it consists
hash function which means it consists
of a sponge
of a sponge
of a sponge
that absorbs input and fit output
that absorbs input and fit output
that absorbs input and fit output
which is a variable length input various
which is a variable length input various
which is a variable length input various
variable length output function and
variable length output function and
variable length output function and
internally there's a permutation which
internally there's a permutation which
internally there's a permutation which
is fixed input fixed output and the the
is fixed input fixed output and the the
is fixed input fixed output and the the
reason that u it is useful along with
reason that u it is useful along with
reason that u it is useful along with
Other catches of similar design is
Other catches of similar design is
Other catches of similar design is
that it directly operate natively on
that it directly operate natively on
that it directly operate natively on
the on the prime field. And as you can
the on the prime field. And as you can
the on the prime field. And as you can
as you know most of the zero
as you know most of the zero
as you know most of the zero
knowledge applications are built off
knowledge applications are built off
knowledge applications are built off
of the prime field such as BRS or
of the prime field such as BRS or
of the prime field such as BRS or
BM254
BM254
BM254
which makes Poseidon natively work
which makes Poseidon natively work
which makes Poseidon natively work
with with this field and they are ideal
with with this field and they are ideal
with with this field and they are ideal
in DK application. Just to give a rough
in DK application. Just to give a rough
in DK application. Just to give a rough
idea, it the amount of constraints
idea, it the amount of constraints
idea, it the amount of constraints
to generate using a regular hash like a
to generate using a regular hash like a
to generate using a regular hash like a
SH 256 versus Poseidon is two order of
SH 256 versus Poseidon is two order of
SH 256 versus Poseidon is two order of
magnitude difference. So it's a lot of
magnitude difference. So it's a lot of
magnitude difference. So it's a lot of
proof side less proof side complexity
proof side less proof side complexity
proof side less proof side complexity
and time to use Poseidon.
and time to use Poseidon.
and time to use Poseidon.
So for for contrast so proof
So for for contrast so proof
So for for contrast so proof
allocation typically don't involve
allocation typically don't involve
allocation typically don't involve
rehashing or anything. but for
rehashing or anything. but for
rehashing or anything. but for
contract implementing logic such as a
contract implementing logic such as a
contract implementing logic such as a
mer tree that you want to generate proof
mer tree that you want to generate proof
mer tree that you want to generate proof
of you want to have the same hash
of you want to have the same hash
of you want to have the same hash
implementation
implementation
implementation
between your contract and what you
between your contract and what you
between your contract and what you
use when you generate the proof for that
use when you generate the proof for that
use when you generate the proof for that
mole tree. I think that's quite obvious.
mole tree. I think that's quite obvious.
mole tree. I think that's quite obvious.
and to have the Prooseidon
and to have the Prooseidon
and to have the Prooseidon
implemented on the on the gas side or
implemented on the on the gas side or
implemented on the on the gas side or
or contrast side is quite expensive.
or contrast side is quite expensive.
or contrast side is quite expensive.
Even with the functions that we already
Even with the functions that we already
Even with the functions that we already
provide for BLS field arithmetics,
provide for BLS field arithmetics,
provide for BLS field arithmetics,
there's still a lot of round trips
there's still a lot of round trips
there's still a lot of round trips
between converting a few element to
between converting a few element to
between converting a few element to
bytes and and things like that. So
bytes and and things like that. So
bytes and and things like that. So
that's why we we want to support
that's why we we want to support
that's why we we want to support
Prooseidon as native host functions.
Prooseidon as native host functions.
Prooseidon as native host functions.
So just a recap of where we were last
So just a recap of where we were last
So just a recap of where we were last
time. Last time we proposed a few
time. Last time we proposed a few
time. Last time we proposed a few
three possible approaches to this.
three possible approaches to this.
three possible approaches to this.
first is just to provide the hash
first is just to provide the hash
first is just to provide the hash
functions plain and simple. you
functions plain and simple. you
functions plain and simple. you
know for different field you know for
know for different field you know for
know for different field you know for
for different field combination of B
for different field combination of B
for different field combination of B
and BLS combination of PID and PIN 2 and
and BLS combination of PID and PIN 2 and
and BLS combination of PID and PIN 2 and
a combination of number of hash
a combination of number of hash
a combination of number of hash
input. So this gives us what like
input. So this gives us what like
input. So this gives us what like
eight different type of host functions
eight different type of host functions
eight different type of host functions
that will cover a lot of use cases.
that will cover a lot of use cases.
that will cover a lot of use cases.
but this approach isn't good because
but this approach isn't good because
but this approach isn't good because
we've from the feedback and from the
we've from the feedback and from the
we've from the feedback and from the
evidence that a lot of these hashes they
evidence that a lot of these hashes they
evidence that a lot of these hashes they
require particular parameters these
require particular parameters these
require particular parameters these
parameters are not set in stone. So
parameters are not set in stone. So
parameters are not set in stone. So
different implementations could choose
different implementations could choose
different implementations could choose
them differently. So even if we specify
them differently. So even if we specify
them differently. So even if we specify
them in in the host for example
them in in the host for example
them in in the host for example
someone else might need a different way
someone else might need a different way
someone else might need a different way
to provide a parameter. So this way
to provide a parameter. So this way
to provide a parameter. So this way
isn't just provide a hash function isn't
isn't just provide a hash function isn't
isn't just provide a hash function isn't
the most maintainable way and what
the most maintainable way and what
the most maintainable way and what
about providing more host functions for
about providing more host functions for
about providing more host functions for
those field arithmetics and also it
those field arithmetics and also it
those field arithmetics and also it
wouldn't solve the problem because even
wouldn't solve the problem because even
wouldn't solve the problem because even
if we provide things like matrix
if we provide things like matrix
if we provide things like matrix
multiplication the pose hashing involves
multiplication the pose hashing involves
multiplication the pose hashing involves
a lot of rounds of permutation each
a lot of rounds of permutation each
a lot of rounds of permutation each
round is doing this multip
round is doing this multip
round is doing this multip
multiplication so we still end up with a
multiplication so we still end up with a
multiplication so we still end up with a
lot of these cause and a all of these
lot of these cause and a all of these
lot of these cause and a all of these
round trips. so one of the proposals
round trips. so one of the proposals
round trips. so one of the proposals
ended up last time was can we provide
ended up last time was can we provide
ended up last time was can we provide
a more generic interface for the for
a more generic interface for the for
a more generic interface for the for
the sponge hash namely the to
the sponge hash namely the to
the sponge hash namely the to
absorb some input doing permutations and
absorb some input doing permutations and
absorb some input doing permutations and
spit out the output and then be and let
spit out the output and then be and let
spit out the output and then be and let
it be parameterized.
it be parameterized.
it be parameterized.
So yeah so that's what we settled on
So yeah so that's what we settled on
So yeah so that's what we settled on
on last time and and yeah so now to
on last time and and yeah so now to
on last time and and yeah so now to
transition to this cap. So this cap
transition to this cap. So this cap
transition to this cap. So this cap
proposes a slightly different approach
proposes a slightly different approach
proposes a slightly different approach
which which I call approach four
which which I call approach four
which which I call approach four
that from the discussion thread for for
that from the discussion thread for for
that from the discussion thread for for
anyone who's following. So approach four
anyone who's following. So approach four
anyone who's following. So approach four
is instead of providing the launch
is instead of providing the launch
is instead of providing the launch
interface we provide the internal
interface we provide the internal
interface we provide the internal
permutation functions that the launch
permutation functions that the launch
permutation functions that the launch
hash uses. so why why why is that? So
hash uses. so why why why is that? So
hash uses. so why why why is that? So
so the the sponge is the sponge is a
so the the sponge is the sponge is a
so the the sponge is the sponge is a
it's sort of its own animal. It's a
it's sort of its own animal. It's a
it's sort of its own animal. It's a
different animal than the permutation.
different animal than the permutation.
different animal than the permutation.
, sponge design had many different
, sponge design had many different
, sponge design had many different
considerations
considerations
considerations
for different applications. For
for different applications. For
for different applications. For
example, not only for hatching but also
example, not only for hatching but also
example, not only for hatching but also
for like generating like a random
for like generating like a random
for like generating like a random
stream of bytes or or for MAC
stream of bytes or or for MAC
stream of bytes or or for MAC
method message authentication code or
method message authentication code or
method message authentication code or
for for random like for receable
for for random like for receable
for for random like for receable
random value generator like these
random value generator like these
random value generator like these
applications are all u designed
applications are all u designed
applications are all u designed
scope of a sponge. So the sponge needs
scope of a sponge. So the sponge needs
scope of a sponge. So the sponge needs
to be more flexible. It needs to
to be more flexible. It needs to
to be more flexible. It needs to
maintain a state. It needs to in some
maintain a state. It needs to in some
maintain a state. It needs to in some
some cases it requires switching between
some cases it requires switching between
some cases it requires switching between
absorbing and squeezing and then
absorbing and squeezing and then
absorbing and squeezing and then
switching back. So the sponge interface
switching back. So the sponge interface
switching back. So the sponge interface
itself isn't
itself isn't
itself isn't
it isn't a single definition that we can
it isn't a single definition that we can
it isn't a single definition that we can
just just take because and
just just take because and
just just take because and
itself is also has some some complexity
itself is also has some some complexity
itself is also has some some complexity
in it. however the internally all the
in it. however the internally all the
in it. however the internally all the
sponge function they call the same
sponge function they call the same
sponge function they call the same
permutation function. So after so in
permutation function. So after so in
permutation function. So after so in
both stun absorb and squeeze the the
both stun absorb and squeeze the the
both stun absorb and squeeze the the
input and output before it was the input
input and output before it was the input
input and output before it was the input
is passed and then the permutation is
is passed and then the permutation is
is passed and then the permutation is
applied and and the permutation is
applied and and the permutation is
applied and and the permutation is
applied and the output is squeezed. So
applied and the output is squeezed. So
applied and the output is squeezed. So
so at the center of it is just this
so at the center of it is just this
so at the center of it is just this
permutation function that takes a fixed
permutation function that takes a fixed
permutation function that takes a fixed
length input and a fixed length output.
length input and a fixed length output.
length input and a fixed length output.
So this is much more maintainable and
So this is much more maintainable and
So this is much more maintainable and
it's much more easy to support in
it's much more easy to support in
it's much more easy to support in
solarong without ramifications because
solarong without ramifications because
solarong without ramifications because
it's just a simple cryptographic
it's just a simple cryptographic
it's just a simple cryptographic
building block and the sorbound host
building block and the sorbound host
building block and the sorbound host
doesn't need to maintain any any state.
doesn't need to maintain any any state.
doesn't need to maintain any any state.
so there's no like state related
so there's no like state related
so there's no like state related
issues for like what if you make a
issues for like what if you make a
issues for like what if you make a
subcontract call do they you know
subcontract call do they you know
subcontract call do they you know
reinitialize a sponge and how to do
reinitialize a sponge and how to do
reinitialize a sponge and how to do
that. So, so by by supporting Prooseidon
that. So, so by by supporting Prooseidon
that. So, so by by supporting Prooseidon
permutation instead of the full
permutation instead of the full
permutation instead of the full
Prooseidon hash it gives us a lot of
Prooseidon hash it gives us a lot of
Prooseidon hash it gives us a lot of
flexibility
flexibility
flexibility
maintaining sort of host
maintaining sort of host
maintaining sort of host
and also sponge itself for for a h for a
and also sponge itself for for a h for a
and also sponge itself for for a h for a
simple hash algorithm that's like a
simple hash algorithm that's like a
simple hash algorithm that's like a
binary hashing
binary hashing
binary hashing
of of a Merkel node for example isn't
of of a Merkel node for example isn't
of of a Merkel node for example isn't
that complicated. is just basically it's
that complicated. is just basically it's
that complicated. is just basically it's
just a single round of taking the input
just a single round of taking the input
just a single round of taking the input
and applying the permutation and
and applying the permutation and
and applying the permutation and
spitting out the output. I've written
spitting out the output. I've written
spitting out the output. I've written
down a little pseudo code that basically
down a little pseudo code that basically
down a little pseudo code that basically
is what it is in the cap. So, so just to
is what it is in the cap. So, so just to
is what it is in the cap. So, so just to
recap, the sponge interface is
recap, the sponge interface is
recap, the sponge interface is
complicated. it the the sponge is
complicated. it the the sponge is
complicated. it the the sponge is
designed for many different use cases,
designed for many different use cases,
designed for many different use cases,
not just hash.
not just hash.
not just hash.
Even though for hash the sponge is
Even though for hash the sponge is
Even though for hash the sponge is
really simple we don't want to just
really simple we don't want to just
really simple we don't want to just
baking a simple sponge implementation
baking a simple sponge implementation
baking a simple sponge implementation
inside host while this is much easier to
inside host while this is much easier to
inside host while this is much easier to
do it in the contract or in the guest or
do it in the contract or in the guest or
do it in the contract or in the guest or
in the SDK
in the SDK
in the SDK
but it is makes much more sense to to
but it is makes much more sense to to
but it is makes much more sense to to
support the primitive that's mostly the
support the primitive that's mostly the
support the primitive that's mostly the
most expensive operations happen
most expensive operations happen
most expensive operations happen
which is the permutation function
which is the permutation function
which is the permutation function
inside the sort of host
So that's the high level motivation and
So that's the high level motivation and
now I can go through the actual two
now I can go through the actual two
now I can go through the actual two
functions being proposed. one is a
functions being proposed. one is a
functions being proposed. one is a
Prooseidon permutation and second one is
Prooseidon permutation and second one is
Prooseidon permutation and second one is
Prooseidon 2 permutation. the two
Prooseidon 2 permutation. the two
Prooseidon 2 permutation. the two
look fairly fairly similar. So so
look fairly fairly similar. So so
look fairly fairly similar. So so
just a bit of background Prooseidon is
just a bit of background Prooseidon is
just a bit of background Prooseidon is
the original version developed in 20
the original version developed in 20
the original version developed in 20
2019. Poseidon 2 is a a improved
2019. Poseidon 2 is a a improved
2019. Poseidon 2 is a a improved
version of that developed in 2023.
version of that developed in 2023.
version of that developed in 2023.
internally they they work slightly
internally they they work slightly
internally they they work slightly
different. Poseidon 2 has u improved the
different. Poseidon 2 has u improved the
different. Poseidon 2 has u improved the
internal matrix shapes and then add
internal matrix shapes and then add
internal matrix shapes and then add
pre relication add add a single
pre relication add add a single
pre relication add add a single
layer of pre-apply but overall it works
layer of pre-apply but overall it works
layer of pre-apply but overall it works
fairly similar. so I'll just cover
fairly similar. so I'll just cover
fairly similar. so I'll just cover
the Poseidon one.
the Poseidon one.
the Poseidon one.
so the process permutation takes the
so the process permutation takes the
so the process permutation takes the
input which is a vector object that is
input which is a vector object that is
input which is a vector object that is
your vector of field element and then
your vector of field element and then
your vector of field element and then
the second thing is the field type.
the second thing is the field type.
the second thing is the field type.
so I think it probably makes sense to
so I think it probably makes sense to
so I think it probably makes sense to
have field type as a symbol but in the
have field type as a symbol but in the
have field type as a symbol but in the
cap I I'm putting U32 should be
cap I I'm putting U32 should be
cap I I'm putting U32 should be
equivalent but yeah field basically is a
equivalent but yeah field basically is a
equivalent but yeah field basically is a
enum that specify which field you you
enum that specify which field you you
enum that specify which field you you
want your permutation function to be
want your permutation function to be
want your permutation function to be
defined on and of course your input will
defined on and of course your input will
defined on and of course your input will
be passed in the same field as the
be passed in the same field as the
be passed in the same field as the
permutation
permutation
permutation
matrix and all that. , and the rest
matrix and all that. , and the rest
matrix and all that. , and the rest
of it is just internal parameters for
of it is just internal parameters for
of it is just internal parameters for
the for the hat functions. , so that's
the for the hat functions. , so that's
the for the hat functions. , so that's
pretty much it. , but I'll just spend
pretty much it. , but I'll just spend
pretty much it. , but I'll just spend
maybe a few a couple minutes just
maybe a few a couple minutes just
maybe a few a couple minutes just
explaining what these fields are. , t
explaining what these fields are. , t
explaining what these fields are. , t
is the capacity parameter. So it's the
is the capacity parameter. So it's the
is the capacity parameter. So it's the
capacity the internal sorry not the
capacity the internal sorry not the
capacity the internal sorry not the
capacity but the internal state size.
capacity but the internal state size.
capacity but the internal state size.
The internal state side much must match
The internal state side much must match
The internal state side much must match
the input and also must match the
the input and also must match the
the input and also must match the
size of internal matrix. It is
size of internal matrix. It is
size of internal matrix. It is
decomposed of the rate which is number
decomposed of the rate which is number
decomposed of the rate which is number
of you can think of as number of input
of you can think of as number of input
of you can think of as number of input
you need to hatch at once plus some
you need to hatch at once plus some
you need to hatch at once plus some
capacity which gives you additional
capacity which gives you additional
capacity which gives you additional
security parameters. d is the degree
security parameters. d is the degree
security parameters. d is the degree
of the the fbark which is the
of the the fbark which is the
of the the fbark which is the
internal
internal
internal
one of the internal step in the
one of the internal step in the
one of the internal step in the
permutation before applying the matrix
permutation before applying the matrix
permutation before applying the matrix
multiplication. So for bn and bs both
multiplication. So for bn and bs both
multiplication. So for bn and bs both
both fields d is equal to five. So we
both fields d is equal to five. So we
both fields d is equal to five. So we
may we may just only accept the equals 5
may we may just only accept the equals 5
may we may just only accept the equals 5
u but of course for other field in the
u but of course for other field in the
u but of course for other field in the
future could be different. the round
future could be different. the round
future could be different. the round
f round t these are the internal partial
f round t these are the internal partial
f round t these are the internal partial
round and the for round these are the
round and the for round these are the
round and the for round these are the
number of round the matrix
number of round the matrix
number of round the matrix
multiplication happens so the yeah
multiplication happens so the yeah
multiplication happens so the yeah
so the there's also a linear layer
so the there's also a linear layer
so the there's also a linear layer
which is u sorry the the linear layer is
which is u sorry the the linear layer is
which is u sorry the the linear layer is
a run the mod matrix multiplication
a run the mod matrix multiplication
a run the mod matrix multiplication
but the nonlinearity is provided by the
but the nonlinearity is provided by the
but the nonlinearity is provided by the
run constants which is also matrix but
run constants which is also matrix but
run constants which is also matrix but
specified for each run. So the so the MD
specified for each run. So the so the MD
specified for each run. So the so the MD
MDS matrix for hash two function is
MDS matrix for hash two function is
MDS matrix for hash two function is
3x3 run constant is a is another
3x3 run constant is a is another
3x3 run constant is a is another
matrix with dimension n by m where n is
matrix with dimension n by m where n is
matrix with dimension n by m where n is
the number of run and m is three.
the number of run and m is three.
the number of run and m is three.
So that's a high high level run through
So that's a high high level run through
So that's a high high level run through
of the different parameters. the
of the different parameters. the
of the different parameters. the
second one is fairly similar. The only
second one is fairly similar. The only
second one is fairly similar. The only
difference is that the internal MDS
difference is that the internal MDS
difference is that the internal MDS
matrix in the second version is a
matrix in the second version is a
matrix in the second version is a
diagonal matrix because of the
diagonal matrix because of the
diagonal matrix because of the
precision 2 improvement
precision 2 improvement
precision 2 improvement
in terms of cost type.
in terms of cost type.
in terms of cost type.
So we so we manage I think we we can
So we so we manage I think we we can
So we so we manage I think we we can
manage to ship this as a native solar
manage to ship this as a native solar
manage to ship this as a native solar
bond library which means that all of the
bond library which means that all of the
bond library which means that all of the
operations they are already existing
operations they are already existing
operations they are already existing
and were defined. These include the
and were defined. These include the
and were defined. These include the
field arithmetic for adding and the
field arithmetic for adding and the
field arithmetic for adding and the
multiplication and things like that. So
multiplication and things like that. So
multiplication and things like that. So
there's no particular peridon specific
there's no particular peridon specific
there's no particular peridon specific
metering parameters we need to support
metering parameters we need to support
metering parameters we need to support
but we do have to add these ban 254
but we do have to add these ban 254
but we do have to add these ban 254
field u arithmetic cost types which
field u arithmetic cost types which
field u arithmetic cost types which
is a very opportune timing because we
is a very opportune timing because we
is a very opportune timing because we
have the cap 74 which has b24
have the cap 74 which has b24
have the cap 74 which has b24
scala field and pairing.
scala field and pairing.
scala field and pairing.
So
 I went through the parameters
 I went through the parameters
metering
metering
metering
rationale. Yes. So that the rationale
rationale. Yes. So that the rationale
rationale. Yes. So that the rationale
why hash function why we don't
why hash function why we don't
why hash function why we don't
provide a hash function out of box
provide a hash function out of box
provide a hash function out of box
rather than providing the permutation
rather than providing the permutation
rather than providing the permutation
primitive. It is explained
primitive. It is explained
primitive. It is explained
and yeah just to also mention these
and yeah just to also mention these
and yeah just to also mention these
parameters they are
parameters they are
parameters they are
so
so
so
yeah so so some of them they are they
yeah so so some of them they are they
yeah so so some of them they are they
are kind of defined based on the
are kind of defined based on the
are kind of defined based on the
application like if you have a curve of
application like if you have a curve of
application like if you have a curve of
if you want to do hashing with BN25
if you want to do hashing with BN25
if you want to do hashing with BN25
254 then the degree is five you can
254 then the degree is five you can
254 then the degree is five you can
change that and then the sum of them is
change that and then the sum of them is
change that and then the sum of them is
depend on the actual application
depend on the actual application
depend on the actual application
which is how many inputs you want to
which is how many inputs you want to
which is how many inputs you want to
hash at once and then based on the size
hash at once and then based on the size
hash at once and then based on the size
of the input these parameters like t
of the input these parameters like t
of the input these parameters like t
and then the number of runs they need to
and then the number of runs they need to
and then the number of runs they need to
be adjusted the original procidum
be adjusted the original procidum
be adjusted the original procidum
paper provides scripts and guidelines
paper provides scripts and guidelines
paper provides scripts and guidelines
for how to generate these parameters
for how to generate these parameters
for how to generate these parameters
in general I think most
in general I think most
in general I think most
applications have their own
applications have their own
applications have their own
they they have they use a a set of
they they have they use a a set of
they they have they use a a set of
generated parameters like CIRCOM does
generated parameters like CIRCOM does
generated parameters like CIRCOM does
and Noel does and to provide the maximum
and Noel does and to provide the maximum
and Noel does and to provide the maximum
like safetiness we would have
like safetiness we would have
like safetiness we would have
these as part of preset in the SDK.
these as part of preset in the SDK.
these as part of preset in the SDK.
So like the SDK SDK interface will look
So like the SDK SDK interface will look
So like the SDK SDK interface will look
exactly just like a hash two that takes
exactly just like a hash two that takes
exactly just like a hash two that takes
two input and then internally you may be
two input and then internally you may be
two input and then internally you may be
able to specify the set of parameter
able to specify the set of parameter
able to specify the set of parameter
like a circum parameter or or neural
like a circum parameter or or neural
like a circum parameter or or neural
parameter things like that and then we
parameter things like that and then we
parameter things like that and then we
we also possibly expose these
we also possibly expose these
we also possibly expose these
Poseidon permutation as a as a more like
Poseidon permutation as a as a more like
Poseidon permutation as a as a more like
a hazmat interface something that
a hazmat interface something that
a hazmat interface something that
advanced users that know what they're
advanced users that know what they're
advanced users that know what they're
doing can can call with their own
doing can can call with their own
doing can can call with their own
parameters but we we will make them
parameters but we we will make them
parameters but we we will make them
the distinction more clear.
Yeah. In terms of testing there's a
Yeah. In terms of testing there's a
reference implementation for Prooseidon
reference implementation for Prooseidon
reference implementation for Prooseidon
and so Horizon lab has a reference
and so Horizon lab has a reference
and so Horizon lab has a reference
imitation for Poseidon 2 and in the same
imitation for Poseidon 2 and in the same
imitation for Poseidon 2 and in the same
repo has Poseidon one. That's the one we
repo has Poseidon one. That's the one we
repo has Poseidon one. That's the one we
likely going to adopt. And it also
likely going to adopt. And it also
likely going to adopt. And it also
provides test vectors for both one and
provides test vectors for both one and
provides test vectors for both one and
two in different fields and parameter.
two in different fields and parameter.
two in different fields and parameter.
And then there's also the original
And then there's also the original
And then there's also the original
Prooseidon paper that come with a a
Prooseidon paper that come with a a
Prooseidon paper that come with a a
sage script implementation with some
sage script implementation with some
sage script implementation with some
reference vectors which we will also
reference vectors which we will also
reference vectors which we will also
match our implementation with in our
match our implementation with in our
match our implementation with in our
tests.
tests.
tests.
There's a draft implementation and I
There's a draft implementation and I
There's a draft implementation and I
think that's it.
think that's it.
think that's it.
Now four is open for questions.
Yeah. So I did a very rough well I
Yeah. So I did a very rough well I
wouldn't say too rough but like the
wouldn't say too rough but like the
wouldn't say too rough but like the
implementation is fairly
implementation is fairly
implementation is fairly
mostly good and then the the field for
mostly good and then the the field for
mostly good and then the the field for
BRS is already there. So I did a
BRS is already there. So I did a
BRS is already there. So I did a
number on on the on the reference test
number on on the on the reference test
number on on the on the reference test
cases for BLS
cases for BLS
cases for BLS
the 3x3 matrix case which is the hash
the 3x3 matrix case which is the hash
the 3x3 matrix case which is the hash
two operation that's about half a
two operation that's about half a
two operation that's about half a
million CPU instruction. So it's a lot a
million CPU instruction. So it's a lot a
million CPU instruction. So it's a lot a
lot better than what I projected last
lot better than what I projected last
lot better than what I projected last
time. And then the 5x5 matrix case I
time. And then the 5x5 matrix case I
time. And then the 5x5 matrix case I
believe that's like cache three input
believe that's like cache three input
believe that's like cache three input
that's around 1 million CPU.
that's around 1 million CPU.
that's around 1 million CPU.
So yeah that's well below our target
So yeah that's well below our target
So yeah that's well below our target
ceiling which we want to support around
ceiling which we want to support around
ceiling which we want to support around
20 hash cores in a single contract.
Oh, okay. You want me to close it? Okay.
Oh, okay. You want me to close it? Okay.
Bye, everyone.

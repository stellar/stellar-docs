hi so hello everyone today we're going
hi so hello everyone today we're going
to talk about project slingshot and ZJ
to talk about project slingshot and ZJ
to talk about project slingshot and ZJ
diem my name is Alejandra and I work at
diem my name is Alejandra and I work at
diem my name is Alejandra and I work at
Stellar on this project for the some
Stellar on this project for the some
Stellar on this project for the some
time already so I'd like to give you an
time already so I'd like to give you an
time already so I'd like to give you an
overview why we do that how we're going
overview why we do that how we're going
overview why we do that how we're going
to use it and why is it interesting so
to use it and why is it interesting so
to use it and why is it interesting so
let's do the time check all right so the
let's do the time check all right so the
let's do the time check all right so the
problem that we have is we know about
problem that we have is we know about
problem that we have is we know about
the ball change so how do we do the
the ball change so how do we do the
the ball change so how do we do the
blockchain that protects the private
blockchain that protects the private
blockchain that protects the private
information while being in the public
information while being in the public
information while being in the public
right it's a public system that's fully
right it's a public system that's fully
right it's a public system that's fully
auditable and transparent but yet we do
auditable and transparent but yet we do
auditable and transparent but yet we do
the private transaction in it so
the private transaction in it so
the private transaction in it so
effectively we want something like
effectively we want something like
effectively we want something like
ledger with TOS so there are two major
ledger with TOS so there are two major
ledger with TOS so there are two major
components to it
components to it
components to it
one is the confidentiality part so for
one is the confidentiality part so for
one is the confidentiality part so for
these we need some sort of encryption
these we need some sort of encryption
these we need some sort of encryption
for our balances and accounts and
for our balances and accounts and
for our balances and accounts and
amounts that we transfer and since it's
amounts that we transfer and since it's
amounts that we transfer and since it's
a public system we need a public
a public system we need a public
a public system we need a public
verification mechanism for proving that
verification mechanism for proving that
verification mechanism for proving that
the encrypted the Hylian transfers are
the encrypted the Hylian transfers are
the encrypted the Hylian transfers are
actually correct and respects the
actually correct and respects the
actually correct and respects the
balancing equation but people when they
balancing equation but people when they
balancing equation but people when they
transaction they don't create the money
transaction they don't create the money
transaction they don't create the money
out of nowhere so we need some sort of
out of nowhere so we need some sort of
out of nowhere so we need some sort of
zero knowledge proof in our technology
zero knowledge proof in our technology
zero knowledge proof in our technology
static
static
static
and the third important component is
and the third important component is
and the third important component is
that some customization mechanism why is
that some customization mechanism why is
that some customization mechanism why is
that the block chains are especially
that the block chains are especially
that the block chains are especially
consensus systems they the work best
consensus systems they the work best
consensus systems they the work best
when they're mostly decentralized
when they're mostly decentralized
when they're mostly decentralized
deployed widely and as many applications
deployed widely and as many applications
deployed widely and as many applications
the users run them and execute the rules
the users run them and execute the rules
the users run them and execute the rules
and check the transactions and this
and check the transactions and this
and check the transactions and this
means that it's very hard to upgrade the
means that it's very hard to upgrade the
means that it's very hard to upgrade the
the system with new features or
the system with new features or
the system with new features or
improvements so we need to on one hand
improvements so we need to on one hand
improvements so we need to on one hand
to make it as simple and focused as
to make it as simple and focused as
to make it as simple and focused as
possible so it's not buggy but at the
possible so it's not buggy but at the
possible so it's not buggy but at the
same time we want to build some
same time we want to build some
same time we want to build some
interesting features around the system
interesting features around the system
interesting features around the system
like from smart contracts to whatever
like from smart contracts to whatever
like from smart contracts to whatever
you know decentralized applications to
you know decentralized applications to
you know decentralized applications to
improve the security of people
improve the security of people
improve the security of people
transacting in this new environment and
one way is to just roll out Network wide
one way is to just roll out Network wide
upgrades which is as hard as it is
upgrades which is as hard as it is
upgrades which is as hard as it is
decentralized or on the other hand
decentralized or on the other hand
decentralized or on the other hand
foresee some customization points so
foresee some customization points so
foresee some customization points so
people can build things on top of it
people can build things on top of it
people can build things on top of it
without changing the underlying rules so
without changing the underlying rules so
without changing the underlying rules so
this is where the VM part comes in we
this is where the VM part comes in we
this is where the VM part comes in we
need some sort of program ability for
need some sort of program ability for
need some sort of program ability for
our system and if it's programmable it
our system and if it's programmable it
our system and if it's programmable it
means that there are programs and it
means that there are programs and it
means that there are programs and it
means that there is some sort of virtual
means that there is some sort of virtual
means that there is some sort of virtual
machine that is going to execute those
machine that is going to execute those
machine that is going to execute those
programs so this is where the DM part
programs so this is where the DM part
programs so this is where the DM part
comes in now what is slingshot and how
comes in now what is slingshot and how
comes in now what is slingshot and how
does it relate to the akkadian so
does it relate to the akkadian so
does it relate to the akkadian so
slingshot is an umbrella term for the
slingshot is an umbrella term for the
slingshot is an umbrella term for the
entire suite of libraries and protocol
entire suite of libraries and protocol
entire suite of libraries and protocol
implementations that include not only
implementations that include not only
implementations that include not only
the can a more interesting part the
the can a more interesting part the
the can a more interesting part the
transaction format the zero knowledge
transaction format the zero knowledge
transaction format the zero knowledge
proof sand the programmable conditions
proof sand the programmable conditions
proof sand the programmable conditions
which is the kvam but also all the
which is the kvam but also all the
which is the kvam but also all the
exhibitory cryptographic libraries such
exhibitory cryptographic libraries such
exhibitory cryptographic libraries such
as
as
as
signature schemes Multi signature things
signature schemes Multi signature things
signature schemes Multi signature things
the multiple tree implementations all
the multiple tree implementations all
the multiple tree implementations all
the way to the entire ball chain system
the way to the entire ball chain system
the way to the entire ball chain system
where the blockchain state machine is a
where the blockchain state machine is a
where the blockchain state machine is a
separate protocol implementation and the
separate protocol implementation and the
separate protocol implementation and the
peer-to-peer networking stack and higher
peer-to-peer networking stack and higher
peer-to-peer networking stack and higher
order application protocols such as the
order application protocols such as the
order application protocols such as the
mechanism behind accounts the protocols
mechanism behind accounts the protocols
mechanism behind accounts the protocols
for synchronizing well that's doing
for synchronizing well that's doing
for synchronizing well that's doing
payment channel sorter books and all
payment channel sorter books and all
payment channel sorter books and all
these kind of things that could be built
these kind of things that could be built
these kind of things that could be built
on top of the on top of the core
on top of the on top of the core
on top of the on top of the core
blockchain system so this whole thing is
blockchain system so this whole thing is
blockchain system so this whole thing is
called slingshot and it's all exists in
called slingshot and it's all exists in
called slingshot and it's all exists in
in a single github repo where the
in a single github repo where the
in a single github repo where the
development happens now what's
development happens now what's
development happens now what's
interesting about the TVM and the
interesting about the TVM and the
interesting about the TVM and the
slingshot is that as a filing modular
slingshot is that as a filing modular
slingshot is that as a filing modular
design why is it important this is not a
design why is it important this is not a
design why is it important this is not a
single application that has a specific
single application that has a specific
single application that has a specific
way of using it it's more like a
way of using it it's more like a
way of using it it's more like a
collection of libraries that we can
collection of libraries that we can
collection of libraries that we can
flexibly figure out how to deploy and
flexibly figure out how to deploy and
flexibly figure out how to deploy and
roll out in the best manner so we can
roll out in the best manner so we can
roll out in the best manner so we can
build a sidechaining or we can use it as
build a sidechaining or we can use it as
build a sidechaining or we can use it as
a private ledger or we can use it as
a private ledger or we can use it as
a private ledger or we can use it as
both the cryptographic pieces are
both the cryptographic pieces are
both the cryptographic pieces are
composable so we can attach the off
composable so we can attach the off
composable so we can attach the off
chain proofs to our transactions so for
chain proofs to our transactions so for
chain proofs to our transactions so for
instance we can offload some
instance we can offload some
instance we can offload some
computational cost from the network by
computational cost from the network by
computational cost from the network by
building some intra-party proofs about
building some intra-party proofs about
building some intra-party proofs about
payments for instance some notarization
payments for instance some notarization
payments for instance some notarization
or zero-knowledge
or zero-knowledge
or zero-knowledge
other schemes completely outside of the
other schemes completely outside of the
other schemes completely outside of the
blockchain so we don't have to load the
blockchain so we don't have to load the
blockchain so we don't have to load the
Internet work with this with this
Internet work with this with this
Internet work with this with this
computationally heavy problem we can use
computationally heavy problem we can use
computationally heavy problem we can use
the full node as a library embedded in
the full node as a library embedded in
the full node as a library embedded in
in the greater application that for
in the greater application that for
in the greater application that for
instance does some interesting indexing
instance does some interesting indexing
instance does some interesting indexing
of the transactions and we can decide
of the transactions and we can decide
of the transactions and we can decide
how big the now it should be how much
how big the now it should be how much
how big the now it should be how much
data
data
data
should store for instance the uijik so
should store for instance the uijik so
should store for instance the uijik so
state compression scheme allows us to
state compression scheme allows us to
state compression scheme allows us to
have very little minimal state at the
have very little minimal state at the
have very little minimal state at the
cost of a little bit more bandwidth
cost of a little bit more bandwidth
cost of a little bit more bandwidth
overhead and you can decide whether you
overhead and you can decide whether you
overhead and you can decide whether you
just have this very compact who know
just have this very compact who know
just have this very compact who know
them better than your wallet or you have
them better than your wallet or you have
them better than your wallet or you have
way even lighter wallet or you build it
way even lighter wallet or you build it
way even lighter wallet or you build it
completely standalone applications and
completely standalone applications and
completely standalone applications and
running on a cluster for instance with
running on a cluster for instance with
running on a cluster for instance with
as much data storage as as you possibly
as much data storage as as you possibly
as much data storage as as you possibly
can because you want to provide as much
can because you want to provide as much
can because you want to provide as much
service to the very light applications
service to the very light applications
service to the very light applications
and this is why the default project is
and this is why the default project is
and this is why the default project is
designed to be modular from the
designed to be modular from the
designed to be modular from the
beginning now specifically the key VM is
beginning now specifically the key VM is
beginning now specifically the key VM is
a transaction format that sits on top of
a transaction format that sits on top of
a transaction format that sits on top of
the networking part and the consensus
the networking part and the consensus
the networking part and the consensus
mechanism and on top of the KVM then you
mechanism and on top of the KVM then you
mechanism and on top of the KVM then you
can build your custom application
can build your custom application
can build your custom application
protocols so what does it mean to say
protocols so what does it mean to say
protocols so what does it mean to say
that the helium is a transaction format
that the helium is a transaction format
that the helium is a transaction format
so in other words the key VM is a fancy
so in other words the key VM is a fancy
so in other words the key VM is a fancy
parser if you think about bitcoin or
parser if you think about bitcoin or
parser if you think about bitcoin or
Stellar or Z cash the transaction format
Stellar or Z cash the transaction format
Stellar or Z cash the transaction format
and those protocols are is more like XML
and those protocols are is more like XML
and those protocols are is more like XML
so this is some kind of hierarchical
so this is some kind of hierarchical
so this is some kind of hierarchical
structure with lists of things that
structure with lists of things that
structure with lists of things that
contain other things that describe
contain other things that describe
contain other things that describe
declaratively the flow of assets in
declaratively the flow of assets in
declaratively the flow of assets in
contrast theorem is much more
contrast theorem is much more
contrast theorem is much more
programmable but the transaction format
programmable but the transaction format
programmable but the transaction format
is more like a remote remote procedure
is more like a remote remote procedure
is more like a remote remote procedure
call where the transaction just sends a
call where the transaction just sends a
call where the transaction just sends a
message to network and then you have the
message to network and then you have the
message to network and then you have the
global state with some programs loaded
global state with some programs loaded
global state with some programs loaded
into that state that can be invoked and
into that state that can be invoked and
into that state that can be invoked and
do some operations do some mutation into
do some operations do some mutation into
do some operations do some mutation into
the state and that was actually simply
the state and that was actually simply
the state and that was actually simply
signed message into this global computer
signed message into this global computer
signed message into this global computer
and the key mam is neither of those two
and the key mam is neither of those two
and the key mam is neither of those two
things it's more like a PDF so it's sort
things it's more like a PDF so it's sort
things it's more like a PDF so it's sort
of a declarative format but at the same
of a declarative format but at the same
of a declarative format but at the same
time it's an executable a little
time it's an executable a little
time it's an executable a little
language that you run through the VM
language that you run through the VM
language that you run through the VM
that is sort of like a parser that
that is sort of like a parser that
that is sort of like a parser that
exist the kids the commands does some
exist the kids the commands does some
exist the kids the commands does some
local operations to determine what
local operations to determine what
local operations to determine what
changes to the state should be made so
changes to the state should be made so
changes to the state should be made so
you can explain this better this is the
you can explain this better this is the
you can explain this better this is the
quick overview of the data model
quick overview of the data model
quick overview of the data model
indicating so you have transactions and
indicating so you have transactions and
indicating so you have transactions and
transactions are objects these little
transactions are objects these little
transactions are objects these little
files transfer assets from inputs and
files transfer assets from inputs and
files transfer assets from inputs and
APIs and they can also issue arbitrary
APIs and they can also issue arbitrary
APIs and they can also issue arbitrary
assets because it's the multi-asset
assets because it's the multi-asset
assets because it's the multi-asset
environment right just like Stellar so
environment right just like Stellar so
environment right just like Stellar so
this is how the esse flows from inputs
this is how the esse flows from inputs
this is how the esse flows from inputs
to outputs and the outputs are actually
to outputs and the outputs are actually
to outputs and the outputs are actually
the objects that we call contracts they
the objects that we call contracts they
the objects that we call contracts they
have a predicate that can all locks some
have a predicate that can all locks some
have a predicate that can all locks some
content inside the contract and provides
content inside the contract and provides
content inside the contract and provides
conditions to unlock the contents and
conditions to unlock the contents and
conditions to unlock the contents and
the contents are called the PD load and
the contents are called the PD load and
the contents are called the PD load and
it's actually a list of things and those
it's actually a list of things and those
it's actually a list of things and those
things could be either values that are
things could be either values that are
things could be either values that are
local linear types the things that you
local linear types the things that you
local linear types the things that you
can move around but cannot duplicate
can move around but cannot duplicate
can move around but cannot duplicate
which are the assets themselves or some
which are the assets themselves or some
which are the assets themselves or some
data parameters so your contract is this
data parameters so your contract is this
data parameters so your contract is this
collection of values and data that can
collection of values and data that can
collection of values and data that can
be locked into this container by a
be locked into this container by a
be locked into this container by a
predicate and the simplest way to think
predicate and the simplest way to think
predicate and the simplest way to think
about the predicate is the public key
about the predicate is the public key
about the predicate is the public key
right so you say whoever owns the
right so you say whoever owns the
right so you say whoever owns the
corresponding private key can unlock the
corresponding private key can unlock the
corresponding private key can unlock the
values and then decide what to do with
values and then decide what to do with
values and then decide what to do with
them and your unlock by showing the
them and your unlock by showing the
them and your unlock by showing the
signature on a transaction so you have a
signature on a transaction so you have a
signature on a transaction so you have a
transaction that says I want to spend
transaction that says I want to spend
transaction that says I want to spend
this value and such-and-such way you
this value and such-and-such way you
this value and such-and-such way you
have to provide a signature that
have to provide a signature that
have to provide a signature that
authorizes you to unlock that contract
authorizes you to unlock that contract
authorizes you to unlock that contract
or the predicate could be a little sub
or the predicate could be a little sub
or the predicate could be a little sub
program so you have to run the program
program so you have to run the program
program so you have to run the program
meaning that the VM will run the program
meaning that the VM will run the program
meaning that the VM will run the program
and check additional conditions that are
and check additional conditions that are
and check additional conditions that are
described by the program before deciding
described by the program before deciding
described by the program before deciding
to unlock the the values and you can
to unlock the the values and you can
to unlock the the values and you can
combine both of them with the scheme
combine both of them with the scheme
combine both of them with the scheme
called a taproot it's a like Merkle tree
called a taproot it's a like Merkle tree
called a taproot it's a like Merkle tree
of programs and public key is so you
of programs and public key is so you
of programs and public key is so you
have the flexibility to decide things
have the flexibility to decide things
have the flexibility to decide things
like you can either
like you can either
like you can either
have multiple parties signed together
have multiple parties signed together
have multiple parties signed together
the contract or they could choose
the contract or they could choose
the contract or they could choose
individually whatever branch they want
individually whatever branch they want
individually whatever branch they want
to execute so this gives you a lot of
to execute so this gives you a lot of
to execute so this gives you a lot of
flexibility in terms of pre-programming
flexibility in terms of pre-programming
flexibility in terms of pre-programming
different conditions that unlock stadium
different conditions that unlock stadium
different conditions that unlock stadium
and the mining and it's a little bit
and the mining and it's a little bit
and the mining and it's a little bit
even more flexible because you can not
even more flexible because you can not
even more flexible because you can not
only pre-program some conditions or
only pre-program some conditions or
only pre-program some conditions or
provide a signature which was action but
provide a signature which was action but
provide a signature which was action but
you can also provide a signature over in
you can also provide a signature over in
you can also provide a signature over in
new conditions so you can decide some
new conditions so you can decide some
new conditions so you can decide some
program later and then sign it and then
program later and then sign it and then
program later and then sign it and then
that program will be executed so this
that program will be executed so this
that program will be executed so this
gives you infinite ability to do some
gives you infinite ability to do some
gives you infinite ability to do some
interesting multi-state schemes while
interesting multi-state schemes while
interesting multi-state schemes while
having pretty simple design so how does
having pretty simple design so how does
having pretty simple design so how does
this all work inside the VM again
this all work inside the VM again
this all work inside the VM again
transaction is just a program like I
transaction is just a program like I
transaction is just a program like I
said like a PDF file so in our case it's
said like a PDF file so in our case it's
said like a PDF file so in our case it's
has a little just a little bit of
has a little just a little bit of
has a little just a little bit of
metadata it's a program that also has a
metadata it's a program that also has a
metadata it's a program that also has a
zero knowledge proof and we will show in
zero knowledge proof and we will show in
zero knowledge proof and we will show in
a second how this proof applies so what
a second how this proof applies so what
a second how this proof applies so what
happens when you want to verify a
happens when you want to verify a
happens when you want to verify a
transaction you instantiate a VM and by
transaction you instantiate a VM and by
transaction you instantiate a VM and by
you I mean the Denelle that verifies the
you I mean the Denelle that verifies the
you I mean the Denelle that verifies the
transaction it instant Chase the VM that
transaction it instant Chase the VM that
transaction it instant Chase the VM that
is completely ephemeral it means that
is completely ephemeral it means that
is completely ephemeral it means that
it's not some sort of globally running
it's not some sort of globally running
it's not some sort of globally running
VM like like a dr. container a kind of
VM like like a dr. container a kind of
VM like like a dr. container a kind of
thing it's it's like an instance of a
thing it's it's like an instance of a
thing it's it's like an instance of a
parser for this specific transaction so
parser for this specific transaction so
parser for this specific transaction so
it's very lightweight you create it just
it's very lightweight you create it just
it's very lightweight you create it just
for a single transaction you load the
for a single transaction you load the
for a single transaction you load the
transaction into this VM and it works as
transaction into this VM and it works as
transaction into this VM and it works as
a simple stack machine so it has a
a simple stack machine so it has a
a simple stack machine so it has a
simple stack it's not your incomplete so
simple stack it's not your incomplete so
simple stack it's not your incomplete so
it has a predictable performance and the
it has a predictable performance and the
it has a predictable performance and the
goal of the VM is not only to provide
goal of the VM is not only to provide
goal of the VM is not only to provide
you with ability to customize a
you with ability to customize a
you with ability to customize a
conditions but it also enforces the
conditions but it also enforces the
conditions but it also enforces the
network rules so the operations that
network rules so the operations that
network rules so the operations that
excuse they are also checking that you
excuse they are also checking that you
excuse they are also checking that you
don't duplicate money that you respect
don't duplicate money that you respect
don't duplicate money that you respect
the rules of the network and don't break
the rules of the network and don't break
the rules of the network and don't break
that so what the in des it runs the
that so what the in des it runs the
that so what the in des it runs the
program
program
program
and the n as the program is running it's
and the n as the program is running it's
and the n as the program is running it's
compiling on the fly thing that we call
compiling on the fly thing that we call
compiling on the fly thing that we call
a constraint system which will be used
a constraint system which will be used
a constraint system which will be used
for the zero knowledge proof so the
for the zero knowledge proof so the
for the zero knowledge proof so the
constraint system is effectively just a
constraint system is effectively just a
constraint system is effectively just a
list of linear and multiplicative
list of linear and multiplicative
list of linear and multiplicative
equations that check that for instance
equations that check that for instance
equations that check that for instance
the sum amount should because some other
the sum amount should because some other
the sum amount should because some other
amount or should be subject to certain
amount or should be subject to certain
amount or should be subject to certain
formula but the cool part is that this
formula but the cool part is that this
formula but the cool part is that this
constraint system works in zero
constraint system works in zero
constraint system works in zero
knowledge meaning that those numbers in
knowledge meaning that those numbers in
knowledge meaning that those numbers in
the formulas that you are manipulating
the formulas that you are manipulating
the formulas that you are manipulating
they are all can be encrypted and so
they are all can be encrypted and so
they are all can be encrypted and so
your program can manipulate this
your program can manipulate this
your program can manipulate this
encrypted values and and require that
encrypted values and and require that
encrypted values and and require that
they conform to certain formula and as a
they conform to certain formula and as a
they conform to certain formula and as a
result of execution of the program you
result of execution of the program you
result of execution of the program you
will have this sort of a matrix of
will have this sort of a matrix of
will have this sort of a matrix of
constraints that builds this constraint
constraints that builds this constraint
constraints that builds this constraint
system and after the program finished
system and after the program finished
system and after the program finished
executing then the verifier runs the
executing then the verifier runs the
executing then the verifier runs the
serial logical flow VM checks the proof
serial logical flow VM checks the proof
serial logical flow VM checks the proof
is correct for this constraint system
is correct for this constraint system
is correct for this constraint system
which proves that whoever knew this
which proves that whoever knew this
which proves that whoever knew this
secret keys that encrypted those amounts
secret keys that encrypted those amounts
secret keys that encrypted those amounts
correctly combined them so if there was
correctly combined them so if there was
correctly combined them so if there was
a smart contract saying that a couple of
a smart contract saying that a couple of
a smart contract saying that a couple of
values must correspond to a certain
values must correspond to a certain
values must correspond to a certain
formula then this these values being
formula then this these values being
formula then this these values being
secret they're still correctly
secret they're still correctly
secret they're still correctly
constrained by by the formula so this is
constrained by by the formula so this is
constrained by by the formula so this is
the job of the zero knowledge proof and
the job of the zero knowledge proof and
the job of the zero knowledge proof and
the VM does that in the end of the
the VM does that in the end of the
the VM does that in the end of the
program execution and finally all the
program execution and finally all the
program execution and finally all the
facts in the VM are fully local there
facts in the VM are fully local there
facts in the VM are fully local there
don't affect the global state so it
don't affect the global state so it
don't affect the global state so it
allows you to evaluate all the
allows you to evaluate all the
allows you to evaluate all the
transactions independently from each
transactions independently from each
transactions independently from each
other and verify in parallel so how do
other and verify in parallel so how do
other and verify in parallel so how do
we even do the effects so all these
we even do the effects so all these
we even do the effects so all these
inputs and outputs are actually recorded
inputs and outputs are actually recorded
inputs and outputs are actually recorded
in the transaction log which is simply a
in the transaction log which is simply a
in the transaction log which is simply a
list of effects that should be applied
list of effects that should be applied
list of effects that should be applied
to the blockchain state and once we've
to the blockchain state and once we've
to the blockchain state and once we've
run the program and verified this your
run the program and verified this your
run the program and verified this your
knowledge constraints then we simply
knowledge constraints then we simply
knowledge constraints then we simply
take this log this list of effects
take this log this list of effects
take this log this list of effects
that are effectively saying that you
that are effectively saying that you
that are effectively saying that you
have to erase certain inputs and create
have to erase certain inputs and create
have to erase certain inputs and create
certain outputs and then we apply them
certain outputs and then we apply them
certain outputs and then we apply them
to the bot fisty and this is very
to the bot fisty and this is very
to the bot fisty and this is very
lightweight operation that can not only
lightweight operation that can not only
lightweight operation that can not only
fail if you're trying to double span the
fail if you're trying to double span the
fail if you're trying to double span the
same output twice and two different
same output twice and two different
same output twice and two different
transactions and if it happens that the
transactions and if it happens that the
transactions and if it happens that the
second transaction tries to suspend the
second transaction tries to suspend the
second transaction tries to suspend the
same input then it will fail in the very
same input then it will fail in the very
same input then it will fail in the very
end at that application stage but this
end at that application stage but this
end at that application stage but this
is the the only stateful operation and
is the the only stateful operation and
is the the only stateful operation and
the system now how do you instructions
the system now how do you instructions
the system now how do you instructions
look like think of this as a Stellar
look like think of this as a Stellar
look like think of this as a Stellar
operations in Stellar transactions you
operations in Stellar transactions you
operations in Stellar transactions you
have realities of operations that you
have realities of operations that you
have realities of operations that you
could do but they are more like a list
could do but they are more like a list
could do but they are more like a list
of things that are not really working
of things that are not really working
of things that are not really working
with each other they just enumerate what
with each other they just enumerate what
with each other they just enumerate what
you want to do in a transaction for
you want to do in a transaction for
you want to do in a transaction for
instance to send money from here to
instance to send money from here to
instance to send money from here to
there or open offer or create an account
there or open offer or create an account
there or open offer or create an account
things like that so in a similar Berean
things like that so in a similar Berean
things like that so in a similar Berean
the key VM has instructions that are
the key VM has instructions that are
the key VM has instructions that are
high level well-liked constellar they
high level well-liked constellar they
high level well-liked constellar they
did their high level operations they
did their high level operations they
did their high level operations they
don't they are not like assembly one
don't they are not like assembly one
don't they are not like assembly one
assembler language low level operations
assembler language low level operations
assembler language low level operations
that just manipulate bits they
that just manipulate bits they
that just manipulate bits they
manipulate values they manipulate
manipulate values they manipulate
manipulate values they manipulate
contracts the high-level concepts but
contracts the high-level concepts but
contracts the high-level concepts but
they are all composable with each other
they are all composable with each other
they are all composable with each other
so for instance you can instantiate a
so for instance you can instantiate a
so for instance you can instantiate a
contract and then open it up and then
contract and then open it up and then
contract and then open it up and then
take the values out of it move them
take the values out of it move them
take the values out of it move them
around maybe mix and merge them together
around maybe mix and merge them together
around maybe mix and merge them together
there and then lock them in a new
there and then lock them in a new
there and then lock them in a new
contract and this sequence of operations
contract and this sequence of operations
contract and this sequence of operations
will be not just the list of them but
will be not just the list of them but
will be not just the list of them but
actually manipulating those values on
actually manipulating those values on
actually manipulating those values on
the stack behind the scenes so here's an
the stack behind the scenes so here's an
the stack behind the scenes so here's an
example let's say you want to make a
example let's say you want to make a
example let's say you want to make a
custom constraint to do something about
custom constraint to do something about
custom constraint to do something about
it
it
it
so you start with pushing some numerical
so you start with pushing some numerical
so you start with pushing some numerical
value on the stack instantiate a
value on the stack instantiate a
value on the stack instantiate a
variable out of it that creates the
variable out of it that creates the
variable out of it that creates the
variable inside the constraint system
variable inside the constraint system
variable inside the constraint system
then you combine different arithmetic
then you combine different arithmetic
then you combine different arithmetic
operations on it that as a side effect
operations on it that as a side effect
operations on it that as a side effect
create those constraints and without
create those constraints and without
create those constraints and without
actually computing
actually computing
actually computing
because the value could could be
because the value could could be
because the value could could be
encrypted and you finished those
encrypted and you finished those
encrypted and you finished those
constraints by saying verify meaning
constraints by saying verify meaning
constraints by saying verify meaning
that you can pull the whole constraint
that you can pull the whole constraint
that you can pull the whole constraint
it you want to record it into the
it you want to record it into the
it you want to record it into the
constraint system so it will be checked
constraint system so it will be checked
constraint system so it will be checked
later then you can so it looks something
later then you can so it looks something
later then you can so it looks something
like this so you have a formula and you
like this so you have a formula and you
like this so you have a formula and you
do this kind of stack machine as syntax
do this kind of stack machine as syntax
do this kind of stack machine as syntax
for multiplying adding checking equality
for multiplying adding checking equality
for multiplying adding checking equality
and verifying and then once you have
and verifying and then once you have
and verifying and then once you have
this variable all verified you can
this variable all verified you can
this variable all verified you can
create overboard value and output in a
create overboard value and output in a
create overboard value and output in a
certain place so you say okay this this
certain place so you say okay this this
certain place so you say okay this this
value is correct so I am making a
value is correct so I am making a
value is correct so I am making a
payment with it and boiler instruction
payment with it and boiler instruction
payment with it and boiler instruction
is kind of cool because it's a zero
is kind of cool because it's a zero
is kind of cool because it's a zero
interest rates boring just within the
interest rates boring just within the
interest rates boring just within the
life of the VM it gives you to balance
life of the VM it gives you to balance
life of the VM it gives you to balance
the negative and positive 1 and negative
the negative and positive 1 and negative
the negative and positive 1 and negative
has to be mixed it with the proper
has to be mixed it with the proper
has to be mixed it with the proper
payment coming from somewhere else
payment coming from somewhere else
payment coming from somewhere else
using this zero knowledge mix
using this zero knowledge mix
using this zero knowledge mix
instruction that we call cloak it's
instruction that we call cloak it's
instruction that we call cloak it's
implements it's a whole clock protocol
implements it's a whole clock protocol
implements it's a whole clock protocol
that allows you to mix M inputs into n
that allows you to mix M inputs into n
that allows you to mix M inputs into n
outputs preserving the assets but in
outputs preserving the assets but in
outputs preserving the assets but in
complete zero knowledge so you don't
complete zero knowledge so you don't
complete zero knowledge so you don't
know where the asset flows within the
know where the asset flows within the
know where the asset flows within the
boundaries of transaction so these
boundaries of transaction so these
boundaries of transaction so these
instructions gonna show you how you can
instructions gonna show you how you can
instructions gonna show you how you can
combine the value of flow with custom
combine the value of flow with custom
combine the value of flow with custom
conditions and the important part is
conditions and the important part is
conditions and the important part is
that this is all imperative meaning that
that this is all imperative meaning that
that this is all imperative meaning that
all the contracts they do not have kind
all the contracts they do not have kind
all the contracts they do not have kind
of declarative conditions but they
of declarative conditions but they
of declarative conditions but they
incredibly do things that they want to
incredibly do things that they want to
incredibly do things that they want to
be done with linear types that cannot be
be done with linear types that cannot be
be done with linear types that cannot be
simply dropped or created out of nowhere
simply dropped or created out of nowhere
simply dropped or created out of nowhere
or duplicated so entire clasts of
or duplicated so entire clasts of
or duplicated so entire clasts of
security vulnerabilities are eliminated
security vulnerabilities are eliminated
security vulnerabilities are eliminated
versus the access control lists always
versus the access control lists always
versus the access control lists always
have this problem where you have hard
have this problem where you have hard
have this problem where you have hard
time combining the different clock rolls
time combining the different clock rolls
time combining the different clock rolls
together here it's very imperative and
together here it's very imperative and
together here it's very imperative and
Lear types help greatly by just
Lear types help greatly by just
Lear types help greatly by just
literally moving the valley where it
literally moving the valley where it
literally moving the valley where it
needs to be moved and then make sure
needs to be moved and then make sure
needs to be moved and then make sure
that you don't you don't break the rules
that you don't you don't break the rules
that you don't you don't break the rules
along the way so this is very powerful
along the way so this is very powerful
along the way so this is very powerful
but at the same time very safe system
but at the same time very safe system
but at the same time very safe system
so I'll say a couple of words about
so I'll say a couple of words about
so I'll say a couple of words about
cryptography so can make it all work
cryptography so can make it all work
cryptography so can make it all work
it's important to have on one hand fancy
it's important to have on one hand fancy
it's important to have on one hand fancy
cryptography but at the same time pretty
cryptography but at the same time pretty
cryptography but at the same time pretty
conservative one so we have this stack
conservative one so we have this stack
conservative one so we have this stack
of the high-performance curve to 5519
of the high-performance curve to 5519
of the high-performance curve to 5519
implementation on top of which we have
implementation on top of which we have
implementation on top of which we have
the safe cryptographic group the which
the safe cryptographic group the which
the safe cryptographic group the which
would build a bulletproof system and
would build a bulletproof system and
would build a bulletproof system and
that allows us to do this custom
that allows us to do this custom
that allows us to do this custom
constraints and we use the blue person
constraints and we use the blue person
constraints and we use the blue person
two ways in one way it's a cloud product
two ways in one way it's a cloud product
two ways in one way it's a cloud product
call that enforces the network rules
call that enforces the network rules
call that enforces the network rules
that mean that you cannot duplicate
that mean that you cannot duplicate
that mean that you cannot duplicate
money and at the same time it allows you
money and at the same time it allows you
money and at the same time it allows you
to do on-the-fly custom constraints and
to do on-the-fly custom constraints and
to do on-the-fly custom constraints and
this is cool because many other 0no
this is cool because many other 0no
this is cool because many other 0no
systems like Z cash they do not allow
systems like Z cash they do not allow
systems like Z cash they do not allow
you to do on-the-fly conditions instead
you to do on-the-fly conditions instead
you to do on-the-fly conditions instead
they use a very complicated trusted
they use a very complicated trusted
they use a very complicated trusted
setup where several priorities must
setup where several priorities must
setup where several priorities must
decide the rules and compute some crunch
decide the rules and compute some crunch
decide the rules and compute some crunch
numbers in order to compose a single
numbers in order to compose a single
numbers in order to compose a single
solid constraint system that will be
solid constraint system that will be
solid constraint system that will be
used for all the purposes of the network
used for all the purposes of the network
used for all the purposes of the network
for for one time and bulletproof allows
for for one time and bulletproof allows
for for one time and bulletproof allows
us to avoid this trusted set up and
us to avoid this trusted set up and
us to avoid this trusted set up and
instead build the constraints on the fly
instead build the constraints on the fly
instead build the constraints on the fly
every time the transaction is running
every time the transaction is running
every time the transaction is running
because this is so fast and lightweight
because this is so fast and lightweight
because this is so fast and lightweight
and finally if you provide the interface
and finally if you provide the interface
and finally if you provide the interface
to all of that we have these easy KVM
to all of that we have these easy KVM
to all of that we have these easy KVM
instructions and then on top with you
instructions and then on top with you
instructions and then on top with you
using these instructions this is where
using these instructions this is where
using these instructions this is where
you build your applications and this
you build your applications and this
you build your applications and this
whole stack that we have is written in
whole stack that we have is written in
whole stack that we have is written in
POS so everything is very neatly
POS so everything is very neatly
POS so everything is very neatly
compiled and one
compiled and one
compiled and one
first of all hassles in an API is in
first of all hassles in an API is in
first of all hassles in an API is in
between two layers and then it's
between two layers and then it's
between two layers and then it's
compiled without any overhead in a in a
compiled without any overhead in a in a
compiled without any overhead in a in a
while finally efficient binary just like
while finally efficient binary just like
while finally efficient binary just like
you would have with C++ for instance so
you would have with C++ for instance so
you would have with C++ for instance so
another cool thing is that the DMA
another cool thing is that the DMA
another cool thing is that the DMA
operations in the KDM are designed to be
operations in the KDM are designed to be
operations in the KDM are designed to be
either cheap or expensive which is funny
either cheap or expensive which is funny
either cheap or expensive which is funny
but the point here is that the chip
but the point here is that the chip
but the point here is that the chip
operations are very cheap it's really
operations are very cheap it's really
operations are very cheap it's really
like a parser and all expensive
like a parser and all expensive
like a parser and all expensive
operations are completely uniform
operations are completely uniform
operations are completely uniform
a scalar point multiplications in this
a scalar point multiplications in this
a scalar point multiplications in this
cryptographic group and this means that
cryptographic group and this means that
cryptographic group and this means that
they can all be deferred and done in a
they can all be deferred and done in a
they can all be deferred and done in a
batch which makes them much faster so
batch which makes them much faster so
batch which makes them much faster so
effectively what you have is you have a
effectively what you have is you have a
effectively what you have is you have a
very quick run of the program then you
very quick run of the program then you
very quick run of the program then you
have a bunch of things to compute in a
have a bunch of things to compute in a
have a bunch of things to compute in a
cryptographic group that you can batch
cryptographic group that you can batch
cryptographic group that you can batch
together and do very efficiently later
together and do very efficiently later
together and do very efficiently later
you can even imagine doing that and in
you can even imagine doing that and in
you can even imagine doing that and in
GPU if you have to verify a lot of
GPU if you have to verify a lot of
GPU if you have to verify a lot of
transactions and then you have an answer
transactions and then you have an answer
transactions and then you have an answer
where the transaction is valid enough so
where the transaction is valid enough so
where the transaction is valid enough so
this gives us very low educational
this gives us very low educational
this gives us very low educational
agency for the features that we have
agency for the features that we have
agency for the features that we have
it's less than one millisecond per
it's less than one millisecond per
it's less than one millisecond per
output so effectively like lesson no
output so effectively like lesson no
output so effectively like lesson no
second for payment or more like Costas
second for payment or more like Costas
second for payment or more like Costas
begins maybe like two milliseconds per
begins maybe like two milliseconds per
begins maybe like two milliseconds per
payment because payment Nelson always
payment because payment Nelson always
payment because payment Nelson always
have them change out but and we use all
have them change out but and we use all
have them change out but and we use all
opportunities to prove performance that
opportunities to prove performance that
opportunities to prove performance that
we can so if you have multiple
we can so if you have multiple
we can so if you have multiple
signatures they all can be aggregated
signatures they all can be aggregated
signatures they all can be aggregated
and then batch verified and transaction
and then batch verified and transaction
and then batch verified and transaction
size is pretty distant so it's like one
size is pretty distant so it's like one
size is pretty distant so it's like one
1/2 to 2 kilobytes and this growth slow
1/2 to 2 kilobytes and this growth slow
1/2 to 2 kilobytes and this growth slow
very quickly so if multiple parties join
very quickly so if multiple parties join
very quickly so if multiple parties join
together they greatly optimize the total
together they greatly optimize the total
together they greatly optimize the total
cost of the network and so a couple of
cost of the network and so a couple of
cost of the network and so a couple of
examples to how you can build something
examples to how you can build something
examples to how you can build something
with with this so one is the basic
with with this so one is the basic
with with this so one is the basic
payments so the cool part is things like
payments so the cool part is things like
payments so the cool part is things like
accounts and balances they are all off
accounts and balances they are all off
accounts and balances they are all off
chain concepts as to the the basic
chain concepts as to the the basic
chain concepts as to the the basic
network on the season it's an APIs and
network on the season it's an APIs and
network on the season it's an APIs and
all the interesting kind of data
all the interesting kind of data
all the interesting kind of data
wrangling it happens I've seen that
wrangling it happens I've seen that
wrangling it happens I've seen that
provide security for the people involved
provide security for the people involved
provide security for the people involved
in for the party stress of acting and
in for the party stress of acting and
in for the party stress of acting and
greatly improved performance because
greatly improved performance because
greatly improved performance because
there is a lot of can a complicated
there is a lot of can a complicated
there is a lot of can a complicated
decision making is completely taken out
decision making is completely taken out
decision making is completely taken out
of the out of the consensus critter
of the out of the consensus critter
of the out of the consensus critter
parts and placed inside their
parts and placed inside their
parts and placed inside their
application this also allows you to
application this also allows you to
application this also allows you to
innovate faster because you can do
innovate faster because you can do
innovate faster because you can do
different protocols and try different
different protocols and try different
different protocols and try different
versions of like payment channels or be
versions of like payment channels or be
versions of like payment channels or be
famous protocols
famous protocols
famous protocols
completely outside of the can a
completely outside of the can a
completely outside of the can a
consensus critical part so you don't you
consensus critical part so you don't you
consensus critical part so you don't you
have to only upgrade the knows that care
have to only upgrade the knows that care
have to only upgrade the knows that care
about this feature and not the entire
about this feature and not the entire
about this feature and not the entire
network so the order book is an
network so the order book is an
network so the order book is an
interesting example of smart contract so
interesting example of smart contract so
interesting example of smart contract so
it's simply a contract that allows you
it's simply a contract that allows you
it's simply a contract that allows you
to unlock the value being offered for a
to unlock the value being offered for a
to unlock the value being offered for a
price so this is where you use the
price so this is where you use the
price so this is where you use the
predicate I can pack several conditions
predicate I can pack several conditions
predicate I can pack several conditions
inside the predicate and the cool thing
inside the predicate and the cool thing
inside the predicate and the cool thing
about the zero knowledge is that you can
about the zero knowledge is that you can
about the zero knowledge is that you can
do this both and public so it's like
do this both and public so it's like
do this both and public so it's like
Stellar like completely public offer and
Stellar like completely public offer and
Stellar like completely public offer and
there's no nothing secret going on but
there's no nothing secret going on but
there's no nothing secret going on but
you can still do this kind of semi
you can still do this kind of semi
you can still do this kind of semi
public so if you have a pool that wants
public so if you have a pool that wants
public so if you have a pool that wants
to be kind forced on the network and be
to be kind forced on the network and be
to be kind forced on the network and be
auditable by authorized parties but you
auditable by authorized parties but you
auditable by authorized parties but you
don't want to do publicize exact prices
don't want to do publicize exact prices
don't want to do publicize exact prices
and exact assets that are being offered
and exact assets that are being offered
and exact assets that are being offered
then you can also do that as well
then you can also do that as well
then you can also do that as well
because all these formulas work on the
because all these formulas work on the
because all these formulas work on the
encrypted values as well and you can
encrypted values as well and you can
encrypted values as well and you can
notice that this contract allows you to
notice that this contract allows you to
notice that this contract allows you to
do imperative description of the
do imperative description of the
do imperative description of the
conditions that you want to do so you
conditions that you want to do so you
conditions that you want to do so you
check that certain quantity and the
check that certain quantity and the
check that certain quantity and the
price is moved to certain address and
price is moved to certain address and
price is moved to certain address and
then you unlock the asset that you have
then you unlock the asset that you have
then you unlock the asset that you have
you never I have to do this in a passive
you never I have to do this in a passive
you never I have to do this in a passive
checks that whatever is provided or
checks that whatever is provided or
checks that whatever is provided or
whatever like feature on that
whatever like feature on that
whatever like feature on that
transaction object is set or some flag
transaction object is set or some flag
transaction object is set or some flag
the set versus in Bitcoin there is very
the set versus in Bitcoin there is very
the set versus in Bitcoin there is very
complicated kind of hashing flags so
complicated kind of hashing flags so
complicated kind of hashing flags so
there's none of those things you can
there's none of those things you can
there's none of those things you can
empirically just do the things that I
empirically just do the things that I
empirically just do the things that I
have to happen and then if there are
have to happen and then if there are
have to happen and then if there are
some kind of negative amounts left on
some kind of negative amounts left on
some kind of negative amounts left on
the stack in DBM then the user has to
the stack in DBM then the user has to
the stack in DBM then the user has to
provide appropriate amount of payment to
provide appropriate amount of payment to
provide appropriate amount of payment to
cover them and finally payment channels
cover them and finally payment channels
cover them and finally payment channels
is a nice example that shows you how to
is a nice example that shows you how to
is a nice example that shows you how to
do complicated state machines in this
do complicated state machines in this
do complicated state machines in this
model where you don't have global
model where you don't have global
model where you don't have global
programmable states like in Assyrian
programmable states like in Assyrian
programmable states like in Assyrian
supima channel natural is a state
supima channel natural is a state
supima channel natural is a state
machine between two parties that can do
machine between two parties that can do
machine between two parties that can do
payments without settling them on the
payments without settling them on the
payments without settling them on the
network and the only thing that Network
network and the only thing that Network
network and the only thing that Network
sees is that the initially deposit some
sees is that the initially deposit some
sees is that the initially deposit some
money in that they closed the channel at
money in that they closed the channel at
money in that they closed the channel at
some point later but all the
some point later but all the
some point later but all the
intermediate movements of the money are
intermediate movements of the money are
intermediate movements of the money are
not visible but still they have to
not visible but still they have to
not visible but still they have to
provide some assurances to the to the
provide some assurances to the to the
provide some assurances to the to the
parties involved so how does it work if
parties involved so how does it work if
parties involved so how does it work if
the one party becomes unresponsive then
the one party becomes unresponsive then
the one party becomes unresponsive then
the latest signed agreement could be
the latest signed agreement could be
the latest signed agreement could be
used as a way to exit the channel and
used as a way to exit the channel and
used as a way to exit the channel and
settle by another party unilaterally so
settle by another party unilaterally so
settle by another party unilaterally so
this state machine is implemented on top
this state machine is implemented on top
this state machine is implemented on top
of transactions so the states are
of transactions so the states are
of transactions so the states are
embedded in those contracts and
embedded in those contracts and
embedded in those contracts and
transitions are the transaction objects
transitions are the transaction objects
transitions are the transaction objects
in themselves which is pretty natural
in themselves which is pretty natural
in themselves which is pretty natural
it's just the intermediate assigned
it's just the intermediate assigned
it's just the intermediate assigned
transactions they are not published
transactions they are not published
transactions they are not published
until you want to exit the channel so
until you want to exit the channel so
until you want to exit the channel so
this is how it looks in this model of
this is how it looks in this model of
this is how it looks in this model of
inputs and outputs and transactions
inputs and outputs and transactions
inputs and outputs and transactions
finally to kind of wrap it up a little
finally to kind of wrap it up a little
finally to kind of wrap it up a little
compressor with all the designs and then
compressor with all the designs and then
compressor with all the designs and then
we can proceed to the questions so it's
we can proceed to the questions so it's
we can proceed to the questions so it's
kind of like a setting for discussion
kind of like a setting for discussion
kind of like a setting for discussion
leader so if you compare the design of
leader so if you compare the design of
leader so if you compare the design of
the KTM it's always very different but
the KTM it's always very different but
the KTM it's always very different but
is founded on similar principles so it's
is founded on similar principles so it's
is founded on similar principles so it's
multi-asset environment for modern
multi-asset environment for modern
multi-asset environment for modern
financial protocols and the specific
financial protocols and the specific
financial protocols and the specific
difference is that the data and asset
difference is that the data and asset
difference is that the data and asset
values are confidential encrypted by
values are confidential encrypted by
values are confidential encrypted by
default you can of course make them
default you can of course make them
default you can of course make them
public if you if you want to do any sort
public if you if you want to do any sort
public if you if you want to do any sort
of conditional or conditional disclosure
of conditional or conditional disclosure
of conditional or conditional disclosure
schemes if you if you need some audit
schemes if you if you need some audit
schemes if you if you need some audit
the concept of accounts is completely
the concept of accounts is completely
the concept of accounts is completely
off chain and the verification of
off chain and the verification of
off chain and the verification of
transaction is largely stateless and
transaction is largely stateless and
transaction is largely stateless and
your mechanism for customization is this
your mechanism for customization is this
your mechanism for customization is this
composable instructions instead of just
composable instructions instead of just
composable instructions instead of just
enumeration of kind of thicker higher
enumeration of kind of thicker higher
enumeration of kind of thicker higher
level operations and another important
level operations and another important
level operations and another important
difference is that the order book logic
difference is that the order book logic
difference is that the order book logic
installer is built in and has some kind
installer is built in and has some kind
installer is built in and has some kind
of stateful conditions that will allow
of stateful conditions that will allow
of stateful conditions that will allow
were more interesting kind of
were more interesting kind of
were more interesting kind of
multi-party map price assurances in the
multi-party map price assurances in the
multi-party map price assurances in the
KVM there is no such build the open
KVM there is no such build the open
KVM there is no such build the open
concept you can build all sorts of order
concept you can build all sorts of order
concept you can build all sorts of order
books on top of the system yourself
books on top of the system yourself
books on top of the system yourself
depending on like how complicated he
depending on like how complicated he
depending on like how complicated he
wanted to do to be compared to the
wanted to do to be compared to the
wanted to do to be compared to the
Syrian atrium is is also a design for
Syrian atrium is is also a design for
Syrian atrium is is also a design for
the customization and smart con metrics
the customization and smart con metrics
the customization and smart con metrics
but the model is quite different the
but the model is quite different the
but the model is quite different the
etherium is sort of like a global state
etherium is sort of like a global state
etherium is sort of like a global state
machine with a lot of code and like
machine with a lot of code and like
machine with a lot of code and like
libraries of code that can call each
libraries of code that can call each
libraries of code that can call each
other and do a lot of stateful changes
other and do a lot of stateful changes
other and do a lot of stateful changes
in the KVM all the changes are isolated
in the KVM all the changes are isolated
in the KVM all the changes are isolated
and limited to this creation and
and limited to this creation and
and limited to this creation and
deletion of the outputs and another
deletion of the outputs and another
deletion of the outputs and another
important part is that the KVM is not
important part is that the KVM is not
important part is that the KVM is not
cheering complete by design so it really
cheering complete by design so it really
cheering complete by design so it really
acts more like a parser and allows just
acts more like a parser and allows just
acts more like a parser and allows just
as little composition between the
as little composition between the
as little composition between the
instructions in data as necessary to
instructions in data as necessary to
instructions in data as necessary to
create ease for financial operations but
create ease for financial operations but
create ease for financial operations but
not to just program whatever and the
not to just program whatever and the
not to just program whatever and the
assets are first-class types that you
assets are first-class types that you
assets are first-class types that you
can move directly around instead of
can move directly around instead of
can move directly around instead of
being some entries and a miniature bank
being some entries and a miniature bank
being some entries and a miniature bank
that you have to program inside your
that you have to program inside your
that you have to program inside your
program inside the serial so this makes
program inside the serial so this makes
program inside the serial so this makes
the whole design much much more easy to
the whole design much much more easy to
the whole design much much more easy to
reason about because you don't have to
reason about because you don't have to
reason about because you don't have to
win vent a little ledger inside the
win vent a little ledger inside the
win vent a little ledger inside the
ledger every time you want to create a
ledger every time you want to create a
ledger every time you want to create a
new asset and finally education Manero
new asset and finally education Manero
new asset and finally education Manero
they they're heavily focused on the
they they're heavily focused on the
they they're heavily focused on the
privacy and they provide some cool non
privacy and they provide some cool non
privacy and they provide some cool non
interactive obfuscation of the
interactive obfuscation of the
interactive obfuscation of the
transaction graph which the key DM does
transaction graph which the key DM does
transaction graph which the key DM does
not provide but you can still do this
not provide but you can still do this
not provide but you can still do this
with teams like pointer and so when
with teams like pointer and so when
with teams like pointer and so when
multiple people join multiple inputs to
multiple people join multiple inputs to
multiple people join multiple inputs to
one transaction then they can sort of
one transaction then they can sort of
one transaction then they can sort of
mix them but Cillian provides you with
mix them but Cillian provides you with
mix them but Cillian provides you with
the ability to have customization in
the ability to have customization in
the ability to have customization in
contracts where easy cash Tamara doesn't
contracts where easy cash Tamara doesn't
contracts where easy cash Tamara doesn't
have any and still even have the
have any and still even have the
have any and still even have the
confidential computation within those
confidential computation within those
confidential computation within those
contracts and finally the occasional
contracts and finally the occasional
contracts and finally the occasional
manera have single assets and to kvms
manera have single assets and to kvms
manera have single assets and to kvms
design
design
design
for multiple asses so as a summary what
for multiple asses so as a summary what
for multiple asses so as a summary what
we're having here is this experiment in
we're having here is this experiment in
we're having here is this experiment in
combining customization confidentiality
combining customization confidentiality
combining customization confidentiality
and scalability features in a single
and scalability features in a single
and scalability features in a single
project and using two to the optimal
project and using two to the optimal
project and using two to the optimal
degree all the latest inventions in the
degree all the latest inventions in the
degree all the latest inventions in the
blockchain space where we have
blockchain space where we have
blockchain space where we have
reasonably innovative cryptography and
reasonably innovative cryptography and
reasonably innovative cryptography and
but still trying to be on a conservative
but still trying to be on a conservative
but still trying to be on a conservative
side and trying to make things very
side and trying to make things very
side and trying to make things very
scalable and high-performance and you
scalable and high-performance and you
scalable and high-performance and you
know obviously pushing as much as
know obviously pushing as much as
know obviously pushing as much as
possible to the kind of chain
possible to the kind of chain
possible to the kind of chain
application to design so we can innovate
application to design so we can innovate
application to design so we can innovate
faster and have the core consensus
faster and have the core consensus
faster and have the core consensus
critical parts as simple as possible so
critical parts as simple as possible so
critical parts as simple as possible so
that's all I got for my talk today and
that's all I got for my talk today and
that's all I got for my talk today and
then we can transition to questions you
then we can transition to questions you
then we can transition to questions you
can check out the demo at the idioms
can check out the demo at the idioms
can check out the demo at the idioms
- demo Dostal org and there is a star
- demo Dostal org and there is a star
- demo Dostal org and there is a star
slash slingshot repository on github
slash slingshot repository on github
slash slingshot repository on github
where all the discussion and design work
where all the discussion and design work
where all the discussion and design work
is happening daily thank you
oh yeah so we received some questions so
oh yeah so we received some questions so
the first question is can the gibeom law
the first question is can the gibeom law
the first question is can the gibeom law
to be applied to the Stellar blockchain
to be applied to the Stellar blockchain
to be applied to the Stellar blockchain
or is it a separate sidechain the
or is it a separate sidechain the
or is it a separate sidechain the
deviant watching is entirely separate
deviant watching is entirely separate
deviant watching is entirely separate
system that can work as a side chain or
system that can work as a side chain or
system that can work as a side chain or
it can work
it can work
it can work
complementary like it can work as a side
complementary like it can work as a side
complementary like it can work as a side
chain complementary reaches dollars so
chain complementary reaches dollars so
chain complementary reaches dollars so
you could have a set of validators
you could have a set of validators
you could have a set of validators
overlapping both systems and using the
overlapping both systems and using the
overlapping both systems and using the
same Stellar consensus protocol so we
same Stellar consensus protocol so we
same Stellar consensus protocol so we
can can operate in parallel and we have
can can operate in parallel and we have
can can operate in parallel and we have
some thoughts on how to do the
some thoughts on how to do the
some thoughts on how to do the
import/export mechanism for their
import/export mechanism for their
import/export mechanism for their
Stellar asses from the main chain into
Stellar asses from the main chain into
Stellar asses from the main chain into
the into the GK VM side chain at the
the into the GK VM side chain at the
the into the GK VM side chain at the
same time and the similar mechanism can
same time and the similar mechanism can
same time and the similar mechanism can
be used for the Zika VM in private
be used for the Zika VM in private
be used for the Zika VM in private
setting let's say you have a
setting let's say you have a
setting let's say you have a
organization where you need a robust
organization where you need a robust
organization where you need a robust
internal ledger that is cryptographic
internal ledger that is cryptographic
internal ledger that is cryptographic
assured and limits the information
assured and limits the information
assured and limits the information
exposure and you would like to use it
exposure and you would like to use it
exposure and you would like to use it
internally but but also interoperate
internally but but also interoperate
internally but but also interoperate
with Stellar so that's also a good idea
with Stellar so that's also a good idea
with Stellar so that's also a good idea
because then you can protect your
because then you can protect your
because then you can protect your
internal data from your own system
internal data from your own system
internal data from your own system
administrators and your IT department so
administrators and your IT department so
administrators and your IT department so
you can more precisely specify who sees
you can more precisely specify who sees
you can more precisely specify who sees
what information if you run their thus
what information if you run their thus
what information if you run their thus
giving and blocking just as your
giving and blocking just as your
giving and blocking just as your
internal private letter the
question is a Kinney build an automated
question is a Kinney build an automated
node for collateralized loan
node for collateralized loan
node for collateralized loan
how would you invoke locking for
how would you invoke locking for
how would you invoke locking for
deposits and is there an up code or do
deposits and is there an up code or do
deposits and is there an up code or do
you require an operator in between so
you require an operator in between so
you require an operator in between so
this is a cool question because
this is a cool question because
this is a cool question because
collateralized loan is one of those
collateralized loan is one of those
collateralized loan is one of those
things that teaching naturally build
things that teaching naturally build
things that teaching naturally build
with the KVM instruction set so you
with the KVM instruction set so you
with the KVM instruction set so you
could make an agreement that the person
could make an agreement that the person
could make an agreement that the person
who receives the the creditor receives
who receives the the creditor receives
who receives the the creditor receives
the money if they lock some digital
the money if they lock some digital
the money if they lock some digital
asset as collateral and this lock will
asset as collateral and this lock will
asset as collateral and this lock will
have a custom predicate that allows you
have a custom predicate that allows you
have a custom predicate that allows you
to take it out of allows that sorry I
to take it out of allows that sorry I
to take it out of allows that sorry I
lost the creditor to take out the loan
lost the creditor to take out the loan
lost the creditor to take out the loan
after some time out and also allows the
after some time out and also allows the
after some time out and also allows the
the person who takes it takes the loan
the person who takes it takes the loan
the person who takes it takes the loan
to unlock the collateral provided they
to unlock the collateral provided they
to unlock the collateral provided they
make a payment and the contract the
make a payment and the contract the
make a payment and the contract the
predicate of the contract will have a
predicate of the contract will have a
predicate of the contract will have a
provision area formula to check that the
provision area formula to check that the
provision area formula to check that the
payment was done including whatever
payment was done including whatever
payment was done including whatever
required interest rate before the tenant
required interest rate before the tenant
required interest rate before the tenant
so this scheme requires you to build a
so this scheme requires you to build a
so this scheme requires you to build a
little bit of this kind of smart
little bit of this kind of smart
little bit of this kind of smart
contractor program to embed in a
contractor program to embed in a
contractor program to embed in a
transaction and build some
transaction and build some
transaction and build some
infrastructure around to kind of support
infrastructure around to kind of support
infrastructure around to kind of support
it and the Wallis - - to use this
it and the Wallis - - to use this
it and the Wallis - - to use this
feature but then it provides both
feature but then it provides both
feature but then it provides both
parties good security against each other
parties good security against each other
parties good security against each other
they can simply unlock the de collateral
they can simply unlock the de collateral
they can simply unlock the de collateral
with mutual agreement but if they
with mutual agreement but if they
with mutual agreement but if they
disagree or don't cooperate then each
disagree or don't cooperate then each
disagree or don't cooperate then each
party has the clause that protects them
party has the clause that protects them
party has the clause that protects them
from another so the creditor is assured
from another so the creditor is assured
from another so the creditor is assured
that after a timeout they can simply
that after a timeout they can simply
that after a timeout they can simply
take the collateral salt in the market
take the collateral salt in the market
take the collateral salt in the market
and the debtor is assured that they
and the debtor is assured that they
and the debtor is assured that they
don't need to cooperate with a creditor
don't need to cooperate with a creditor
don't need to cooperate with a creditor
they can simply take back the lawn to
they can simply take back the lawn to
they can simply take back the lawn to
take back the cloud or provided the
take back the cloud or provided the
take back the cloud or provided the
payout alone to pre predefined address
payout alone to pre predefined address
payout alone to pre predefined address
and so that's a perfect example for the
and so that's a perfect example for the
and so that's a perfect example for the
use of the KVM and you don't need any
use of the KVM and you don't need any
use of the KVM and you don't need any
third party to intermediate ease these
third party to intermediate ease these
third party to intermediate ease these
elections was fully like just to parties
elections was fully like just to parties
elections was fully like just to parties
and without any trusted third party to
and without any trusted third party to
and without any trusted third party to
your medium I was able to provide a
your medium I was able to provide a
your medium I was able to provide a
timeline for when he expects to get him
timeline for when he expects to get him
timeline for when he expects to get him
to be fully complete and live on Stellar
to be fully complete and live on Stellar
to be fully complete and live on Stellar
so that's a trick question because like
so that's a trick question because like
so that's a trick question because like
the GBM itself was pretty complete
the GBM itself was pretty complete
the GBM itself was pretty complete
what's required which is a canal like
what's required which is a canal like
what's required which is a canal like
annoying engineering problem is to build
annoying engineering problem is to build
annoying engineering problem is to build
this kind of blockchain kinda networking
this kind of blockchain kinda networking
this kind of blockchain kinda networking
infrastructure around it so you could
infrastructure around it so you could
infrastructure around it so you could
integrate it just with the kind of
integrate it just with the kind of
integrate it just with the kind of
networking nodes which is an ongoing
networking nodes which is an ongoing
networking nodes which is an ongoing
problem right now with we we have the
problem right now with we we have the
problem right now with we we have the
blockchain state machine we have the
blockchain state machine we have the
blockchain state machine we have the
peer to peer network components but
peer to peer network components but
peer to peer network components but
there is also you know also kind of
there is also you know also kind of
there is also you know also kind of
wearing the right packaging you have a
wearing the right packaging you have a
wearing the right packaging you have a
node with the UI stuff and things like
node with the UI stuff and things like
node with the UI stuff and things like
that but also there is the integration
that but also there is the integration
that but also there is the integration
with the installer consensus protocol
with the installer consensus protocol
with the installer consensus protocol
and integration with the Stellar assets
and integration with the Stellar assets
and integration with the Stellar assets
there are two separate problems so so
there are two separate problems so so
there are two separate problems so so
far I would like to have an assistant
far I would like to have an assistant
far I would like to have an assistant
as possible but we're kind of getting
as possible but we're kind of getting
as possible but we're kind of getting
out of the stage where we have to build
out of the stage where we have to build
out of the stage where we have to build
something within this gonna slingshot
something within this gonna slingshot
something within this gonna slingshot
project and now it's you know in the
project and now it's you know in the
project and now it's you know in the
last in the ongoing wakes we're going to
last in the ongoing wakes we're going to
last in the ongoing wakes we're going to
really face the problem of integrating
really face the problem of integrating
really face the problem of integrating
where the Stellar consensus protocol and
where the Stellar consensus protocol and
where the Stellar consensus protocol and
with a horizon and with like input of
with a horizon and with like input of
with a horizon and with like input of
the assets so we're working on the
the assets so we're working on the
the assets so we're working on the
roadmap for this right now so this
roadmap for this right now so this
roadmap for this right now so this
require not just kind of work on the
require not just kind of work on the
require not just kind of work on the
project itself but more like an
project itself but more like an
project itself but more like an
integration work and working with more
integration work and working with more
integration work and working with more
or engineers on the store in a broader
or engineers on the store in a broader
or engineers on the store in a broader
taller side so the roadmap isn't being
taller side so the roadmap isn't being
taller side so the roadmap isn't being
in development right now we have any
in development right now we have any
in development right now we have any
more questions well thanks everyone for
more questions well thanks everyone for
more questions well thanks everyone for
joining us today we're glad you've
joining us today we're glad you've
joining us today we're glad you've
watched this livestream and if you would
watched this livestream and if you would
watched this livestream and if you would
like to participate in a project and I
like to participate in a project and I
like to participate in a project and I
have questions would like to integrate
have questions would like to integrate
have questions would like to integrate
things with your applications then
things with your applications then
things with your applications then
please find the github repository which
please find the github repository which
please find the github repository which
is a Stellar slash slingshot and I would
is a Stellar slash slingshot and I would
is a Stellar slash slingshot and I would
be glad to see your issues or pull
be glad to see your issues or pull
be glad to see your issues or pull
requests thank you so much

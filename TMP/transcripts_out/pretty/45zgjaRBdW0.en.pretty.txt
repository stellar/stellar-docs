 so Darth do you want to give us a.Quick overview on the scalable.Configuration issue yeah I can do that.Can you hear me yes I can hear you okay.Perfect so yeah the issue at the.Moment is that all current Network.Related settings are stored in The.Ledger header and this isn't a good.Place to store you know the Soroban.Settings because they can be quite large.I think the current estimate for meeting.Or alone sorry for metering alone is.When kilobyte so before we go through.The approaches I'll mention that they.All assume the use of dedicated Ledger.Entries for storing settings as.Described in CAP 46-9 and that the.Settings will be created on protocol.Upgrades the only differences in these.Approaches are how the settings.Themselves are upgraded.So approach one which is described in.Cap 46-9 this requires a mechanism.For validators to introduce and.Distribute setting upgrades directly to.The overlay the validators will then.Vote on the hash of the flooded settings.Approach 2 allows users to use Soroban to.Introduce possible setting upgrades into.The system using arbitrary Ledger.Entries allowing validators to vote on.One of these entries to overwrite an.Existing setting we use Soroban here so.Accurate fees will be charged for the.Large for the larger operation and.Ledger entries that will be introduced.There's still a question of how the user.Will interact with sore button we can.Add a new operation.Add a new option to the invoke host.Function up or rely on a smart contract.Itself to create these entries. approach three is similar to approach.Two except that a new Stellar classic.Operation will be used to create the.Entries that validators will vote to use.To make this Opera to make sure this.Operation isn't spanned the idea here is.To make sure the to make the operation.Withdraw a large amount of excellent.From The Source account.But this idea needs some additional work.To guarantee that the operation always.Has a sufficient balance for the.Withdrawal once the operation has been.Flooded because you don't want the.Operation to get flooded and fail .Because the network will have already.Flooded the that doesn't work for the.Operation. so yeah that's the summary of the.Three approaches. and I know their their opinions on. all these so the yeah this is Homer.Do you have a do you have any.Opinions on what would you prefer.Sid I have a question.So can you tell us a little bit more.About what is stored in that in these.Network configurations like concretely.And why is it important to preserve.These that data.So for example from you know for.Metering we need we have different .Parameters on how specific things get.Charged. and so the structure will have you.Know say like you know a bunch of .U64s. that that indicate how like specific.Settings should be charged and that that.Is what sorbonne will use..When deciding how metering should be.Used but we want these settings to be.Configurable that's why it's not just.Hard-coded in SOROBAN the settings.Will be stored somewhere and which and.The value should be able to upgrade .The settings whenever they want. if all the validators agree.Does that make sense.Yes.It just it's it doesn't sound like.Something that would..Change frequently between two subsequent.Legends right but it's more something.Like yeah when we'll go to upgrade to.Protocol Version Y then we need to make.That update.Am I cool we don't want so we don't want.To tie the upgrading of the settings to.Protocol upgrades.Right for example right now we can.Update. I believe like at the Base reserve if.We want to without updating the protocol.Right so that we want this to work the.Same way.And well I agree that we we won't update.The settings very often it I wouldn't be.Surprised if we you know did it twice in.This specific protocol version.It's just it's just generalizing what.We're already doing a letter header to a.Much larger number of number like this.It's in a potentially unbounded number.Of numbers although it's not it's not.Like enormous it's not thousands and.Thousands of entries but it's probably.Tens or or possibly as much as 100 so.Yeah does it make sense to do something.In the in the like of.Having an optional field in the.Ledger that would have that data and in.Any subsequent.Ledger header just say hey in the in.Ledger number XYZ we've last updated.These parameters.So I mean that's how I think we're.Describing is how like current upgrades.Currently work. like you just you submit the upgrade.To upgrade specific setting the issue.Here is that the the settings can be.Quite large right so it's not it.Doesn't like you know sending a. one kilowatt xdr blob.In the current mechanism wouldn't work.It actually wouldn't work at all next in.The with the current xcr because we have.A limit of I think 128 bytes per upgrade. but which is why we're exploring .Like a more scalable solution.Ed can I can I ask you a question about. the other approaches that that are.Not approach number one here in.Approach number two for example is this.Is you you sort of you've got you've got.Two things that are in play one of them.Is sort of propagating promulgating the.The proposed changes the set of options. and one of them is is .A consensus vote if.People vote on two different config.Settings you know what happens in.Approach to like there's still there's.Still a consensus conflict resolution.Problem the same as you would have in.The first one where there's this.Arbitrary you know take the largest.Upgrade choice that the consensus layer.Is doing in approach two what does a.Consensus player do if there's if.There's two con two conflicting votes.It would be the same as what it is today.Right like if you if two if there's two.Different votes on say the Base reserve.I I don't I don't actually know what.Conflict resolution is on the Base.Reserve right now my point is that it is.Currently happening in the consensus.Layer and it approach too it sounds like.You're trying to take it out of the.Consensus layer so then oh.I want to say that all the approaches.Actually are the same in terms of voting.Like in any case what leaders would vote.On the hash of the upgrade set of the.Config upgrade set. and the reason for that is that well.We don't want to blow the SCP values as.Well. because you have plenty of them and.Even the update upgrades are rare.Event we don't really want to have huge.Spines during this forever. so voting always happens on the hash.Of the config upgrade set and the.Default mechanism for consensus is that.If you don't agree this is upgrade .Evolved against it and then there is not.An upholds yes yeah but so all of this.Happens very quickly all this happens.Very quickly during the voting round and.I'm not concerned with the the.Like I object to this to this vote.Because that that's not likely to happen.Very often unless someone just you know.Doesn't schedule their validator it's.It's the combining thing if if validator.A uses you know arms upgrade.For upgrade set a and and validator B.For B then when someone hears those.Two or or nominator here's those.Two or whatever they do a.A value combined right they do a SCP.Value combined yeah this is this a not.Combinable right like that okay you need.A vote and for the contract upgrades is.A hash of the whole set of upgrades that.Need to be upgraded atomically like so.Any conflict just fails immediately any.Conflict just goes immediately as we.Don't try like in option one I guess.It is possible to do something weird.There or you can you know have some.Fuzzy matching of the upgrades you know.You say like this operation should take.Thousand units of gas and I say it.Should take a thousand one unit of gas.And maybe it doesn't matter in sand but.It kind of introduces too much.Unnecessary.Surface for potential issues and bugs.And sure I'm just saying that looking at.The document that I'm reading right here.It says that the CAP picks the largest.Upgrades which is arbitrary and requires.Some sort of conflict resolution it may.Want to only vote for a specific hash so.That sounds to me like a conflict.Resolution mechanism but I'm just I'm.Just trying to clarify whether that.That's that's real or whether it's yeah.Maybe that's not one or.Yeah maybe that's how it is but I think.In all approaches idea for voting is.The same like revolt on the hash of the.Whole upgrade set and Valderas have two.Agree on this hash exactly.And then the question is normally how we.Distribute the premature of this hash.Instead I do have a question on kind.Of like the implementation burden like.What is between the different.Approaches what is you know what's the.What's the low hanging fruit and what's. what requires like additional.Mechanics. I would so I would say approach to.Should be the simplest. correct me if I'm wrong but it.Shouldn't be hard to you know add a.Function sore bond to you know create.These entries.And then you know when the like any.Mechanism to interact with that function.Should be simple either a new operation.Or the invo coast function up or I think.Using smart contract is a little more.Complex because I think there's some .Some there there are more details.Around that but I don't think like I.Think in my opinion approach to the.Simplest approach approach three. yeah I think we have to be careful.And to make sure that it's not spammable.An approach one requires work in the.Overlay in the consensus layer.And is the reason approach to is the.Simplest because it used it reuses the.Metering mechanics that we have in in.Soroban.Yeah that's that's the only reason we're.Putting it in in Soroban itself.So what does that I would say I mean.Approach one is not hard either in the.Series to protect care for that and they.Both approaches I don't think there is.Too much work anyways. this one problem is there for.Surabana too like we figured it out.Discussing this. concerns for example.You know by the transactions it install.Vasms they can be pretty big too and we.Don't want to flood them for free.Basically and .I guess in this sense I like it's maybe.Not necessarily a very easy problem to.Solve but we need to solve it anyways so.Kind of option to just piggybacks on.This file with options three I guess we.Need to change something in classic.Mechanisms to make appropriately so.Yeah I kind of from drinks it probably.Too is the best it's a long time for the.Week.And use the amount of work additional.Work required yeah.Could you could you speak to the.Complexity of the consensus change.That's described in in verse one it says.The consensus changes it would be.Complex is that like.Because it involves the item fetcher.Because we would have to have a second.Like like the way we do DX pitching is.That it yeah I mean it's again I I.Haven't traveled I haven't triven this.Point about consensus layer complexity.It doesn't it's complex per se just.Literally reuses the TX set logic but.The except logic is arguably not very.Simple either yeah.Replicating.Yeah I mean on one hand it's trivial.That that we copy something that exists.But we are copying something complex so.Maybe it's really better to just use.Normal Ledger mechanisms to put this.Interest into lecture and yeah not.Bother about I didn't yet another.Flooding problem.The one question I have about that is.That. the consensus module has to actually.Be able to judge when it has a given.Hash right if there's if there's a vote.For hash X it has to then ask The Ledger.Hey the hash X actually exist.Because I'm not going to vote on a.Config setting that I don't have.Right like in The Ledger right so this.Is this is just moving it from moving.That question from item fetcher over to.A ledger inquiry and that's a.Synchronous Ledger inquiry in the middle.Of consensus right.Yes okay.I have no idea if this is a big problem.Or not hopefully are we okay with that I.Mean that's kind of the risk of my mind.But maybe the maybe that's okay I.Think that's probably less pain.Yeah.Yeah the thing that is kind of .Annoying I mentioned that in the in the.Dock with the .Approach that relies on on consensus is.We would have to to to secure the .Upgrades in some way right now .Upgrades because they are small we don't.Actually.They are not actually signed so you.Know values in SCP they are actually.Signed so that you you if some valid.Data all goes Rogue you can basically.Blame you know who introduced that .The value that is kind of spamming the. validators. so you can basically decide okay I'm.Going to remove this validator from my. Quorum set that's kind of the idea.With the signature.Upgrades are not part of this because.It's today they are small so if we.Start to make to have to and the the.Reason for upgrades not being included.In the sign payload is the. there's an option for validator to.Remove the upgrade from the value if.They don't agree with it so for you know.So that basically you can still close.Ledgers. you know with transactions even if.There is no consensus on the on the.Actual upgrades. which yeah I mean we didn't have. you know so much of those problems.You know until now there's like you.Know broad agreement on on like for.Example if you want to upgrade the.Network right to a specific protocol.Version there was no contention I think.We'll have potentially more contention.In the future as we think of network.Parameters that maybe are impacting.Certain contracts right like as every.Time we change like fees I mean like.The yeah metering schedule right like.We're going to cause maybe certain.Contracts to become more expensive.Therefore there is maybe a higher chance.Of disagreement between between very.Data so I think this the the chance.Of conflict is higher in you know.Post-organ. and and that's why yeah I think.We may have yeah multiplications.Where somebody there are going to say.Hey you know I'm I don't agree with this.Thing so I'm going to drop that upgrade.And.And then until the conflict is resolved.You don't want to be in a situation.Where the network is not agreeing on.Basically anything right.Anyway so so that's kind of why you can.Drop those those upgrades and.And right now they are not signed so we.Would have to either make them signed .If we want to make them bigger. or just not you know keep them small.And you know that's kind of the option.Too.So I do have a question that relates to.The.The user experience of of changing.The configuration right now you know.Validators you know just have like.Stellar core Commands to control this is.The idea to maintain the same experience.Across all of these different approaches.Or do different approaches mandate.Different user experience.I think I can answer that I mean it's.Easier to arm an upgrade for a hash like.It doesn't require any changes because. hash is a small like if you needed to.Distribute the whole upgrade set as in.Option one and that's durable but it's.Annoying like it's annoying to do this.As a or command you need to maybe extend.The command interface to take a file.Instead of you know just to get request.Or something like this so approaches.Like two and following a SIM for.Instance because it doesn't require any.Exchanges like we say Hey you like you.Want to upgrade to this set of configs.With hash X here is a link to the.Lectures that actually contains this.Entry so I think the distribution is.Kind of linear in this it's easier to.Arm these upgrades.But it introduces the transactions that.Needs to be submitted.Yes someone needs to submit a.Transaction this is true.Yeah so the US does change so in all.Approaches right because in the approach.Two and three you need to you know.Submit this operation but in approach.One the the initial set of upgrades.Needs to be distributed as well right. I guess that would be maybe another.Solid core command that the validator.Would would .Would submit and then that that's how.That would be flooded right but to be.Honest I do feel like approach one is.An extension of the current experience.We have which is you know the validators.Will coordinate the validators always.Need to coordinate regardless outside of.The network right so you know they.Coordinate on a Channel right now you.Know Justin tells people hey if you want. to upgrade or to change this value.You this is the command you use right so.Maybe the the.Mechanics are going to be a bit.Different we're going to say hey this is.You know an xdr take a look at it at a.Stellar lab or SDC or whatever and this.Is the hash vote on it. so it's still like you you don't.Introduce like another.Step of.Of you know submitting transactions to.The network.Well only one person needs to submit the.Transaction it's not like value there.Was once you know the thing is populated.You know it's basically like today.Yeah basically whoever initiates the.Upgrade should send the transaction.Which I don't think is a huge View.Because it's a big thing they need to.Propagate any weightages.Foreign.Got it okay that makes sense yeah by the.Way this closes a kind of a a potential.You know.Communication problem that we have today.Right like today.When we for example when you know we.As SDF say Hey you know we are proposing.To upgrade the network to you know.Version 19 right like we did last year.People look at that message is like .It it and it's not signed we don't.Publish that with you know digital.Signatures or anything so in theory you.Could imagine somebody faking you know. us and then getting people to vote.For something else I think the chance of.That again increases as you increase the.Complexity of those things that people.Are voting on. and the benefit of the.Of the having the The Entity that is.Kind of championing for a specific .Change is that because this is actually.An actual transaction on the network.It's it's also signed by The Entity.So that's kind of you know one of the.Extra.Pre-free benefit from option two and.Three.So essentially a configuration change.Proposals become on-chain activity.Yeah and actually so that's something.I wanted to kind of maybe because we.Didn't talk about that too much like .In in the doc we only kind of mention it.That option two like one of the things I.I think. that this opens the possibility for.In the future to have a.Like a point the validators to to like. Ledger entries that are controlled by.Those. so that you can.Form many validators there's well there.Is a concept that we discussed before.Right that is actually in a paper that. that was published a few years ago.About the notion of governing and.Non-governing validators. and I think this .For certain things this will this may.Actually become.Like .More interesting you know in the.Context of yeah Dell's that are.Not the tier one validators.That are kind of managing certain.Aspects certain parameters that you.Know of the network. and then the the the the validators.That are interested in actively.Participating this of course you know.They get to they would not just blindly. vote for those things but otherwise. otherwise other validators just might.Do that right for for those.Like maybe not as.As coupled to to to to network .Operators right or maybe even need like. additional voting or something right.And you want that to to happen on chain.Because you want more transparency or.Something right.Got it so yeah it does sound like.There's some added benefits to.Approach too and it seems like from an.Implementation perspective it's it's.It's fairly simple do we have any.Concern about.You know it's not it's not immediately.Obvious that Stellar configuration.Changes should be proposed on SOROBAN .It feels a bit like we're using just.Sorbon because it's it's there. and you know I don't I don't find it.Offensive but but like can there be.You know issues from it and things like.We want to do like in pure Stellar and. and now we're introducing them to the.Storybond.I think this kind of ties into like.Subtopic I wanted to talk about is.Whether or not to be as separating sort.Of an operations. into like different operations in the.Transaction because currently you have.Just one golden vocalist function that.Does a bunch of stuff and this changes.It would do even more stuff. so I'd say using suraban is just an.Implementation detail here.And nothing prevents wake up an option.Two from being a separate operation.And also we may want to do this to all.The operations anyway just to you know.Have a single flat hierarchy of things.You can do to discover. which basically would make it pretty.Opaque in terms of like how exactly.Transactions have been executed.I think improves the the X sound would.So I can.So the derived question here is whether.We want to split the invoke host.Operation into like multiple types of.Cerebon invoking operations yeah right.Like in this particular case like I feel.Like it's a race a strong case for.Making it a separate operation it was.Very explicitly namely containing.Internal assumptions that you know.People don't randomly submitted and .For all the existing operations there.Is the same consideration I know people.Have any opinions on this.Would be accessible from from the story.About environment in addition to being.Accessible through the this dedicated.No I mean the same about the current.Invoke host function transaction.Operations that annoys me and which is.Why I'm proposing this is that we are.Not actually invoking a host function in.The same way you can invoke it on yeah.From from the contract like they are.Divergent they like the cost functions.That we invoke from Stellar core are not.The same course functions that are more.Invoked from contracts so the name.Doesn't make too much sense I mean even.Though initial intent kind of made sense.But is there any implementation and.Requirements ended up they're not quite.Consistent and.Convinced we should keep it this is in.This cost functional.You know we could just be a bit more.Explicit and just say the operations and.The adapter lessons you are doing.Without involved in the Waterhouse at.All.Yeah my opinion.Yeah I think I think the original the.Original intent was to make calls.Uniform and I think we may be paying a.Fairly high price to try to make.Two entry paths to call look the same.You know we're sort of orienting.Everything in order to make that one.That one path prior to use code.Well I think maybe like the this is more.Related to I saw there was like .If we have a dedicated host function for.All this stuff I agree maybe we need to.Maybe we need to think about this but.Like I I'm not actually convinced that.This is the necessary to have anything.First class for for those Network.Upgrades inside suraban like I think we.Should be able to point to basically.Any saruban State should be.Considered valid for like as long as.We can you know like I was saying in the.Dock like it's basically a byte you.Know a byte array.That we happen to be able to decode. you know using because it's some xdr.Right that we can understand that the.Network level but that in from a Solomon.Point of view I think it's just a byte.Array.And if we do it like that there's.Nothing special about.Like any of that stuff okay this is an.Important point that I didn't understand.So from the approach number to your.Perspective we're not actually.Introducing changes to SOROBAN in order.To facilitate this so what is in the.Dock right now it talks about having.Special Ledger entries that are like.You know so you need like. a host function to basically.Manage to the special entries but I'm.Not at you know when we originally.Discussed that I didn't think we would.Actually have dedicated legendaries.For the for as input to.To to the upgrade. I thought that at the end yes you.Know when the when upgrades are actually.When those network settings are actually.Active yes there are special entries on.Ledger but in terms of like how do we.How do you get did they get fed into the. upgrade function. that I don't think we I don't think.We need to have a dedicated dedicated.Ledger entries you know with that.Specific format as input would that be.At that point in the dark was more to .Specify that it's not a config setting.Entry.I I guess it wasn't you know it wasn't.Clear what it actually is because I.Wasn't expected out but what Nico's.Saying is probably the best way to do.This where we specify that you know for.An upgrade it'd be a byte array of a.Config setting entry or a byte array of.A vector of config segment entries right.I'm not sure I'm good at the point.Because they don't have an entry like.Sent to me it would just be I think with.Nico's things it'd just be a contract.Data entry it's not a contract we don't.Have a contract so it cannot be contract.Data.You know you can no like is anybody like.You know as part of this right like you.Can imagine that's why I think like as.If you if you think of.In the future you want to have some.Doubts doing that like it's just a.Special case like like if I want to.In the first iteration of this the way.You would do it is you have a dummy.Contract you know that has like . State you know associated with it.That is just a single. you know that has a single value in.It and that allows you to to basically.You know as a user I can persist I can.Yes like kind of like a balance right .For. you know for token contract but.Instead of a balance it's basically a.Binary blob.And then in the upgrade that's how.You get it on The Ledger all right and.Then the upgrade just points to that.Specific Ledger entry that contains.The binary problem of Interest.So what do you guys suggesting we would.Have a contract specific cost function.No there's nothing specific to this.It's it's just like yeah to in order.To construct how how would we vote and.Wait like it has to be special right.Like a similar proposal and option for.Opposite. there needs to be a way like since we.Are voting on a hash or something you.Need a straightforward way of finding.This hash in The Ledger yeah that's why.You you can you can point to any.Arbitrary contract .Data right you're using the Ledger key.A hash.Yeah you bought an electric key.You would vote on a pair Ledger key hash.Probably right like maybe you can make.It work with just a ledger key but like.That I you know for now I think it's.Still a joke.Right right.Maybe we need to yeah we need we need to.Maybe like sketch that a little bit so.That I can so basically you would vote.On say I mean that's quite inefficient.Right.I guess the best you can do is contract.80 plus some data ID and accurate format.Actually I do but so I think I.Think this has been super informative it.Sounds like there's a very strong.Bias towards approach number two here. and there are some details that we.Need to figure out like whether this is.Actually something that's special cased.In Soroban or it's just a a general.Ledger entry and then the validators.Is part of the upgrade process just.Pointing at this Ledger team so .Let's I think we can take this.Conversation offline about the details.And and if needed we can we can bring.These up in one of the next meetings. we have around 20 minutes left.And so before we go on that Siddharth.Do you think we have enough to. to keep prototyping here.Yeah we should be good.Okay. so we don't have a lot of time we.Have 20 minutes. and Garand is here today to start.Talking about State expiration which is.A very big hairy topic so garen's.Gonna give a very brief overview about.This today if we have time we're going.To do q a I imagine that we're going to.Be talking about these about this.Specific issue a few more times so no.Big decisions will be made today. during the stages.Yeah so I guess we want the time in.Time so I just wanted to kind of start.Out with the general motivation and then.Talk about more about the interface and.Then we'll leave the implementation.Details to probably future conversations.So essentially the issue we're trying to.Solve with archival state is this issue.Of unbounded Ledger State size at least.Right now it's not a classic the number.Of Ledger entries we have to store is.Growing and there's not a strong.Incentive for users to delete entries.Additionally a large amount of those.Entries that exist on The Ledger are.Either outdated or just won't ever be.Used again for instance we have a lot of.Climbable balances that are more.Spam-like entries that aren't used very.Often or won't be used at all they're.Taking up this Ledger space and.Increasing larger bloat and so for the.Healthy skill patterns of the network we.Want to be able to essentially cap.Ledger State size and not allow for this.Arbitrary growth and to do that we want.To essentially delete entries that.Aren't being used but somehow not delete.And keep the entries that are being used.Often and so in order to do that what we.Do is we want to implement this concept.Of rent so essentially for all Soroban.Smart contract data entries the data.Entry will have a rent balance which is.Some amount of xlm that is reserved for.That entry to pay a rent fee and then as.That entry lives on The Ledger it will.Have a rent fee deducted from that rent.Balance and then whenever that entries.Rent balance goes to zero the entry is.Deleted from The Ledger answers if it.Never existed before.Now this is obviously it opens up.Some issues right so imagine you have a.Wallet or a balance that stores a lot of.Tokens that are valuable you wouldn't.Want this entry to be permanently.Deleted and lost just because you forgot.To pay rent and forgot to up to rent.Balance and so instead of even though.The entry is permanently deleted from.The Bucket List what we do is we take.That entry and we send it to a special.Kind of node called an archiver node.And this archiver node is essentially.Storing all of these entries and then if.A user then wants to use an entry that.Has defaulted on rent and then been sent.To an archiver node then what they have.To do is they have to go pay a fee and.Then retrieve that entry from the.Archive node and then give that entry.Back to the validators and then once.That fee has been paid the validators.Will then take that archive entry put it.Back on the bucket list and then this.Entry can be used as if it was never.Deleted.And so kind of the implementation.Details as to how this work is the.Archive is implemented in a Merkle.Tree-like structure and then in order to.Restore an entry from the archive and.Then put it back on the ledger so it can.Be used again you have to provide a.Proof of inclusion that this entry that.You say was archived actually does exist.In the archive and so this Merkle.Structure is very powerful because it.Means that validators are able to check.And make sure that the entry you say is.In the archive is actually legitimate.But the validators don't need to store.The archive all they need to do is store.This root Merkel hash and then they are.Able to validate proofs that are.Generated from the archive so kind of.High level how this works is the.Validators themselves don't store any of.The archive State and cannot produce.These proofs but the archive of the.Archive nodes do store the entire.Archive State and have enough.Information to produce these proofs and.So the archive nodes we kind of Envision.To serve a similar purposes kind of.Horizon where they are supporting the.Validators but are not directly involved.In consensus.And so from an interface perspective.This has a couple of issues that we kind.Of need to discuss especially when it.Comes to security.And so because the we want the.Validators to store as little State as.This archive is possible.They don't store any of the keys and.They don't know what's in or not in the.Archive and so if you can imagine an.Example say we have like this token.Contract right and you have a balance on.That token contract but you don't use it.And So eventually the rent balance on.That entry will go to zero and that.Entry will be deleted from The Ledger.And then stored in the archive now once.You default on rent from the perspective.Of the validator it's as if this entry.Has never existed before and because the.Validator doesn't actually store the.Archive it has no way of knowing that.This entry used to be in the bucket list.Or that this entry is currently in the.Archive and so this means that if say.The smart contract was to create another.Balance with that exact same address.This would be allowed right because the.Archive or because the validator doesn't.Know that this entry and this key exists.In the archive it will create and.Generate new keys which means that we.Have this issue of key collisions where.You can imagine if this process was.Repeated several times it's possible to.Have an entry with multiple different.Versions of that entry with the exact.Same key that exists I'm simultaneously.On The Ledger and also in the archive.Now for some types of data these key.Collisions aren't that big of a deal.Right so if you can imagine if you have.Say a balance of some amount of token.With your given key and there are.Multiple different balances you have so.Say you have 10 xlm in an account and.Then that 10xl imbalance gets archived.And then someone sends you another 5xlm.And eventually that entry gets archived.With your key there are two entries in.The archive that corresponds your.Balance one with 10 xlm one with 5xlm.But this isn't that big of a deal.Because both of them are valid right you.Can just restore the 5x on them balance.Spend that 5x Alum and then restore the.10 xlm spend that no problem because.Both of those balances are valid even.Though they have the same key but for.Some data types that's not the case.Right so if you can imagine a smart.Contract implementation that uses a.Nonce value so let's say that we have.Something like usdc that uses a nonce to.Protect against double spends and make.Sure that transactions can't be played.Say that this nonce value is something.Like 10 a non-zero value and then gets.Archived well now this token contract.When it needs to do something the token.Contract will see that there does not.Exist in nonce because from the.Perspective of the validators the.Contract itself has no way of knowing.What's in the archive because the.Contract is running on a validator and.The validation store the archive and so.Whenever the contract sees that there.Doesn't exist a nonsense on The Ledger.Instead of going to the archive and.Restoring the nonce with a correct value.Of 10 what the contract will do is just.Create a new nonce with a value of zero.And so what you can imagine is say that.We have the correct notes value which is.10 in the archive and this new zero.Nonce because this nonce is incorrect.And is essentially shadowing a valid. version of the nonce in the archive.This allows malicious users to execute a.Replay attack because they can take a.Transaction that says hey if nonce is.Equal to zero this transaction is okay.And even though the correct non's value.In the archive is 10 the knots value on.The Ledger is zero and so they can.Replay this transaction and maliciously.Use this nonce value.And so we have this challenging problem.That for certain types of values like.Nonsense there needs to make sure that.You only have a single version of that.Entry between both the bucket list and.The archive.This is a problem because the validators.Don't store the archive and so there's.No way of checking if a key exists or.Not directly from the archive.So that's issue number one.This thing like nonsense where you want.To make sure there's only one version of.The entry that exists and then the.Second or the second issue that comes up.With security is something where you.Restore an outdated version of an entry.So similarly let's think of a token.Where you have some sort of kyc Entry.Right and so say that you have a kyc.Entry that allows a user to spend their.Tokens and then that kyc entry isn't.Touched for a while and So eventually it.Runs out rent balance and gets sent to.Now a new kyc entry is generated on the.Bucket list but this kyc entry revokes.Access to those funds now let's say that.This new kyc entry that revokes access.Isn't used for a while and it too falls.Into the archive but a malicious user.Might do is go into the archive instead.Of restoring the most recent version.That revokes access instead restore the.Earlier version of that kyc entry that.Gives the user access to spend those.Funds and so by restoring an out-of-date.Entry what you can do is essentially.Do a versioning attack where you take an.Out of date entry restored onto the.Bucket list and then you're essentially.Able to pretend as if it is newer than.The kyc entry that revoked access.And so essentially we have two issues we.Need to solve here first we need to make.Sure that you can only restore the.Latest version of an entry so you can't.Do this like kyc rollback attack and.Second for certain types of data we need.To make sure that there's only one.Version that exists in the archive in.The bucket list.Now we don't need that guarantee of the.Uniqueness guarantee for all types of.Data for example the balance example.I talked about earlier it's completely.Fine if you have multiple different.Balances but for things like nonsense.You need to make sure you only have one.And so essentially because we have these.Two different requirements we expose two.Different types of storage at the Soroban.Interface level right now we're calling.This unique storage and recreatable.Storage now essentially the differences.Here is that unique storage guarantees.That whatever entry you have there's.Only ever one copy of so in our non's.Example if you're using unique storage.And you say you know I use unique.Storage to create announce value and.That Knox value gets sent to the archive.If you try to recreate that value the.Function will panic because it says hey.This is unique storage and entry already.Exists in the archive so I'm not going.To let you to recreate that.Under the hood how we do that and.Again this is an implementation detail.For later is we use a combination of.Proofs of inclusion and also proofs of.Exclusion so for instance whenever you.Create a unique data entry for the first.Time you need to also provide a proof.That this entry has never existed before.And so this proof needs to become from.The archive nodes because the validators.Don't store enough information to prove.That something never existed but if you.Provide this proof to the validators.They are able to check the proof and.Make sure it's legitimate and so because.You have this extra step for Unique data.And needing to prove that nature never.Existed it's more expensive.Now the recreatable data doesn't have.This guarantee and so for a thing for.Entries like nonsense that have security.Implementation implications you wouldn't.Want to use recreatable data because you.Could have multiple versions of your.Nonsense and you could recreate nonsense.And have security issues.However you would want to use.Recreatable data for something like a.Balance that doesn't have this issue.Because recreatable data is much cheaper.Because you don't need the security.Guarantees you don't need to provide all.These proofs of exclusion and whenever.You create a recreatable entry you don't.Need to prove that's never existed.Before.And so essentially we tried to provide.These two classes of data so that users.Who need some sort of security guarantee.Can use the more expensive and slower.Unique data but for entries that don't.Require those strict guarantees you can.Use recreatable data.Now in addition to these two data types.We also introduce a third storage type.Called temporary storage and what.Temporary storage is is it kind of just.Does what's the name sounds like it's.Entries that are meant to be temporary.And so essentially if you have a.Temporary storage entry whenever its.Rent balance goes to zero instead of.Being sent to an archive it is.Permanently deleted and because you.Don't need to worry about sending this.To the archive and there's not this.Archival cost the temporary entries are.The least expensive storage type.Now you wouldn't want to use this for.Sensitive data such as balances because.If a balance defaulted on rent it would.Then be lost forever but for temporary.Entries such as if you want to give.Another user authority to use your funds.For say 100 days you could use a.Temporary entry that automatically.Deletes itself.Or if you had some sort of data that is.Easily recreatable such as like a.Payment Channel you could also use.Temporary data for that because whenever.It was deleted you could just regenerate.The exact same entry again.And so these are the three data types in.The storage mediums we're trying to.Present to the end user now the issue is.We have these security issues that are.Generated from the archive interface and.They can be very tricky to protect.Against for instance it's a very tricky.To think about examples like kyc.Rollback and nonce attacks in the.Context of this archive especially since.Archival state is not only a new.Interface for Stellar but a pretty new.Interface for blockchains in general and.So we want to provide an interface and.Define use cases as clearly as possible.For each type of storage.And try to make this as seamless as.Possible for the end developer and.Trying to abstract away as much of the.Complexity from the archival interface.As possible.So I think this is a pretty tricky.Problem. but I think that's the high level.Issue I want to talk about today is just.The security issues that arise from this.Archival state and then the three types.Of storage that we've tried to implement.So far and so I think I'd be open to any.Questions or if anyone has anything I'd.Like to talk a little bit more in depth.About.Bro. thanks for that just a quick.Question you just you were talking about.Unique storage and having to supply .Proofs that does that mean that in order.To create a unique storage entry.I need to have access to an archival.Node.Yeah so essentially how that works is.Out when you actually from the.Perspective of the validator itself .So yes you do need to have access to a.An archiver node to produce these and so.Kind of what we're Imagining the.Interface would look like is that RPC.Nodes. kind of double as pre-flight nodes.And archiver nodes and so during the.Free PreFlight process if you generate a.Unique entry or if you want to access an.Entry that's in the archive of the.PreFlight note itself will carry.Archival data and so the PreFlight note.Will be able to essentially kind of work.Similarly to the footprint when it.Generates Footprints for a read write.Data accesses that the pre-flight node.Will be able to retrieve the proofs that.Are required for your transaction and.Then give those Trend or give those.Proofs to the validator and so because.The PreFlight node is generating and.Providing these proofs whenever you.Actually go to apply that transaction on.The validator the proofs are available.Because they've already been made in.Advance by the previous flight node.And just a bit here for recreatable.Storage I don't need that right yeah so.For recreable storage it's cheaper.Because you don't need to provide any.Proofs and there's no work to be done.You can just if a key doesn't exist on.The Bucket List you can just generate.That new key without any checks or.Balances no problem.Well to make an amendment like it's not.Like nothing has to be done through a.Created both storage because if you want.To benefit from the fact that it's.Recreatable you need to write some codes.That allows you to nurse entries for.Example if you have a token contract and.Your balances are creatable. you probably want to provide a.Contract function that allows users to.Recreate there is a balance given.Approve basically.So like both involve something to be.Done but in case of unique storage it.Would need to be done every time you.Create a new entry while for a tradeable.It's only if your entry has got archived.And you actually want to restore it.Which hopefully shouldn't be the case.Too frequently.Yeah kind of the difference is in unique.Storage if something exists on the.Archive you must restore it in.Recreatable storage if the entry exists.In the archive you have the option of.Either restoring it or just if the.Restore would be too expensive or you.Don't want to restore it for some reason.Just creating a new entry with the same.Key.But but just to be clear with regards.To what Dima just said if I do have an.Existing if the Ledger entry has been.Recreated with the same key. when I try to restore it right now.Will it. will it fail or will it like use some.Sort of like custom merge capability.What's what's gonna happen yeah so when.It comes to recreatable data there's a.Function that we Define called .An archive latest version and.Essentially how this works is whenever.You restore unique data it's.Automatically. add to the bucket list immediately.Because unique or for Unique data.Because unique data is known to be.Unique and so you know you won't have a.Key collision between the archive and.The bucket list so you can just.Automatically add to the bucket list for.Recreatable storage this isn't true.There could be a key collision and so.Whenever you restore a recreatable.Storage entry.It's not immediately add to the bucket.List but instead this function .Restore latest archived entry just.Returns the unarchived version right and.So in the doc if you look at the last.Two pages there are two example.Functions on how to restore our.Recreatable data. to example implementations that.Contract might do but essentially.Because of these key collisions it's the.Responsibility of the smart contract.Implementation to resolve these.Collisions and so for instance what you.Can do is after you get the restore.Latest or the unarchived entry returned.From this function you can check the.Bucket list and see if there's a.Collision and then if there's no.Collision the smart contract can just.Write the key immediately no problem but.If there is a collision then what the.Smart contract might do is compare the.Values of the recently unarchived.Version and the bucket list version and.Pick one or discard the other or in the.Example of balances there could be some.Sort of merge operation defined by the.Smart contract and so if you have two.Balances the unarchived behavior.Might be okay take the unarchived.Version sum the balances of the version.That's live on the bucket list and the.Recently unarchived version and then.Just write the result which is the sum.Of those two balances and so because.There are different use cases depending.On the contract that's a contract.Implementation that this contract.Developer itself might think must think.Of.It and is there a I see you have a.Section on default implementation. what should be the default.Implementation yes I think the the.Safest default implementation is just if.There's no key Collision IE if you want.To restore something and there's no key.On the bucket list then you restore it.And add to the bucket list if there is a.Collision just panic and fail because. you don't want it to be a no up.Because the an archive function does.Delete the entry from the archive.Right because you can't unarchive and.Entry twice from the archive once you've.Unarchived it once it's gone forever and.So you won't want to lose entries if.You can't if there's a key collision and.So I think the safest option. that preserves all the data is for.The default just if there's a collision.Just panic and then you either have to.Wait for the entry that's on the bucket.List to be archived or delete the entry.Yourself on the bucket list and then the.Default. unarchive will work.Okay I imagine there are a lot of.Questions unfortunately we are at time. so this discussion is going to .Carry on feel free to ask questions on.Live chat Garen if you can hang out.There and ask any questions and answer.Any questions that'll be great.And yeah thank you all this has.Been a very productive hour and we'll.See you all next week.

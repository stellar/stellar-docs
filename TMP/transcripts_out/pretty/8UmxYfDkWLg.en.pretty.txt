All right, I'll get started., so.Welcome everyone., today I'll be.Speaking about CAP 74 which .Introduces host functions for the .BN24 pairing friendly curve., so as.You as you may know, Stellar already has.Support for has host function support.For the BLS 12 through 381 curve which.Was chosen over BN24 due to growing.Support for it and security. but.We've gotten ecosystem feedback that.There are existing use cases that rely.On B2 BM 52 BN254 and adding native.Support for it will make it easier to.Implement those use cases on Stellar.The other option would be to adapt those.Use cases to to use the the.Existing VLS host functions. but that.Would be prohibitively expensive in some.Cases.So this proposal the main part of this.Proposal is that it adds three host.Functions G1 add G1 malt and a.Pairing check which gives us parody.With the BN24 pre-ompiles in the EVM.Now there have been some discussions.About extending this in particular.Adding a host function for G1.Multiscaler multiplication but this.Proposal doesn't include that. at the.Moment we're just trying to support the.Existing BN24 use cases and this.Should be sufficient and for for any new.Use cases I the recommendation is.To use BLS. the the CAP also specifies new new.Cost types for the BN operations which.Are similar to the cost types that we.Added for BLS they're just a subset.Because BN has a subset of host.Functions and Yeah. it's a a pretty.Pretty short cap.. we also define the field the field.And groups.And yeah are there any questions?
If there aren't any questions. Oh,.If there aren't any questions.Tor's typing.Yeah, it's a pretty straightforward cap., if if anyone has any questions, you.Can tag me on Discord and we can we can.Have discussion., but if not, I'll .I'll pass it off to Jay to discuss.Adding host support for Poseidon and.Hash functions.Can you hear me?
Yeah, I can hear you,.J.Okay, wonderful.Yeah, great., I.Just want to add on what Sid just .Talked about. so yeah the ecosystem. technically they could use all.These BRS functions but in the proving.Proving framework including like this.The circuit like switching those.Curves off is it's in reality it's more.Challenging than u than we thought.It's.Not just a simple curve swap but.Sometimes those protocols can be evolved.And circles have to be recompiled with.Different curve. and then there's.Also different type of issues with.Like different u like proving systems.Support one curve versus another.So.BN254 is is mostly for backward.Compatibility. and also we've also.Added a solorone example of importing.The BN 254 inside the solar contract.Which works but it takes I think like.500 million instruction to do one.Pairing.So that that is also.Prohibitive.Just wanted to point out.The like these two specific rational why.This is needed. cool. and yeah I will start on yes thank.You an yes so the poseidon hash.Function has also been one of the.Requested. primitive to add into solar so.I've recently just looked into this I.Don't have a CAP yet but I will lay.Out what I what I found and and sort.Of the different approaches u like.Informally here and I'll work on the cap. probably be ready in the next couple.Days. so yeah, first of all, why is.This also needed.In the proving in the DK application?
In the proving in the DK application?
In the proving in the DK application?
. the the commitment scheme is a lot.Of commitment scheme is hash hash based.Meaning you hash something and then you.Prove that this thing has been hashed is.Without revealing it.So the hash.Function is is critical and then for.The hash function that's used is also.Important in terms of the performance of.The prover side. so from what I .From what I understand not expert but. from what I understand is using the.Right hash function like Poseidon can.Reduce the number of arithmetic argu .The the arithmetic gates the arguments.By an order of magn like two orders of.Magnitude.So this this is a fairly big.Difference that's why a lot most of.The like the circuits use these field. field based hash functions and.Poseidon and pose then two are two of.The most widely used ones. so the.Next next question is why do we need to.Support in the in the host .Although the proof is generated offchain.And the verification of the proof is .Doesn't involve hashing the hash is.Needed because some applications need to.Maintain for example a mer tree of of.Different coins for example and then.To prove the coin's existence they can.Prove without without hashing but to.Update it on chain or some any kind of.State that involves hashing to be.Proven it it needs to use a hash to to.Update.So to to to be consistent we.Need to make sure that the hash function.That's being proven is same hash.Function as what's being used for.Contract state update.So that's kind.Of a big u overview of rational and.Poseidon functions these are these.Are not two these are not one function.It's rather a family of functions or.It's a rather it's a it's an approach .That based on on sponges and then .Ways to connect it connect these .Sponges to provide different.Permutations with different input So.It's fairly generic. you can.In terms of you can plug in different.Parameters like for example if you.Require a higher security parameter then.The round parameters will be larger and.Also depending on how many inputs you.Need to hash at once also how many .Output the throughput the number of.Runs needs to be adjusted.So, so in.The Prooseidon paper there's.Different implementations of different.Versions of Prooseidon given on the.Requirement as well as underlying .Field.So here we the primary field what.We have to support for compatibility.Is BN24.And also BS2381.So that's a that's a two requirement.And based on these requirement some of.These parameters can be decided but.Some of them are still can be some of.Can be cho choices.So we need to.Really decide what level of.Flexibility we want to supported with. so in this discussion last the.Discussion thread the last post I've.Laid out the three approaches that I.Feel we could support it. so these.Are in terms of u from the most high.Level to the most low level.So number.One we support it as hash functions.Directly.So for that we we will support.Poseidon Poseidon 2 and the two.Curves and then.So yeah I think this is the most.Straightforward one but the but the.Limitation is that we are we need to.Kind of decide on the parameters. internally like like there's a so so.In the in the Prooseidon paper they.Describe how to choose these parameters.And they they choose it.They provide a.Script to how to generate these.Parameters and own guideline on how how.To choose them and in reality from from.What I know seems like different.Applications. sometimes generate their own.Parameters.I'm talking about these.Internal like round constants like these.Matrixes. so so if if someone from.Another ecosystem. that generates a proof with a.Different instantiation of Prooseidon.Then potentially here we could not .Support it.So, so, so there's a little.Bit of compatibility risk we we.Have to decide but I think for for.This one most parameters are fairly.Straightforward. and then we need to.Make sure that the major prover.The the major prover can be supported.Like the circum or no and we we just.Need to make sure that whatever.Parameter we choose is compatible with a.Major that wants whether we wanted to.Migrate to Stellar with so that's number.One number two is to expose the.Internal poseidon building blocks so .As I briefly mentioned earlier the.Prociding hashing is a is a sponge.Based like a block cipher it.Consists of absorbing the input per.Permuting them and then squeezing them.So one of the ecosystem member .Antonio suggested that we could support.The generic interface to to.Provide these and then users can just.Choose the parameters or choose the.Security parameters field and all that u.And then we can expose these options .Through the SDK. I like this.Approach. but I think it's maybe a.Little bit it involves a little bit of.Figuring out the requirements for the .The libraries and then the the the level.Of details we wanted to expose how to.Expose them to SDK.I'm I'm not I'm not.Expert in the this part yet. so I.Will say that this one right now I.Would I would say this is a a less.Favorable option. and for I think one.Of the one of the main advantage for.This one is that Osan and Poseion 2 they.Use very similar interface.Potentially this this one is more.Cleaner that we just support this and.Then the two different variants can.Be supported like more uniformly.Doesn't add complexity.Station.Yeah. yeah, I think.Yeah, this requires the user to.Understand what they're doing and how to.Instantiate the hasher with these.Options.Yeah I think yeah I'll also talk about.Number three because I think exposing.The host function. exposing the hash function is the.Most straightforward approach but in.Reality it's just the different.Parameters we we can support them all.But then with.With the internal building block it's.Possible that we could let give.More flexibility but yeah I Think that's.Kind of the main rationale but in how to.Do it we have to think it more carefully. wanted to say that for approach two and.Probably three it's not like we have.To put much burden on the users it's.Just that we can build SDK functions.Right that do the same cache.Functions for example because you have.An option one but there is a huge.Benefit of you know not introducing.Like combinatorial explosion of the.Code types into host which I think is a.Really bad property of approach one.Right it seems like instead of just.Setting a few cost types we need a lot.Of them and if you wanted to do.Something more complex we would need.Even more and this is I think a lot of.Maintenance burden and a lot.Complexity in the protocol which I think.Kind of would be nice to avoid.So I.Feel like these parameters could be.Implemented in the SDK.So user.Complexity would remain the same.The.Only question is really performance at.This point.Yeah, I disagree on the cost type.Part. because I think doing two.And three can reduce the amount of cost.Types potentially because these are just. three building building blocks and.Then yeah. to be clear I totally agree with you.I'm saying that I do not like option one.Because in option one we need a cost.Type per. hash and per whatever curve and.Perity which is an argument of the.Function which is what I refer to.This explosion right we have like three.Different inputs to that so I think.We're on the same page here I agree that. we probably want to have more limited.And like number of cost types that can.Be useful building blocks. Yeah. and by the way, .Also the RT it.I think for for a minimum we just we.Need to support RT 2 to support the.Merco tree or binary Merkel tree. but.We.Fairly certain we don't need four right.Now and then one maybe.So at a minimum.Maybe just a R of two but I would need.To confirm it if this is this is just.What we need.Yeah, I still feel like it.Is like a really hacky design, right?
Is like a really hacky design, right?
Is like a really hacky design, right?
Like we have a host functions, it has an.Like we have a host functions, it has an.Argument, but it can have only like.Couple of values.But. I don't know.I I would really try to.Stay with the building blocks and do.Work on the SDK side if it is feasible.From you know the instruction count.Standpoint.So number three is going a step.Further. to to do this without.Providing any Prooseidon host.Functions because the algorithm.Itself is fairly they say.It's more like applying. like applying arithmetics.Repeatedly in iterations. so in.Theory most of the heavy costs are in.The field arithmetics which we already.Provide for BS 12381 and then for BN we.Are going to provide them.Question is can we just do this on the.Guest side so I did a bit of experiment. what what I wrote yeah hash 2 takes.About 17.6 6 million instructions.This is trying to like do the.Optimized implementation or I think it.It's with the current implementation.That's the best we can do and out of.Which only like around three million.Other crypto arithmetics. the main.Reason is that every like to do every .Irrespective you have to go round trip. to the host and then to do the bite.To internal representation conversion.And then internal type for for efficient.Arithmetic requires if I remember.Correctly it's a Montgomery form.So it.Needs to do some arithmetic to convert.The numbers into some form that's.Efficient for multiplication for.Multiplication or division for example.So there's quite a lot of these.Overhead.So the s the the thought.Process is if we can bundle these.Into some u like more efficient. field arithmetic functions such as.Dot product and matrix multiplication. is it possible that we can reduce.That cost?
I don't have a straight.Answer for that but my intuition is.That we can include we can we can reduce.That significantly but maybe not to the.Level that we require. for reference. to hash a mer tree of a million.Entries we need 20 hash operations.This would require at least you know.10 to five times reduction of of that.Number. so I think we can.Like reducing these operations. it's.It's doubtful that we'll get close to.The upper bound that we we're.Shooting for. yeah bit of rationale.Reason into that is because even though.We can provide the matrix multiplication.These matrix are fairly small like 3x3.So we're not bundling like a thousand.Operation into one we are just bundling.Like you know nine and then the the rest.Of it still like was code and these.Loops and which will still have.Significant overhead that's why I feel.Like this approach even though it's more.Attractive it it probably wouldn't.Wouldn't work well and also it will.Require the user to handle their.Preciding implementation.So overall I.Think in my opinion number one is. is probably the best option to.Support it today. and then we need to.Think more about these parameters and.Choices. any numbers for option one. like how much more is it?
Yeah, I yeah, in number three, I.Yeah, I yeah, in number three, I.Added up all the metered cost for.Arithmetic.They are about 2.5 million.So I would say number one would be.Much more closer to that. there's.Still.Like some like extra cost of like memory.Allocation and like.Like the the conversions still a bit but.I would say it will be much closer to .2.5 million.Are the numbers in three like when.You say optimize is that like what do.You mean by that?
Is that like a native.Call that you tested. 17 million?
 17 million?
 17 million?
 Yeah, it's not it's not a native. Yeah, it's not it's not a native.Call.It's was contrast.So, it's.Basically implementing.Poseidon cache in in W was but.Calling the host functions for BS .Scalar add multiply and these functions., optimize just means that I try I try.What I can or what I know to make.Sure that these calls are all necessary.And then we're not wasting like.Unnecessary convergence and things like.That. Okay.Okay.I I don't know the in terms of CPU.Cost.I don't know how much they will be.Different.It's more like the.Complexity and the maintenance. so I.Would imagine if done properly they will.Be pretty similar in terms of.Performance but it's more like the.Question of yeah we want to expose that.Level. right.Again for the complexity I.Sure I get the argument like I think.Really complexity.I said can be moved on the SDK right.I think what is important here is.Protocol complexity and I feel like one.Is more protocol complexity just from.From the standpoint of maintaining the.Permutations of different input.So if.Two is really yeah it's unique as the.Same.So so yeah if you had a number for.Two and if you knew that it's not.Significantly worse than one and I feel.Like two is much better option.I haven't done enough .Exploration in that direction yet.Yeah,.We I'll try that in the update.But even for two, we need at least. Prooseidon and Prooseidon two because.These spongy implementations are. so that we're talking.About. yeah like at least maintaining like.Six.Six of these functions essentially.But it it just feels much better.Still because it's like at least finite.And it covers like all the cases, right?
And it covers like all the cases, right?
And it covers like all the cases, right?
 Yeah.So as Nika points out like if.Friendly isn't hard for coded so you.Know something new needs to be done.And can do it as a guest layer.Yeah I'll I'll do a little bit.More exploration to two and yeah if I.Yeah I'll update on thread.Yeah, Alex, I think yeah, that's a yeah,.That's a agreement.I think yeah, two is.More flexible., it's just little bit.Of complexity to to do it, right?
Yeah, I think .Yeah, I think .In option two,.Even though we expose these.Primitives, the internal parameters.Would still have to be.Like I think these interfaces don't let.You specify the.Like the security parameters like the.The the long constants matrixes. so.Yeah one thing one other thought I had.Was should we expose those or should we.Like let let the user initiate the hash.With set of parameters they they want.And how relevant would that be for .Most ecosystem but I haven't figured out.Answer to that yet so there's.Potentially they're doing two with.Maximum in top interoperability you.Could be more complex. Different parameters like would they.Impact the runtime or are they just. No, it's just numbers. No, not not runtime.Yeah, it's.It's just different hash.Output will be different.But the.Runtime is just the yeah the.Width of the inputs and the number of.Runs.So yeah long time I think we with.Number two we can we can have that.Metered with like per iterations but.The security parameter is just the.Choice of. yeah like the choice of hash states.That don't provide different outputs.Yeah, I agree.Like if we.Add a capability to provide.Configuration and it does not change.Host complexity much then we should do. because. okay. from the hosting point I would be.Concerned about the metering but since.We can meter it all the same I don't see.Like why would pass in an additional.Vector or something as an input but. but we introducing too much.Complexity here.I think yeah mix yeah two.Would be a a good yeah good solution for.Interoperability.I'll spend more time.On that.Hey guys.Hey. Can you hear me?
 Can you hear me?
 Can you hear me?
 Yes. Yes. I'm in a bit of a loud environment.So,.You know,.You can hear me., yeah.So, I joined.In the middle, so maybe I missed some.Things, but I think I kind of understood.J's proposal. with a hardcoded.Option, an option that enabled us to.Configure MDS and run constants. seems to me that the.Configurable option is the is a good way.To go because that still optimizes the.Hash function itself run faster after.The initialization but enable some.Flexibility. the one thing I think we need to.Ensure is and I don't entirely.Understand how it works is how often.We need to initialize the potent initial.Initialization types. like let's say for milling.As instructions. so I think it would be good to.Understand whether say to deploy as a.Separate contract and then poly to.Whether the initialization only occurs.Once deployment is done.So that those.Are details that are less familiar.So as long as we can guarantee that the.Initialization of the hash doesn't often.Think abilities disadvantage. yeah I don't know any specific.Questions lots of when doing stuff so.Actually guy was looking into that as.Well yesterday he was looking into.Implementations from what we saw Tom.When we did it with you when we had the.Budgets it seemed So if it's around.For milling instructions and then the.Hashes themselves are around 10 million.For everything running wasn't right but.As long as for instance those four.Million instructions happen.In my limitation one positive that's.That's not too bad.Sorry, could you repeat the part?
What's.The forming instruction?
The forming instruction?
The forming instruction?
 , that's the that's the construction. , that's the that's the construction.Of the house. Oh, okay.,.I think we.Yeah, I'm thinking like if if it's like.A contract like every contract has its.Own the the seat for like the RNG.For example.Similarly, every every.Contract can set its own the state and.Then they can once it's set it should be..Yeah that should be the initial cost.Yeah I'm not also familiar I'm also not.Very familiar with the internal working.Of like these hashes so I need to look.Look a bit into it but I imagine the.Initialization is just one time and.Absorbing. yeah and then yeah you need to and then.To use you have to absorb it first.That would be like probably based on the.Number of inputs.So the initialization is.Just like reading the checking the.Conference.It's not a stateful or.Something that So as long as that's.Done,. you can hash. Yeah, that's right. Yeah, I guess it's per No, it can be per.Per it can be per contract life.That's a good question that then you.Need to serialize it somehow.Betweenations or if you're if you're.Invoking a method from another contract.That then I guess can just keep invoke.Getting cached and we can keep invoking.That but hey I I'm talking here about.Lesson.But but yeah I mean it's it's not for.Invocation it's it's.How however long you can do. I have a com I have a question about.What you wrote.So why why would it.Matter whether other V projects have.Different configuration witnesses apart.From unless you want some.To be inter between different.Channels.Other than that we can speak around for.Answers., sure.Makes sense.I mean, it's not.It's not it's definitely there's.Definitely an advantage to having the.Same parameters that.I think I think it makes.Sense.U Yeah.Allowing the.Constants to be overwritten for Yeah.For different chains and different.Projects.Yeah, good point.Thanks GPT.So I think that's seems like.That's the main questions and.Concerns is the interoperability and the. flexibility.So yeah, I will look into.Option two in more depth and then I will.Update that thread and then CAP will.Follow. is there any other questions?
I guess also to also to add I guess it.I guess also to also to add I guess it.Would be good to look at the parameters.Of the circum lead the standard the.Circum library and see what they.Correspond to in terms of other stuff in.Specific projects because I so far.I've replaced them with something that.Works on interoperable between what I.Could that work in cir and rust.And m.So that's a riding stand library.If we.Can go back to the stand library and use.The parameter that probably that.Simplifies C. Oh okay.So, so did you say you.You you changed those parameters in.Order to. Yeah, basic basically on on both ends.Both on serum . on the rough end.Basically parameters that I keep from.Side implemented forum but. I need to check if it depends on the.Fun library or from other library system.That I found.That's how it's hard to.Double check that if we could exceed to.The default CD parameter that would be.Good. And probably they probably work on other.Project.So perhaps supporting. right like supporting like a default set.If if it's not overwritten like default.To like a circum or something.Cool.If no other questions, I guess.Hand it over to you, Bri.You want to.Close the meeting?.

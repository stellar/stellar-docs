Okay, I'll get started., hi everyone.Today, , we are going to be talking.About CAP 75, which is a proposal to add.Two new host functions to support.Poseidon and Poseidon 2 head functions., so the CAP itself is fairly.Straightforward., two new host.Functions. it it's pretty standalone.Doesn't involve any of the previous.Protocols mostly except using the.BLS and BN field. but I want to spend.A little bit time on the approaches that.We decided on and the rationale behind.This approach.So first of all just a.Quick introduction on on the.Motivation why do we want the Poseidon.And Poseidon 2 hatches. so so.The Poseidon and Poseidon 2 they are.I'll call them Poseidon family.So they.Are they are family of hashes basically.It accept a range of parameters and then. you can configure it to to compute.Output.So what it what it is is it's a.Sponge based. hash function which means it consists.Of a sponge. that absorbs input and fit output.Which is a variable length input various.Variable length output function and.Internally there's a permutation which.Is fixed input fixed output and the the.Reason that u it is useful along with.Other catches of similar design is.That it directly operate natively on.The on the prime field.And as you can.As you know most of the zero.Knowledge applications are built off.Of the prime field such as BRS or.BM254.Which makes Poseidon natively work .With with this field and they are ideal.In DK application.Just to give a rough.Idea, it the amount of constraints .To generate using a regular hash like a.SH 256 versus Poseidon is two order of.Magnitude difference.So it's a lot of.Proof side less proof side complexity.And time to use Poseidon.So for for contrast so proof.Allocation typically don't involve.Rehashing or anything. but for.Contract implementing logic such as a.Mer tree that you want to generate proof.Of you want to have the same hash.Implementation. between your contract and what you.Use when you generate the proof for that.Mole tree.I think that's quite obvious. and to have the Prooseidon.Implemented on the on the gas side or.Or contrast side is quite expensive.Even with the functions that we already.Provide for BLS field arithmetics,.There's still a lot of round trips.Between converting a few element to.Bytes and and things like that.So .That's why we we want to support.Prooseidon as native host functions.So just a recap of where we were last.Time.Last time we proposed a few .Three possible approaches to this..First is just to provide the hash.Functions plain and simple. you.Know for different field you know for.For different field combination of B.And BLS combination of PID and PIN 2 and.A combination of number of hash.Input.So this gives us what like.Eight different type of host functions.That will cover a lot of use cases..But this approach isn't good because.We've from the feedback and from the.Evidence that a lot of these hashes they.Require particular parameters these.Parameters are not set in stone.So.Different implementations could choose.Them differently.So even if we specify.Them in in the host for example.Someone else might need a different way.To provide a parameter.So this way.Isn't just provide a hash function isn't.The most maintainable way and what.About providing more host functions for.Those field arithmetics and also it.Wouldn't solve the problem because even.If we provide things like matrix.Multiplication the pose hashing involves.A lot of rounds of permutation each.Round is doing this multip.Multiplication so we still end up with a.Lot of these cause and a all of these.Round trips. so one of the proposals.Ended up last time was can we provide.A more generic interface for the for.The sponge hash namely the to.Absorb some input doing permutations and.Spit out the output and then be and let.It be parameterized.So yeah so that's what we settled on.On last time and and yeah so now to.Transition to this cap.So this cap.Proposes a slightly different approach. which which I call approach four .That from the discussion thread for for.Anyone who's following.So approach four.Is instead of providing the launch.Interface we provide the internal.Permutation functions that the launch.Hash uses. so why why why is that?
So.So the the sponge is the sponge is a.It's sort of its own animal.It's a.Different animal than the permutation., sponge design had many different.Considerations. for different applications.For.Example, not only for hatching but also.For like generating like a random.Stream of bytes or or for MAC .Method message authentication code or.For for random like for receable.Random value generator like these.Applications are all u designed.Scope of a sponge.So the sponge needs.To be more flexible.It needs to .Maintain a state.It needs to in some.Some cases it requires switching between.Absorbing and squeezing and then.Switching back.So the sponge interface.Itself isn't.It isn't a single definition that we can. just just take because and.Itself is also has some some complexity.In it. however the internally all the.Sponge function they call the same.Permutation function.So after so in.Both stun absorb and squeeze the the.Input and output before it was the input.Is passed and then the permutation is.Applied and and the permutation is.Applied and the output is squeezed.So at the center of it is just this.Permutation function that takes a fixed.Length input and a fixed length output.So this is much more maintainable and.It's much more easy to support in.Solarong without ramifications because.It's just a simple cryptographic.Building block and the sorbound host.Doesn't need to maintain any any state. so there's no like state related.Issues for like what if you make a.Subcontract call do they you know.Reinitialize a sponge and how to do.That.So, so by by supporting Prooseidon.Permutation instead of the full.Prooseidon hash it gives us a lot of.Flexibility.Maintaining sort of host.And also sponge itself for for a h for a.Simple hash algorithm that's like a.Binary hashing.Of of a Merkel node for example isn't.That complicated.is just basically it's.Just a single round of taking the input.And applying the permutation and.Spitting out the output.I've written.Down a little pseudo code that basically.Is what it is in the cap.So, so just to.Recap, the sponge interface is.Complicated. it the the sponge is.Designed for many different use cases,.Not just hash.Even though for hash the sponge is.Really simple we don't want to just.Baking a simple sponge implementation.Inside host while this is much easier to.Do it in the contract or in the guest or.In the SDK. but it is makes much more sense to to.Support the primitive that's mostly the.Most expensive operations happen.Which is the permutation function .Inside the sort of host.So that's the high level motivation and. now I can go through the actual two.Functions being proposed. one is a.Prooseidon permutation and second one is.Prooseidon 2 permutation. the two.Look fairly fairly similar.So so.Just a bit of background Prooseidon is.The original version developed in 20.2019. Poseidon 2 is a a improved.Version of that developed in 2023.Internally they they work slightly.Different.Poseidon 2 has u improved the.Internal matrix shapes and then add. pre relication add add a single.Layer of pre-apply but overall it works.Fairly similar. so I'll just cover.The Poseidon one.So the process permutation takes the.Input which is a vector object that is.Your vector of field element and then.The second thing is the field type.So I think it probably makes sense to.Have field type as a symbol but in the.Cap I I'm putting U32 should be.Equivalent but yeah field basically is a.Enum that specify which field you you.Want your permutation function to be.Defined on and of course your input will.Be passed in the same field as the.Permutation. matrix and all that., and the rest.Of it is just internal parameters for.The for the hat functions., so that's.Pretty much it., but I'll just spend.Maybe a few a couple minutes just.Explaining what these fields are., t.Is the capacity parameter.So it's the. capacity the internal sorry not the.Capacity but the internal state size.The internal state side much must match.The input and also must match the.Size of internal matrix.It is.Decomposed of the rate which is number.Of you can think of as number of input.You need to hatch at once plus some.Capacity which gives you additional.Security parameters. d is the degree.Of the the fbark which is the .Internal.One of the internal step in the.Permutation before applying the matrix.Multiplication.So for bn and bs both.Both fields d is equal to five.So we.May we may just only accept the equals 5.U but of course for other field in the.Future could be different. the round.F round t these are the internal partial.Round and the for round these are the.Number of round the matrix.Multiplication happens so the yeah. so the there's also a linear layer.Which is u sorry the the linear layer is.A run the mod matrix multiplication.But the nonlinearity is provided by the.Run constants which is also matrix but.Specified for each run.So the so the MD.MDS matrix for hash two function is.3x3 run constant is a is another.Matrix with dimension n by m where n is.The number of run and m is three.So that's a high high level run through.Of the different parameters. the.Second one is fairly similar.The only.Difference is that the internal MDS.Matrix in the second version is a.Diagonal matrix because of the.Precision 2 improvement.In terms of cost type.So we so we manage I think we we can.Manage to ship this as a native solar.Bond library which means that all of the.Operations they are already existing.And were defined.These include the.Field arithmetic for adding and the.Multiplication and things like that.There's no particular peridon specific.Metering parameters we need to support.But we do have to add these ban 254.Field u arithmetic cost types which.Is a very opportune timing because we.Have the CAP 74 which has b24. scala field and pairing. I went through the parameters.Metering.Rationale.Yes.So that the rationale.Why hash function why we don't.Provide a hash function out of box.Rather than providing the permutation.Primitive.It is explained.And yeah just to also mention these.Parameters they are.Yeah so so some of them they are they.Are kind of defined based on the.Application like if you have a curve of.If you want to do hashing with BN25 .254 then the degree is five you can.Change that and then the sum of them is.Depend on the actual application .Which is how many inputs you want to.Hash at once and then based on the size.Of the input these parameters like t.And then the number of runs they need to.Be adjusted the original procidum.Paper provides scripts and guidelines.For how to generate these parameters .In general I think most.Applications have their own. they they have they use a a set of.Generated parameters like CIRCOM does.And Noel does and to provide the maximum. like safetiness we would have.These as part of preset in the SDK.So like the SDK SDK interface will look.Exactly just like a hash two that takes.Two input and then internally you may be.Able to specify the set of parameter.Like a circum parameter or or neural.Parameter things like that and then we.We also possibly expose these.Poseidon permutation as a as a more like.A hazmat interface something that.Advanced users that know what they're.Doing can can call with their own.Parameters but we we will make them .The distinction more clear.Yeah.In terms of testing there's a.Reference implementation for Prooseidon.And so Horizon lab has a reference.Imitation for Poseidon 2 and in the same.Repo has Poseidon one.That's the one we.Likely going to adopt.And it also.Provides test vectors for both one and.Two in different fields and parameter.And then there's also the original.Prooseidon paper that come with a a.Sage script implementation with some.Reference vectors which we will also.Match our implementation with in our.Tests.There's a draft implementation and I.Think that's it.Now four is open for questions.So I did a very rough well I.Wouldn't say too rough but like the.Implementation is fairly.Mostly good and then the the field for.BRS is already there.So I did a .Number on on the on the reference test.Cases for BLS .The 3x3 matrix case which is the hash.Two operation that's about half a.Million CPU instruction.So it's a lot a.Lot better than what I projected last.And then the 5x5 matrix case I.Believe that's like cache three input.That's around 1 million CPU.So yeah that's well below our target.Ceiling which we want to support around.20 hash cores in a single contract.Oh, okay.You want me to close it?
Okay.Bye, everyone.

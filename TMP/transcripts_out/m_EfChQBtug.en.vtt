WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:59.999 align:start position:0%
Hey everyone, welcome to the Stellar protocol discussion for May 12- 2022. In these meetings we discuss and plan for upcoming changes to versions of the Stellar protocol, changes that are necessary to evolve the protocol to meet ecosystem needs. I'm just real quick. A word on venue. You know, last week we tried having this discussion in the Stellar developer Discord and there were some technical issues. So we're back to live streaming this on youtube. You know, we just don't want to let the technical issues of a platform prevent us from having these discussions so that we can talk about the substance and keep moving forward. We may experiment with other venues in the future, but you know we'll make sure to stress, test platforms,

00:01:00.000 --> 00:01:59.999 align:start position:0%
So there's just not technical glitches that prevent the conversation from happening. That said, we are discussing this week some CAPs that are related to Project Jump Cannon, which is the an announcement that we made earlier this year that we are working to bring smart contracts to Stellar and as part of that there are protocol changes that need to happen. It's been a bit different this time because we've sort of modularized those changes into a series of Core Advancement Proposal, each of which focuses on a specific aspect or specific type of change that needs to happen to accommodate smart contracts. Now, if you're watching this right now, it's a technical discussion. So I advise looking at the links in the show notes, which are the actual links to the Core Advancement Proposal that we're going to discuss and to the discussions that exist on the Stellar dev mailing list, which is where sort of long form question and answers happen. In addition to the Stellar debt mailing list, there's also the Stellar dev Discord and there's a Jump Cannon and a jump can and dev channel in there and anyone can join either of those forums in order to like see the discussion unfold or

00:02:00.000 --> 00:02:59.999 align:start position:0%
Participate in the discussion. We're doing this in the open so that you know you can sort of see the work happening, or and also so that you can have a voice in the changes as we make them. So, that said, there are a number of CAPs that are on the table right now that relate to smart contracts into Jump Cannon, and we discussed a few of them last week. I think this week we're going to start out by talking about some of the classic smart interoperability questions that remain, most of which have to do with CAP 48 and CAP 49, that are kind of two different flavors of how to approach that. And as recently as this morning there was some interesting discussion on the mailing list about that, and so I think we start there and I think, I don't know, John, do you want to? start? Honestly, I'd rather just let eco start. I mean, Nico posted this huge thing with a bunch of questions and I responded to it. So like it's kind of Niko's turn to talk, in the sense that I'm the most recent speaker on the thread. So maybe we can just kind of go

00:03:00.000 --> 00:03:59.999 align:start position:0%
Through and we can try to figure out. Basically just kind of talk through some of these questions and understand what we're actually talking about and make sure we're on the same page on a variety of different things and if we're not on the same page, That sounds good. Wall of text: yeah, sorry, yeah. So I guess, like, maybe I don't know- like one of the things we can talk about is actually around compliance, because I think that's actually the most important bit that is in there. Okay, I mean, like I'm, I think we, should discuss potentially changing. I mean maybe not this time around, but like you know that this is like in there's an level of expectation in terms of on the compliance front, that I think we should maybe adjust, even in classic, so that we can

00:04:00.000 --> 00:04:59.999 align:start position:0%
Make things work for John cannon. So like the type of things I'm talking about here is that both proposals kind of suffer from the same problem. So today, if you have an asset that you issued on the seller network and you like our version, basically we only have like a couple of smart contracts basically on today, right, like we have emms and the DEX, those are like the kind of equivalent and today we track. If you have, like money or any asset locked into a contract, it's going to be recovered. Basically, when you, your authorization gets revoked. And I think this breaks completely in Jump Cannon. Because, well, that's actually not well if we don't do anything, right, like because the only thing that gets really revoked is

00:05:00.000 --> 00:05:59.999 align:start position:0%
Your trust line, like the ground of your trust line, like you lose access to your wallet. But if you parked your money in some smart contract- that is the you know, like the I know shady guy on the corner- basically there's no way to enforce anything there. So then the question is like, well, what do we do? Because if you don't do anything? In both proposals we're basically saying, well, you know, if you want to get around any kind of restrictions, just, you know, send your money to this smart contract over there. And then it's like this super mixer or something. And then, like you can, you can't reasonably have enforcement, so maybe we can start with that. Like we can say, well, that's okay, that's the new reality, new reality. And then my, then I would argue that we should just stop doing what we are

00:06:00.000 --> 00:06:59.999 align:start position:0%
Doing in classic like, or at least say that we are going to stop doing, you know, recover basically like assets from pools or from our other DEX, like, if you know, because that's actually a lot of the overhead that we have today in classic. So I'll start with that, like I don't know what people think, so I can just start with saying what, how. I responded to your question to the same question from the email thread, which was basically like: this does work in CAP 48 and CAP 49. You just might not like the way it works but, like, all the compliance controls that exist on classic still exist. They just don't extend to all the contracts by default. So you might recall- Nico would definitely recall, because we spoke about it a lot when we were doing the liquidity pools- that we had this discussion about whether we should go back and make people, you know, revoke trust on, revoke authorization on every single liquidity

00:07:00.000 --> 00:07:59.999 align:start position:0%
Pool individually or do the whole thing globally and basically, like usability for issuers run out what one out over? Like simplicity of protocol design and we ended up making it so that, like, basically you revoke and it just gets everything automatically. But both CAP 40 and CAP 49 just revert back to the hey you have to go and manually chase everything down mode, which is the only mode that is sensible in smart contract land, like there's. The only possible moods are you have to go and chase everything down yourself or you can do nothing. But they're the third mode of it, Does it all automatically- is not a feasible solution here. But basically, the way that you would deal with this in the cap- let's talk about the CAP 48 or CAP 49 world, doesn't really matter for the sake of argument. So let's just say in CAP 48, the way you would do this is like hey, like, suppose that I want to evade authorization stuff and so I send my money to some random contract.

00:08:00.000 --> 00:08:59.999 align:start position:0%
Well, you look off chain and you say okay, like where is this guy been sending his money? Oh, he sent his money to this contract, frees that address and the issuer just goes through and kind of freezes everywhere where I'm sending money until they get all their money back. So basically, like your actions contaminate all the downstream systems and that works fine because at the end of the day, in CAP 48 all the money is stored. Like when money is held by a contract, it's living in a trust line and so you can just use the normal authorization techniques on it. Or in the CAP 49 world there's like the interoperability layer has authorization, and you can do the exact same thing. You just do it at the contract layer instead of at the inter, at the trustline layer, so you can do this. It's just kind of annoying, but it's not just nothing

00:09:00.000 --> 00:09:59.999 align:start position:0%
So well. So the thing is that you can actually design better protocols that you want, like those smart contracts, firm compliance. You should design a compliance protocol that actually allows to do something a little better than that because, like this situation that you're like describing here- I mean it's like you're shutting down the bank because there's like one guy that you know that doesn't behave and that doesn't sound like. I mean I don't think you can like. I know I like the smart contract is the bank. Right, like it's kind of like that it's an automated thing that holds assets on behalf of a bunch of people. I don't think you can generally do better than that, the reason being: contracts are mutable and so like. Suppose that I have some contract and I claim to comply with your. You know your compliance protocol. Right, meaning like the you know it's a contract. It can hold acid a and acid b and they claim to control to comply with

00:10:00.000 --> 00:10:59.999 align:start position:0%
Both. Acid as an asset. B is compliance protocol, and then at some point they decided, like you know, we don't want to do that and they just redeploy without the compliance controls and now that money is unrecoverable, so like, the only thing the only recourse the issuer would have against that would be to go and freeze up the bank anyway. So like, yes, you can design a protocol that has better properties than that. But the fact is that in a world with anything being mutable, you can't really like, you can't avoid the need to fall back on that, of course, as a fallback. I see that is, you know, reasonable, but if that's the only option, it's not the only option in the world. You can design whatever you want, right, but like in the context of classic assets that are authorized, if you are saying that the def, this kind of default world that we are, that they know they had like a bunch of comments on like, are we

00:11:00.000 --> 00:11:59.999 align:start position:0%
Forcing people to be opted into this new thing that doesn't fit the expectation from people. I mean the basically like: if we don't opt people in, we'll end up in a world where everything is useless because people don't opt in. Like in a world where we can't like, where we can't assume that people will do anything, and that is the world we should assume we live in. Then basically all the work we've been doing for the last seven years could be a total waste. You know, like all the anchors we've onboard and stuff, if we can't get them to take the actions that would be required, it's just like: hey, we just threw it all out. Ideally, everything just works automatically and we do the same thing. And if you want to do something better than the same thing, then that's when you have to take action and that's the world I would expect. Like, for example, if you don't want this default behavior, hey, there's an easy solution to that: set your asset to auth required and then nobody will be able to send money into the smart contract side of it,

00:12:00.000 --> 00:12:59.999 align:start position:0%
And then all you have to do is just, deploy your own wrapper and you get whatever functionality you want. But that's the action path. And since most people don't have author cards, that they don't have automatable set, they don't have author vocals, that they don't have off club backable or whatever the hell, that one is called clawback enabled or whatever this- the default behavior is what everybody is inheriting anyway all the time, right every day. I'm talking about specifically, yeah, like for the mutable stuff, I agree, We can basically kind of take the same stance that I think we've been taking with claimable balances, for example, which is you take whatever the current, the current statement of the issue is kind of what you inherit, right? No, that's not what I'm proposing at all. You're muted, oh, I don't know. Can you not hear me? I'm not muted on my side. There was nothing I can hear. I can hear him. He said: that's not what he's proposing at all. Okay, I don't know what I'm proposing is you, and can you hear me now? Yes, yeah, okay. What I'm proposing is that you inherit the current state of the

00:13:00.000 --> 00:13:59.999 align:start position:0%
Flags, whatever they are right, that's what I'm saying. Yeah, like not. Like they don't get frozen. Like if I go and change my flags, I inherit the new flags. The way that it works for, like authors, no, but like if you want to, yeah, but no number. Like, well, if you wanted to, if you were saying I'm right now, I'm not earth required and then in future I become art required, well, it's kind of too late. You're all this stuff is now out in smart and you know, out of control. Basically like, oh, you have to. You're kind of yeah, and there's a great solution to that. You know what you do. You set yourself to author required and then you go and claw back everybody's money like would you really call that a great solution? Yeah, it is a great solution. Actually, the reason I consider it a great solution is because nobody has their flag set. So this can happen to you right now anyway. Basically,

00:14:00.000 --> 00:14:59.999 align:start position:0%
Like you know, like any issuer can come and just freeze up all your assets whenever they want to and just say like, hey, like you have two options: either you are frozen forever or you accept my new terms of service and you basically do a swat, that's it. Anybody can do that at any time, and the thing I want to make happen is just have everything that works today, just working smart. That is like my number one goal, But the thing is I mean going back to this though? Like I think it kind of breaks everything. And smart, if you allow people to just kind of like, I take the example of a poo right, a trading pool. If I change the reserve in some random way, I'm breaking all the environments of that pool, correct? And so there are two solutions to that problem, both of which I actually laid out in the email I sent to you. The first one is to say like hey, like assets that aren't frozen as off immutable, can't use them. Basically, like you check in advance whether it's good to go and, if it's not good to go, you can't do it.

00:15:00.000 --> 00:15:59.999 align:start position:0%
So in this case it'd be like automutable, not off, revocable. The other option is you actually have a guard in your contract which checks that the balances are what you expect them to be. So, basically, like you track the balances internally- there's only two in a liquidity bowl, so it's not a big deal- and then, when you actually start doing work, you check like hey, like, are the balances on chain equal to the balances that I expect? If not, I know that there was an external thing frozen and that's basically like a single bad actor poisoning the bank. But in that world there's a huge incentive for the owner of the contract to go and resolve the problem, to liberate all their other users. So well then if they use the user of our contract, what do you mean? Like many of those? No, well, like. What I mean? is that in many cases, the contract like: is this thing that you want to lock and that's kind of it. There's no like operator, right? I mean like, if you want to live in a world where you're using auth required assets and you're taking

00:16:00.000 --> 00:16:59.999 align:start position:0%
Multiple people's money, you better have an operator, because those problems can't always be resolved on chain like there's. Like the standard liquidity pool token would never like design, would never let you escape that situation. But that's not the expectation in this web 3 world. Is that you want to have like a, like an mm, right? Like you don't want to have like some random operator, or like controlling the internals of the mm you might need to like if your contract is, immutable and you accept the funds and the funds can be frozen, then there's just literally no way to resolve your problems without an operator. So the solution, exactly. So that's why, like it sounds kind of broken to allow that to happen in the first place. I don't think it's broken. You should know better than to do that like the only other option is to prevent that and just say like, hey,

00:17:00.000 --> 00:17:59.999 align:start position:0%
Like these assets are useless, that's what I think we should do. So you think that USDC should be useless? It should be like, if there is no, yes, like you know, I'm like it's leslie, okay, great, that's is either you allow people to claw back or, like make random changes to your state, breaking all environments. Like you can't write software, I mean you have to know all those environs ahead of time. Right, like what can happen? What are the situations that can happen with this one asset? That I can accept? You can't. You have to kind of inherit that in every single smart contract, because you have to make the assumption that, oh yeah, somebody can mess with my- you know- trust lines or whatever. Like you know the equivalent of trust lines. That sounds kind of super weird. So let me make a couple statements here. The first statement is: like you can write software that doesn't have this

00:18:00.000 --> 00:18:59.999 align:start position:0%
Problem because you can have the guards on it. The second step: everybody needs to put the grounds, sure? The second statement is that on Ethereum, USDC is blacklistable. I I've read the contract. It is very clearly blacklistable, in fact. I believe the term that they use in the contract actually is that it inherits blacklistable, so it's right there. And the third thing is there are liquidity pools that have that functionality nonetheless. That, like you know, you can go and trade USDC in a liquidity pool. So that's an extension to esc 20. Then that is blacklistable, right? Yeah, it's just additional functionality, right. But this is like then it goes back to maybe. Like you know, we are not implementing erc20 on the network. We're actually implementing something broader than that we have to. I don't agree, like those contracts, the interface that those that like unit swap is depending on is the erc20 interface.

00:19:00.000 --> 00:19:59.999 align:start position:0%
The other stuff is just that's not true. You're saying that if, what you do, you have a new initial pool with USDC that can, like I'm pretty sure, like you take if you're attesting is true. If you, if there's a pool somewhere on Ethereum right that has USDC and USDC decides to blacklist the pool or do something crazy with it, the pool is now compromised. Basically it's done. I that could be the case, we'd have to go and review the code, but that could be the case. And then there's like potentially a cascading effect, right, like you know, people may have corrupted this as character or something like it basically has all sorts of weird things. Yeah, I think we'd have to go and confirm whether that's actually the case. But I do believe that is possible. But, like, the following statements are true: USDC is not authentable,

00:20:00.000 --> 00:20:59.999 align:start position:0%
Ustc has no flags yet set. It is unlikely we will end up in a world where USDC will set any of the flags, especially immutable, because they'd like to control their future. And specifically, like they won't set, not revocable, and we know that because their Ethereum one is revocable. So, like in this world, you basically are saying like, if we don't want to handle that, then USDC should be useless. On smart, and then I would question whether we should do this at all. I mean, I don't know, it sounds complicated to have, like the default being like this super complex thing to deal with. On the on smart side,

00:21:00.000 --> 00:21:59.999 align:start position:0%
I mean maybe, but that means that we have to expose more than just the rc20 we might be able to. I mean one thing we might be able to do, is make it so that assets are like we might be able to do the clawback inheritance thing, because it's a lot easier to deal with frozen than claw back. Frozen, yeah, destroys everything. Yeah, well, it doesn't. Again, you can put the guards in which do exactly the same thing. It's not hard, but right, but then, but it's still the same thing- like you cannot use basically any assets, useful assets, what do you mean? Sorry, you're saying that USDC has, no, is not immutable, so it is not. But if we did the clawback inheritance thing, it wouldn't really matter. You run a contract, you can check whether it has clawback enabled and you don't have to do the clawback cards. And if you try to make a payment, you'll just fail because you're blacklisted.

00:22:00.000 --> 00:22:59.999 align:start position:0%
Is there a next question we should move on to? It's definitely no. Like the thing that this conversation is really shows that it's going to be very hard for people to write smart contracts that don't break. Because if we are serious about compliance and if we don't add compliance into like the default thing that we're, or like if we don't address this beyond what 48 currently

00:23:00.000 --> 00:23:59.999 align:start position:0%
Defines theoretically, people are still going to want functionality, probably like this for some assets, and so they're gonna go and implement them- this themselves, I guess, in a contract and then are we gonna end up in the same situation. Like you know, there are people are gonna write like a liquidity pool that doesn't handle those edge cases, just like what John you were pointing out on, happens on Ethereum. But to be clear, I don't know that. That's true for a fact. I suspected it right. But I mean like we're going to end up. We probably end up with something similar where we have the basic erc20. Somebody goes and defines a blacklistable or a deny listable interface. Some people ignore that, other people code around it. It's I don't know, it doesn't really sound like we're actually avoiding the problem by not implementing it in ours. We're just we're saying like we're not going to provide that interoperability if we don't-

00:24:00.000 --> 00:24:59.999 align:start position:0%
I mean, I don't disagree with you- like if we don't provide this functionality and people require it, they will just build it. Right. So by deciding to build it or not, we're not actually changing with the weather, whether the problem exists or not. We're just saying that we're not going to support interoperability with these features of Stellar assets, right? So I think what it comes down to, I think is that it's like what I was saying, like what we need to then do is use classic assets as kind of the

00:25:00.000 --> 00:25:59.999 align:start position:0%
Testing ground for what are those additional properties that you need to expose so that everybody, from day one, basically handles those such cases. There's like basically no chance we can achieve that I want to emphasize like number, like it could be as simple as yeah, like exposing the art, like some you know something. I mean like my argument would be like there's no way to globally handle callback, at least like the only thing that's going on. I'm not saying handle club like. I'm not saying handle club like clawback, I think requires its own set of protocol, like actual api, you know, like a. When I say protocol here, I mean like you know what are, like the methods that you need to expose as a smart contract in order to support kind of a nice low friction clawback.

00:26:00.000 --> 00:26:59.999 align:start position:0%
But I don't think that would be in scope, in anytime soon. Like I think there is no, basically like we don't really support glowback in smart. I mean we don't support it as in you know, if clawback is enabled, well, first you have to know about it and then it potentially if you, if it can be enabled, you have to be able to handle the situations where it would happen. Isn't that enough? Like, as long as a contract can detect whether the assets it is interacting with is clawback enabled or sorry if the contracts trust line is callback and they would not the asset, then the contract knows whether it can take on that risk on or whether it wants to interact because, like, we have the same problem with starlight, with the payment channels.

00:27:00.000 --> 00:27:59.999 align:start position:0%
Like payment channels don't work or payment channels are not as safe if the assets can just be clawed back out of the payment channel, like undefined. You end up in undefined behavior and you know when we worked on that we said: well, that's the risk you take if you do multi asset channels like you just need to work with the issuer. So are we saying this is a problem just because we expect people to write immutable contracts where there's no issue that you can go to? Like there's no one you can like talk to about the problem, like, is that the distinction? I mean, I think maybe, like it would help to have like some concrete, super concrete examples on the cable, because I mean I think what's weird is that there's, like there's, even without clawback enabled, there's, of course, the ultimate clawback, which is that someone could say: we're not going to honor this asset and we're going to issue some new asset because something went horribly wrong, right, so you could always just make the issue, can always

00:28:00.000 --> 00:28:59.999 align:start position:0%
Make the token useless. So I think that we're worried about this like this. I mean it's not maybe not improbable, but it's this kind of weird situation where someone kind of does something that is kind of changes the rules, but such that we don't believe that the asset is worthless anymore, but now we no longer know whom it belongs to it. Some somehow like broken the attribution of who owns the asset, right, like this is what we're worried about. Like if the asset were worthless, okay, fine, that was the risk we took, But if, like, that is still worth something. But maybe there's a contract with two units of a and two people who are allowed to claim it and suddenly you've clawed back one and now the semantic says whoever gets their first gets to claim their and the other person doesn't. And we think that's unfair or like otherwise. Could you just like paint some of these like scenarios that we're concerned about, like concretely what it might look like? I mean, I think one concrete scenario would be like you have a liquidity pool that's pegged with, like that, between two usd,

00:29:00.000 --> 00:29:59.999 align:start position:0%
Like fully collateralized, stablecoins, call them usdt and ustc. And let's pretend, for the sake of argument, whether it's true or not, that usdt is in fact really actually truly collateralized. I'm not making a statement whether it is or isn't in this context. So let's pretend, how about you and usd? Sure, great usdi and usdb, and we'll just pretend we know which one's which. But and basically, like you have this pool and let's say it's got like 100 million usda and 100 million usdb, plus or minus epsilon on both sides, because maybe the price is actually like 99 cents or 99 9 cents or whatever, who cares. And then the issuer of usdb is like: oh, actually that was like osama bin laden, my bad. And gets a call from the us government and like: revokes 25 million dollars. And now the pool- and I'm sorry, I said revoked, I mean clause back 25 million dollars- and now the pool is kind of in this like super bowl state.

00:30:00.000 --> 00:30:59.999 align:start position:0%
Well, actually, well, presumably what happened is immediately arbitragers would get in there and suck out a bunch of destroyed, meaning sucked out to arbitrage, and that's kind of bad. Your only defense against this: or you could either say like hey, like I checked that this asset was clawbackable and like that's a risk you took by putting money into this pool, or you can put. You can say like hey, like you can't make a pool if it's cloud backable or you can have a guard that checks whether the balances are still what those contracts thought. Let's, can we step back from mechanism a second and say, like what is it suppose that, like what we can do is between any two transactions? We can do whatever we want, right? So like, pretend we're god for a second and luke what is the ideal response to this? Look like so, first of all, it seems a little. Is it the terrorists who have actually invested in the liquidity pool?

00:31:00.000 --> 00:31:59.999 align:start position:0%
So it's like what you would really want to do is sort of like revoke the assets in proportion. You'd want to kind of like revoke some. The us government can only, you know, let's say, revoke usda, not usdb. So what you should do is like you should like freeze in proportion to what's been clawed back, so that you keep the proportion of assets the same right. And ultimately, the right thing to do is that the terrorists are not allowed to withdraw their money from liquidity pool and everybody else it kind of is business as usual, right, I think that's what. Yeah, that's what you're doing. The current product, you know in our classic protocol today, yeah, exactly which one we have to withdraw, like, we first withdraw, like the pull shares for that individual. But I don't know if we want to replicate that behavior. Okay, so can we first figure out what we would want in an ideal world and then figure out what, whether there are sensible mechanisms that could achieve it. Well, what's your definition of what you want? That's what I'm trying to figure out.

00:32:00.000 --> 00:32:59.999 align:start position:0%
I mean like you know. No, I mean like. what's even like? I guess maybe that's what you're asking. Like, what is even a desirable aspect of this? Exactly like, I guess. Let me describe to you what I would consider like the most ideal possible world. would probably be that every contract like: imagine you actually care about clawback. I don't know if we do, who cares? But let's pretend so, focusing on clawback, like the most ideal possible world would probably be that every contract implements a like issuer clawback function and basically, like the issuer's the only one who can call that. Whatever you want the issuer to be- I'm talking about native, like classic assets- and the issuer's first point of call is to call that admin function when it wants to do something. And if it does that, the contract hopefully does the right thing. And if the contract doesn't provide that functionality or doesn't do the right thing, then the issuer just takes whatever action is necessary in order for them to comply,

00:33:00.000 --> 00:33:59.999 align:start position:0%
Whatever that means, and damn all who suffer. That's probably like the best possible world you could achieve. So like, let's say that that's what we wanted to happen, okay, so actually, before I continue, does anybody have a better world? Okay, so basically, we're adding a new method that, like, you're required to implement, or maybe there's a default value, but like the sensible way to implement it is that you know you do whatever should happen, but like, basically, your contract gets to react every time funds are clawed back. No, that's not what I'm saying, oh, sorry, no, I guess. Where is this function defined? Is it defined on the contract that owns the asset or is it defined on every contract that holds an asset? I guess, yeah, every country could be the whole. It has

00:34:00.000 --> 00:34:59.999 align:start position:0%
To be the contract that holds the asset. Like the pool has to implement that thing. Yeah, so the question is: we could do this. And so the question is like: is there a sensible default, like do we force everybody to implement this? Or like you know, but then that's like a barrier to like deploying your smart contract because I just like write more code, or is there some kind of default? Like the default is frozen until it gets upgraded or something, or I don't know. Like I think the default should be. you can- opt out basically of this whole thing. Like you can basically say I don't want to deal with assets that have those type of properties because it's you know, I see. So, if you haven't implemented this function, then you just can't hold certain assets that are: no, I totally don't think this makes any sense because I can implement this function and just assert- that could be my whole implementation. That's what I mean. So assert basically says: freeze the smart contract until- and you know, as soon as any funds have been called back from it.

00:35:00.000 --> 00:35:59.999 align:start position:0%
I'm sorry I cut off late. Yeah, so he's put his contract. Yeah, I guess no, like I think David is probably right, you don't want to kind of have like the like in the case of a pool, right, you probably don't want to have like an arbitrary amount taken under your feet because this breaks all your environs. Instead, you want to just like what. You want that to happen and probably, in addition, the contract gets completely stopped. The default, I'm talking about the default. Yeah, so the default is that it should stop the contract, but also it should grant someone permission to upgrade the contract or something, right, I mean, you know, I mean like, basically what we need is like human intervention, right, like we did this thing assuming that these dollars were fine, and suddenly, like, the rules have completely changed. So of

00:36:00.000 --> 00:36:59.999 align:start position:0%
Course, we could just lock all the assets in perpetuity, or we could, like you know, figure out some way to, like you know, arbitrate the situation, you know, which might require human judgment, because this wasn't something we just put, like a- yeah, like 20 digits proof of work, you know, unlock code on it. So I want to go back to something that you said, David, like, oh, like what you know, if you don't define this function, then you know you don't support these type of assets. I think like we're talking about two different things here. Like there's contracts deciding if they want to use an asset, and they can do that if we provide a way for them just to read their own trust line. Like, does my trust line have clawback enabled? Simple function, simple flag. No, but I'm saying like, if a contract has any trust line that gets clawed back, then there has to be a. Then there's a function to kind of deal with that. There's like a car? Yes, so I think what we're talking about is hooks, or

00:37:00.000 --> 00:37:59.999 align:start position:0%
The idea of to hook into an event. That's happening, rather than having a function that does the thing that needs to happen. We just want, like a function that notifies the contract. This is happening, whether you like it or not, because you decided to hold a claw backable asset. So, like once you hold it, you can't get out of this happening, and then you just get told when it happens. So contracts don't have to provide that function. If they don't care that it happens, it'll just happen and the consequences will just be whatever they are. But if you care about it and you want to mutate your internal state, maybe, or update something, then you have the option to do that. But I guess what we're anticipating is that there are a bunch of situations where people write contracts without any possible idea, like they just can't imagine that USDC would ever like try to claw back their asset and yet, you know, two years later, USDC like sets the claw backable- whatever

00:38:00.000 --> 00:38:59.999 align:start position:0%
It's called clawback enabled flag on their account and actually like claws something back right, and so, basically that though, like so clawback is designed so that once you hold, once you have a truss line, you can't get enabled. So I mean, we've already designed around that. I think I think the other thing we can do is, you know, we can make the SDK or however you're interacting, you're writing contracts, so that when the account, when the contract, says I'm willing to hold an asset- I'm assuming that we're going to have some way of saying that, like on Stellar, like on classic, you have to explicitly say that you're going to allow the outside to be clawbackable. And then, you know, maybe that call fails if you just haven't passed that flag in, if the asset is clawbackable like so then, coming back, I think, John, like your example then is not so scary, because in your example, either usda or usdb already had to be have clawback enabled, right. So is there some other example that's more scary? So actually, just to be clear,

00:39:00.000 --> 00:39:59.999 align:start position:0%
The proposal. I wrote the like it was actually based off of the current flag, so like things could become claw backable later- we don't have to do it like that, but they can't become callbackable later for an existing trust line. Well, that's how it's. That's how like the current stuff works. That's not what my proposal specified, at least not CAP 49, CAP 48, I guess does work like that kind of default. It doesn't have to be like that. We could make it all work like this, just a little extra complexity to deal with some stuff. But it might save complexity somewhere else. But the thing that I'm like skeptical about here is like the notion of a callback here. Like you probably don't want to do callbacks. Callback, it could be that like the contract is stuck until someone calls the un the cleanup clawback method or something. But my argument would really be like to implement this the whole opposite way,

00:40:00.000 --> 00:40:59.999 align:start position:0%
Which is basically like hey, like we have a strong recommendation for you to implement this function and if you implement it, we encourage issuers to use it. There is no promise that they will because at the end of the day, like if the issuer needs to do something unilaterally, they should be able to, and since then, sure, but why should this be up to the issuers, like the? I guess what I'm saying is like the invocation should be a result of something happening on classic, not of the issue or doing some kind of smart contract thing. No, it definitely has to be a smart contractor thing. First of all, because definitely should not be the issuer not paying gas to clean up other people's smart contracts who did not like anticipate something being well, that raises a problem. Then, because, like, if I ride my hook, my callback to use, like some obscene amount of gas, like who's going to pay for that, what? That's the point. Like somebody who

00:41:00.000 --> 00:41:59.999 align:start position:0%
Cares about that contract, what? No, oh well, you're saying if it's called at a different time, I mean at the end of the day, like the callback could always fail, right, even if you implement it and you think it won't fail, it could still. Like, for example, like consider, like a usda usdb liquidity pool, right, what does a clawback on Stellar do. Well, it returns both assets. Well, what if the other asset you were already frozen? Well then, the operation would fail. And so they look like at the end of the day, like there has to be the support for a unilateral clawback anyway, and the contract has to handle that. And so, like, in the world where there is a unilateral clawback, we might as well just say that the contract should supply a function and the issuer should call it. But you have to deal with it if they don't. Anyway, if anybody can call this function, is that like can anybody call a function?

00:42:00.000 --> 00:42:59.999 align:start position:0%
I would say that it would have. It should, have a guard on the issuer type of thing, So basically, it should check like hey, like is the person who can call this, the person who can call it. I mean, presumably what it should do. Like the function should like, examine all the trust lines and, if they're all in the expected state, not do anything and otherwise clean up the mass. Yeah, I feel like what we're describing is like some general function, like we're actually just going, a more general function that just is. Something might be wrong. Go check your state, yeah, figure it out if it's not. And like we're not actually talking about callbacks specifically, we're more talking about how to get a contract unstuck that gets in a bad state. That's not really talking. Sure, yeah, that's way harder to try. Like there's only one. If you're in a generically borked state, there's only one solution: human intervention. That's the only possible solution if you're generically borked. Because in what way are you borked? Well, only a human can determine that unless you've written a program that can analyze the state of all, the program of

00:43:00.000 --> 00:43:59.999 align:start position:0%
Like all the possible states that you're in. And since, like that sounds generally hard and like generally not feasible in a gas like research constrained world, there's like no hope of that. So, okay, so the distinction of the function you're talking about is that because only the issuer could call this, because there's a guard for that, me writing a contract. I can trust the issue. We'll only call this if they are in fact doing this thing. I'm very clearly saying like there's no protocol specifications here at all. The only thing I'm saying is like it is a recommendation to people who write contracts that they should provide a function that implements clawback if they would like to hold callbackable assets right. But as the contract author, I need to be thinking about where my trust lies. So if this function is going to mutate the internal state of my contract, I I've got to be trusting the issuer to only call it when this is actually happening. I don't necessarily know what you mean- like the function should be implemented

00:44:00.000 --> 00:44:59.999 align:start position:0%
In such a way that it leave like it. Like leaves your contract in a same state. So like if you want it to only be callable by the issuer- which would be the same thing to do- you should check that, but you don't have to check that. In theory, you could let anybody close out on your contract. It just sucks. You do not want to be called by the issuer, right? The issuer is not, in general, going to know about every smart contract using their asset. Well, you want to be. callable by anyone, but only do anything if, like, something unexpected is happening in the state of your trust lines. Right? So you want like a, basically. You want basically a like a board on board check. That's at the beginning of most of your methods, right? And then you want to clean up the mess method that, like, anybody can call to, like, clean up the thing that's causing all the other methods to, I think John's function. The issuer is clawing back from the contracts account and so the issue knows about the contract, in this case because they're clawing it back. So that's why they know to call that function on

00:45:00.000 --> 00:45:59.999 align:start position:0%
The contract. And I mean, clearly, why did they care? Like that's not, like maybe the issuer only does classic, you know. Like does USDC care about smart contracts? Like they're there to provide an asset that has a well defined you know, redemption path, and like that's fine. They're not here to like parse people's smart contracts and spend a bunch of gas doing whatever right. So I feel like what we need to do is just have a way for a people who care about a smart contract to clean up the mess when the smart contracts assumptions about assets are no longer correct or about trust lines, which, in theory, where you know, we've been talking about mutable contracts, so like, even if a contract is in the worst possible state, somebody can upload a new version of that contract to fix it. Only if somebody can actually do so. Right. But, like, Nico protested

00:46:00.000 --> 00:46:59.999 align:start position:0%
Against my notion that these contracts would even be mutable. If they're mutable, there's no problem. Like in the world where the contracts are immutable and somebody actually has the authority to mute them, mutate them, whether that is like an issue, like not an issue, sorry- an organization, an entity or a person, there's no problem. The accounts get frozen or the accounts get called back. The issuer- just, you know, the owner of that contract- just calls up the issuer of the asset and says like hey, like, how do we fix this problem? Oh, this is how we need to mutate the state. Cool, I'll write the function to do that. I mean one can imagine, you know, wanting to set up a contract that you can only change when it gets worked, or something like you know, maybe there's value for like yes, if suddenly, like uscc gets called back, then I get the ability to upgrade this contract, but usually I don't want this ability because, like you know, the contract should be its own logic. That would be easy to write, though. You could write that contract. That's not hard, you can do that without any magic at all. So

00:47:00.000 --> 00:47:59.999 align:start position:0%
I don't know, I feel like we're not. all talking about the same thing here, and I think that's why we're not agreeing on stuff like: what kind of clawbacks? Are there other like types of edge case or edge cases that this would apply to? Or is that, or is it just the club like sorry, classic clawbacks, a clawback enabled asset that gets the trip that invokes clawback, classic clawback, right? Are there other state changes that could happen on classic that would lead to this situation. Or is this limited to clawbacks? I mean, like getting frozen would be not as complicated but equally bad. So an auth required token where you deauthorize the trust line. So there are the other auth flags. Because it's also like can we just say hey, no, clawback enabled assets in smart contracts can't use them

00:48:00.000 --> 00:48:59.999 align:start position:0%
Maybe. I mean, like here's a way that you could implement this if we wanted that. Basically, like you can only create a in the CAP 48. You can only create a in the CAP 48 world. You can only create a trust line for a smart contract to an asset that is already going. Basically, like that operation of creating the trust line would fail if you would end up with the clawback enabled flag on your trustline and then you just never end up in this world. Yeah, I think we should just make it like a choice. You know you call trust trustline with no options and that's the case. It just fails if it's callback enabled or there's like an additional flag or option you can pass. That just says like I'm willing to go the potentially unsafe route of having a trust line that's called like

00:49:00.000 --> 00:49:59.999 align:start position:0%
Enabled, and then at least it's surfaced to the developer like it's in their face. It's the same thing that we're talking about with re entry yeah, the surface, so they know about it. Dave David, on the context of the cleanup method, I think the big issue with the cleanup method is, like there are worlds that you can enter where you don't know how to clean up, like you don't necessarily know what like suppose that an issue or claws back from your contract. Do you know why they did that? So how do you fix the state of your contract? Well, I'm thinking, like what the cleanup method could do is it could like add a signing key to, or somehow like enable the author of the contract to upgrade it, for example, or like it goes in safe mode or something, and then unlock some like a maintenance. I think that's one of the like patterns that some smart contracts have already, like you have, like even the ones that have like a dial, like you have. You know, you can basically go into this

00:50:00.000 --> 00:50:59.999 align:start position:0%
Maintenance mode. It just takes like a week or something, like it's not instant. There was a bug a few months ago, actually on a I think a bridge protocol or something, where it was not a week, it was like a second instead. But yeah, I just I don't know Personally, I just feel like we're making this really complicated, like at the end of the day. I feel like usability should be front of mind for developers and like, if we make this complicated, nobody's going to use it and then we failed, right? So can I say? the question is so the point, but so the only we would need to have a default for this method, right? So like we're not saying like everybody has to implement a method, but like basically, the problem is that, like people are going to make assumptions about trust lines and every once in a while, these assumptions may like

00:51:00.000 --> 00:51:59.999 align:start position:0%
Break, you know, like a way that would cause like really weird, like you know, unspecified behavior of the smart contract. And so should we have some default thing where, like, by default, the contract like enters maintenance mode or whatever, when these assumptions are broken? I mean that assumes that we, like we impose a maintenance mode onto the entire world, and I just don't think we should like, if you want that behavior- well, you said assert- what happens when an assert fails, like, are you seriously thinking about having an assert? Well, what I meant about in a search was like I was actually giving you a pathological case of where what you were proposing wouldn't work for the cleanup. Oh, it's just, it just asserts and fails. It says nothing, you cannot do it. It's like: oh what, what's good? Did that? Do you? Right, like anybody can like that, I for an assert to have an asset. You also need to write that condition in the first place. Right, like no, I'm saying that's not. Like a false, that's no. I see yeah,

00:52:00.000 --> 00:52:59.999 align:start position:0%
That's no. I see yeah, number like even no, but like I was even thinking for, like you know, even if you have like all the defaults and all that stuff, like you have to write your environs in a way so that you can handle, you can know basically that you are blocked, and that sounds kind of not workable. Well, I mean, I guess you know to. My proposal would basically be that anytime a third party like forcibly does something to one of your trust lines, you get in a state where someone has to call this cleanup function. If you haven't implemented the cleanup function, then like nothing can happen to your contract. That just sounds undesirable to me. But maybe your contract sounds pretty undesirable too, which is that like whoever first, like, which is like a bunch of arbitragers go in and suck out like all the money that's there by accident. No, my proposal is just that, like, if you're a contract developer, you should handle it, figure out what you're saying, you can But how do we know people are going to

00:53:00.000 --> 00:53:59.999 align:start position:0%
Do this right? We don't. And if they don't then they're then like it's the same thing as any other smartphone. So when they don't, do we want, like people to lose money to arbitragers or do we want, like the contract, to freeze? And people have to like debate, how to clean up the mess? What if it can't be cleaned up? Like what if there's nobody who owns the contract? That was the case that Nico was talking about. If nobody owns the contract, nobody can clean it up, and now the money's just locked up forever. Well then, maybe the default implementation of this function is that it like hands signing authority back to whichever account. Like created this market. What if they don't have a key anymore? Yeah, then everybody loses their money. Well, that's the world that Niko was talking about, with the contract being immutable. Like, again, if the contract is mutable, there's just not really a problem here. Well, it is a problem if everybody loses their money. No, in the world where the contracts are mutable and people can actually perform the mutation- I mean there's not really a problem because people can just come through and clean up the mess. No, sorry, they can't clean up the mess

00:54:00.000 --> 00:54:59.999 align:start position:0%
If arbitragers have sucked out a bunch of money. That's why you should handle the guarding conditions that you need, if you do need them well. I feel like we're out of time for this discussion right here in person today, but it seems like there's a lot. I mean, I think we just got to keep working async on the dev discussion mailing list and on the Discord and reconvene here next week. I don't know. I don't know what the next steps are, though I mean like the thing I wanted to say is like I think for the first phase of this, I think I would do what's kind of what lee was saying, which is like we don't support global assets, right, like if you have to have on your trust line. Basically, this for cla, for those classic things I'm talking about for the first version, you can't, even you can't do anything right, and then you can deploy a contract, basically that uses that and then,

00:55:00.000 --> 00:55:59.999 align:start position:0%
In parallel or later, we can figure out this global. Like how can we make clawback work in smart world and then retrofit this to classic? I think the main lines of work should be. The first. One should be: like: let's go and figure out what happens with these kinds of contracts on Ethereum. Like these problems exist. People are doing something. That's why they don't though. Right, because the one thing that's different here is that there's this: the classic world is going to kind of reach in and mess with the smart contract world in a way that can't happen in Ethereum. That's not true. Like I literally told you that USDC has an auth revoke function. It has revoked, like so it has. Yeah, you can revoke. I don't know if they have. Do they have a clawback? I don't think so, because that would be a. That's the one that really breaks everything. I mean they both break everything, but clawback something more. See you next week. Bye,

00:56:00.000 --> 00:56:59.999 align:start position:0%
David, I see you next week, What people are doing, yeah, and how they're handling it, and then we should resume this. But again, like I'm like, I think it's a favor of keeping it simple. I know that there's like the theoretical possibilities in edge cases, but I think it's also worth pointing out that I don't know that there are any active clawback enabled assets on in classic right now. Just fyi, I agree with that. Yeah, all right, see everybody next week.
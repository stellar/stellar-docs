WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:59.999 align:start position:0%
All righty. Welcome to another episode of engineering talks. My name is Tyler van der Hooven and I'm gonna be talking today about a preset proposal for turing complete smart contracts for Stellar. Precept simply means that this is just some work that I've been doing on a Stellar ecosystem proposal around this idea of turing complete contracts and we're going to talk a lot about that today. Obviously, that's what the talk is all about, but it's important to kind of reset your thinking a little bit. We all have an idea of what turing complete or smart contracts means. I'm gonna try and come into this without too much baggage and explain what I mean a bit along the way, and I'm going to be using

00:01:00.000 --> 00:01:59.999 align:start position:0%
Aetherium as our comparison project, because most of us, when we think of smart contracts, have etherium in mind. So this is not necessarily a competition against etherium. It's simply a comparison of features that, if this SEP were accepted and used, how would you? How you would accomplish similar sorts of things that you could on etherium on Stellar, and comparing the functionalities and features that aetherium offers with what this Turing signing server SEP would allow you to accomplish on Stellar. So let's dive in. Today's gonna be a bit technical. We're gonna go through Trent, blazed through these slides pretty quick and then get into some examples and encode, but it will be a little bit longer probably than we're used to for these engineering talks. To stick with me, it is quite interesting, super excited. I've spent a lot of time thinking and working on this problem myself as something that I very much need in my own development

00:02:00.000 --> 00:02:59.999 align:start position:0%
And I think would really benefit the Stellar community at large. All right, so the problem is, if the room has market dominance in an arena we're better suited to serve, namely Finance, so we have assets and the ability to have assets as first class citizens where there in an account. But often times financial architecture will be built in aetherium in instances where oftentimes it would be better to have that built in Stellar's, it's going to be faster, cheaper and you're going to have this capabilities and functionalities that are native in aetherium and you'll have to kind of custom build that yourself, whereas in Stellar they will often be built in kind of at the base layer. So our solution ears to appeal to aetherium developers by bringing functional feature parity and that's a key phrase here: functional feature parity. This isn't feature parity, it's functional. So what you can accomplish in etherium trying to allow that same type of

00:03:00.000 --> 00:03:59.999 align:start position:0%
Functionality in Stellar, in the financial arena, and so the solution there for me, the product there for me, I guess, is smart contracts. Now we have a concept of smart contracts and seller. It's kind of using operations and this nature of Stellar transactions you can accomplish a lot of different things atomically inside of a transaction. So you can have lots of different operations that open things up and close things off all within the same transaction. You don't have to do a bunch of individual things and then who knows what's going to happen inside, because lots of things can happen in a single ledger. You can accomplish a lot of very intelligent, smart things and by using things like time bounds or pre assigned transactions you can get away with a lot of, I would say, complex big business logic and we've sort of slapped some our contracts on to that. But in no way is that what most of the world thinks of- at least most of the blockchain world thinks of- when they think of smart contracts as a concept- is very different than what we tend to

00:04:00.000 --> 00:04:59.999 align:start position:0%
Talk about when we talk about Stellar smart contracts today. So we're gonna be moving away from what most of us think of when we think of Stellar smart contracts and moving much closer to what aetherium means when it says smart contracts. So my definition is a smart contract as the ecosystem understands it. So, regardless of what wikipedia says, the smart contract is the way that smart contract- the word phrase is used- as the ecosystem at large, the blockchain ecosystem, understands. It is an arbitrary turing complete program. It's in complete programming, executed on a decentralized network for the purpose of minimizing trust. So you have this idea of a program that has arbitrary programming, that does who knows what, that accomplishes some sort of goal, and that goal is better accomplished when it's trust minimized or there isn't a lot of third party trust involved, or it's decentralized. And this is

00:05:00.000 --> 00:05:59.999 align:start position:0%
Important to kind of for all of us to agree- even if you don't necessarily agree with me on this- that this is where I'm coming from when I talk about the smart contracts that I'm envisioning through this SEP that I'm building, is this idea of trust: minimize, minimizing trust, so there will still be trust involved. There's always trust involved. It's just who and how much and what are those parties that you're trusting, and then arbitrator and complete programming: the ability to do kind of any sort of logic that you need to create some sort of output. Instead, you don't have that. Stellar is not turing complete that allows it to be very fast and flexible in scale very quickly, whereas an aetherium- those things are bundled together where you have what we'll get to in a minute: the idea of transaction creation and execution. So what does that really mean? Was this ecosystem doing with smart contracts? There are two things when it comes to financial smart

00:06:00.000 --> 00:06:59.999 align:start position:0%
Contracts: there's transaction creation and transaction execution. So building blockchain mutations. Basically, these are the instructions for how I want to change the existing state of the ledger or blockchain by adding another block, and then also the transaction execution, which takes those instructions, takes those mutations and actually runs them to perform the changes. So you have the instructions and the execution, the creation in the execution. So we have that right in Stellar and a theorem, you can both create transactions and execute transactions both in Stellar and aetherium. So what's the big deal? How is what's the problem? Well, the problem is decentralization. In Stellar there is no decentralized transaction. Create atheria m--. There is because in the virtual machines that run aetherium- those are run all over the world, anybody that's running an ethereal node and participating in the consensus- the

00:07:00.000 --> 00:07:59.999 align:start position:0%
Transaction creation and execution both happen in that process of arriving at consensus, whereas in Stellar only the execution of the transaction, the creation of that transaction, happens outside of the execution. So you sort of give it very detailed in permissible instructions and then send it to the consensus protocol to actually execute that. In aetherium you send a very minimum information and then both the creation and execution- because assets are not first class citizens, you can build a whole program that will handle the kind of input that anybody might send it and then the ledger for your particular smart contract will be updated. So both of those things happen the same time. It would be one of the reasons that if your iam is built the way that it is and why some of the reasons or ways that it differs from something like Stellar, which what I'm going to get into that too deeply and I honestly don't understand it perfectly. But with my new, this set proposal that I've been working on, we're gonna look at

00:08:00.000 --> 00:08:59.999 align:start position:0%
Today, we're looking at adding decentralized transaction creation so smart contracts do not execute. This is really important. It very something is very different than aetherium. All that on adding or proposing that we add through this step is transact, decentralized transaction creation, which we will then tag on to the existing architecture we already have within Stellar, the decentralized transaction execution which would give us through this, what I'm tagging is SEP acts. if we add seller and this new sub X together, we get feature, functional feature parity with aetherium, where we have decentralized transaction creation and decentralized transaction execution, which would be amazing and we'll get to why- hopefully- maybe some of your wheels are starting to turn on- what decentralized transaction creation would allow us to do some of the things that it would allow us to accomplish, which we cannot do now, but we'll get into that. So essentially, sub X is Turing signing servers, decentralized turing complete

00:09:00.000 --> 00:09:59.999 align:start position:0%
Trying action creation. So a few weeks ago we had a engineering talk on Sept 30, which is the key recovery servers, and we have Federation servers as well. So we have this concept within solar ecosystem proposals of external servers or services which run to provide sort of additional logic or additional functionality, common additional functionality across the ecosystem, and so this would be an additional server that would be running, the individuals or enterprises would run, which would allow this decentralized, turing complete transaction creation where you have these multiple parties running, something which will accomplish some goal in a decentralized way. So still, the smart contracts via sip X have three entities: they have users, contract creators and Turing server. So some of these may be

00:10:00.000 --> 00:10:59.999 align:start position:0%
Blurred at times the line between the two, but they are distinct in the sense that regardless of whether they end up being the same entity or individual, they will be serving three separate purposes. So users submit transactions for final execution, the final there, the final interested party. They have something that they want to accomplish, and they interface with touring servers, but it's typically transacting through a contract, not the Turing server. So they'll be contracts that users interact with and those contracts are hosted on the Turing servers. So I will interact with a contract which is hosted on multiple turing servers, and then there are contract creators, obviously, who create the contracts and either provide services or just innocuous features. So we'll get to some of those in a minute. But a contract creator doesn't necessarily have to be some sort of service provider. They can just build a contract that anyone can implement and

00:11:00.000 --> 00:11:59.999 align:start position:0%
Use to provide some additional decentralized functionality, and so I have a diagram here which is 100% useless, so we are going to break that down. User wants to interact with a contract creator for the service right there providing save users and contract creators. We have this concept already today, where you have some third party that you're wanting to interact with your Stellar address, whether you're making a payment or you want to provide some sort of functionality of the service providers offering, and you have a very one to one relationship. You send instructions or requests, you interact with their UI and they send you back responses, whether that sign this transaction or add this trust line or whatever that interaction might be. It's very much one to one and this is where some of the issues are going to arrive. This is unacceptable as a requirement. Oftentimes this will be fine, but I think it's not the right thing to say. This is the way it has to be right. So it's

00:12:00.000 --> 00:12:59.999 align:start position:0%
Unacceptable as a requirement as it leaves the user trusting a single entity and a contract creator liable for a high level of responsibility and involvement and ultimately it's not decentralized. You could add more servers, but ultimately the contract creator is controlling all of those servers and decentralization, like at its core, is mitigating trust or taking that trust and splitting it amongst multiple parties so that no one entity controls everything. We split that up to where there's a level of trust, because no one entity is the single trusted entity, and so we are getting to that diagram I showed a little bit before we get. We introduced- if they're disinterested but incentivized- third party service, the Turing signing server, which will act as a permission request arbitrator between users and contract creators. To the server we upload a strict, specific turing complete program or smart contract which will create transactions. They don't execute, they create transactions. So the contract creator will build a program which will create

00:13:00.000 --> 00:13:59.999 align:start position:0%
Outputs. It's basically just in this. In my case it's going to be a lambda function, but ultimately it's just an API endpoint which, when called, takes an input and then outputs a valid transaction. Stellar transaction and then the Turing signing server, as you can see here, stores contracts and holds keys, and those keys are seller keys which sign for the transaction that the contract generates, and in Stellar we have this concept. The reason this works or is valuable is because in Stellar we have the concept of multi sig where you've got multiple signers which can be added to accounts and can sign for any transaction that's being originating or originates from that account. So if I want to make a payment, I can sign with my key, or I can sign with somebody else's key if they've been added as a signer to my account. And so as we start to, we create this contract and we

00:14:00.000 --> 00:14:59.999 align:start position:0%
Uploaded to a turing signing server. When we upload it, a signing key is sent back to us, and that signing key is what we upload to our contract. We add that signature to our contract or we gave it to our user to add to their accounts so that we can sign for some action off of their account. Now, when we have just one Turing signing server, we're going to see that doesn't get us any improvements, but it's the duplicity, the lots of Turing signing servers where we start to see the power come out. but this allows for transactions and their signatures to be generated following the strictness of a codified contract rather than the trust of a contract creator entity- and this is the big point here. That's may seem a little bit abstract, but it's really powerful because if I want to do something- let's say I want under very strict, specific circumstances- I want you to be able to use my account to pay

00:15:00.000 --> 00:15:59.999 align:start position:0%
Yourself a hundred dollars. You know, if some parameter is met, I can't ever give you my secret key, because if I give you that you can do much more than just pay yourself a hundred dollars. So how can I give you access to my account without giving you complete access to my account? It's only strict, specific, turing complete access to my account. Well, I get that through this contract creation, where I upload a contract to a Turing signing server and then you interact with that Turing signing server and, rather than you having access to the secret seed, you have access to only perfectly signed transactions from those turning signing servers. So I don't give you a secret key, I give you signed transactions through these Turing signing servers and then you can interact with the Turing signing servers rather than directly with my account. And that's kind of one example, but hopefully that starts to make sense.

00:16:00.000 --> 00:16:59.999 align:start position:0%
So the reason this becomes, or how this becomes, decentralized is we upload these contracts to lots of different Turing signing servers, so it's the same contract across lots of different Turing signing servers, and then through thresholds- right, so we're out of T signers, multi sig to accounts, but each of those can have a threshold. So I can say: to make a payment, you need a threshold of three, so I need at least a weight of three to be able to make a payment. And so when I upload all this same contract, all of these turns signing servers, they all send me back a key which I add to my account as signers, but only with a weight of one, so that no one turing signing server, not even two turing signing servers, could sign for or collude to do something with my account. You would need at least three and through thresholds, you can add any number of, I guess, up to 20 thresholds to agree very complex, secure logic to

00:17:00.000 --> 00:17:59.999 align:start position:0%
Account for whatever kind of logic you're trying to perform with your contract. But essentially you're just going to upload this to a number of turing signing servers and then, through thresholds, decide how many of those turing signing servers need to add their signature to the transaction that's being requested. And because it's the same contract, it's producing the same transaction, the same XDR, and if any one of these gets a little sneaky and tries to, you know, make a payment to themself, they would change the XDR and therefore the signature for all the other turing signing servers would be invalid. If the requests that the user is making to the turning signing servers is different than any of the others, it will be rejected, it'll be spat out because it doesn't match any of the others and the signature therefore would be invalid when it finally comes to submission time. And so now the contract creator is a nonentity they no longer really interact with. The user interacts directly with the Turing signing server. So contract

00:18:00.000 --> 00:18:59.999 align:start position:0%
Creators don't even need to, at this point, run a server. They just uploaded some arbitrary JavaScript logic or really any programming logic, language logic, to these Turing signing servers. And, so long as it's valid and producing good transactions and being used and not being nefarious, the user can interact with Turing signing servers completely separate from the contract creator, in a decentralized manner, getting transactions which follow the pattern that the contract creator allowed for because they've added their signature to it and, in this case, following our example before, the user can begin interacting and making payments to themselves for 100 so long as it follows the pattern that the contract creator allowed for. So hopefully it's starting to make sense. Turning signing servers allow for secure, decentralized transaction creation and signing through programmable contracts. So again we need to remember that Turing signing servers their goal is to create transactions, not to submit

00:19:00.000 --> 00:19:59.999 align:start position:0%
Them, so they perform the business of creating a valid signed transaction and that signing doesn't have to be- and often I would say is not- complete. It's partial signing, it's signing for some of the logic of the transaction that was performed, but there's- probably should be- some piece that's left to the user, whether that's paying the base fee, whether that's in a- you know, a vending machine example- you have to pay a hundred lumens to get a hundred of your asset back, like Ana ICO model, or some sort of token giveaway, or there's lots of different instances where you're, the user is going to be the final signer, and so the transaction that comes back is signed and it's signed enough for all the interaction that deals with the contract creators account, but there's still some piece that's left for the user account. So it's just adding signatures to a transaction, but not necessarily fully signed, although that obviously could be. Again, the business

00:20:00.000 --> 00:20:59.999 align:start position:0%
Logic appears in the contract, not in the XDR itself, not in the Stellar transaction itself, so you can create all kinds of business logic that produces a transaction. At the end of the day, that could be any sort of thing and that's kind of what we're gonna look through here now. So, again, like the motto, for this is you get what you permit. So when you start talking about, could I do this or could this be used in this case, the answer is going to long as is related to, like seller transactions and getting a payment and kind of really getting access to your account through a secure contract, like so long as that's the question, the answer is yes, because so long as you create the right permissions, it's you can allow for it. You can build for something like that amazing. The houses, compared to etherium smart contracts, will just look through this really quick. So now with this, FX would have, along with the 3m, decentralized transaction creation and

00:21:00.000 --> 00:21:59.999 align:start position:0%
Decentralized transaction execution, and then the difference here, arguably, is going to be again the safety over liveness that we have within the selection, since it's protocol, versus if you're in virtual machines anyway, where the safety aspect to the contract control is it's just creating transactions, it's not actually executing them, and so you don't have to necessarily worry about your accounts or about the safety of your account so long as you've built your contract correctly. And then the liveness aspect of it is going to come down to how well did you write your contract, is your account funded, all the things that are already limitations just within Stellar, versus the ethereal model which is, once you upload a contract, there's nothing you can do to really alter that, because both transaction creation and execution are happening at the same time. But that contract will always exist, it will always be up, unless you have some of those non decentralized back doors open. So some of the core philosophical design

00:22:00.000 --> 00:22:59.999 align:start position:0%
Differences: Stellar, smart contracts: nothing unacceptable can happen. In a favor smart contracts, nothing unexpected can happen and there's benefits on both sides. Really depends on what you're trying to build for those Stellar smart contracts, because that is just generating a transaction, the final execution is in the hands of whoever the final user is, whereas in aetherium, smart contracts, the final execution is in the hands of the contract. So you execute it, hoping that it does what you expect, whereas with a social on card track, you execute it and then it spits out a final transaction which you have a final say and whether or not you want to submit it. So, finally, the thing that we were all looking forward to, examples, and I think, yes, that is pretty much my last slide. I'm going to switch now to my browser. I'm going to open- I've got some glitch demos here. So fantastic little service here, glitch, and I'm going to open up all of these examples and then make this a

00:23:00.000 --> 00:23:59.999 align:start position:0%
Little bit bigger. So the first one I'd like to look at is a very basic kind of run of the mill vending machine example. So when we talk about smart contracts, vending machines- kind of a really good starting point where you give it an input and it gives a guaranteed output. So in this case we're running a Tyler coin trade or swap where you send in a hundred lumens and you get a hundred Tyler coin back, or it's always a one to one so if you did 50, it'd be 50 one to one so if you did 50, it'd be 50 if you'd tend to be 10. So I've got an account here. So if I can open this, I've got an account here which I am making a payment tune, and this is just a standard seller account that I've funded with friend bot. There's nothing fancy that's been added to this. There's a contract, though, that I've uploaded that says all the logic around: when a transaction come

00:24:00.000 --> 00:24:59.999 align:start position:0%
Or when a request comes in to this contract, take a hundred lumens, make a operation for taking a hundred lumens from this account and then send it ten- all right, send it ten top corner 100 for 101 to one, and so we'll give it that hundred, and then we'll generate the XDR. So let me just pop in the code for this real quick. We make that a little bigger. So this would be our vending machine smart contract. So, essentially, there's a contract that says when a request comes in and it has source and amount, we're just going to build a Stellar transaction and then spit out the xgr and that's going to be a payment for 100 lumens to me and then send back tot it going to the source account, which is the account that we add right here, and then it also adds the fee payment to the

00:25:00.000 --> 00:25:59.999 align:start position:0%
Turrets. So to the Turing signing servers. again I mentioned that they are disinterested but incentivize third parties. They have no benefit to get from collusion but they have benefit to get from collecting on fees. So if you run a Turing signing server, you can charge fees to execute these contracts as well as upload contracts. So transact servers have a business opportunity but they're just interested in the sense that they don't care what contracts are being run. So this is a very- I mean 57 lines of code plus comments. So very small little contract. But it does allow arbitrary logic and it allows me to safely say I can run an entire contract here of paying out my Tyler coin in exchange for XLM, all through just this very basic JavaScript code. So I'm going to upload this. When I upload this contract to a Turing signing server, they are going to send back a signing key because this is

00:26:00.000 --> 00:26:59.999 align:start position:0%
The account, this is the contract address that is going to be paying out Tyler coin. If we look this up in still our experts on the test net, we will see the windows condemn. When we upload it to the Turing signing servers, they send back signing keys and those signing keys are what we add to this contract to allow for these contracts to actually generate signed transactions. Because the Turing signing server is going to generate an XDR and then add a signature using whichever signing key they have for that contract. And then we have a threshold of three, like I mentioned before. So if three, so long as three addresses sign off on this, any transactions coming from this contract, we can generate a valid signature and the execution the transaction will go through, in this case paying out toilet claim. So let's go back here and generate that xtr, that generate

00:27:00.000 --> 00:27:59.999 align:start position:0%
XE. Our button is going to call the Turing signing servers. It's going to say: hey, this account would like to generate an ex TR and it looks like we have got a, an ex TR and it looks like we have got a beautiful error. So you know, so is the way it goes. But essentially what would have happened if it had worked would be: the contract goes out to all of those different addresses, all those different Turing signing server sends back the same XDR with the signature. The signatures get added to the transaction that comes in. We add our final signature to the ex TR to the transaction and then we can submit it right. So we have to. We have this account. We would have to sign for that hundred lumen payment. It pays out the hundred lumens and then the signatures that we received from the Turing signing servers for the Tyler coin are all valid. All the signatures are there. We can make this relatively complex payment all through a very simple Turing signing server smart

00:28:00.000 --> 00:28:59.999 align:start position:0%
Contract. So that would be our vending machine example. The next one would be. Let's do this weather coin, so this one kind of showcases, but I would call Oracle eyes data. But really it's just taking a third party API and using that information to generate a transactions, a different transaction or our variable transaction. So in this case we are using the dark sky API. We are looking up the weather at my current location and if it's raining, we are going to generate a transaction for rain coin, and if it's sunny outside, we're gonna generate a transaction that pays out Sun coin, and so again we need the same address. When I upload this, the same thing happens. Each sharing sighting server sends back a different, a new signing key. We had that signing key to the contract and then the contract, when we call it, will generate signatures for this particular transaction. So hopefully this

00:29:00.000 --> 00:29:59.999 align:start position:0%
One will work. It's not raining at my house at the moment, so unfortunately you can't get a any rain coin. So in this case it's looking it up and it's saying, because it's raining, we're not going to be able to get any rain coin. So if it was raining, you'd be able to get rain coin. But because it's not theirs, I think there's logic actually running in the glitch app which says: if it's not raining, don't generate the XDR. So maybe a little bit of a letdown, but still you can provide arbitrary logic to say, because it's not raining in my house right now, we're going to spit out and reject this transaction, which is really cool because you allow that logic to say: I'm going to give away like usage of my account, but only under certain parameters. And in this case it's an arbitrary third party API which is providing the information. That's as well. It's not raining, and so because it's not raining, we're not going to generate a signature for it. We're throwing that out, which is cool. The next one would be the filter

00:30:00.000 --> 00:30:59.999 align:start position:0%
Smart contract, and this one's actually a little bit different because, instead of adding signatures to a contract address, we're actually adding signatures to an account, to a user's account, and this is one of those examples where a contract- the ones we've looked at so far have been sort of third party services, so somebody's actually trying to run a business off of smart contracts. In this case, somebody just created a random- you know, open source- smart contract which provides filtering functionality, and so maybe I have an account that I want to give access to someone for, but only if they're XLM- payments are below a hundred lumens. So I've made a filter smart contract here which basically says: when a transaction comes in, so the input here is actually in xtr. So we're going to generate a Steller's transaction which has to have just one operation, which is

00:31:00.000 --> 00:31:59.999 align:start position:0%
A payment, and it has to be an amount- that is less than 100, because if it's great, greater than 100 lumens, the request will be rejected. But in this case we actually want to attach this contract to a user's account, not to a contract account. So there isn't really a contract address here. Somebody's just created this contract and says, hey, I'm gonna upload this and if you would like to get this to use it, if you would like to get this filtering functionality for your account, then you just need to add the signing keys to your address. So if we take this xtr here, which is a valid example- we can look up the account that it's attached to. So we've added the signing keys to this account and right now there's just two. So we've uploaded this contract to tutoring servers, taking their signing keys and attach them to our account. We

00:32:00.000 --> 00:32:59.999 align:start position:0%
Have a threshold of 3, which means we need all three of these, both turning signing servers and then our own TFI signing key to sign off on, and then we kind of have this escape base64 or sha 256 hash that if something terrible happens and we need to rescue this account, we kind of have that in our back pocket. That's not a turning signing server thing, that's just good practice if you've kind of locked out your account to yourself. But anyway, sharing signing servers are going to sign for two. So by themselves these turning saying servers can't do anything. There's no collusion capability possibility because at most, they would only have a weight of two, which isn't enough to do anything. They would need that final signer, my sign, my signature- to actually do anything. So, however, I can't also, by myself, do anything. This account is useless on its own. It needs those other tutoring signing servers to actually accomplish anything. And those turning signing servers are locked in to only signing for this, which is that the

00:33:00.000 --> 00:33:59.999 align:start position:0%
Transaction is greater than or is less than 100 limits. So if we go back here, we can see this payment is for 100 XLM. So if we go and we generate the xtr on this- all of my examples are today- this is not fantastic- and we try the invalid one. It works. It doesn't. It filters a transaction here looks like this one's not working. I think I may have uploaded the beta X beta. Let me look real quick at the contract address and make sure I'm actually using the right contractors, because this one is kind of cool, so we edit. our project real quick in our JavaScript. Know it's got the right one. Yeah, who knows,

00:34:00.000 --> 00:34:59.999 align:start position:0%
Probably shouldn't have fooled with it too much before doing the demo. But anyway, if you had a valid example which we- this is valid X? Er but looks like something's up with my Turing signing servers, this would be valid. It would be signed. You could view it in the laboratory and then submit the transaction to the network, so long as it was under that hundred. One more example here: this on glitch is our hourly wager demo. So I play video games occasionally and on Fridays will do wager pools. So maybe, like you know, 10 lumens or 20 bucks or something like that, and there that all gets pulled together and whoever wins the game gets the pool. You could also see it as a donation pool where, or even like a Kickstarter or something where, if

00:35:00.000 --> 00:35:59.999 align:start position:0%
Balance reaches over a certain threshold and the money's released. There's lots of different smart contract logic that comes through these types of functionalities. But you don't want a single entity holding all those funds with the risk that they could run away, and so you might add multiple human signers to that. But if one of them gets bitter and doesn't want to do the thing, that, you know I go you cheated and it's I'm not going to sign off on this transaction where you could run it to issues, when you have those human variables. But if it's just machines and they're just following contract logic, you remove that layer, that risk and do the perform, that trust minimized aspect of things, which is really what we're after and what turning signing servers exists for. And so in this case, you have a contract address which has the Turing sang service been uploaded to all of the turning signing servers, with threshold of three again. So you need at least three of these Turing signing servers and then individuals will start to pay this account. You can see the payments coming into this account, into the wager pool, and then, in

00:36:00.000 --> 00:36:59.999 align:start position:0%
This case, every hour the contract will go through, you'll be able to generate an xgr which will pick at random one of these individuals as the winner and payout the pool to them. So, again, if we go to our arrow, the wager contract- it's a little bit longer contract, but not really still 100 lines- where it takes into account the operations for this contract account, looking at the payments, and then we'll randomly select one of those as a winner every hour. So those are examples. In that case, again, you upload the signers, in this case to the contract, like we did before. The last one that I think is really interesting is a recurring revenue model. So one of the issues right now with recurring revenue models on Stellar is that you have to pre sign loads of transactions and kind of bump sequence numbers and it gets quite hairy when it actually comes time

00:37:00.000 --> 00:37:59.999 align:start position:0%
To execute those, as they have to give to pre sign loads of transactions, especially if it's like shorter terms, on weekly or monthly basis, and you have a lot of these transactions just kind of sitting around hoping that they'll be valid whenever it comes time to submit them. With Turing signing servers, you can create a contract which takes into account when a payment, was last made and for how much it was when it was made, all the information around the actual payment and then, if it's time, if it's been a month since the last payment, you can make another payment and so essentially you would create this transaction much like the filter transaction or much like the filter contract. You upload this contract, add the signers to a user account, but those signers can only sign through this contract and so if it's been a month since the last payment was made, you can call this contract and it will generate a transaction which makes a thousand lumen payment. But as soon as you submit

00:38:00.000 --> 00:38:59.999 align:start position:0%
That to the network, it's and you try and call it again and say, hey, I just want to keep collecting thousands of lumens from this account, it's going to say, hey, it hasn't been a month since the last time we ran, since we ran this contract. So in that case you don't have to have any pre signed transactions. You simply wait until the time comes, you generate the transaction and you can actually generate it and submit it through some sort of third party service. The user wouldn't necessarily ever have to know, other than they would still have ownership over their account and if at any point in the future they wanted to cancel their subscription, they would simply remove your turning signing signers from their account and any calls to that account to make a payment would fail because the user removed this turning signing server signers from their account. So I think, if this account still exists, we could actually look at

00:39:00.000 --> 00:39:59.999 align:start position:0%
The signers that have been added for this account. It looks like I saw on that one. I think it's actually yeah, so we've got the two signers here, but then it's also got a threshold of two. So while we need both turning signing servers to generate that recurring payment every month if at any point the user wants to remove those signers, they're able to do that because they have a weight of two set on their operation threshold. So that's been a basic overview of what I have so far on turning signing servers. It's still a work in progress. Obviously, if that's something that seems interesting to you- and hopefully it does- I am looking for more people to get involved on actually building out smart contracts. So I have quite a few turing signing servers, just tests that turn signing server set up, they're ready to be used, ready for people to poker and see what's possible. Hopefully some

00:40:00.000 --> 00:40:59.999 align:start position:0%
Of these examples have gotten your wheels turning, but now is kind of the announcement for that. We need some people to start using this thing, to start poking it around to see if this makes sense as a septa, see if we built the right thing, and then towards the as that sort of happens and we sort of get a better idea of what this should be and how it works and doesn't work and what kind of contracts can be built using this. We'll move into the actual draft, the SCP draft portion, where we write it all up. We have the API endpoints. We showcase how to build one of these servers and run it successfully and all the fees around it and how to generate revenue, how to run a secure turning to a server, but also how to create good contracts and then hopefully we can get it to an active state where it starts to be used more and becomes a normal sort of used active seller ecosystem proposal: within the ecosystem where these Streng

00:41:00.000 --> 00:41:59.999 align:start position:0%
Signing servers become possible, where anybody can spin up a contract and upload it to a plethora of turing signing servers and then, beyond that, it's just the acceptance of it and it becomes a normal part of Stellar development. Alright, so that was long. Apologize for that. Apologize that the demos didn't work out great. Hopefully we'll have those back up and running so that everybody can play around with what we have so far. Should have that within the next couple of days and linked on the youtube. Let's go for questions. I hope there's a couple of questions that you guys have for me as things pop up and I will begin to answer those and then we'll close out. But as you have questions for me, feel free to type them into the chat and we'll walk through them. Otherwise, you can find me on Twitter and key base at T. Y VD H. I would love to chat. All right, how is this relevant for cross border payments? Where does this fit in decentralized finance? Well, you kind of

00:42:00.000 --> 00:42:59.999 align:start position:0%
Set it there. In decentralized finance, a lot of its going to boil down to what you mean by decentralized. Everybody kind of has their own idea of what decentralized means, and when it comes to things like D- central payments for cross border payments or decentralized finance for cross border payments, it's gonna come down to like who's in charge, who's in control and what are the differences? What layer's do you have when you're talking about ownership? So in the case of an anchor, for example, and wanting to facilitate payments being made in and out of the ecosystem, or putting up offers on the orderbook to maintain liquidity between assets, right now all of that stun and a completely centralized way where an entity controls their orderbooks and so long as those orders are out there, they're free to take them down. And when you have these cross border payments moving back and forth, that can become an issue if a large portion of the success happens on one entity maintaining liquidity. So it

00:43:00.000 --> 00:43:59.999 align:start position:0%
Would be possible that a liquidity provider could create a smart contract that creates orderbooks that are decentralized, where they don't have the ability to alter or remove the orders, that it just runs the liquidity and doesn't remove itself, doesn't have a capability to remove itself. So a lot of it has to do, I think, with removing barriers towards trust. And this is actually kind of interesting because that's one of the biggest barriers when doing cross border payments is: do I trust them? Are they going to do what I expect them to do? By using turning signing servers are really by adding decentralization or trust minimization into your workflow, into your business logic, you're able to guarantee some level of trust because you relinquish some portion of control, whether that's liquidity providing or making good on payments. The more that you can guarantee through math that something is going to happen, versus guaranteeing through goodwill- or I have a good business plan, I've done this in the past- the better off you're going to be when it comes to winning people's trust, like it's going

00:44:00.000 --> 00:44:59.999 align:start position:0%
To become true more and more as other businesses do that and say: you don't trust us. You verify through the code that we've written that we don't ultimately control, weave or link which control of our secret key, our ability to alter the state of the ledger, to these transient servers which ultimately own the contract. They run the contract through users interacting with it. So in that sense, depending on how it's implemented and at what level, it makes sense for a company to add in trust minimization to their business logic. Pterence and insurers will be useful for cross border payments or decentralized finance, but a lot of it again is going to ultimately boil down to what is decentralization mean and is that actually helpful when it comes to trust minimization or making payments across borders. Is SCF going to run a turn signing server? Who runs strange signing servers without any incentive? I don't think SDF is going to reconcile you server. I mean I run a couple right now just as testing

00:45:00.000 --> 00:45:59.999 align:start position:0%
Demos. But yeah, there is tons of incentive to run a tutoring center. We didn't talk a whole lot about fees or uploading contract fees, but that's a big part of running a churning signing server. It would be kind of a separate talk. What is it like to run a turning sign server but you can charge excellent fees. So basically part of the XDR: when transcending server spits out a transaction, part of that transaction is payments to the turn sending servers. So those are these small fees paid out to the Turing signing service, as well as fees for actually uploading a contract. So it might be ten or a hundred lumens or five USD to upload a contract to a turing signing server. So there's both the incentive for people to upload contracts but also to run good Turrentine servers so that you can continue to collect on fees as cheering sighing servers are executing smart contracts. Don't understand why you need

00:46:00.000 --> 00:46:59.999 align:start position:0%
Signed transactions with other party. When you share your sign, transactional attorneys, sensor, owner of training center to execute your contract only if that Turing something. Let me read the question. I really don't understand why you need Turing signing servers to share signed transactions with other party. When you share your sign transaction with Turing signing server, owner of Turing signing server can execute your contract signed transaction to attack you again. That's only if you allow that. How did you write your contract? Because you some turing some contracts may accept a incoming XDR, but it's not. It doesn't have to be a signed transaction that's coming in, it's just instructions or it's just a contract. It's just a that's been submitted to a jury in signing server but it doesn't have any signatures on it yet. And if you write your turn signing server contract in such a way that the output is a partially signed transaction, so not full, where you still need to sign for the source account, you still need to sign for those fees maybe, but there's still another signature that's needed, the

00:47:00.000 --> 00:47:59.999 align:start position:0%
Transaction is only partially signed. It's not Val viable to submit to the network yet. So what? Someone? Yeah, a lot of it is gonna boil down to trusting all of the Turing signing servers together. But you already trust that with the way the seller consensus protocol works, where you trust the individual nodes that are running Stellar. So this idea of disinterested but incentivized third parties is quite strong and it has been proven to work quite well. So ultimately it boils down to again: you get what you permit. And if you allow for the generation of a transaction that is completely signed and valid, then, yes, the turning signing server could submit that. But even that isn't necessarily an issue, unless they're submitting something that you don't want them to submit. It ultimately depends on what that transaction accomplishes. But because you're splitting up your secret key between lots of different during signing servers, any single one probably shouldn't- unless

00:48:00.000 --> 00:48:59.999 align:start position:0%
You've allowed for it- be able to do anything on their own. They would need to collude with other turing signing servers to actually accomplish anything dangerous. So what's the difference between sharing your signed transactions contracts with Turing signing server over traditional servers? The only difference is they aren't their traditional servers, just operating as turned sending servers. Ultimately it boils down to two owns the turing psychic servers, because if you own them, there's not two centralization there, but if some other entity owns those, some other entity is running those, so long as again, you're uploading it to multiples of those you're running sort of a. It's not a clone, but it's similar to how Stellar works already, where SDF and Lobstr CoinQuest all run validator nodes and you submit a transaction to their network and they validate the transactions and perform the operations

00:49:00.000 --> 00:49:59.999 align:start position:0%
Within those transactions. This is kind of the same thing where you have a secret key which is split up amongst lots of different servers and those servers then add their signature to any transactions coming from the contract and so long as it's valid and it's all the same, and it's a valid signature, it can be submitted to the Stellar network. How would you see this use for subscriptions, like you mentioned before? Also, does this support more than just JavaScript? So I gave an example on the subscription model. Ultimately, you would just have contracts that were built for different amounts, or it could maybe take variable amounts. I haven't thought too deeply about exactly how would we use. My purpose isn't to be too stringent on how it should be used, and more provide a platform that works and then allow other people to build on top of that. So you kind of would have to think: ok, if I can either get ownership over someone's account, but in a very controlled way,

00:50:00.000 --> 00:50:59.999 align:start position:0%
Through contracts, only through contracts, or I can give ownership to my account, but only through strict contracts, what does that allow for? What are the capabilities there? And then there's tons of them and subscriptions would be one of those with fee bumps, I don't know. I will be interesting to see if fee bums kind of gets rid of the issue with recurring revenue, since you can pay sequence numbers and fees from different accounts now. So some of the issues we had there may already be gone. I haven't looked into that too deeply, but when it comes to complicated or turing complete recurring revenue models, or you need to do much more beyond just paying fees and sequence numbers. You actually need to do some logic, external logic, or taking accounts of the person's account. You know like refunds or oh, they partially paid, and now we have to perform some logic around. Some sort of partial payment or upgrades and you know more strike like functionality. Then you could use something like this

00:51:00.000 --> 00:51:59.999 align:start position:0%
To accomplish that through, because the turn signing server or smart contract logic and again you don't do. You need to do that. I don't know. That depends on how much your users need and value a decentralized option for something like this or a decentralized option, and maybe they do, maybe they don't. That, ultimately, is up to the users and what they expect out at the services that they're making use of. All right, do we have any other questions? Those were good questions and again this isn't set in stone. This is very isn't discussion and we don't want to spend our time doing the wrong thing, but at the same time, all you have to do is spend a little time looking at aetherium to realize that smart contracts and turing complete smart contracts is a very powerful tool that is very valuable and I think it's worth taking a look at. Is there opportunity, doesn't make sense for us to include some sort of functionality like this functional

00:52:00.000 --> 00:52:59.999 align:start position:0%
Feature- parity- that would allow for decentralized transaction creation where you don't have to trust the person who's creating the transaction. You can mitigate that, you can relegate that through other parties. All right, SuperDuper, I appreciate everyone hanging out again. Feel free to reach out on key base or Twitter with follow up questions. I'll try and get working links to these demos as well as some API Doc's for people to poke around. If you want to get involved building these things or testing it out, be sure and reach on them, you know. Thanks again or for coming out, and we'll catch y'all later. Bye.
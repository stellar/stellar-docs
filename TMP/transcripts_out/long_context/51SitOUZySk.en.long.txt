Hello everyone and welcome to the the hello everyone and welcome to the the last Stellar Developer Meeting this. Last Stellar Developer Meeting this last Stellar Developer Meeting this year and on the agenda for today we. Year and on the agenda for today we year and on the agenda for today we have two things we have Jay from the. Have two things we have Jay from the have two things we have Jay from the the core engineering team they'll talk. The core engineering team they'll talk the core engineering team they'll talk about some new additions in protocol. About some new additions in protocol about some new additions in protocol 22 and then he is going to give some. 22 and then he is going to give some 22 and then he is going to give some demos so I will. Demos so I will demos so I will invite Jay to join me here on stage invite Jay to join me here on stage. Invite Jay to join me here on stage hello hello can you hear me yeah I can hello hello can you hear me yeah I can. Hello hello can you hear me yeah I can hear you okay great hi everyone hear you okay great hi everyone . Hear you okay great hi everyone I'm I'm Jay core developer today I'm I'm I'm Jay core developer today I'm. I'm I'm Jay core developer today I'm going to walk you through the going to walk you through the. Going to walk you through the building blocks that we introduced in building blocks that we introduced in. Building blocks that we introduced in protocal 22 which went live U this month. Protocal 22 which went live U this month protocal 22 which went live U this month. A couple weeks ago specifically a couple weeks ago specifically a couple weeks ago specifically. Around the The cryptographic around the The cryptographic around the The cryptographic. Primitives namely bs2 381 Primitives namely bs2 381 Primitives namely bs2 381. so yeah so the cap for bs2 so yeah so the cap for bs2 so yeah so the cap for bs2. 3d1 is cap 59 which was introduced 3d1 is cap 59 which was introduced . 3d1 is cap 59 which was introduced I would say three or four months ago I would say three or four months ago . I would say three or four months ago but today I'm going to focus on just but today I'm going to focus on just. But today I'm going to focus on just like a high level overview of what you like a high level overview of what you. Like a high level overview of what you can do with different types of can do with different types of. Can do with different types of functions introduce as well as the the functions introduce as well as the the. Functions introduce as well as the the SDK interface and I'm also going to show SDK interface and I'm also going to show. SDK interface and I'm also going to show a couple examples simple ones to a couple examples simple ones to. A couple examples simple ones to illustrate how you can make use of these illustrate how you can make use of these. Illustrate how you can make use of these core functionality today to build useful. Core functionality today to build useful core functionality today to build useful. Applications so let's get applications so let's get applications so let's get. Started first let me share my started first let me share my started first let me share my.  screen okay so screen okay so yeah yeah walking through u a few things. Yeah yeah walking through u a few things yeah yeah walking through u a few things. so first just briefly take you so first just briefly take you so first just briefly take you. Through the cap since this is not a through the cap since this is not a through the cap since this is not a. Protocol meeting I'll just be really protocol meeting I'll just be really protocol meeting I'll just be really. Brief and not spend any time brief and not spend any time brief and not spend any time. Explaining the details and nuances you explaining the details and nuances you explaining the details and nuances you. Can read more about them can read more about them can read more about them . So yes so this cap cap 59 is about so yes so this cap cap 59 is about . So yes so this cap cap 59 is about bs12 bs12 bs12 381 so the brs1 123 3d1 is a is a new . 381 so the brs1 123 3d1 is a is a new 381 so the brs1 123 3d1 is a is a new . Curve that that's added so curve that that's added so curve that that's added so. The well it's not a new it's not one the well it's not a new it's not one the well it's not a new it's not one. Curve it's rather like a family of curve it's rather like a family of curve it's rather like a family of. Curves U there's namely the the G1 which Curves U there's namely the the G1 which. Curves U there's namely the the G1 which is the base field and then the G2 which is the base field and then the G2 which. Is the base field and then the G2 which is the extension field and what's what's is the extension field and what's what's. Is the extension field and what's what's what's useful about this curve what's useful about this curve. What's useful about this curve specifically is that you can you can specifically is that you can you can. Specifically is that you can you can compute pairings which is taking a compute pairings which is taking a. Compute pairings which is taking a point in G1 pointing G2 repair them point in G1 pointing G2 repair them. Point in G1 pointing G2 repair them and then it Maps into a different point and then it Maps into a different point. And then it Maps into a different point in a in a higher higher degree space in a in a higher higher degree space. In a in a higher higher degree space so at a high level what why is this so at a high level what why is this. so at a high level what why is this useful you might ask so just like useful you might ask so just like. Useful you might ask so just like cryptography we wanted to compute cryptography we wanted to compute . Cryptography we wanted to compute like we want to do computations and we like we want to do computations and we. Like we want to do computations and we want we don't want to do them in a a want we don't want to do them in a a. Want we don't want to do them in a a plain manners right just like ecdsa plain manners right just like ecdsa. Plain manners right just like ecdsa you you utilize the you you utilize the you you utilize the. properties of eliptic curve and then properties of eliptic curve and then properties of eliptic curve and then. and then the particularly the and then the particularly the and then the particularly the . Discrete logarithmic problem is is hard discrete logarithmic problem is is hard discrete logarithmic problem is is hard. To solve meaning that if you multiply a to solve meaning that if you multiply a to solve meaning that if you multiply a. Point a certain times on the curve point a certain times on the curve point a certain times on the curve. And get a different curve it's really and get a different curve it's really and get a different curve it's really. Hard to invert that process to get the hard to invert that process to get the hard to invert that process to get the. Number that you multiplied with which number that you multiplied with which number that you multiplied with which. Makes it useful for private key and makes it useful for private key and makes it useful for private key and. Public key so same principle here B2 public key so same principle here B2 public key so same principle here B2. C1 is just eliptic curve and it can C1 is just eliptic curve and it can C1 is just eliptic curve and it can. It can used it can be used for it can used it can be used for it can used it can be used for. Signatures which I we show in our first signatures which I we show in our first signatures which I we show in our first. Example first example later on but it's example first example later on but it's example first example later on but it's. Also it can do a lot more so yeah so also it can do a lot more so yeah so also it can do a lot more so yeah so. The so the high level G of this is that the so the high level G of this is that the so the high level G of this is that. using the new the new curve you can using the new the new curve you can using the new the new curve you can. Do encrypted computation that follows do encrypted computation that follows do encrypted computation that follows. Certain rules and these are the basic certain rules and these are the basic certain rules and these are the basic. Building blocks which people use to building blocks which people use to building blocks which people use to. Build more advanced and interesting build more advanced and interesting build more advanced and interesting. Applications such as CK applications such as CK applications such as CK knock all right so yeah so here are the. Knock all right so yeah so here are the knock all right so yeah so here are the new host functions introduced I think. New host functions introduced I think new host functions introduced I think. The total is like 12 if I remember the total is like 12 if I remember the total is like 12 if I remember. Correctly there's a yeah the basic correctly there's a yeah the basic correctly there's a yeah the basic. Ones Point addition ones Point addition ones Point addition G1 Point Point multip. G1 Point Point multip G1 Point Point multip multiplication with a constant MSM. Multiplication with a constant MSM multiplication with a constant MSM which is basically a scaler like a. Which is basically a scaler like a which is basically a scaler like a vector multiplication which is yeah just. Vector multiplication which is yeah just vector multiplication which is yeah just. Multiplying a vector of number by a multiplying a vector of number by a multiplying a vector of number by a. Vector of points and then add them up so and then so these ones the up so and then so these ones the. Hash to curve in map to curve these hash to curve in map to curve these hash to curve in map to curve these. Ones are if you use if you want to ones are if you use if you want to ones are if you use if you want to . Use a digital signature scheme like if use a digital signature scheme like if use a digital signature scheme like if. You want to map a random message onto you want to map a random message onto you want to map a random message onto. The curve and and and map to a point the curve and and and map to a point the curve and and and map to a point. Perform the cryptographic functions perform the cryptographic functions perform the cryptographic functions. On it you first have to take that on it you first have to take that on it you first have to take that. Message and you have to Hash it onto the message and you have to Hash it onto the. Message and you have to Hash it onto the curve internally how it works very. Curve internally how it works very curve internally how it works very. Briefly is that it there's a h this hash briefly is that it there's a h this hash. Briefly is that it there's a h this hash function sh 256 and then you also function sh 256 and then you also. Function sh 256 and then you also provide something called a DST which is provide something called a DST which is. Provide something called a DST which is the domain separate Separation The the domain separate Separation The. The domain separate Separation The Domain separation tag which is just a Domain separation tag which is just a. Domain separation tag which is just a tag that you append to every message tag that you append to every message. Tag that you append to every message such that your applications domain such that your applications domain. Such that your applications domain separate from say like ethereum's separate from say like ethereum's. Separate from say like ethereum's application like so it's always good application like so it's always good. Application like so it's always good to have a unique DST for every to have a unique DST for every. To have a unique DST for every application to avoid some kind of application to avoid some kind of. Application to avoid some kind of intricate attack so the basically how intricate attack so the basically how. Intricate attack so the basically how it works is that it just hashes like it works is that it just hashes like. It works is that it just hashes like repeatedly hashes that message into repeatedly hashes that message into. Repeatedly hashes that message into a certain lens which corresponds to a certain lens which corresponds to. a certain lens which corresponds to the the length of the the point on the the length of the the point on. The the length of the the point on the curve and then it checks if that the curve and then it checks if that. The curve and then it checks if that point is on the Curve and then if not point is on the Curve and then if not. Point is on the Curve and then if not it it add one and repeat and then it it add one and repeat and then . It it add one and repeat and then once it is on the curve then it once it is on the curve then it. Once it is on the curve then it multiplies by some co-actor to send this multiplies by some co-actor to send this. Multiplies by some co-actor to send this curve to the correct subgroup curve to the correct subgroup . Curve to the correct subgroup so this is just getting a little bit so this is just getting a little bit. So this is just getting a little bit into more detail is that these curves into more detail is that these curves. Into more detail is that these curves obviously they are Prime like they obviously they are Prime like they. Obviously they are Prime like they Prime field so the the it's the numbers Prime field so the the it's the numbers. Prime field so the the it's the numbers on this curve are are modulus of a of a on this curve are are modulus of a of a. On this curve are are modulus of a of a large Prime in this case the prime large Prime in this case the prime. Large Prime in this case the prime number is number is number is 381 bits long thus the name U BR is 12. 381 bits long thus the name U BR is 12 381 bits long thus the name U BR is 12 381 and the subgroup is is different. 381 and the subgroup is is different 381 and the subgroup is is different subgroup is the number of points. Subgroup is the number of points subgroup is the number of points that we pick or like the the definition. That we pick or like the the definition that we pick or like the the definition of the curve pick such that these . Of the curve pick such that these of the curve pick such that these operations are defined so the subgroup. Operations are defined so the subgroup operations are defined so the subgroup is a subset of all available points on. Is a subset of all available points on is a subset of all available points on the BS 81 curve and then the for this. The BS 81 curve and then the for this the BS 81 curve and then the for this particular case the subgroup size is 256. Particular case the subgroup size is 256 particular case the subgroup size is 256. Bit so which is very convenient to be bit so which is very convenient to be. Bit so which is very convenient to be represented as a big U represented as a big U. Represented as a big U 256 and so yeah some of the host 256 and so yeah some of the host. 256 and so yeah some of the host functions here actually if you look functions here actually if you look. Functions here actually if you look at they're called f which basically at they're called f which basically. At they're called f which basically takes some U 256 vales and then like add takes some U 256 vales and then like add. Takes some U 256 vales and then like add them together like these numbers them together like these numbers. Them together like these numbers represent the the scalar in the represent the the scalar in the. Represent the the scalar in the definition of of this particular curve definition of of this particular curve. Definition of of this particular curve where the the modulus of the scaler where the the modulus of the scaler. Where the the modulus of the scaler equals the subgroup size so this is equals the subgroup size so this is. Equals the subgroup size so this is useful for manipulating the points useful for manipulating the points. Useful for manipulating the points like multiplying them and then making like multiplying them and then making. Like multiplying them and then making sure that this scaler is actually like sure that this scaler is actually like. Sure that this scaler is actually like represented by the points on the curve represented by the points on the curve. Represented by the points on the curve like yeah so we just covered hash to curve and. So we just covered hash to curve and then yeah then we repeat for G2 which then yeah then we repeat for G2 which. Then yeah then we repeat for G2 which is which is different group of points. Is which is different group of points is which is different group of points. same thing here map to G map map same thing here map to G map map same thing here map to G map map. To G2 hash to G2 and then the important to G2 hash to G2 and then the important to G2 hash to G2 and then the important. One or I guess the most interesting one or I guess the most interesting one or I guess the most interesting. One that the applications built off one that the applications built off one that the applications built off. Of is the pairing so of is the pairing so of is the pairing so so what the parent does is I'm I'm. So what the parent does is I'm I'm so what the parent does is I'm I'm going to borrow some other slides. Going to borrow some other slides going to borrow some other slides here so this is. Here so this is here so this is a this is just like a onepage a this is just like a onepage . A this is just like a onepage explanation for BL signature which will explanation for BL signature which will. Explanation for BL signature which will cover in a bit in our example and here cover in a bit in our example and here. Cover in a bit in our example and here is just the definition of a pairing is just the definition of a pairing. Is just the definition of a pairing which takes a point in the first group which takes a point in the first group. Which takes a point in the first group point on the second group pair them point on the second group pair them. point on the second group pair them up and send it to a different group up and send it to a different group. Up and send it to a different group the interesting about the paing is the interesting about the paing is. the interesting about the paing is that it is bilinear which means that it that it is bilinear which means that it. That it is bilinear which means that it is linear with respect to both the is linear with respect to both the. Is linear with respect to both the first U term as well as the second term first U term as well as the second term. First U term as well as the second term so so here you see pairing of P so so here you see pairing of P. So so here you see pairing of P plus s is equal to pairing of P times plus s is equal to pairing of P times. Plus s is equal to pairing of P times pairing of s and same same here on the pairing of s and same same here on the. Pairing of s and same same here on the second term Q Plus R you can pair second term Q Plus R you can pair. Second term Q Plus R you can pair them separately and multiply together so them separately and multiply together so. Them separately and multiply together so the reason here is a multiplication the reason here is a multiplication. The reason here is a multiplication again this is just some details is again this is just some details is. again this is just some details is that because the paing result is sent that because the paing result is sent. That because the paing result is sent to like a higher degree the 12th to like a higher degree the 12th. To like a higher degree the 12th degree that's part of the name BR is degree that's part of the name BR is. Degree that's part of the name BR is 12 so we need to get to the 12th 12 so we need to get to the 12th . 12 so we need to get to the 12th degree extension field which is a degree extension field which is a. Degree extension field which is a multiplic multiplicative Group which multiplic multiplicative Group which. Multiplic multiplicative Group which means you can perform like means you can perform like. Means you can perform like multiplications instead of a additive multiplications instead of a additive. Multiplications instead of a additive Group which is our G1 and G2 so just Group which is our G1 and G2 so just. Group which is our G1 and G2 so just some details but important fact is that some details but important fact is that. Some details but important fact is that you can these relationships can hold you can these relationships can hold. You can these relationships can hold and then by the extension of it if and then by the extension of it if. And then by the extension of it if you have a u on the left side if you you have a u on the left side if you. You have a u on the left side if you have a p repeated eight times this have a p repeated eight times this. Have a p repeated eight times this is essentially multiplying the result is essentially multiplying the result. Is essentially multiplying the result eight times and then which is equivalent eight times and then which is equivalent. Eight times and then which is equivalent to taking the this paring result the to taking the this paring result the. To taking the this paring result the plain par result of p and Q and exponent plain par result of p and Q and exponent. Plain par result of p and Q and exponent take the exponent a and then you can take the exponent a and then you can. Take the exponent a and then you can move this a either you know on the left move this a either you know on the left. Move this a either you know on the left side or on the right side or move it out side or on the right side or move it out. Side or on the right side or move it out it doesn't it doesn't matter so the it doesn't it doesn't matter so the. It doesn't it doesn't matter so the pairing this pair relationship can be pairing this pair relationship can be. Pairing this pair relationship can be quite useful as we see in the example. Quite useful as we see in the example quite useful as we see in the example. Of both signature as well as a SN verification okay so I think that goes verification okay so I think that goes. Over well we just covered the FR which over well we just covered the FR which over well we just covered the FR which. Is the field this is just a this is just is the field this is just a this is just. Is the field this is just a this is just a very simple like modular a very simple like modular. A very simple like modular arithmetics but with a very specific arithmetics but with a very specific. Arithmetics but with a very specific module like addition module like addition . Module like addition subtraction subtraction subtraction multiplication power inversion and. Multiplication power inversion and multiplication power inversion and that's. That's that's all so now let's look at the SDK so how all so now let's look at the SDK so how. All so now let's look at the SDK so how does this look inside the SDK which does this look inside the SDK which. Does this look inside the SDK which is which is what you'll be is which is what you'll be . Is which is what you'll be interfacing with is so if you look at interfacing with is so if you look at. Interfacing with is so if you look at the SD there's a it sits inside the the SD there's a it sits inside the. The SD there's a it sits inside the crypto library and then there's a brst crypto library and then there's a brst. Crypto library and then there's a brst 381 module so the all the functions 381 module so the all the functions. 381 module so the all the functions are exposed inside the BRS 12 381 module are exposed inside the BRS 12 381 module. Are exposed inside the BRS 12 381 module so the few additional functions like so the few additional functions like. so the few additional functions like checking if a if a point is in the checking if a if a point is in the. Checking if a if a point is in the subgroup but overall there is a subgroup but overall there is a. Subgroup but overall there is a pretty much one to one correspondence pretty much one to one correspondence. Pretty much one to one correspondence between the host function and the SDK between the host function and the SDK. Between the host function and the SDK function oh and also one interesting function oh and also one interesting. Function oh and also one interesting to notice is there's a two addition to notice is there's a two addition. To notice is there's a two addition method one is just a plain addition method one is just a plain addition. Method one is just a plain addition and then the other one is the checked and then the other one is the checked. And then the other one is the checked Edition so so the reason for that is Edition so so the reason for that is . Edition so so the reason for that is so remember what I said earlier was so remember what I said earlier was . So remember what I said earlier was the BL 12 381 points are defined over a the BL 12 381 points are defined over a. The BL 12 381 points are defined over a particular subgroup but particular subgroup but. Particular subgroup but but but just the the addition operation but but just the the addition operation. But but just the the addition operation can perform on any point on the curve can perform on any point on the curve. Can perform on any point on the curve doesn't have to belong to the subgroup doesn't have to belong to the subgroup. Doesn't have to belong to the subgroup but in order for that addition to be but in order for that addition to be. But in order for that addition to be useful for our pairings and for our useful for our pairings and for our . Useful for our pairings and for our other like a SN operation like they other like a SN operation like they. Other like a SN operation like they have to be in the subgroup but the have to be in the subgroup but the. Have to be in the subgroup but the subgroup check is is is kind of subgroup check is is is kind of. Subgroup check is is is kind of expensive so if you have a contract expensive so if you have a contract. Expensive so if you have a contract which does like a number of these which does like a number of these. Which does like a number of these additions and only you want to make sure additions and only you want to make sure. Additions and only you want to make sure the end result is on the subgroup then the end result is on the subgroup then. The end result is on the subgroup then you can use the plain add function you can use the plain add function. You can use the plain add function which is not taking which is not taking which is not taking. yeah which is not taking the the yeah which is not taking the the yeah which is not taking the the. The check it's just it's just point the check it's just it's just point the check it's just it's just point. Doing the addition whereas if you wanted doing the addition whereas if you wanted. Doing the addition whereas if you wanted to be safe and then you wanted to use to be safe and then you wanted to use. To be safe and then you wanted to use the the checked ad which performs the the the checked ad which performs the . The the checked ad which performs the the the subgroup check in in the end modifcation yeah these are all very. Modifcation yeah these are all very standard yeah repeat for G2 parent G2 parent check oh yeah okay one thing about. Check oh yeah okay one thing about check oh yeah okay one thing about the parent check here like I . The parent check here like I the parent check here like I mentioned earlier in this equation . Mentioned earlier in this equation mentioned earlier in this equation . This is a parent check it's check this is a parent check it's check this is a parent check it's check. Checking a pairing of two points equals checking a pairing of two points equals checking a pairing of two points equals. Some relationship of pairing like with a some relationship of pairing like with a. Some relationship of pairing like with a either like a a result of a pairing either like a a result of a pairing. either like a a result of a pairing multiplied by each other or like multiplied by each other or like. Multiplied by each other or like additional terms but the the pairing additional terms but the the pairing. Additional terms but the the pairing result itself is is a point on a result itself is is a point on a. Result itself is is a point on a higher degree in a higher degree higher degree in a higher degree . Higher degree in a higher degree extension F12 and then to compute that extension F12 and then to compute that. Extension F12 and then to compute that F12 is very expensive so the parent F12 is very expensive so the parent. F12 is very expensive so the parent check is intended such that we we can check is intended such that we we can . Check is intended such that we we can perform multiple pairings together perform multiple pairings together. Perform multiple pairings together and then check that this the end result and then check that this the end result. And then check that this the end result equals to one which means this equals to one which means this. equals to one which means this pairing returns true or false if it pairing returns true or false if it. Pairing returns true or false if it satisfies true otherwise it's false satisfies true otherwise it's false . Satisfies true otherwise it's false the the benefit of that is that these the the benefit of that is that these. The the benefit of that is that these intermediate result they can be they can intermediate result they can be they can. Intermediate result they can be they can be performed on a a much lower degree be performed on a a much lower degree. Be performed on a a much lower degree which is much more efficient and only at which is much more efficient and only at. Which is much more efficient and only at the very end do you have to or you don't. The very end do you have to or you don't the very end do you have to or you don't. Have to but like internally the have to but like internally the have to but like internally the. Algorithm will send that to the algorithm will send that to the algorithm will send that to the . The 12's order and then do the the 12's order and then do the the 12's order and then do the. Comparison check with the the U the comparison check with the the U the comparison check with the the U the. Number one in 12 extension so so the number one in 12 extension so so the number one in 12 extension so so the. Reason for that is in most of the reason for that is in most of the reason for that is in most of the. Applications either in signature applications either in signature applications either in signature. Checking or in in SN verification you checking or in in SN verification you. Checking or in in SN verification you only need to do pairing to to check only need to do pairing to to check. Only need to do pairing to to check certain relation hold like in a SN for certain relation hold like in a SN for. Certain relation hold like in a SN for example you are checking that your example you are checking that your. Example you are checking that your polinomial contains a certain polinomial contains a certain. Polinomial contains a certain structure by that you are Computing structure by that you are Computing. Structure by that you are Computing some some some polinomial relations and then you're. Polinomial relations and then you're polinomial relations and then you're checking that the left side equals right. Checking that the left side equals right checking that the left side equals right. Right right hand side this relation right right hand side this relation right right hand side this relation. Hold so you you in in now the point you hold so you you in in now the point you hold so you you in in now the point you. Actually need that 12 degree extension actually need that 12 degree extension actually need that 12 degree extension. Point all you have to do is to make sure Point all you have to do is to make sure. Point all you have to do is to make sure the left side equal right side so so far. The left side equal right side so so far the left side equal right side so so far. I haven't heard of any application I haven't heard of any application I haven't heard of any application. That specifically needs the result of that specifically needs the result of that specifically needs the result of. The pairing so that's why we went with the pairing so that's why we went with the pairing so that's why we went with. This design of just passing a vector of this design of just passing a vector of this design of just passing a vector of. G1 Vector of G2 perform pairwise Che G1 Vector of G2 perform pairwise Che G1 Vector of G2 perform pairwise Che. Pairing and then check the result in the pairing and then check the result in the. Pairing and then check the result in the end if it's equal than equal to one end if it's equal than equal to one. End if it's equal than equal to one then return true otherwise return false then return true otherwise return false. Then return true otherwise return false so it's just a so it's just a so it's just a. It's other line mass is the same but it's other line mass is the same but it's other line mass is the same but. Just you know something to be be just you know something to be be just you know something to be be. Aware like it's it's not taking a single aware like it's it's not taking a single. Aware like it's it's not taking a single point pair with a single point but point pair with a single point but. Point pair with a single point but taking a vector of pair with a vector taking a vector of pair with a vector. Taking a vector of pair with a vector and then these ones we covered okay and then these ones we covered okay. and then these ones we covered okay so I think that's it for the building so I think that's it for the building. So I think that's it for the building block oh it took 20 minutes it's block oh it took 20 minutes it's. Block oh it took 20 minutes it's probably should probably speed up a probably should probably speed up a. Probably should probably speed up a little huh little huh little huh okay so let's talk about the the useful. Okay so let's talk about the the useful okay so let's talk about the the useful applications U first first of all the. Applications U first first of all the applications U first first of all the BRS signatures so I think I went. BRS signatures so I think I went BRS signatures so I think I went through this in one of the protocol. Through this in one of the protocol through this in one of the protocol meeting earlier so I just keep it a. Meeting earlier so I just keep it a meeting earlier so I just keep it a little more brief because the other. Little more brief because the other little more brief because the other ones I think more interesting so the. Ones I think more interesting so the ones I think more interesting so the BR signature the way it works I'm. BR signature the way it works I'm BR signature the way it works I'm trying to find the paragraph that does. Trying to find the paragraph that does trying to find the paragraph that does explanation so yeah so so here there's a. Explanation so yeah so so here there's a explanation so yeah so so here there's a. There's some some kind of secret key and there's some some kind of secret key and. There's some some kind of secret key and then oh sorry this is a public key okay so the the public key is some. okay so the the public key is some number times the point the generator number times the point the generator. Number times the point the generator point and then the the signature is point and then the the signature is . Point and then the the signature is the public key times hash of the message the public key times hash of the message. The public key times hash of the message and by the parent property if you just and by the parent property if you just. And by the parent property if you just if you do the the public key and the if you do the the public key and the. If you do the the public key and the hash of the message and then you move hash of the message and then you move. Hash of the message and then you move the the Scala part around in the the the Scala part around in the. The the Scala part around in the end you just you get a you get a a check end you just you get a you get a a check. End you just you get a you get a a check which is the the generator so the the. Which is the the generator so the the which is the the generator so the the. Pairing of the of the public key and the pairing of the of the public key and the. Pairing of the of the public key and the hash of message equals the the pairing hash of message equals the the pairing. Hash of message equals the the pairing of the the generator and then the the of the the generator and then the the. Of the the generator and then the the the signature so yeah if you it's fairly the signature so yeah if you it's fairly. The signature so yeah if you it's fairly straightforward the public key here straightforward the public key here. Straightforward the public key here sorry I don't know why you call PK it's sorry I don't know why you call PK it's. Sorry I don't know why you call PK it's actually just a secret key here you actually just a secret key here you. Actually just a secret key here you can move it can move it can move it it appears on the left in the beginning. It appears on the left in the beginning it appears on the left in the beginning but you can move it on the right and. But you can move it on the right and but you can move it on the right and then this becomes the the the signature. Then this becomes the the the signature then this becomes the the the signature so the left and right must hold if this. So the left and right must hold if this so the left and right must hold if this signature is valid and the good thing. Signature is valid and the good thing signature is valid and the good thing about it is that if you have the same. About it is that if you have the same about it is that if you have the same. Message and then multiple public Keys message and then multiple public Keys message and then multiple public Keys. Signing the message then you can signing the message then you can signing the message then you can. Essentially just aggregate all the essentially just aggregate all the essentially just aggregate all the. Signatures together and aggregate all signatures together and aggregate all signatures together and aggregate all. The Public Public Keys together do the Public Public Keys together do the Public Public Keys together do. This off chain and all you have to do is this off chain and all you have to do is. This off chain and all you have to do is just to verify one pairing then you just to verify one pairing then you. Just to verify one pairing then you can you know verify potentially hundreds can you know verify potentially hundreds. Can you know verify potentially hundreds of signatures all at once and this is. Of signatures all at once and this is of signatures all at once and this is. Only this is if the messages are only this is if the messages are only this is if the messages are. Same but if the message are unique then same but if the message are unique then same but if the message are unique then. For every message like M number message for every message like M number message for every message like M number message. There will be like M plus one parent there will be like M plus one parent there will be like M plus one parent. Checks so that's the general idea of checks so that's the general idea of checks so that's the general idea of. the UHS signature so let's see the the UHS signature so let's see the the UHS signature so let's see the. Example so example so example so so we have so we have so we have . Here hope you can see the code here here hope you can see the code here here hope you can see the code here . So this one example is already in the s so this one example is already in the s so this one example is already in the s. Bomb example repo you can look at bomb example repo you can look at bomb example repo you can look at. It today I try to keep it documented it today I try to keep it documented it today I try to keep it documented. I think it's fairly straightforward I think it's fairly straightforward I think it's fairly straightforward. in the it's a pretty much as in the it's a pretty much as in the it's a pretty much as. Increment contract but the increment is increment contract but the increment is increment contract but the increment is. requires an O which is a for every requires an O which is a for every. requires an O which is a for every time you increment it will check called time you increment it will check called. Time you increment it will check called check or and then check some the check or and then check some the. Check or and then check some the signature payload and the and then signature payload and the and then. Signature payload and the and then the public key so inside here is the public key so inside here is. The public key so inside here is basically just loading loading the basically just loading loading the. Basically just loading loading the aggregate public key loading your aggregate public key loading your . Aggregate public key loading your domain separation tag and then domain separation tag and then. domain separation tag and then construct the vector and call pairing construct the vector and call pairing. Construct the vector and call pairing that's all that is and then you can look that's all that is and then you can look. That's all that is and then you can look at the test which is doing most of the at the test which is doing most of the. At the test which is doing most of the setups setups setups here it contains 10 pairs of signatures. Here it contains 10 pairs of signatures here it contains 10 pairs of signatures applying the aggregation and. applying the aggregation and applying the aggregation and signature aggregation and then here just. Signature aggregation and then here just signature aggregation and then here just. Runs the test which invokes the check runs the test which invokes the check runs the test which invokes the check. All with some random all with some random all with some random payload if I run. Payload if I run payload if I run that yeah the that yeah the that yeah the. Signature signature passes and then signature signature passes and then signature signature passes and then. It dumps out the the budget and then it dumps out the the budget and then it dumps out the the budget and then. Yeah so this simple operation is like 31 yeah so this simple operation is like 31. Yeah so this simple operation is like 31 31 million CPU instructions so 31 million CPU instructions so. 31 million CPU instructions so yeah remember this is 10 10 different yeah remember this is 10 10 different. Yeah remember this is 10 10 different signatures on the same payload so 31 signatures on the same payload so 31. Signatures on the same payload so 31 31 million to verify 10 signature you 31 million to verify 10 signature you. 31 million to verify 10 signature you can do also more if they can do also more if they. Can do also more if they more so that's a very brief walk more so that's a very brief walk. More so that's a very brief walk through of the the V signature so through of the the V signature so . Through of the the V signature so now I want to go go and do something now I want to go go and do something. Now I want to go go and do something new and the potentially interesting new and the potentially interesting. new and the potentially interesting which is the the cross 16 verifier so in which is the the cross 16 verifier so in. Which is the the cross 16 verifier so in order to show that we have the building order to show that we have the building. Order to show that we have the building block to build real ZK applications I block to build real ZK applications I. Block to build real ZK applications I went and generated a very simple went and generated a very simple. Went and generated a very simple simple proof and then Ed a very simple proof and then Ed a very . Simple proof and then Ed a very simple impementation of the grass 16 simple impementation of the grass 16 . Simple impementation of the grass 16 verifier to verify that proof and I verifier to verify that proof and I. Verifier to verify that proof and I want to walk you through it want to walk you through it. Want to walk you through it so I don't know if we have enough time so I don't know if we have enough time. So I don't know if we have enough time for me to for me to for me to actually actually. Actually so do do we do we have time how much so do do we do we have time how much. so do do we do we have time how much time we have yeah yeah yeah take the time we have yeah yeah yeah take the. Time we have yeah yeah yeah take the time you need yeah okay yeah because I time you need yeah okay yeah because I I. Time you need yeah okay yeah because I do want to just walk you through the do want to just walk you through the. Do want to just walk you through the steps that that's required to to steps that that's required to to. Steps that that's required to to generate the the proof and and and see generate the the proof and and and see. Generate the the proof and and and see see it in action because a lot of a lot see it in action because a lot of a lot. See it in action because a lot of a lot of this is is looks like magic when you of this is is looks like magic when you. Of this is is looks like magic when you first run it like just dump dumped a first run it like just dump dumped a. First run it like just dump dumped a bunch of things so okay bunch of things so okay. Bunch of things so okay so here don't know if you can see the so here don't know if you can see the. So here don't know if you can see the link here but I'm basically using link here but I'm basically using . Link here but I'm basically using circum U circum doio if you just circum U circum doio if you just. Circum U circum doio if you just search for it at the installation the search for it at the installation the. Search for it at the installation the getting started guy so circum is a is getting started guy so circum is a is. Getting started guy so circum is a is a tool so a tool so a tool so circum and snjs is a pair of tools. Circum and snjs is a pair of tools circum and snjs is a pair of tools one is for defining the circuit which is. One is for defining the circuit which is one is for defining the circuit which is. A arithmetic relation of what you're a arithmetic relation of what you're a arithmetic relation of what you're. Trying to compute and then snjs is a is trying to compute and then snjs is a is trying to compute and then snjs is a is. A tool that allows you to take in the a tool that allows you to take in the a tool that allows you to take in the. Circuit and and do all kinds of circuit and and do all kinds of circuit and and do all kinds of. Computations and generate the proof and computations and generate the proof and computations and generate the proof and. Also verify the proof so what we're also verify the proof so what we're also verify the proof so what we're. Doing is we're going to just follow doing is we're going to just follow doing is we're going to just follow. This exact guide here this exact guide here this exact guide here generate Define the circuit do all. Generate Define the circuit do all generate Define the circuit do all the setup necessary generate the proof. The setup necessary generate the proof the setup necessary generate the proof and then once we have the proof we will. And then once we have the proof we will and then once we have the proof we will write our own contract to verify it. Write our own contract to verify it write our own contract to verify it in soron instead of verified in. In soron instead of verified in in soron instead of verified in snjs okay so let's. Screen all right hope you can see screen all right hope you can see my both of my. My both of my my both of my screens so so I did little bit of screens so so I did little bit of. Screens so so I did little bit of preparation so here's a brand new preparation so here's a brand new. Preparation so here's a brand new folder I have these two files these folder I have these two files these. Folder I have these two files these are the exact instructions here it tells are the exact instructions here it tells. Are the exact instructions here it tells you to copy the input copy the circle I you to copy the input copy the circle I. You to copy the input copy the circle I just did in advents so we don't have to just did in advents so we don't have to. Just did in advents so we don't have to go through that so the first thing it go through that so the first thing it. Go through that so the first thing it wants you to do is to install these wants you to do is to install these. Wants you to do is to install these dependencies which I already did so we dependencies which I already did so we. Dependencies which I already did so we can skip that and the second one is that can skip that and the second one is that. Can skip that and the second one is that it tells you to Define the circuit. it tells you to Define the circuit it tells you to Define the circuit. In the circum language the the circle is in the circum language the the circle is. In the circum language the the circle is really simple it's the simplest you really simple it's the simplest you. Really simple it's the simplest you can get basically multiplying two can get basically multiplying two. Can get basically multiplying two numbers and then and then output the the numbers and then and then output the the. Numbers and then and then output the the result of the result of the result of the. Multiplication however the the multiplication however the the multiplication however the the . Interesting part is that these inputs A interesting part is that these inputs A interesting part is that these inputs A. And B are private inputs so in the and B are private inputs so in the and B are private inputs so in the. End your proof will prove that this end your proof will prove that this end your proof will prove that this. Computation was done correctly computation was done correctly computation was done correctly . Without revealing What A and B is so without revealing What A and B is so without revealing What A and B is so. Only the only public output will be C only the only public output will be C . Only the only public output will be C the the number the result of the the the number the result of the. The the number the result of the multiplication so what we what we did multiplication so what we what we did. Multiplication so what we what we did here is just copy this exact program here is just copy this exact program . Here is just copy this exact program into this multiplier file and then the next. File and then the next one compiling the circuit so yeah so one compiling the circuit so yeah so. One compiling the circuit so yeah so scales gives you the the Circ scales gives you the the Circ. Scales gives you the the Circ instructions how to do that so this instructions how to do that so this. Instructions how to do that so this is basically just writing this circuit is basically just writing this circuit. Is basically just writing this circuit in in in some formats and so that it in in in some formats and so that it. In in in some formats and so that it can can be understood by the other can can be understood by the other. Can can be understood by the other tools tools tools but there's one thing we have to. but there's one thing we have to but there's one thing we have to change on this. Command which is BRS command which is BRS 12381 so the reason that we need to 12381 so the reason that we need to. 12381 so the reason that we need to specify this is the the circuit specify this is the the circuit. Specify this is the the circuit compilation needs to know the range compilation needs to know the range. Compilation needs to know the range of like the the the range of prime of like the the the range of prime. Of like the the the range of prime number so it needs to take the prime the number so it needs to take the prime the. Number so it needs to take the prime the prime number the 3 381 one bit number. Prime number the 3 381 one bit number prime number the 3 381 one bit number. Associated with with our curve right associated with with our curve right associated with with our curve right. This B 12 31 and use that as a as as a this B 12 31 and use that as a as as a this B 12 31 and use that as a as as a. Curve to generate this circuit otherwise curve to generate this circuit otherwise. Curve to generate this circuit otherwise it I don't know what happens although I it I don't know what happens although I. It I don't know what happens although I haven't tried but you should you should haven't tried but you should you should. Haven't tried but you should you should do that so once you do that it will do that so once you do that it will. Do that so once you do that it will generate the multiplier in this R1 CS generate the multiplier in this R1 CS. Generate the multiplier in this R1 CS format and then some other stuff so the format and then some other stuff so the. Format and then some other stuff so the R1 CS is a rank one constraint system R1 CS is a rank one constraint system . R1 CS is a rank one constraint system why is it called so so think of any why is it called so so think of any. Why is it called so so think of any complex computation like a a know a squ complex computation like a a know a squ. Complex computation like a a know a squ * Bal C something like that you can * Bal C something like that you can. * Bal C something like that you can always break it down into simpler always break it down into simpler. Always break it down into simpler computation by creating intermediate computation by creating intermediate. Computation by creating intermediate Gates and then assigning intermediate Gates and then assigning intermediate. Gates and then assigning intermediate gates to you know more intermediate and gates to you know more intermediate and. Gates to you know more intermediate and then like in the end you you just then like in the end you you just. Then like in the end you you just compute two things to an output compute two things to an output. Compute two things to an output so so the the the process of R1 CS is so so the the the process of R1 CS is. So so the the the process of R1 CS is just comp deconstruct a complex just comp deconstruct a complex. Just comp deconstruct a complex computation in something into something computation in something into something. Computation in something into something simple as a left left hand side times simple as a left left hand side times. Simple as a left left hand side times right hand side equals an output whereas right hand side equals an output whereas. Right hand side equals an output whereas both left hand side right hand side and both left hand side right hand side and. Both left hand side right hand side and output are rank one which means the output are rank one which means the. Output are rank one which means the highest polinomial degree is one so you highest polinomial degree is one so you. Highest polinomial degree is one so you can have like a plus b but not a can have like a plus b but not a. Can have like a plus b but not a square so that's what it is okay once you do that the next. Is okay once you do that the next step is to compute the witness so so at step is to compute the witness so so at. Step is to compute the witness so so at this point we have the circuit which is this point we have the circuit which is. This point we have the circuit which is our structure of our computation but in our structure of our computation but in. Our structure of our computation but in order to to compute it like in order to order to to compute it like in order to. Order to to compute it like in order to to be verifiable we have to comput it to be verifiable we have to comput it. To be verifiable we have to comput it with some inputs and then generate with some inputs and then generate . With some inputs and then generate the proofs and all that so here is just the proofs and all that so here is just. The proofs and all that so here is just defining the the input I did did here defining the the input I did did here. Defining the the input I did did here which is exactly what it's using so it which is exactly what it's using so it. Which is exactly what it's using so it Tak Tak Tak 3 * 11 so the output will be 33 . 3 * 11 so the output will be 33 3 * 11 so the output will be 33 but we don't we won't know about this. But we don't we won't know about this but we don't we won't know about this three and. Three and three and 11 so once we have that we will enter 11 so once we have that we will enter. 11 so once we have that we will enter the the JS the the JS the the JS. Library okay it's empty right it's Library okay it's empty right it's Library okay it's empty right it's. Generate yeah some other AO generated generate yeah some other AO generated . Generate yeah some other AO generated code to compute stuff so what we do code to compute stuff so what we do. Code to compute stuff so what we do here is here is here is actually copy this one but I'll input. actually copy this one but I'll input actually copy this one but I'll input. This some okay so this one is just generating some okay so this one is just generating. the the witnesses and then you can also do this with and then you can also do this with. C++ and then once you do that you have C++ and then once you do that you have C++ and then once you do that you have. The the witness file I don't think we the the witness file I don't think we. The the witness file I don't think we can load it yet but it's just a can load it yet but it's just a. Can load it yet but it's just a yeah the the witness is just the yeah the the witness is just the. yeah the the witness is just the input basically input basically input basically . Like I think the witness is it private like I think the witness is it private like I think the witness is it private. Or just probably I don't I forgot the or just probably I don't I forgot the or just probably I don't I forgot the. Exact terminology but it's possible that exact terminology but it's possible that. Exact terminology but it's possible that the witness is just a public output U so. The witness is just a public output U so the witness is just a public output U so. So so only the C part 33 is contained in so so only the C part 33 is contained in. So so only the C part 33 is contained in the witness okay now comes to the proving. Witness okay now comes to the proving part so yeah so so here here there's a part so yeah so so here here there's a. Part so yeah so so here here there's a bunch of commands if you do it for the bunch of commands if you do it for the. Bunch of commands if you do it for the first time it will look fairly weird first time it will look fairly weird. First time it will look fairly weird because it's telling you to generate because it's telling you to generate . Because it's telling you to generate a power to ceremony so what what it a power to ceremony so what what it. A power to ceremony so what what it what it really is is so in order to what it really is is so in order to. What it really is is so in order to yeah so in order to compute the proof yeah so in order to compute the proof. Yeah so in order to compute the proof so okay so remember we have the R1 CS so okay so remember we have the R1 CS. So okay so remember we have the R1 CS file and then the R1 CS is just a system file and then the R1 CS is just a system. File and then the R1 CS is just a system with equations of different nodes and. With equations of different nodes and with equations of different nodes and. Then every equation is just a simple then every equation is just a simple then every equation is just a simple. Rank one left right equals output rank one left right equals output rank one left right equals output . Multiplication and and and so the the multiplication and and and so the the multiplication and and and so the the. Next step in order to make that into next step in order to make that into next step in order to make that into. Some kind of provable structure is to some kind of provable structure is to . Some kind of provable structure is to convert this into a qap which is a qu. Convert this into a qap which is a qu convert this into a qap which is a qu. Quadratic arithmetic program what it quadratic arithmetic program what it quadratic arithmetic program what it. Does is to on each side the left right does is to on each side the left right does is to on each side the left right. And output it fits a number of and output it fits a number of and output it fits a number of. Polinomial that evaluate to at polinomial that evaluate to at polinomial that evaluate to at. Certain points so the number of certain points so the number of certain points so the number of. Equations is is a number of constraints equations is is a number of constraints equations is is a number of constraints. And at each constraint the polinomial and at each constraint the polinomial and at each constraint the polinomial. Will evaluate at a different points so will evaluate at a different points so will evaluate at a different points so. To keep them separate and then a pol to keep them separate and then a pol to keep them separate and then a pol. Polinomial is the aggregation of smaller polinomial is the aggregation of smaller. Polinomial is the aggregation of smaller Pol polinomial defined over each unique Pol polinomial defined over each unique. Pol polinomial defined over each unique node so what you what you think in node so what you what you think in. Node so what you what you think in the and is just the and is just the and is just. A instead of left left times right a instead of left left times right a instead of left left times right. Equals output you have a left side equals output you have a left side equals output you have a left side. Polinomial of some degree degree polinomial of some degree degree polinomial of some degree degree. Which which matches the number of which which matches the number of which which matches the number of. Constraints and same for right hand side constraints and same for right hand side. Constraints and same for right hand side and the opposite side and the opposite side . And the opposite side and and in order to to verify this and and in order to to verify this. And and in order to to verify this polinomial computed correctly we so polinomial computed correctly we so. Polinomial computed correctly we so here here's a key here's a key here here's a key here's a key . Here here's a key here's a key concept U is in order to verify the concept U is in order to verify the. Concept U is in order to verify the computational polinomial all you have to computational polinomial all you have to. Computational polinomial all you have to do is to verify the computation of a do is to verify the computation of a. Do is to verify the computation of a polinomial at a single random Point polinomial at a single random Point . Polinomial at a single random Point so this may sound little you know so this may sound little you know. So this may sound little you know counterintuitive in the beginning but if counterintuitive in the beginning but if. Counterintuitive in the beginning but if you if you have polinomial of degree two. You if you have polinomial of degree two you if you have polinomial of degree two. Then there can be only two roots and then there can be only two roots and then there can be only two roots and. Then if you have two polinomial of then if you have two polinomial of then if you have two polinomial of. Degree two you you subtract them degree two you you subtract them degree two you you subtract them. Together it can still only have two together it can still only have two together it can still only have two. Roots so which means that it can the two Roots so which means that it can the two. Roots so which means that it can the two polinomial can only be identical at n polinomial can only be identical at n. Polinomial can only be identical at n number of points where n being the number of points where n being the. Number of points where n being the degree of the polinomial so even if we degree of the polinomial so even if we. Degree of the polinomial so even if we have you know hundreds thousands of have you know hundreds thousands of. Have you know hundreds thousands of constraints in our circuit the space the constraints in our circuit the space the. Constraints in our circuit the space the total space of our of our SN the total space of our of our SN the. Total space of our of our SN the the prime modulus or rather the subgroup the prime modulus or rather the subgroup. The prime modulus or rather the subgroup is 200 200 56 bits long so it is is 200 200 56 bits long so it is. Is 200 200 56 bits long so it is impossible for any Collision to impossible for any Collision to. Impossible for any Collision to happen in in real chance so this this a happen in in real chance so this this a. Happen in in real chance so this this a key concept of how to like how to key concept of how to like how to. Key concept of how to like how to convert this polinomial into a u into a convert this polinomial into a u into a. Convert this polinomial into a u into a non interactive check which is you just non interactive check which is you just. Non interactive check which is you just need to make sure that it's evaluated at need to make sure that it's evaluated at. Need to make sure that it's evaluated at a truly random value and then this a truly random value and then this. A truly random value and then this the verifier or anyone can just take the the verifier or anyone can just take the. The verifier or anyone can just take the output of that and then make sure and output of that and then make sure and. Output of that and then make sure and then check the verification that the then check the verification that the. Then check the verification that the the polinomial equality holds with the polinomial equality holds with. The polinomial equality holds with pairing what we introduce here so pairing what we introduce here so. Pairing what we introduce here so this is what it does so so the power of this is what it does so so the power of. This is what it does so so the power of to here the the long story short is just to here the the long story short is just. To here the the long story short is just the the steps necessary to generate that. The the steps necessary to generate that the the steps necessary to generate that. Random point at which the polinomial are random point at which the polinomial are. Random point at which the polinomial are evaluated that's really what it is so. Evaluated that's really what it is so evaluated that's really what it is so. I'm going to spe speed around through I'm going to spe speed around through I'm going to spe speed around through. These steps here it's not really that these steps here it's not really that. These steps here it's not really that interesting there's a lot of output you interesting there's a lot of output you. Interesting there's a lot of output you can look at it later sorry B 12 sorry B 12. 31 that's the first step contribute to 31 that's the first step contribute to 31 that's the first step contribute to. Ceremony some random text it's going to compute set up some text it's going to compute set up some. ceremony and then the gr 16 requires ceremony and then the gr 16 requires. Ceremony and then the gr 16 requires a a public a Universal setup which is a a public a Universal setup which is. A a public a Universal setup which is for the whole like you have to do once for the whole like you have to do once. For the whole like you have to do once and then the per Circle specific setup and then the per Circle specific setup. And then the per Circle specific setup so that's the second step here so this was the last command prepare. So this was the last command prepare phase two and then yeah phase two and then yeah. Phase two and then yeah just set up the circle specific stuff okay and then stuff okay and then. and then contribute to and then contribute to and then contribute to the another text okay so now we have the. The another text okay so now we have the the another text okay so now we have the. The the proving key and the the the proving key and the the the proving key and the. Verification key set up for this circuit verification key set up for this circuit. Verification key set up for this circuit and the next step is to generate the proof okay so in the end we have this. Proof okay so in the end we have this proof yeah which which contains ter. Yeah which which contains ter terms which is like encrypted evaluation terms which is like encrypted evaluation. Terms which is like encrypted evaluation of polinomial at some public public. Json do we get. Public public. Json do we get that oh I think I sent it to the that oh I think I sent it to the. That oh I think I sent it to the previous folder but yeah the previous folder but yeah the. Previous folder but yeah the public should just have one value here public should just have one value here. Public should just have one value here which is 33 so to verify verify which is 33 so to verify verify. which is 33 so to verify verify a proof to so what what we need to do is. A proof to so what what we need to do is a proof to so what what we need to do is. To write a a to write a a to write a a contract this here it makes really. Contract this here it makes really contract this here it makes really easy for you to do so there's a step. Easy for you to do so there's a step easy for you to do so there's a step where you can call to generate a. Where you can call to generate a where you can call to generate a ethereum u solidity contract for. Ethereum u solidity contract for ethereum u solidity contract for verifying verifying. Verifying and then and then and then four yeah here yeah so the cont itself is it's. Here yeah so the cont itself is it's not that interesting I'm not familiar not that interesting I'm not familiar. Not that interesting I'm not familiar too much with solidity but most of the too much with solidity but most of the. Too much with solidity but most of the logic here is just packing bits into logic here is just packing bits into. Logic here is just packing bits into memories and then in the end it's called memories and then in the end it's called. Memories and then in the end it's called this caring on you know a bunch of terms. This caring on you know a bunch of terms this caring on you know a bunch of terms. So we can easily convert that into a Sor so we can easily convert that into a Sor. So we can easily convert that into a Sor Bond and the output of you know our Bond and the output of you know our. Bond and the output of you know our contract is just this much it it contract is just this much it it. Contract is just this much it it verifies the proof takes a verification verifies the proof takes a verification. Verifies the proof takes a verification key which is some like G1 G2 points key which is some like G1 G2 points. Key which is some like G1 G2 points and then approve which contains also and then approve which contains also. and then approve which contains also points in G1 G2 public signal in this points in G1 G2 public signal in this. Points in G1 G2 public signal in this case just one which is 33 encoded into case just one which is 33 encoded into. Case just one which is 33 encoded into the scale a field the scale a field the scale a field. Number and then aggregate the input number and then aggregate the input number and then aggregate the input. And then yeah construct the back to and then yeah construct the back to and then yeah construct the back to. Check paing and that's really it and check paing and that's really it and check paing and that's really it and. Then I did I copied all of the the then I did I copied all of the the then I did I copied all of the the. Outputs it's a it will be a different outputs it's a it will be a different. Outputs it's a it will be a different one than what we gener earlier because one than what we gener earlier because. One than what we gener earlier because there an entropy I because of the there an entropy I because of the. There an entropy I because of the random randomness but but I did this random randomness but but I did this. Random randomness but but I did this earlier I just copied all these the earlier I just copied all these the. Earlier I just copied all these the the pro the proof part and the ver if the pro the proof part and the ver if. The pro the proof part and the ver if ification key part this is proof and ification key part this is proof and. Ification key part this is proof and then this is the VK and then construct then this is the VK and then construct. Then this is the VK and then construct the the key construct the proof and then the the key construct the proof and then. The the key construct the proof and then just call the verify proof and assert. Just call the verify proof and assert just call the verify proof and assert. That this result must be true because that this result must be true because. That this result must be true because the we've putting you know the output. The we've putting you know the output the we've putting you know the output. At 33 so which is matches our public at 33 so which is matches our public at 33 so which is matches our public. Output so let's run this output so let's run this output so let's run this test okay so it finished and you can see. Test okay so it finished and you can see test okay so it finished and you can see. That this verifying the ZK proof that this verifying the ZK proof that this verifying the ZK proof . Takes around 30 like 41 million CPU takes around 30 like 41 million CPU takes around 30 like 41 million CPU. Instructions it performs four parent instructions it performs four parent instructions it performs four parent. Checks per some addition multiplication checks per some addition multiplication checks per some addition multiplication. In G1 space so if you have more public in G1 space so if you have more public in G1 space so if you have more public. Input then there will be more input then there will be more input then there will be more. Multiplication and additions here but multiplication and additions here but multiplication and additions here but. The pairing is only there's only four the pairing is only there's only four the pairing is only there's only four. Pairing so the so the total CPU is pairing so the so the total CPU is pairing so the so the total CPU is. Roughly this this amount yeah I think roughly this this amount yeah I think. Roughly this this amount yeah I think that's it sorry for taking longer that's it sorry for taking longer. That's it sorry for taking longer than expected but this is it and than expected but this is it and. Than expected but this is it and hopefully that you can see that this is hopefully that you can see that this is. Hopefully that you can see that this is this is you know exciting stuff this is you know exciting stuff. this is you know exciting stuff that you can use to build DK that you can use to build DK. That you can use to build DK application today you may ask what's the application today you may ask what's the. Application today you may ask what's the use of it you know the real use of it you know the real. Use of it you know the real interesting part is is in the circuit interesting part is is in the circuit. Interesting part is is in the circuit part so instead of proving you know a part so instead of proving you know a. Part so instead of proving you know a b and c you can write a much b and c you can write a much . B and c you can write a much interesting one like you know proving interesting one like you know proving. Interesting one like you know proving hash like comput computation of a hash hash like comput computation of a hash. Hash like comput computation of a hash or or knowing a pass in a Merle tree or or knowing a pass in a Merle tree. Or or knowing a pass in a Merle tree which is like proof of possession or which is like proof of possession or. Which is like proof of possession or something like that so all the something like that so all the. Something like that so all the Innovations you know a lot of it can can Innovations you know a lot of it can can. Innovations you know a lot of it can can happen on the Contra side which is what happen on the Contra side which is what. Happen on the Contra side which is what you guys you know are that that stuff you guys you know are that that stuff. You guys you know are that that stuff so yeah really looking forward to so yeah really looking forward to . So yeah really looking forward to seeing what comes out of it and yeah seeing what comes out of it and yeah . Seeing what comes out of it and yeah let me know if you have questions we let me know if you have questions we. Let me know if you have questions we also have a Discord threat feel free to also have a Discord threat feel free to. Also have a Discord threat feel free to post it there and I'll hand it over to post it there and I'll hand it over to. Post it there and I'll hand it over to cin great thank you so much this was cin great thank you so much this was . Cin great thank you so much this was this was really good I think the this was really good I think the. This was really good I think the examples and and walking through the examples and and walking through the. Examples and and walking through the code really made it U easier to code really made it U easier to. Code really made it U easier to understand and and see see potential understand and and see see potential. Understand and and see see potential with so I know we have one question with so I know we have one question . With so I know we have one question let me see Elliot was asking a question let me see Elliot was asking a question. Let me see Elliot was asking a question earlier about if the host functions are earlier about if the host functions are. Earlier about if the host functions are all that's needed for CK snarks on all that's needed for CK snarks on. All that's needed for CK snarks on Stellar or if there's still additional Stellar or if there's still additional. Stellar or if there's still additional functionality that's missing I don't functionality that's missing I don't. Functionality that's missing I don't know if you have an answer for that yeah know if you have an answer for that yeah. Know if you have an answer for that yeah to to verify the SN it's all we need to to verify the SN it's all we need . To to verify the SN it's all we need okay so there there are some some quoes okay so there there are some some quoes. Okay so there there are some some quoes in SDK which we we we build it like in in SDK which we we we build it like in. In SDK which we we we build it like in the like we provide the the the most the like we provide the the the most. The like we provide the the the most generic like interface to expose this generic like interface to expose this. Generic like interface to expose this for but there's a little bit corks like for but there's a little bit corks like. For but there's a little bit corks like you like for example ear U see in order you like for example ear U see in order. You like for example ear U see in order to try to store that I have to store to try to store that I have to store. To try to store that I have to store the Bice instead of the G1 G2 but that's the Bice instead of the G1 G2 but that's. The Bice instead of the G1 G2 but that's the fix and also to compute the the fix and also to compute the . The fix and also to compute the negation of a point you have to do it negation of a point you have to do it. Negation of a point you have to do it on the contract side but yeah in on the contract side but yeah in. On the contract side but yeah in terms of verification all the tools are terms of verification all the tools are. Terms of verification all the tools are there but there may be some ux gap there but there may be some ux gap. There but there may be some ux gap which I'm discovering and should be which I'm discovering and should be. Which I'm discovering and should be fixing soon and also with your guys help fixing soon and also with your guys help. Fixing soon and also with your guys help we will be able to make it better yeah we will be able to make it better yeah. We will be able to make it better yeah but in terms of verification that's it but in terms of verification that's it. But in terms of verification that's it but in terms of pro proving so as you but in terms of pro proving so as you. But in terms of pro proving so as you see proving has to happen offchain and see proving has to happen offchain and. See proving has to happen offchain and then that's quite elaborate toour set then that's quite elaborate toour set. Then that's quite elaborate toour set and also like different Suites of and also like different Suites of . And also like different Suites of you know there's different Frameworks of you know there's different Frameworks of. You know there's different Frameworks of U like Marin you know gr 16 Plank and. U like Marin you know gr 16 Plank and U like Marin you know gr 16 Plank and. And all the other other tools that you and all the other other tools that you and all the other other tools that you. Can use so we haven't provide any of can use so we haven't provide any of can use so we haven't provide any of. That and we don't endorse any of it I that and we don't endorse any of it I. That and we don't endorse any of it I was just using the snjs as a example was just using the snjs as a example. Was just using the snjs as a example because that's one of the you know most because that's one of the you know most. Because that's one of the you know most well known and then yeah that also well known and then yeah that also. Well known and then yeah that also the the public ceremony aspect yeah the the public ceremony aspect yeah. The the public ceremony aspect yeah we don't have it on chain so but yeah we don't have it on chain so but yeah. We don't have it on chain so but yeah you can verify it but not there's no you can verify it but not there's no. You can verify it but not there's no proving tour CH available at the proving tour CH available at the. Proving tour CH available at the moment okay great any any other moment okay great any any other. Moment okay great any any other questions feel free to put them in the chat I don't. Chat I don't think that's the case think that's the case think that's the case we are kind of running out of time so. we are kind of running out of time so we are kind of running out of time so. I will save the the walk through of will save the the walk through of will save the the walk through of. Quick start for the next meeting but quick start for the next meeting but quick start for the next meeting but. Yeah if there's no other questions then yeah if there's no other questions then yeah if there's no other questions then. I think I think I think U we will stop it right here let's see see yeah yeah yeah. Okay well thank you Jay thank you for okay well thank you Jay thank you for okay well thank you Jay thank you for. For for for your presentation it was for for for your presentation it was for for for your presentation it was. Really good I think I think going really good I think I think going really good I think I think going. Forward when we when we add new forward when we when we add new forward when we when we add new. Functionality in in protocol when we functionality in in protocol when we functionality in in protocol when we . Upgrade the network I think it's it's upgrade the network I think it's it's upgrade the network I think it's it's. Relevant to to maybe spend some time in relevant to to maybe spend some time in relevant to to maybe spend some time in. In these meetings to to go over some of in these meetings to to go over some of in these meetings to to go over some of. The new new functionality and some of the new new functionality and some of the new new functionality and some of. The the things we can do as a developer the the things we can do as a developer the the things we can do as a developer. so yeah look forward to to more of so yeah look forward to to more of. so yeah look forward to to more of this kind of presentations but thank you. This kind of presentations but thank you this kind of presentations but thank you. J Jay and thank you for everyone who J Jay and thank you for everyone who J Jay and thank you for everyone who. Joined have a good holiday thank you you joined have a good holiday thank you you. Joined have a good holiday thank you you guys happy holiday bye.

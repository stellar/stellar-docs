 the first is partial stay archival the first is partial stay archival cap 62 and then in memory Soroban. Cap 62 and then in memory Soroban cap 62 and then in memory Soroban state for cap 66 and no Tom I will never. State for cap 66 and no Tom I will never state for cap 66 and no Tom I will never. Stop using in Centric Linux distro cool stop using in Centric Linux distro cool stop using in Centric Linux distro cool. So I guess before I get started guess so I guess before I get started guess. So I guess before I get started guess a little bit of background so a little bit of background so. A little bit of background so protocol 23 is kind of where the protocol 23 is kind of where the. Protocol 23 is kind of where the rubber is going to start hitting the rubber is going to start hitting the. Rubber is going to start hitting the road as far as state archival is road as far as state archival is. Road as far as state archival is concerned so kind of some you know concerned so kind of some you know. Concerned so kind of some you know background to you when soron launched we background to you when soron launched we. Background to you when soron launched we of course had the interface for state of course had the interface for state. Of course had the interface for state archival with rent and all those sort archival with rent and all those sort. Archival with rent and all those sort of stuff with the intention that of stuff with the intention that. Of stuff with the intention that eventually entries that have run out of eventually entries that have run out of. Eventually entries that have run out of rent will be archived and then removed rent will be archived and then removed. Rent will be archived and then removed from validators in order to free up from validators in order to free up. From validators in order to free up space so you don't have you know the space so you don't have you know the. Space so you don't have you know the issues that come with large amounts issues that come with large amounts. Issues that come with large amounts of state that have to be of state that have to be. Of state that have to be maintained and so that's kind of maintained and so that's kind of. Maintained and so that's kind of where we're going now today the where we're going now today the. Where we're going now today the interface is such that you still pay interface is such that you still pay. Interface is such that you still pay rent you still have to issue restores rent you still have to issue restores. Rent you still have to issue restores and all the sort of things things but and all the sort of things things but. And all the sort of things things but the data is not actually yet removed the data is not actually yet removed. The data is not actually yet removed from from from validators and so that's where we're. Validators and so that's where we're validators and so that's where we're going so initially the plan was for. Going so initially the plan was for going so initially the plan was for protocol 23 was to have what we're. Protocol 23 was to have what we're protocol 23 was to have what we're calling full State archival and in full. Calling full State archival and in full calling full State archival and in full State archival what happens is . State archival what happens is State archival what happens is entries once they have run out of. Entries once they have run out of entries once they have run out of rent be removed from the live State. Rent be removed from the live State rent be removed from the live State and then they are added to this. And then they are added to this and then they are added to this temporary data store called the hot. Temporary data store called the hot temporary data store called the hot archive and the hot archive is still. Archive and the hot archive is still archive and the hot archive is still maintained by all validators but it's. Maintained by all validators but it's maintained by all validators but it's just a separate database that just. Just a separate database that just just a separate database that just maintains entries that have been. Maintains entries that have been maintains entries that have been recently archived the thinking being. Recently archived the thinking being recently archived the thinking being was that eventually this hot archive. Was that eventually this hot archive was that eventually this hot archive would become full and when the hot. Would become full and when the hot would become full and when the hot archive is full what you would do is you. Archive is full what you would do is you archive is full what you would do is you. Would create a Merkle tree of that would create a Merkle tree of that would create a Merkle tree of that. Data validators would maintain the data validators would maintain the data validators would maintain the. Merkel rout and then delete all the Merkel rout and then delete all the Merkel rout and then delete all the . Information in the hot archive and then information in the hot archive and then information in the hot archive and then. You just repeat this process iteratively you just repeat this process iteratively. You just repeat this process iteratively so essentially you evict entries from. So essentially you evict entries from so essentially you evict entries from. The live state to the hot archive state the live state to the hot archive state the live state to the hot archive state. Eventually that hot archive cach will eventually that hot archive cach will eventually that hot archive cach will. Become full and then you'll actually become full and then you'll actually become full and then you'll actually. Delete and remove those entries from the delete and remove those entries from the. Delete and remove those entries from the validator and then the restoration validator and then the restoration. Validator and then the restoration process once an entry has been archived process once an entry has been archived. Process once an entry has been archived in this way if it no longer lives in the in this way if it no longer lives in the. In this way if it no longer lives in the validator there's like a Merkel style validator there's like a Merkel style. Validator there's like a Merkel style proving scheme to which you are able proving scheme to which you are able. Proving scheme to which you are able to restore an entry back to the live ler to restore an entry back to the live ler. To restore an entry back to the live ler state so that's kind of what we consider. State so that's kind of what we consider state so that's kind of what we consider. Full state archival which is where full state archival which is where full state archival which is where. Entries actually get deleted from entries actually get deleted from entries actually get deleted from. Validators but thinking about this validators but thinking about this validators but thinking about this. Problem a little bit more and looking at problem a little bit more and looking at. Problem a little bit more and looking at the current metrics of soron it seems. The current metrics of soron it seems the current metrics of soron it seems. That we're still a little too early for that we're still a little too early for that we're still a little too early for. This full C archival I think long term this full C archival I think long term this full C archival I think long term. If you look at smart contract if you look at smart contract if you look at smart contract. Platforms that have large amounts of platforms that have large amounts of platforms that have large amounts of. State there are significant issues with State there are significant issues with State there are significant issues with. Maintaining all that state you have maintaining all that state you have maintaining all that state you have . Lots of you know Hardware lots of you know Hardware lots of you know Hardware. Requirements on a network like salana to requirements on a network like salana to. Requirements on a network like salana to maintain large amounts of cashes and maintain large amounts of cashes and. Maintain large amounts of cashes and then you have a networks like then you have a networks like. Then you have a networks like ethereum that don't have large hard ethereum that don't have large hard. Ethereum that don't have large hard requirements but they're very slow just requirements but they're very slow just. Requirements but they're very slow just due to maintaining these very large due to maintaining these very large. Due to maintaining these very large databases so long term at scale I think databases so long term at scale I think. Databases so long term at scale I think it's still very important to have the it's still very important to have the. It's still very important to have the full State archival solution where full State archival solution where. Full State archival solution where entries are deleted from validators and entries are deleted from validators and. Entries are deleted from validators and then restored VI proving schemes but then restored VI proving schemes but. Then restored VI proving schemes but the reality of the situation is we're the reality of the situation is we're. The reality of the situation is we're not quite there yet and I think that not quite there yet and I think that. Not quite there yet and I think that currently there is less than a gigabyte currently there is less than a gigabyte. Currently there is less than a gigabyte of soron state currently live Stellar of soron state currently live Stellar. Of soron state currently live Stellar and so going through all these hoops and so going through all these hoops. And so going through all these hoops and adding all this complexity for and adding all this complexity for. And adding all this complexity for this proving scheme just to delete a this proving scheme just to delete a. This proving scheme just to delete a small amount of data isn't really small amount of data isn't really . Small amount of data isn't really worthwhile at this point and so that's worthwhile at this point and so that's. Worthwhile at this point and so that's why for protocol 23 instead of going the why for protocol 23 instead of going the. Why for protocol 23 instead of going the full cival route where we actually full cival route where we actually. Full cival route where we actually delete entries we are doing something delete entries we are doing something . Delete entries we are doing something called or I'm proposing something called. Called or I'm proposing something called called or I'm proposing something called. Partial SE archival and this is what cap partial SE archival and this is what cap. Partial SE archival and this is what cap 62 kind of explains and so in partial. 62 kind of explains and so in partial 62 kind of explains and so in partial. State archival what we do is we do kind State archival what we do is we do kind State archival what we do is we do kind. Of the first half of the full state of the first half of the full state of the first half of the full state. Archival so we still maintain two archival so we still maintain two archival so we still maintain two. Different databases on the validator you different databases on the validator you. Different databases on the validator you have the live bucket list which contains. Have the live bucket list which contains have the live bucket list which contains. All of your live state which is the all of your live state which is the all of your live state which is the . The Ledger that exist today and then you The Ledger that exist today and then you. The Ledger that exist today and then you still have a what's called the hot still have a what's called the hot. Still have a what's called the hot archive which is a cache of recently archive which is a cache of recently. Archive which is a cache of recently archived entries and so what you would archived entries and so what you would. Archived entries and so what you would do is that whenever an entry runs out of do is that whenever an entry runs out of. Do is that whenever an entry runs out of rent it would be evicted and removed rent it would be evicted and removed. Rent it would be evicted and removed from the live State and added to this from the live State and added to this . From the live State and added to this hot archive database now the key hot archive database now the key. Hot archive database now the key distinction here with partial stay distinction here with partial stay. Distinction here with partial stay archival is even though you still remove archival is even though you still remove. Archival is even though you still remove things from the live bucket list and add. Things from the live bucket list and add things from the live bucket list and add. Them to to the hot archive you never them to to the hot archive you never them to to the hot archive you never. Actually delete the hot archive the actually delete the hot archive the actually delete the hot archive the. Hot archive never becomes full such that hot archive never becomes full such that. Hot archive never becomes full such that the entries are never actually the entries are never actually. the entries are never actually removed from validators and so it's removed from validators and so it's. Removed from validators and so it's partial St archival because you are partial St archival because you are. Partial St archival because you are still kind of storing live state in one still kind of storing live state in one. Still kind of storing live state in one database and storing archive state in a database and storing archive state in a. Database and storing archive state in a different database but you're not different database but you're not. Different database but you're not actually removing any state from actually removing any state from. Actually removing any state from validators and so I think my current validators and so I think my current. Validators and so I think my current proposal would be in protocol 23 to proposal would be in protocol 23 to. Proposal would be in protocol 23 to implement the partial state archival implement the partial state archival. Implement the partial state archival with the intention of later on in the with the intention of later on in the. With the intention of later on in the future extending this to the full State future extending this to the full State. Future extending this to the full State archival solution the only reason is archival solution the only reason is. Archival solution the only reason is is that I is that I is that I think that for the you can the the. Think that for the you can the the think that for the you can the the. Size at which the the hot archive size at which the the hot archive size at which the the hot archive. Becomes full and becomes deleted is becomes full and becomes deleted is becomes full and becomes deleted is. Configurable and so I think we could configurable and so I think we could configurable and so I think we could. Do something reasonable such as we could do something reasonable such as we could. Do something reasonable such as we could Implement on this St archival solution Implement on this St archival solution. Implement on this St archival solution but we could set the the capacity of but we could set the the capacity of. But we could set the the capacity of the hot archive to something very high the hot archive to something very high. The hot archive to something very high like 50 GB such that it would take a like 50 GB such that it would take a. Like 50 GB such that it would take a long time and a lot of network activity long time and a lot of network activity. Long time and a lot of network activity to actually start deleting State and to actually start deleting State and. to actually start deleting State and then you know if the network was to grow then you know if the network was to grow. Then you know if the network was to grow that much such that we had 50 gigabytes that much such that we had 50 gigabytes. That much such that we had 50 gigabytes of archived sorb on state then it of archived sorb on state then it. Of archived sorb on state then it would actually make more sense to start would actually make more sense to start. Would actually make more sense to start deleting State and requiring proofs for deleting State and requiring proofs for. Deleting State and requiring proofs for all the operational benefit that we get all the operational benefit that we get. All the operational benefit that we get there and so that's kind of the there and so that's kind of the. There and so that's kind of the current proposal of 62 is we're going to current proposal of 62 is we're going to. Current proposal of 62 is we're going to still maintain all information on the still maintain all information on the. Still maintain all information on the validators but we're just going to move validators but we're just going to move. Validators but we're just going to move archived information from one database archived information from one database. Archived information from one database to a different database now the to a different database now the. to a different database now the reason that we want to do this this reason that we want to do this this. Reason that we want to do this this separation of archive State and live separation of archive State and live. Separation of archive State and live state is that it actually opens up a state is that it actually opens up a. State is that it actually opens up a large number of optimizations and so large number of optimizations and so. Large number of optimizations and so that's what we get into in cap 66 which that's what we get into in cap 66 which. That's what we get into in cap 66 which is inmemory Soroban State and so we is inmemory Soroban State and so we. Is inmemory Soroban State and so we can because we have the system where the. Can because we have the system where the can because we have the system where the. Live State or the live bucket list live State or the live bucket list live State or the live bucket list. Holds all classic information and all holds all classic information and all holds all classic information and all. Live soron information and we have a live soron information and we have a live soron information and we have a. Completely separate database that stores completely separate database that stores. Completely separate database that stores all the archive State now because of the. All the archive State now because of the all the archive State now because of the. Rent system and because of the the rent system and because of the the rent system and because of the the. Way that we do write fees you know where way that we do write fees you know where. Way that we do write fees you know where a write fee is a function of the total a write fee is a function of the total. A write fee is a function of the total size of the bucket list we actually have size of the bucket list we actually have. Size of the bucket list we actually have a way to put a soft limit on the amount a way to put a soft limit on the amount. A way to put a soft limit on the amount of live soron State at all times the of live soron State at all times the. Of live soron State at all times the reason being is that you know with the reason being is that you know with the. Reason being is that you know with the the current bucketless size if you the current bucketless size if you. the current bucketless size if you were to add enough life State such that were to add enough life State such that. Were to add enough life State such that you go beyond the target bucka size you go beyond the target bucka size. You go beyond the target bucka size rights become very very expensive such rights become very very expensive such. Rights become very very expensive such that the network users are that the network users are. That the network users are incentivized to allow entries to run out incentivized to allow entries to run out. Incentivized to allow entries to run out of rent and become archived and so of rent and become archived and so. Of rent and become archived and so because of the way our fee system works because of the way our fee system works. Because of the way our fee system works we have a way to essentially have a we have a way to essentially have a. we have a way to essentially have a soft limit on the amount of State in the soft limit on the amount of State in the. Soft limit on the amount of State in the light bucket list at all times and so. Light bucket list at all times and so light bucket list at all times and so. What I'm proposing is to change that fee what I'm proposing is to change that fee. What I'm proposing is to change that fee slightly such that instead of the slightly such that instead of the. Slightly such that instead of the Soroban right fee corresponding to the Soroban right fee corresponding to the. Sorbon right fee corresponding to the size of the entire live leer of both size of the entire live leer of both. Size of the entire live leer of both classic and Soroban entries it only classic and Soroban entries it only. Classic and Soroban entries it only applies to the life soron entries and so applies to the life soron entries and so. Applies to the life soron entries and so essentially the the buckus target essentially the the buckus target. Essentially the the buckus target size instead of being a buckus size size instead of being a buckus size. Size instead of being a buckus size would change to just be the the life would change to just be the the life. Would change to just be the the life soron Target size and I think this is soron Target size and I think this is. Soron Target size and I think this is much more fair given that classic much more fair given that classic. Much more fair given that classic entries don't actually have to pay rent entries don't actually have to pay rent. Entries don't actually have to pay rent yet and so it's a little unfair that yet and so it's a little unfair that. Yet and so it's a little unfair that adding classic entries actually changes adding classic entries actually changes. Adding classic entries actually changes the WR fees and the rent fees for Soroban the WR fees and the rent fees for Soroban. The WR fees and the rent fees for Soroban and especially as the network exists and especially as the network exists. and especially as the network exists today classic State dominates sorant today classic State dominates sorant. Today classic State dominates sorant State size and so changes in sorant State size and so changes in sorant. State size and so changes in sorant usage don't actually really affect soron usage don't actually really affect soron. Usage don't actually really affect soron right fees rather changes in classic right fees rather changes in classic. Right fees rather changes in classic usage affect soron right fees and so by usage affect soron right fees and so by. Usage affect soron right fees and so by changing the The Bucket List Target size changing the The Bucket List Target size. Changing the The Bucket List Target size to a Soroban state instead of just all to a Soroban state instead of just all. To a Soroban state instead of just all total State we have a much more fair total State we have a much more fair. Total State we have a much more fair fee system but what that also allows us fee system but what that also allows us. Fee system but what that also allows us to do is to prioritize live sorup on to do is to prioritize live sorup on. To do is to prioritize live sorup on state above arive state so what do I state above arive state so what do I. State above arive state so what do I mean by that so if we change the the mean by that so if we change the the. Mean by that so if we change the the way that we calculate fees to only look way that we calculate fees to only look. Way that we calculate fees to only look at sbon size we can use the fee system at sbon size we can use the fee system. At sbon size we can use the fee system to enforce a maximum amount of Life to enforce a maximum amount of Life. To enforce a maximum amount of Life State at any time so for instance we State at any time so for instance we. State at any time so for instance we could set the target soron State size to could set the target soron State size to. Could set the target soron State size to 1 Gigabyte and then the fee system would. 1 Gigabyte and then the fee system would 1 Gigabyte and then the fee system would. Ensure that there's not much more than 1 ensure that there's not much more than 1. Ensure that there's not much more than 1 gigabyte of Life Sor on state at a given. Gigabyte of Life Sor on state at a given gigabyte of Life Sor on state at a given. Point now you could maybe you know go a point now you could maybe you know go a point now you could maybe you know go a. Little bit above that if people are little bit above that if people are little bit above that if people are. Willing to pay expensive fees willing to pay expensive fees willing to pay expensive fees. but the way that the fee growth works but the way that the fee growth works. but the way that the fee growth works is that you know you are reasonably is that you know you are reasonably. Is that you know you are reasonably capped to a small amount of state and so capped to a small amount of state and so. Capped to a small amount of state and so because we have the system where the because we have the system where the. Because we have the system where the amount of live sorb on state at any amount of live sorb on state at any. Amount of live sorb on state at any given time is fixed what we can actually given time is fixed what we can actually. Given time is fixed what we can actually do is just store all Soroban state in do is just store all Soroban state in. Do is just store all Soroban state in memory and not have disk access at all memory and not have disk access at all. Memory and not have disk access at all and so that's the current proposal in and so that's the current proposal in. And so that's the current proposal in cap 66 is to prioritize all live cap 66 is to prioritize all live . Cap 66 is to prioritize all live soron state in memory and this is soron state in memory and this is. Soron state in memory and this is made possible because we store live made possible because we store live. Made possible because we store live soron state in one database and archived soron state in one database and archived. Soron state in one database and archived state in a different database and so by state in a different database and so by. State in a different database and so by splitting the state into two separate splitting the state into two separate. Splitting the state into two separate databases we can very easily just databases we can very easily just. Databases we can very easily just iterate over the the live database and iterate over the the live database and. Iterate over the the live database and store all that sorab on state in store all that sorab on state in. Store all that sorab on state in memory and so that's kind of what's memory and so that's kind of what's. Memory and so that's kind of what's Happening behind the scenes as to Happening behind the scenes as to. Happening behind the scenes as to what the the validator is doing what the the validator is doing . What the the validator is doing now we're able to do this because of the now we're able to do this because of the. Now we're able to do this because of the maximum soron State size if we didn't maximum soron State size if we didn't. Maximum soron State size if we didn't have this and if have this and if have this and if. Sorban LIF state was able to grow Soroban LIF state was able to grow Soroban LIF state was able to grow. Unboundedly this would be a very unboundedly this would be a very unboundedly this would be a very. Dangerous optimization because dangerous optimization because dangerous optimization because. Validators might run out of ram but validators might run out of ram but validators might run out of ram but. Because of the St kival system we can because of the St kival system we can because of the St kival system we can. Actually fix the amount of Life State actually fix the amount of Life State actually fix the amount of Life State. And so there's no runaway R risk and so and so there's no runaway R risk and so and so there's no runaway R risk and so. We can very reasonably store all we can very reasonably store all we can very reasonably store all. Soron state in memory and so there soron state in memory and so there soron state in memory and so there. Are some changes we need to make to the are some changes we need to make to the are some changes we need to make to the. developer experience and the user developer experience and the user developer experience and the user. Experience to make this possible so experience to make this possible so experience to make this possible so. First we are going to to change some first we are going to to change some first we are going to to change some. Of the resource types A little bit So of the resource types A little bit So. Of the resource types A little bit So currently today we only have one read currently today we only have one read. Currently today we only have one read resource which is read bites and read resource which is read bites and read. Resource which is read bites and read entries and this assumes that all the entries and this assumes that all the. Entries and this assumes that all the information you're reading is on disk information you're reading is on disk. Information you're reading is on disk and so what we're going to do or what and so what we're going to do or what. And so what we're going to do or what cap 66 proposes is to split this into cap 66 proposes is to split this into. Cap 66 proposes is to split this into two different resource types so they're two different resource types so they're. Two different resource types so they're going to be an explicit inmemory read going to be an explicit inmemory read. Going to be an explicit inmemory read resource and then an explicit on disk resource and then an explicit on disk. Resource and then an explicit on disk read resource now the reason we're doing. Read resource now the reason we're doing read resource now the reason we're doing. This is that even though all Soroban this is that even though all Soroban this is that even though all Soroban. State is or all life soron state is held state is or all life soron state is held. State is or all life soron state is held in memory Soroban contracts can still in memory Soroban contracts can still. In memory Soroban contracts can still access classic State and classic State access classic State and classic State. Access classic State and classic State needs to be on disk now because classic needs to be on disk now because classic. Needs to be on disk now because classic entries aren't subject to State archival entries aren't subject to State archival. Entries aren't subject to State archival they have the runaway Ram risk and so. They have the runaway Ram risk and so they have the runaway Ram risk and so. We can't store classic entries in memory we can't store classic entries in memory. We can't store classic entries in memory and so Soroban contracts will still. And so Soroban contracts will still and so Soroban contracts will still. Have to pay disk fees for for classic have to pay disk fees for for classic have to pay disk fees for for classic. State that's exist additionally we're State that's exist additionally we're State that's exist additionally we're. Only storing live state in memory and so only storing live state in memory and so. Only storing live state in memory and so if you access archive state for example if you access archive state for example. If you access archive state for example a restore operation then you would still a restore operation then you would still. A restore operation then you would still have to do dis reads and so there's a have to do dis reads and so there's a. Have to do dis reads and so there's a dis vew for that but essentially what dis vew for that but essentially what. Dis vew for that but essentially what would be changed is that you would would be changed is that you would . Would be changed is that you would there would be a network limit for the there would be a network limit for the. There would be a network limit for the maximum number of on disk read maximum number of on disk read. maximum number of on disk read entries as well as the maximum number entries as well as the maximum number. Entries as well as the maximum number of inmemory read entries now that being of inmemory read entries now that being. Of inmemory read entries now that being said because the inmemory reads are a said because the inmemory reads are a. Said because the inmemory reads are a lot cheaper than the on disk reads we lot cheaper than the on disk reads we. Lot cheaper than the on disk reads we can actually pass aot that savings down can actually pass aot that savings down. Can actually pass aot that savings down to the user so in this proposal to the user so in this proposal . To the user so in this proposal there would actually be no in memory there would actually be no in memory . There would actually be no in memory read bites limit so essentially the read bites limit so essentially the. Read bites limit so essentially the read limit for Life s on state would read limit for Life s on state would. Read limit for Life s on state would just completely go away because in just completely go away because in. Just completely go away because in memory reads are cheap and so there's no memory reads are cheap and so there's no. Memory reads are cheap and so there's no reason to limit that now we would reason to limit that now we would. Reason to limit that now we would still limit the total number of entries still limit the total number of entries. Still limit the total number of entries being read but the bytes being read being read but the bytes being read. Being read but the bytes being read would not be limited additionally would not be limited additionally . Would not be limited additionally because we're not doing dis access because we're not doing dis access . Because we're not doing dis access there would no longer be a read fee there would no longer be a read fee. There would no longer be a read fee associated with accessing Sor on State associated with accessing Sor on State. Associated with accessing Sor on State and so because you you still have to and so because you you still have to. And so because you you still have to pay like a instruction like CPU pay like a instruction like CPU . Pay like a instruction like CPU count and things like that to actually count and things like that to actually. Count and things like that to actually process large amounts of data but process large amounts of data but. Process large amounts of data but because we're not going to disk there because we're not going to disk there. Because we're not going to disk there doesn't need to be an explicit fee or doesn't need to be an explicit fee or. Doesn't need to be an explicit fee or resource for that and so essentially resource for that and so essentially. Resource for that and so essentially for live SW on state you don't have for live SW on state you don't have. for live SW on state you don't have to pay for reads and you can read as to pay for reads and you can read as. To pay for reads and you can read as many bytes as you want you still have many bytes as you want you still have. Many bytes as you want you still have to pay for the CPU though so it's still to pay for the CPU though so it's still. To pay for the CPU though so it's still an implicit fee but there's no explicit an implicit fee but there's no explicit. An implicit fee but there's no explicit read fee and so that's kind of the read fee and so that's kind of the. Read fee and so that's kind of the First Advantage to the inmemory versus First Advantage to the inmemory versus. First Advantage to the inmemory versus on disk resource now the second thing on disk resource now the second thing. On disk resource now the second thing this allows us to do is is also this allows us to do is is also. This allows us to do is is also Implement autor restore functionality Implement autor restore functionality. Implement autor restore functionality and so previously when we first and so previously when we first. And so previously when we first launched Soroban we weren't sure what the launched Soroban we weren't sure what the. Launched Soroban we weren't sure what the final State archival proof system was final State archival proof system was. Final State archival proof system was going to look like and so while from a going to look like and so while from a. Going to look like and so while from a technological or from a technical technological or from a technical. Technological or from a technical standpoint there was no reason to standpoint there was no reason to. Standpoint there was no reason to require a separate restore operation require a separate restore operation. Require a separate restore operation and a separate invoke host function and a separate invoke host function. And a separate invoke host function operation we did that just to give us operation we did that just to give us. Operation we did that just to give us flexibility later on in case the proof flexibility later on in case the proof. Flexibility later on in case the proof system turned out to be very involved system turned out to be very involved . System turned out to be very involved but in cap 57 we've actually outlined a but in cap 57 we've actually outlined a. But in cap 57 we've actually outlined a pretty lightweight proof system that pretty lightweight proof system that. Pretty lightweight proof system that works with invoke host function and so works with invoke host function and so. Works with invoke host function and so what we're going to do in cap 66 is what we're going to do in cap 66 is. What we're going to do in cap 66 is we're going to allow automatic restore we're going to allow automatic restore. We're going to allow automatic restore and so what this means is that you no and so what this means is that you no. And so what this means is that you no longer will have to issue a restore longer will have to issue a restore. Longer will have to issue a restore operation prior to your invo host operation prior to your invo host. Operation prior to your invo host function but actually your invo host function but actually your invo host. Function but actually your invo host function operation will just function operation will just. Function operation will just automatically restore any archive automatically restore any archive. Automatically restore any archive keys that are in the footprint and so keys that are in the footprint and so . Keys that are in the footprint and so this you know reduces the transaction this you know reduces the transaction. This you know reduces the transaction count required reduces fees and should count required reduces fees and should. Count required reduces fees and should just offer a much better user experience just offer a much better user experience. Just offer a much better user experience now the the way this works in resources now the the way this works in resources. Now the the way this works in resources though is that like I mentioned before though is that like I mentioned before. Though is that like I mentioned before the live Soroban state is all cached the live Soroban state is all cached. The live Soroban state is all cached in memory in one database and archive in memory in one database and archive. In memory in one database and archive state is uncached and on dis in a state is uncached and on dis in a. State is uncached and on dis in a separate database and so if you call separate database and so if you call. Separate database and so if you call info Coast function and every entry info Coast function and every entry. Info Coast function and every entry you're using is currently live you're using is currently live. You're using is currently live then you would have the free inmemory then you would have the free inmemory. Then you would have the free inmemory resource bites and you wouldn't have to resource bites and you wouldn't have to. Resource bites and you wouldn't have to pay for dis that being said if you're pay for dis that being said if you're. Pay for dis that being said if you're using automatic restore the entries using automatic restore the entries. Using automatic restore the entries being restored would come out of the being restored would come out of the. Being restored would come out of the disk read bytes and would be charged disk read bytes and would be charged . Disk read bytes and would be charged disk fees because again for the the disk fees because again for the the. Disk fees because again for the the entries that are archived and live in entries that are archived and live in. Entries that are archived and live in the hot archive database those do have the hot archive database those do have. The hot archive database those do have to be read off a to be read off a to be read off a. Disk and so I think that's kind of a disk and so I think that's kind of a disk and so I think that's kind of a. kind of at the high level of what kind of at the high level of what kind of at the high level of what. We're proposing kind of you know the we're proposing kind of you know the we're proposing kind of you know the. Tldr except been talking for for a tldr except been talking for for a tldr except been talking for for a. Little bit is that you know C the little bit is that you know C the little bit is that you know C the. Archived entries live in their own archived entries live in their own archived entries live in their own. Database and live sbond State lives in database and live sbond State lives in database and live sbond State lives in. the separate dat or a live database the separate dat or a live database the separate dat or a live database. we are then going to Cache all the we are then going to Cache all the. we are then going to Cache all the sbond state in the live database in sbond state in the live database in. Sbond state in the live database in order to pass that savings on to you order to pass that savings on to you. Order to pass that savings on to you there will be an inmemory rebite limit there will be an inmemory rebite limit. There will be an inmemory rebite limit and an on disk rebite limit in fee and an on disk rebite limit in fee. And an on disk rebite limit in fee and then finally there will be and then finally there will be. And then finally there will be automatic restore to you know automatic restore to you know. Automatic restore to you know essentially remove the need for the essentially remove the need for the. Essentially remove the need for the restore operation in most cases so I guess are there there any. Cases so I guess are there there any questions or any conversation points questions or any conversation points. Questions or any conversation points we'd like to touch on more looks like there's a question in. More looks like there's a question in in the this in the chat the chat box in the this in the chat the chat box. In the this in the chat the chat box but I think a lot of daps and but I think a lot of daps and . But I think a lot of daps and extend TTL by default will that still be extend TTL by default will that still be. Extend TTL by default will that still be necessary necessary necessary ah yeah so I think so just because we. Ah yeah so I think so just because we ah yeah so I think so just because we. Have automatic restore doesn't mean that have automatic restore doesn't mean that. Have automatic restore doesn't mean that you don't want to still manage your TTL you don't want to still manage your TTL. You don't want to still manage your TTL and so like I managed before if all the and so like I managed before if all the. And so like I managed before if all the entries that you're using are entries that you're using are. Entries that you're using are currently live then what're or then currently live then what're or then. Currently live then what're or then you don't have to pay read fees and you don't have to pay read fees and. You don't have to pay read fees and you have much larger read you have much larger read. You have much larger read limits and so you are still limits and so you are still. Limits and so you are still incentivized to pay rent also so but incentivized to pay rent also so but. Incentivized to pay rent also so but the issue is when you restore when you the issue is when you restore when you. The issue is when you restore when you restore something you have to pay right restore something you have to pay right. Restore something you have to pay right fees for the restoration and you also fees for the restoration and you also. Fees for the restoration and you also have to pay discre fees for the have to pay discre fees for the. Have to pay discre fees for the restoration and so I think from a restoration and so I think from a . Restoration and so I think from a from a fees perspective if you're using from a fees perspective if you're using. From a fees perspective if you're using an entry a lot it's still in your best an entry a lot it's still in your best. An entry a lot it's still in your best interest to extend the TTL to save interest to extend the TTL to save. Interest to extend the TTL to save money as you know even BEC just money as you know even BEC just. Money as you know even BEC just because the restore is automatic do not because the restore is automatic do not. Because the restore is automatic do not make mean it's free and so you still make mean it's free and so you still. Make mean it's free and so you still have to pay for that restore and even have to pay for that restore and even. Have to pay for that restore and even if it's the same invo Coast function an if it's the same invo Coast function an. If it's the same invo Coast function an invo Coast function invoking a invo Coast function invoking a. Invo Coast function invoking a function that only accesses live function that only accesses live. Function that only accesses live state is significantly less expensive state is significantly less expensive. State is significantly less expensive than invoking a host function that has a than invoking a host function that has a. Than invoking a host function that has a automatic restore on the front end of automatic restore on the front end of. Automatic restore on the front end of that so we still definitely want to that so we still definitely want to. That so we still definitely want to extent extent extent TL yeah let's yeah let's. See oh so for OrbitLens will it be see oh so for OrbitLens will it be see oh so for OrbitLens will it be. Possible to tell in advance whether the possible to tell in advance whether the possible to tell in advance whether the. Entry will be automatically restored entry will be automatically restored entry will be automatically restored. During the simulation yes and so this during the simulation yes and so this. During the simulation yes and so this is kind of more of the implement is kind of more of the implement. Is kind of more of the implement details which are included in the cap details which are included in the cap . Details which are included in the cap but what we're doing is captive core has. But what we're doing is captive core has but what we're doing is captive core has. Recently added a couple of HTTP n recently added a couple of HTTP n recently added a couple of HTTP n. Points for querying Ledger State that points for querying Ledger State that. Points for querying Ledger State that will be used by RPC in order to will be used by RPC in order to. Will be used by RPC in order to simulate transactions correctly and so simulate transactions correctly and so. Simulate transactions correctly and so essentially this endpoint is a high essentially this endpoint is a high. Essentially this endpoint is a high performance you know multi-thread HTTP performance you know multi-thread HTTP. Performance you know multi-thread HTTP endpoint that has a similar endpoint that has a similar. Endpoint that has a similar performance to a SQL table queries performance to a SQL table queries. Performance to a SQL table queries and so it should be appropriate for for and so it should be appropriate for for. And so it should be appropriate for for production use cases and what this production use cases and what this. Production use cases and what this endpoint will do is it's a key value endpoint will do is it's a key value. Endpoint will do is it's a key value search where for every key you provide search where for every key you provide. Search where for every key you provide it it will tell you if that key it it will tell you if that key. It it will tell you if that key exists and then if it exists it'll give exists and then if it exists it'll give. Exists and then if it exists it'll give you the value and then it will also you the value and then it will also. You the value and then it will also give you meta information about that key give you meta information about that key. Give you meta information about that key and so it will give you the Ledger entry. And so it will give you the Ledger entry and so it will give you the Ledger entry. It will tell you if it's live or it will tell you if it's live or it will tell you if it's live or. Archived and then it will also tell archived and then it will also tell archived and then it will also tell. You you know what its current TTL you you know what its current TTL you you know what its current TTL. Value is and if it's in memory or on value is and if it's in memory or on value is and if it's in memory or on. Disk and so the captive core endpoint disk and so the captive core endpoint . Disk and so the captive core endpoint is kind of Ed to be the new kind of is kind of Ed to be the new kind of. Is kind of Ed to be the new kind of entry point for this information and entry point for this information and. Entry point for this information and so you should be able to query the so you should be able to query the. So you should be able to query the current archival state and the current current archival state and the current. Current archival state and the current in memory versus on dis state of any in memory versus on dis state of any. In memory versus on dis state of any entry directly via captive core again entry directly via captive core again. Entry directly via captive core again there's also meta that we're emitting there's also meta that we're emitting. There's also meta that we're emitting for all these events so if you wanted to for all these events so if you wanted to. For all these events so if you wanted to it's theoretically possible to injust it's theoretically possible to injust. It's theoretically possible to injust meta and maintain the state of Soroban meta and maintain the state of Soroban . Meta and maintain the state of Soroban entries that way but if you don't entries that way but if you don't. Entries that way but if you don't want to do that and create your own SQL want to do that and create your own SQL. Want to do that and create your own SQL table and Pipeline and pipeline you can table and Pipeline and pipeline you can. Table and Pipeline and pipeline you can just use the the captive core htpn points so will automatic restore. Points so will automatic restore become automatically available for become automatically available for. Become automatically available for existing contracts yes so the this is existing contracts yes so the this is. Existing contracts yes so the this is all handled at the RPC level and so all handled at the RPC level and so. All handled at the RPC level and so the essentially what's changing is that the essentially what's changing is that. The essentially what's changing is that with protocol 23 and this is detailed with protocol 23 and this is detailed. With protocol 23 and this is detailed in cap 66 specifically in cap 66 specifically. In cap 66 specifically is that we are changing the footprint to is that we are changing the footprint to. Is that we are changing the footprint to have this field where you distinguish. have this field where you distinguish have this field where you distinguish. In the footprint if a sorond key is in the footprint if a sorond key is in the footprint if a sorond key is. Either in memory or on disk and so either in memory or on disk and so either in memory or on disk and so. Essentially what the validators will essentially what the validators will essentially what the validators will. Do is that for whenever they receive do is that for whenever they receive do is that for whenever they receive. And apply an info Coast function they and apply an info Coast function they and apply an info Coast function they. Will look at the footprint and for every will look at the footprint and for every. Will look at the footprint and for every sore Bond entry that is marked as sore Bond entry that is marked as. Sore Bond entry that is marked as being on disk AKA marked as being Arch being on disk AKA marked as being Arch. Being on disk AKA marked as being Arch before running that transaction before running that transaction . before running that transaction the validator will essentially restore the validator will essentially restore. The validator will essentially restore those entries automatically and so those entries automatically and so. Those entries automatically and so the actual contract and the contract the actual contract and the contract. The actual contract and the contract logic will not change which means that logic will not change which means that. Logic will not change which means that all deployed contracts are automatically all deployed contracts are automatically. All deployed contracts are automatically compatible with this now the compatible with this now the. compatible with this now the invocations to those contracts will invocations to those contracts will. Invocations to those contracts will change slightly because of the footprint change slightly because of the footprint. Change slightly because of the footprint changes but again this will all be changes but again this will all be. Changes but again this will all be handled by RPC and so pre-flight will handled by RPC and so pre-flight will . Handled by RPC and so pre-flight will will do all this automatically let's see other. let's see other questions oh so ler streaming mode questions oh so ler streaming mode . Questions oh so ler streaming mode I'm I'm not sure about the context I'm I'm not sure about the context . I'm I'm not sure about the context but but but behind enabling or disallowing . Behind enabling or disallowing behind enabling or disallowing metast streams on validators versus. Metast streams on validators versus metast streams on validators versus captive core instances I imagine it. Captive core instances I imagine it captive core instances I imagine it has to do with performance reasons where. Has to do with performance reasons where has to do with performance reasons where. You don't want ingestion to make a you don't want ingestion to make a you don't want ingestion to make a. Validator fall out of sync and validator fall out of sync and validator fall out of sync and. Essentially that config setting is an essentially that config setting is an. Essentially that config setting is an opinionated way of saying that validator. Opinionated way of saying that validator opinionated way of saying that validator. Should be high performance and never should be high performance and never should be high performance and never. Get blocked whereas like a watcher node get blocked whereas like a watcher node get blocked whereas like a watcher node. That's not participating in validation that's not participating in validation that's not participating in validation. would be more appropriate for would be more appropriate for would be more appropriate for. Observing and adjusting the meta because observing and adjusting the meta because. Observing and adjusting the meta because there's not it doesn't depend on a there's not it doesn't depend on a. There's not it doesn't depend on a downstream system where if the meta downstream system where if the meta. Downstream system where if the meta stream gets clogged because the stream gets clogged because the. Stream gets clogged because the downstream system isn't adjusting fast downstream system isn't adjusting fast. Downstream system isn't adjusting fast enough you wouldn't want to lose sync enough you wouldn't want to lose sync. Enough you wouldn't want to lose sync and have a validating node fall off the and have a validating node fall off the. And have a validating node fall off the network because of a a downst stream network because of a a downst stream. Network because of a a downst stream issue cool so I guess cool so I guess . I'll from George about the cap mentioned I'll from George about the cap mentioned. I'll from George about the cap mentioned somewhere that autor restore won't somewhere that autor restore won't. Somewhere that autor restore won't always be possible can you elaborate on always be possible can you elaborate on. Always be possible can you elaborate on these scenarios ah yes okay thank you these scenarios ah yes okay thank you. These scenarios ah yes okay thank you for pointing this out so there are a for pointing this out so there are a. For pointing this out so there are a couple of edge couple of edge couple of edge. Cases where an invocation will still cases where an invocation will still cases where an invocation will still. Require an explicit R operation sorry and so essentially sorry and so essentially. because the inmemory reads are so because the inmemory reads are so because the inmemory reads are so. Much cheaper they don't have much cheaper they don't have much cheaper they don't have . Limits like the on desk read the limits like the on desk read the limits like the on desk read the. On just do while there there is no on just do while there there is no on just do while there there is no. Read byit limit at all and while read byit limit at all and while read byit limit at all and while. There is an entry read limit the there is an entry read limit the there is an entry read limit the. Expectation is that this limit will be expectation is that this limit will be expectation is that this limit will be. Significantly higher than the dis limits significantly higher than the dis limits. Significantly higher than the dis limits and so just for you know example and so just for you know example. And so just for you know example suppose that a in protocol 23 the suppose that a in protocol 23 the. Suppose that a in protocol 23 the transaction in memory read limit is 40 transaction in memory read limit is 40. Transaction in memory read limit is 40 entries and the on disk read limit is 20 entries and the on disk read limit is 20. Entries and the on disk read limit is 20 entries and so say you have like this entries and so say you have like this. Entries and so say you have like this Dex you know trade that will access Dex you know trade that will access. Dex you know trade that will access 40 soron entries now if all of those 40 soron entries now if all of those. 40 soron entries now if all of those entries are Al then you know the entries are Al then you know the . Entries are Al then you know the it's within the limits the invocation it's within the limits the invocation. It's within the limits the invocation Works no problem but say that all 40 of Works no problem but say that all 40 of. Works no problem but say that all 40 of those entries are archived now even those entries are archived now even. Those entries are archived now even though the inmemory limits are large though the inmemory limits are large. Though the inmemory limits are large enough for that transaction to succeed enough for that transaction to succeed. Enough for that transaction to succeed you can only the the automatic you can only the the automatic. you can only the the automatic Restorations will come from the on disk Restorations will come from the on disk. Restorations will come from the on disk limits and so because you have to pay limits and so because you have to pay. limits and so because you have to pay disk fees and are subject to the dis disk fees and are subject to the dis. disk fees and are subject to the dis limits for the restore operation you can limits for the restore operation you can. Limits for the restore operation you can only restore in this example 20 only restore in this example 20. Only restore in this example 20 entries automatically even though you entries automatically even though you. Entries automatically even though you need to have authority to be live to need to have authority to be live to. Need to have authority to be live to complete this Dex trate operation and so complete this Dex trate operation and so. Complete this Dex trate operation and so in this scenario you would need to to . In this scenario you would need to to in this scenario you would need to to . Still manually submit a restore still manually submit a restore still manually submit a restore. Operation just because the way operation just because the way operation just because the way. That the limits are set you can't fit that the limits are set you can't fit that the limits are set you can't fit. That many restores in a single that many restores in a single that many restores in a single . Transaction now that being said transaction now that being said transaction now that being said . Especially given some other exciting especially given some other exciting especially given some other exciting. Work that's happening in 23 we expect work that's happening in 23 we expect. Work that's happening in 23 we expect to raise limits pretty significantly to raise limits pretty significantly. To raise limits pretty significantly across the board and so I suspect that across the board and so I suspect that. Across the board and so I suspect that this Edge case will not affect most this Edge case will not affect most. This Edge case will not affect most transactions it will only affect very transactions it will only affect very. Transactions it will only affect very expensive transactions that are doing expensive transactions that are doing. Expensive transactions that are doing stuff and so for instance if you have stuff and so for instance if you have. Stuff and so for instance if you have a DEX trade and it's trading assets a DEX trade and it's trading assets. A DEX trade and it's trading assets that are mostly live you won't be that are mostly live you won't be. That are mostly live you won't be affected really you're only going to be affected really you're only going to be. Affected really you're only going to be affected if you have like a DEX trade affected if you have like a DEX trade. Affected if you have like a DEX trade that's crossing a ton of orders and for that's crossing a ton of orders and for. That's crossing a ton of orders and for some reason all those orders were archived so you mentioned that the. Archived so you mentioned that the restore op could be deprecated restore op could be deprecated . Restore op could be deprecated because of the automatic restore but because of the automatic restore but. Because of the automatic restore but this Ed Case requires you to keep this Ed Case requires you to keep. This Ed Case requires you to keep something something like that around something something like that around. Something something like that around right yeah so I think I mentioned right yeah so I think I mentioned. Right yeah so I think I mentioned the cap that we met deprecate the the cap that we met deprecate the. The cap that we met deprecate the restore op and that's just because restore op and that's just because. Restore op and that's just because that if the footprint is automatically that if the footprint is automatically. That if the footprint is automatically restored then having both the restore restored then having both the restore. Restored then having both the restore op and the extend TTL op is kind of op and the extend TTL op is kind of. Op and the extend TTL op is kind of redundant because for instance say redundant because for instance say. Redundant because for instance say that you just want to restore something that you just want to restore something. That you just want to restore something you don't actually need two operation you don't actually need two operation. You don't actually need two operation types you could just essentially use the. Types you could just essentially use the types you could just essentially use the. Extend TTL put all the keys you want to extend TTL put all the keys you want to extend TTL put all the keys you want to. Restore in the footprint and then just restore in the footprint and then just restore in the footprint and then just. Set the TTL extension to zero and this set the TTL extension to zero and this set the TTL extension to zero and this. Is functionally equivalent to the is functionally equivalent to the is functionally equivalent to the. Restore up and so when I mentioned restore up and so when I mentioned . Restore up and so when I mentioned deprecating the restore op I don't mean deprecating the restore op I don't mean. Deprecating the restore op I don't mean deprecating the ability to restore deprecating the ability to restore. Deprecating the ability to restore transaction or to restore entries via an transaction or to restore entries via an. Transaction or to restore entries via an explicit transaction but just mean like explicit transaction but just mean like. Explicit transaction but just mean like you know mechanically do we need both you know mechanically do we need both. You know mechanically do we need both the restore op and the extend TTL op the restore op and the extend TTL op. The restore op and the extend TTL op where the extend TTL up could now you where the extend TTL up could now you. Where the extend TTL up could now you know in theory at least both do a know in theory at least both do a. Know in theory at least both do a restoration as well as extend okay yeah that makes sense Nico. Extend okay yeah that makes sense Nico had a question about how the Soroban had a question about how the Soroban. Had a question about how the Soroban state size is initialized at upgrade state size is initialized at upgrade. State size is initialized at upgrade time it's it's not specified in the cap time it's it's not specified in the cap. Time it's it's not specified in the cap yeah I think I need to expand on this yeah I think I need to expand on this. Yeah I think I need to expand on this a little bit more so I think part a little bit more so I think part. A little bit more so I think part of this cap is that we are changing of this cap is that we are changing . Of this cap is that we are changing the semantic meaning of a network config the semantic meaning of a network config. The semantic meaning of a network config setting so so in particular The setting so so in particular The. Setting so so in particular The Bucket List Target size will become the Bucket List Target size will become the. Bucket List Target size will become the Soroban state size now the issue is Soroban state size now the issue is. Sorbon state size now the issue is currently the bucket list is like 11 or currently the bucket list is like 11 or. Currently the bucket list is like 11 or 12 gigabytes and so we all of our 12 gigabytes and so we all of our. 12 gigabytes and so we all of our network settings are assuming that network settings are assuming that. Network settings are assuming that the your target size is like 13 gigs the your target size is like 13 gigs . The your target size is like 13 gigs but now the issue is if we you know but now the issue is if we you know. But now the issue is if we you know do a protocol upgrade protocol do a protocol upgrade protocol. Do a protocol upgrade protocol upgrades previously have never actually upgrades previously have never actually. Upgrades previously have never actually changed config settings and so if you changed config settings and so if you. Changed config settings and so if you just do the protocol upgrade all of a just do the protocol upgrade all of a. Just do the protocol upgrade all of a sudden instead of your Baseline sudden instead of your Baseline . Sudden instead of your Baseline for fees being 12 gigs with a target for for fees being 12 gigs with a target for. For fees being 12 gigs with a target for 13 gigs because we're only tracking 13 gigs because we're only tracking. 13 gigs because we're only tracking Soroban State your target is still 13 Soroban State your target is still 13. Sorbon State your target is still 13 gigs but now your Baseline is like 400 gigs but now your Baseline is like 400. Gigs but now your Baseline is like 400 megabytes because there's like a lot megabytes because there's like a lot. Megabytes because there's like a lot less soron State compared to life State less soron State compared to life State. Less soron State compared to life State and then you have this dos attack where and then you have this dos attack where. And then you have this dos attack where until you upgrade the network confix until you upgrade the network confix. Until you upgrade the network confix settings you essentially have no read or settings you essentially have no read or. Settings you essentially have no read or write fees for both in memory and write fees for both in memory and. Write fees for both in memory and on dis State and so you could have like on dis State and so you could have like. On dis State and so you could have like a Doss attack where someone writes like a Doss attack where someone writes like. A Doss attack where someone writes like tons and tons and tons of temp entries tons and tons and tons of temp entries. Tons and tons and tons of temp entries and like you know spams The Ledger for and like you know spams The Ledger for. And like you know spams The Ledger for essentially zero fees and so I think essentially zero fees and so I think. Essentially zero fees and so I think what I'm proposing is that you know what I'm proposing is that you know. What I'm proposing is that you know currently there's like an operational currently there's like an operational. Currently there's like an operational lag between upgrades because core lag between upgrades because core. Lag between upgrades because core validators can only cue one upgrade validators can only cue one upgrade. Validators can only cue one upgrade at a time and so we'd have to get all of at a time and so we'd have to get all of. At a time and so we'd have to get all of tier one to arm for the protocol 23 tier one to arm for the protocol 23. Tier one to arm for the protocol 23 upgrade and then after that goes through upgrade and then after that goes through. Upgrade and then after that goes through have them all arm for the network config. Have them all arm for the network config have them all arm for the network config. Setting upgrade and in between that time setting upgrade and in between that time. Setting upgrade and in between that time you have free free reads and free wrs. you have free free reads and free wrs you have free free reads and free wrs. Which is a huge security risk and so which is a huge security risk and so which is a huge security risk and so. What I'm proposing is that because what I'm proposing is that because what I'm proposing is that because. Protocol 23 is semantically changing protocol 23 is semantically changing protocol 23 is semantically changing . What this config setting means the what this config setting means the what this config setting means the. Protocol upgrade itself should also protocol upgrade itself should also protocol upgrade itself should also. Change the value and so you know this is change the value and so you know this is. Change the value and so you know this is slightly different implementation wise slightly different implementation wise. Slightly different implementation wise than what we've done previously but I than what we've done previously but I. Than what we've done previously but I think it should be relatively think it should be relatively. Think it should be relatively straightforward implementation straightforward implementation . Straightforward implementation whereas like the protocol 23 upgrade whereas like the protocol 23 upgrade . Whereas like the protocol 23 upgrade both semantically changes what the Buist both semantically changes what the Buist. Both semantically changes what the Buist Target size means as well as it resets Target size means as well as it resets. Target size means as well as it resets it to a initial starting value that's it to a initial starting value that's. It to a initial starting value that's more reasonable given this new more reasonable given this new. More reasonable given this new interpretation of the data Okay so we've actually updated. Okay so we've actually updated settings on protocol upgrades before settings on protocol upgrades before. Settings on protocol upgrades before that I think we we know that works cool that I think we we know that works cool. That I think we we know that works cool okay great let's see a couple other okay great let's see a couple other. Okay great let's see a couple other  questions okay so for OrbitLens the. Questions okay so for OrbitLens the storage for the hot archive yes so storage for the hot archive yes so . Storage for the hot archive yes so the hot archive and the live Buck list the hot archive and the live Buck list. The hot archive and the live Buck list are both part of ensus so we need the are both part of ensus so we need the. Are both part of ensus so we need the hash of that state and so for that hash of that state and so for that. Hash of that state and so for that reason both of the the live database reason both of the the live database. Reason both of the the live database and the hot archive database are both and the hot archive database are both . And the hot archive database are both bucket list DB bucket list DB bucket list DB. Implementations and that's just implementations and that's just implementations and that's just. Because they we have to meriz those because they we have to meriz those because they we have to meriz those. Structures then Buck list DB is pretty structures then Buck list DB is pretty structures then Buck list DB is pretty. Fast these days now with respect fast these days now with respect fast these days now with respect. To offering tables to buckless DB we to offering tables to buckless DB we to offering tables to buckless DB we. We don't really have any plans to do we don't really have any plans to do we don't really have any plans to do. That and the reason is it's a very that and the reason is it's a very that and the reason is it's a very. Difficult structure to add tables to difficult structure to add tables to difficult structure to add tables to . So it's a it's a log structured merge so it's a it's a log structured merge so it's a it's a log structured merge. Tree which is kind of a a variant of tree which is kind of a a variant of tree which is kind of a a variant of. Like database used by like rock CB or like database used by like rock CB or like database used by like rock CB or. Level DB and it's also completely level DB and it's also completely level DB and it's also completely. Made inhouse like we didn't Fork levels made inhouse like we didn't Fork levels made inhouse like we didn't Fork levels. We didn't Fork rocks or anything like we didn't Fork rocks or anything like we didn't Fork rocks or anything like. That and so kind of we we have it that and so kind of we we have it that and so kind of we we have it. It works very well for query types it works very well for query types it works very well for query types. That the valers require and it's very that the valers require and it's very that the valers require and it's very. Efficient at those but we have to efficient at those but we have to efficient at those but we have to. Essentially like hand write C++ essentially like hand write C++ essentially like hand write C++. Optimized code for those specific optimized code for those specific optimized code for those specific. Queries and and so it would be both a queries and and so it would be both a queries and and so it would be both a. Very significant undertaking to allow very significant undertaking to allow very significant undertaking to allow. Like you know arbitrary index types like you know arbitrary index types like you know arbitrary index types . For Downstream and it would also for Downstream and it would also for Downstream and it would also. Probably not be a very efficient probably not be a very efficient probably not be a very efficient. Database just because it's a lock database just because it's a lock database just because it's a lock. Structured merge treat and so a SQL structured merge treat and so a SQL structured merge treat and so a SQL. Style index query would not work very style index query would not work very. Style index query would not work very well on it and so I think what I'd like well on it and so I think what I'd like. Well on it and so I think what I'd like to do with this is you know we've to do with this is you know we've. To do with this is you know we've we've for arbitrary key value lookups we've for arbitrary key value lookups. We've for arbitrary key value lookups we have exposed end points that are we have exposed end points that are. We have exposed end points that are on the same scale as SQL queres but on the same scale as SQL queres but. On the same scale as SQL queres but again they're just raw key value stores again they're just raw key value stores. Again they're just raw key value stores they're not like you know indexes or you they're not like you know indexes or you. They're not like you know indexes or you know really tables and I think know really tables and I think . Know really tables and I think there's been a lot of work done by there's been a lot of work done by. There's been a lot of work done by the platform folks on like the the the platform folks on like the the. The platform folks on like the the CDP and things like that and so I CDP and things like that and so I. CDP and things like that and so I think given that the complexity of think given that the complexity of. Think given that the complexity of the database of Stellar core is the database of Stellar core is. The database of Stellar core is increasing a lot and for a variety of increasing a lot and for a variety of. Increasing a lot and for a variety of reasons we only support Buist DB now reasons we only support Buist DB now. Reasons we only support Buist DB now and no longer support SQL I think and no longer support SQL I think. And no longer support SQL I think that any sort of raw database that any sort of raw database. That any sort of raw database access needs to move more in the access needs to move more in the. Access needs to move more in the direction of utilizing Downstream direction of utilizing Downstream. Direction of utilizing Downstream utilizing met ingestion using CDP and utilizing met ingestion using CDP and. Utilizing met ingestion using CDP and not rely on direct access to course not rely on direct access to course. Not rely on direct access to course databases just because you know nowadays databases just because you know nowadays. Databases just because you know nowadays with buck DB the core database is very with buck DB the core database is very. With buck DB the core database is very specialized and is not suitable for specialized and is not suitable for. Specialized and is not suitable for generic queries cool I cool I think there's a couple people typing so. Think there's a couple people typing so think there's a couple people typing so I'll let them finish or if anyone else. I'll let them finish or if anyone else I'll let them finish or if anyone else has any other questions if not I have a. Has any other questions if not I have a has any other questions if not I have a third cap that I'd like to introduce. Third cap that I'd like to introduce third cap that I'd like to introduce I'll give it a second and then we can. I'll give it a second and then we can I'll give it a second and then we can. Move on all right I feel like that's we've on all right I feel like that's we've had enough time oh answer about. Had enough time oh answer about had enough time oh answer about slp1 dial would you mind linking that. dial would you mind linking that question again I'm not quite sure what question again I'm not quite sure what. Question again I'm not quite sure what the slp1 question is oh yeah the new limits sorry. Oh yeah the new limits sorry yeah cool so I guess now I'd like yeah cool so I guess now I'd like. Yeah cool so I guess now I'd like to move on to cap 65 the reusable to move on to cap 65 the reusable. To move on to cap 65 the reusable module cache and so like I mentioned module cache and so like I mentioned. Module cache and so like I mentioned before we were doing all this before we were doing all this. Before we were doing all this optimization stuff for a memory State optimization stuff for a memory State. Optimization stuff for a memory State and essentially in addition to and essentially in addition to . and essentially in addition to saving all the contract data in memory saving all the contract data in memory. Saving all the contract data in memory we can also save all the contract we can also save all the contract. we can also save all the contract code and by extension all the code and by extension all the. Code and by extension all the contract modules in memory because contract modules in memory because. Contract modules in memory because you know we have a way of EX of you know we have a way of EX of. You know we have a way of EX of archiving contract instances and archiving contract instances and. Archiving contract instances and contract code that hasn't paid rep contract code that hasn't paid rep. Contract code that hasn't paid rep recently and so with that I think recently and so with that I think. Recently and so with that I think gr's on the call if you want come up and gr's on the call if you want come up and. Gr's on the call if you want come up and talk about cap 65 I don't think gr's on the call I I. I don't think gr's on the call I believe we were going to speak about CFE believe we were going to speak about CFE. Believe we were going to speak about CFE 65 next week right oh sorry I guess I 65 next week right oh sorry I guess I. 65 next week right oh sorry I guess I got a I gave youall a little teaser for got a I gave youall a little teaser for. Got a I gave youall a little teaser for next week then my apologies got a next week then my apologies got a. Next week then my apologies got a littlee of the gun but so yeah so I don't want to steal grain thunder. I don't want to steal grain thunder so I'll just you know leave you with a so I'll just you know leave you with a. So I'll just you know leave you with a teaser that we can you know have lots of teaser that we can you know have lots of. Teaser that we can you know have lots of this not only helps optimize the the this not only helps optimize the the. this not only helps optimize the the read limits but also optimize CPU read limits but also optimize CPU. read limits but also optimize CPU utilization as well but we'll talk about utilization as well but we'll talk about. Utilization as well but we'll talk about that more later all right unless there are any other. All right unless there are any other questions questions questions we can conclude this. we can conclude this we can conclude this meeting thanks great Garen it was a. Meeting thanks great Garen it was a meeting thanks great Garen it was a great. Talk all right thank you and you know talk all right thank you and you know the dis if youall have any more. The dis if youall have any more the dis if youall have any more questions or concerns you know there's a. Questions or concerns you know there's a questions or concerns you know there's a. Couple of discussion tabs on the Caps or couple of discussion tabs on the Caps or. Couple of discussion tabs on the Caps or just ping me on Discord.

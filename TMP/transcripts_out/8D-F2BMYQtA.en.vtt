WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:59.999 align:start position:0%
Hello everyone welcome to the Open Protocol Meeting, which is being live streamed and for all of you watching at home I just want to give a quick overview the goal of these meetings is to talk about and plan for changes to upcoming versions of the Stellar protocol. So we go over Core Advancement Proposal aka CAPs, which are open source specs and they describe new features designed to evolve the protocol and meet ecosystem needs and the CAP life cycle begins with the draft and today, that's what we're discussing discussing a draft specifically a draft of CAP 21, which is titled generalized transaction preconditions preconditions this CAP has actually been kicking around for quite a. While it was first created in may of 2019. But with the recent addition of claimable balances, which were introduced in Protocol 15 there were some new possibilities, that opened up and this week David MaziÃ¨res has been adapting the original proposal with those claimable balances possibilities possibilities in mind. So fair warning this is a
00:01:00.000 --> 00:01:59.999 align:start position:0%
technical discussion so. If you want to follow along I suggest reading the CAP and the recent developer developer mailing list thread about it both of, which are linked to in the event description description. So I think you know just a sort of quick overview of CAP 21 it generalizes the time balance field in transaction to support other conditions including conditions, that relax sequence number checking checking and, that provide relative time locks it does, that by extending account entry to keep track of the time and ledger number, which an account sequence number was last changed it also replaces the time bounce field of transaction with a union, that allows more general transaction preconditions preconditions. So the goal is to advance network scalability by facilitating off-chain payment channels and, that's sort of like what we're talking about today is this are there questions, that we can answer will this CAP help create those payment channels it's also to advance security and simplicity and interoperability with other networks by enabling relative time locks and finally it should make it easier for
00:02:00.000 --> 00:02:59.999 align:start position:0%
developers to create highly usable products products by enabling time-delayed queue recovery. So today it's the first discussion of this newly revised cap. So part of what we're trying to do here is really just get like a sanity check check before we start prototyping anything does anything have anyone have anything they want to add here at the top yeah as well as insanity check I think there's also. So this one question is the overall approach saying and the other question is Nico's raised some points many of, which are you know things one could go either way on. And so it'd be nice to just kind of see what the consensus is for for where we should go great I mean and since this is sort of something, that you've been working on do you want to start out with any any questions, that start out with any questions, that you might have or sort of pick a point where you think the discussions will start we can go from there yeah I mean I think thanks for I think your summary was was pretty good here I mean I guess the the things we could discuss are one you know does this seem useful for
00:03:00.000 --> 00:03:59.999 align:start position:0%
like a bunch of different scenarios. Because if you have one mechanism, that supports like a bunch of different things then, that's good. So i've got four examples of things, that you can do with this you know. If people accept those, that's great. If people have questions it's also great. If people have other things like could it do this like I was very grateful lee kind of suggested this, that you have a one-way payment channel and maybe this isn't perfect. But this is. But the fact, that I was able to cook something up pretty quickly using this mechanism to do something, that hadn't been one of the things we'd anticipated was you know an encouraging sign I would say yeah. And then the other thing is like sort of nitpicky like technical questions, that we should get consensus on. So where should we start application like uses or or just dive right into the nitpicky questions questions David can you give a high level overview why these things are relevant for payment channels ah okay good. So the the the kind of overall
00:04:00.000 --> 00:04:59.999 align:start position:0%
the the kind of overall architecture architecture of a lot of payment channels and a lot of other protocols frankly higher level protocols on blockchains involves kind of a two-phase thing where you want someone to be able to kind of recover unilaterally from a failure. If the other party goes away or starts becoming non-cooperative. But you don't want people to do something something invalid. So there's kind of one phase where you disclose, that you're going to do something. And then there's a certain amount of time in, which someone else can object. If you're doing something, that's not quite right like you're trying to for example example close a payment channel with an old closing state and there's a more recent closing state. But then. If nobody objects. Then after, that time delay you're able to to close the channel. So this pattern of kind of disclose. And then finalize something is extremely important in a number of contexts. And so with without CAP 21 it is possible
00:05:00.000 --> 00:05:59.999 align:start position:0%
but. But both extremely tricky to do with Stellar and you have to sort of pay a time penalty and, that things where like for example. When someone fails you might in a payment channel you might lose access to your funds for twice as long. Because you cannot the only way to do it is with kind of these pairs of transactions, that have non-overlapping absolute times in them essentially. So we've done stuff like this like starlight a long time ago was was a proposal it uses it just gets super complicated. And so the idea here is like let's just make it a let's just provide as a primitive the thing you actually want, which is kind of the ability to do something after some relative delay and since we already have this notion of accounts and sequence numbers it seems like and since sequence numbers are extremely useful for sort of invalidating a bunch of stale transactions you can just kind of give them successive sequence numbers it seems like the simplest way to address this is to just have a a transaction precondition says
00:06:00.000 --> 00:06:59.999 align:start position:0%
have a transaction precondition says you can do this transaction. But only. When the account has been idled for a certain amount of time therefore. If the attack count gets changed. When someone discloses, that they want to do something you have to wait, that amount of time before they can actually do the thing and in, that time somebody else can object by you know raising the sequence number further and invalidating whatever you were going to do to close the transaction. So so, that's kind of what what led to this the proposal. So it might be worth mentioning, that the bitcoin protocol has relative time locks they added it specifically for enabling the lightning network just as a reference. But it seems, that David like you were talking about relative time locks. But your your proposal is actually much bigger than, that and also includes some some sequence number changes and maybe you can talk a bit about, that and why, that's relevant relevant yeah. So so the
00:07:00.000 --> 00:07:59.999 align:start position:0%
so the the sigma summer changes are. Because we have basically it's our sequence sequence numbers are extremely brittle and hard to use right in in protocols. Because basically you have to have the exact sequence number in order for for a transaction to run. So so for example example one consequence of this is, that in a you know. If we don't have CAP 21 and you're implementing payment channels the kind of disclosure transaction, that sets you up to to close payment channel needs to be signed on multiple source accounts you need multiple versions of it. Because you know. If you submit yours. But you submit the wrong one. Then I still need to submit one. And so and. So it needs to be on a different source account. Because you've already burned the sequence number of yours yours another example is you want to set it like a pre-signed
00:08:00.000 --> 00:08:59.999 align:start position:0%
transaction, that will, that you can kind of submit at any time to do something like clean up some mess or something and again the account account, that's only valid. If the count is like in a particular sequence number. And so without I think overly complicating things I added a feature where you can optionally for an account say by the way this transaction is valid for a range of sequence numbers. So whenever you execute a transaction you always leave the account state the the the invariant is the transaction is only valid. When the sequence number of the transaction is greater than the sequence number of the account and after you've executed a transaction the sequence number of the account is always the sequence number the transaction you just executed until. Now it's always been the case, that it also, that the sequence number the account has to be exactly one less than the sequence number of the transaction in order for the transaction to be valid
00:09:00.000 --> 00:09:59.999 align:start position:0%
with this new optional feature you can add a different a minimum sequence number. So you can say actually I want this transaction to be valid valid for any sequence number below the transaction or for you know the last hundred sequence numbers numbers. And so this makes transactions, that you've kind of signed ahead of time a lot less brittle the particular you know particular example of where where I use this well actually it seems to come up in actually all of the the proposed actually all of the proposed applications. So in payment channels it's useful. Because I can submit a disclosure transaction and. If it's the wrong one you can submit a disclosure transaction and they can both just be on the escrow account we didn't need to have our special other accounts just for the sequence number. Because because you know an earlier disclosure transaction doesn't invalidate a later one. Because the disclosure transactions are signed to accept a range of sequence numbers you know another place where this
00:10:00.000 --> 00:10:59.999 align:start position:0%
might come up is where you have you want to be submitting large large numbers of transactions on one account you have like a farm of 100 servers, that are all like you know each each round they're kind of submitting a transaction on on the same source account and using the new feature you can accept gaps in the sequence number space so. If like one server happens to be down or not produce a assigned transaction time, that's okay you can just skip over its transaction another example, that I had was recovering like. If you want a friend to be able to help you recover your account in case you lose your keys you know you want to pre-sign a transaction, that you give to them, that they can just submit and will will add their signing key to your account. But of course you don't want them to be able to do, that immediately you want to have some chance to object in case somebody like steals their key. And so again you want
00:11:00.000 --> 00:11:59.999 align:start position:0%
want one transaction you can just submit, that will bump this disclose, that this is going to happen and bump the sequence number all the way up to the point where your friend can take over the account. And then a second transaction with a relative time lock, that allows your friend after a few days or whatever to take over, that account and help you regain access to your funds one thing, that I wanted to can you guys hear me yes excellent one thing, that I wanted to to kind of ask about was how you anticipate this interrupt excuse me interacting with claimable balance ids, which are sequence number dependent is the anticipation, that. When you do one of these range bounded bounded transactions on the sequence number, is bumped to the last sequence number prior to submission like prior to the operations being applied so, that no matter where you were applied in the range the any claimable balance generated would always be generated using an id, that is equal to the actual sequence number
00:12:00.000 --> 00:12:59.999 align:start position:0%
of the transaction. So there should be no change the the the definition of the operation id still applies unchanged in the sense, that every transaction still has a sequence number the only thing we're changing and always leaves the account with, that sequence number. When it's finished executing the difference is simply, that the transaction may be valid even. If a transaction with the prior sequence numbers have not executed yet. So just to make sure I'm 100 on the same page as you. If the sequence number bounds were minimum one maximum three whether I played the transaction at sequence number one two or three the claimable balance would always be created as. If it was ab sequence number three three I think what you're saying is technically correct but, that's not maybe not the clearest way to view it. So I just view it as there's no maximum sequence number there's just a sequence number, which is just the sequence number of your transaction. And then there's a minimum sequence number, that says. When your transaction starts being valid and the minimum sequence number by
00:13:00.000 --> 00:13:59.999 align:start position:0%
default. If you don't specify it is just one less than the sequence number of the transaction meaning like every transaction transaction can be submitted at exactly one sequence number. But you can you can reduce, that minimum sequence number number down to all the way down to zero. If you want the reason I'm kind of asking about it specifically in this way is, that the the language you this way is, that When the transaction finishes executing you will be at blah blah sequence number number yeah. But I actually think, that the phrase you want to use is. When the operation start executing you will be at blah blah sequence number. Because otherwise it's quite ambiguous about, which sequence number you're at. When you're actually doing these operations and also it's quite ambiguous what it means to a bump sequence okay. So let me actually address. So there's several points. So I. So the way I was viewing it is, that the the the the operation id in a claimable balance is depends on the actual sequence number of the transaction not the reason is, that I was assuming
00:14:00.000 --> 00:14:59.999 align:start position:0%
that you kind of execute transactions in two phases one in one phase you kind of claim all the fees and and bump all the claim all the fees and bump all the sequence and address those sequence numbers and you know validate the sequence numbers. And then in a second phase you do all the operations including things like bump sequence. But it is currently the case, that for example example you could you could submit two transactions transactions in the same block right and depending on the order in, which they actually one of them could like bump sequence to invalidate the other right. If they have different transaction level source accounts and so, that behavior is sort of unchanged in, that like all the validation and checking whatever is still all happening before bump sequence. But regardless of bump sequence. When you're generating a. So forget CAP 21. When you're generating an operation id it's still based on the sequence number of the account in the sense, that. If you have a bump transaction, that's not going to affect the operation ids right I'm actually
00:15:00.000 --> 00:15:59.999 align:start position:0%
I'm actually trying to confirm, that right. Now I was under the impression, that it was based off of the actual sequence number of the account at the time, that it executes so, that would make it difficult to predict the the operation ids, which I think think might be a a problem with claimable balances. If it's the case so, that might be something independent of CAP 21, that we might want to revisit regardless right maybe it's not it's it's not. Because you don't know the order in, which transactions on different source accounts are going to execute in the same block. So you could have a situation where you have a transaction it you know know it it creates some claimable balances and then. Because some other transaction happened to call bump sequence sequence, that the claimable balances have a different op id, that would be oh. But no no no we no no like the oh. But no no we no like the sequence numbers are strictly like they are enforced at the time we
00:16:00.000 --> 00:16:59.999 align:start position:0%
apply the transaction yeah David is right, though actually it comes from the transaction sequence number number not from the account sequence number. And so given, that that's the case CAP 21 doesn't change, that that. Then it CAP 21 doesn't change, that. Then it doesn't every every transaction doesn't every transaction still has a unique sequence number it's just we're. Now can skip some sequence numbers we're a little bit more flexible at. When a transaction runs I have kind of a basic question, which is what was the original rationale for sequence numbers replay prevention. Because we don't have utxos we need to we just need to make sure, that like a valid transaction cannot be submitted multiple times to you know double the payments payments the reason I'm asking is. Because I could foresee, that. If this is a a feature for convenience maybe many people would use this feature. So they don't have to think about sequence numbers and, although that's like a choice, that they've made maybe this actually makes their implementation less secure
00:17:00.000 --> 00:17:59.999 align:start position:0%
well no they still need to think about it it's still it still prevents replay. But but one thing, that this allows for example is, that let's say, that you have a fairly low low volume you know account where you're not doing a lot of payments you could decide decide, that rather than query for the the latest sequence number the account account you could just kind of use the like the unix time epoch as like the low 32 bits of your sequence number right and, and now sequence number right and now. If you set your minimum sequence to zero, that that would just work obviously you would it would not work work you would like get some transactions rejected. If you happen to on two different machines use the generate transactions at exactly the same time and use the same sequence number but. If that's unlikely to happen. Then then maybe, that's a better trade-off in some situations and we would allow, that that and just following up on just to make sure it's super clear to you eric like this wouldn't let you ignore sequence numbers imagine, that you wanted to be like hey you know I'm gonna set the minimum minimum
00:18:00.000 --> 00:18:59.999 align:start position:0%
minimum number to one and the maximum number to n64 max, that's not going to cause any problems. But again there's no match I'm not going to work there's no maximum number exactly please don't use the term maximum number it's going to take you straight to in 64 max you can do this one time, and now you're a count stock I suppose we could we should actually do the maybe we should add the limitation the same way bump sequence doesn't let you bump to n64 max right. Because we have some idea, that we want to be able to delete the account. And then recreate it and and not have old recreate it and not have old transactions be valid it does let you bump into 64 max actually it just stuck at, that point. And then you're just stuck you need to use another okay. Because we can't delete the account okay. So great. So fine we can just allow to have the same thing. Then yeah. So so is one way to think about this, that it's a bit like a normal transaction with a bump sequence built into it yeah. But but with a slight built into it yeah. But with a slight advantage, that the bump sequence happens later in the processing of a block and this happens
00:19:00.000 --> 00:19:59.999 align:start position:0%
happens earlier during the initial phase of like collecting fees and validating transactions. But yeah it acts a lot like an implicit like basically you're you're implicitly like basically you're implicitly your sequence number is implicitly a bump sequence. Now so where there are also you know I believe on the Stellar dev mailing list there were some specific technical issues issues, that Niko raised and I want to make sure, that we do. If they're important, that we do have time to get to them does it seem like time to move on to those are there still more sort of high level or general questions questions let's get specific okay. So so the first one is, that I mean this is something I feel strongly about. But it's not the hill, that I want CAP 21 to die on. So maybe we end up just deferring this to some some leader cap. But the way we do extensions for unions by kind of
00:20:00.000 --> 00:20:59.999 align:start position:0%
kind of dangling more and more nested structures off the end of a structure is kind of messy and gross and it seems like the reason we're doing this is just. Because we're like we don't have have enough like engineering resources to kind of fix each individual SDK in a way, that like frankly wouldn't be, that hard. If we had someone who is like living and breathing, that that SDK. So so I you know I think it's much better to do your have your extensions to unions be kind of like having like an outer union. So you can just kind of keep improving the data structure structure and you know keep most of the fields the same as opposed to having like many nested unions, which is both you know encodes in a more it takes more bytes to encode and is like more of a pain to program to. Because you have all these nested unions. So I'm suggesting, that the account entry extension, that we replace the thing, that's currently a v2 dangling off of v1
00:21:00.000 --> 00:21:59.999 align:start position:0%
with with just a a v3, that that has everything in it and this isn't even like transaction state right this is like ledger state. So like like. But by the time you talk talking about software, that's actually parsing these like ledger entries like we're already in like pretty advanced software and not like random end users who were like doing XDR parsing on the on the actual blockchain state as opposed to transactions I mean I think the by the way this was the last thing on the list I think in terms of priorities I don't know why we're spending spending time yeah. So again right. Now I mean we can't can't okay why don't we defer this to the end. Then so the next next question is, that and this is kind of a more general general point. But it's like coming up here too we have we're using a combination of signed and unsigned integers
00:22:00.000 --> 00:22:59.999 align:start position:0%
for durations and time points and it would be super nice. If we could kind of unify, that across everything. And so my proposal. So I don't have a strong opinion on, which. Because 62 to the 64 or 2 to 63 are both very large numbers of seconds John has suggested, that it's useful to to you know do queries in sql and, that sql doesn't have good support for unsigned 64-bit entities not just sql it's also no other languages sure. So so what we could do is change time point to be assigned 64-bit integer have duration be assigned 64-bit integer and we would just say, that any time bounds, that is negative is just treated as like you know n64 max basically for backwards compatibility and I doubt any why would anyone nobody is going to care about. If they've already signed a transaction whether the time bounds is like 2 to the 63 or 2 to
00:23:00.000 --> 00:23:59.999 align:start position:0%
the 64 seconds from the epic right I mean I think a priori I think, that sounds fine to me i'd have to just look carefully through everything and make sure, that it doesn't break anything terribly I mean. But a priori I agree like nobody cares. If something's gonna happen in 2200 or I don't know two to the 64 must put you into like the 30 000 or something I don't know something like, that no I mean it's got to be much more than, that. Because 32 bits already gets us to like like 20 30 something right. So 16. Yeah no yeah you're totally right you know he death of the universe kind of thing like I think we got bigger problems to worry about at, that point in time like yeah even changing crypto yeah yeah exactly I think my problem said 25 deep by, that point okay. So for, that one is, that where we're landing it sounds a priori okay. But like we should go to sign
00:24:00.000 --> 00:24:59.999 align:start position:0%
64-bit 64-bit and we just have to be a little careful about legacy you know do it in a way, that doesn't mess up legacy transactions okay. So another question. So someone. So again you know I just like doing things nice and simple and figure we already have unions like we've already got two kinds of precondition. Now no precondition time bounds. And then these like general preconditions so. If we want to add more stuff we could just add a new kind of precondition you know. But an alternative would be to kind of turn this into a little language like like the claimable balance preconditions and you know having like an array of different things you know again the proposal could work either way way I like this way. Because it's simpler but. If
00:25:00.000 --> 00:25:59.999 align:start position:0%
there's overwhelming desire to go the other way we can do, that as well I guess one concern you can go first Nico I was just waiting to see. If anybody wanted to go first yeah I know I was like thinking, that. If we just do this pattern right without the array I think it would just end up growing. If we add more condition even actually with the current version version like you always use like the worst almost like max max maximum size bikewise, that doesn't seem like a you know a good property I think in terms of complexities complexities you know we can make it, that it's actually fairly simple like I would say like you know the array has to be strictly ordered by you know value for example right like you cannot put like, that's where you have like a normalized
00:26:00.000 --> 00:26:59.999 align:start position:0%
form right you can't you have to put for example time bomb before before sequence number right things like, that that and. If you did, that could you expand the the possibilities yeah, that's it yeah I mean this thing is like 20 bytes right. If it's not. doing anything. So let's see there's one two three four yeah five things. So like 20 bytes I don't know 24. Because the direct duration is like 64 bits. But I mean I mean especially for things like yeah I don't know I mean I can make it work the other way it'll be like you know more complicated to implement everywhere there'll be like more weird edge conditions you know I think, that in the end maybe you'll shave you know eight or 12 bytes off the size of some
00:27:00.000 --> 00:27:59.999 align:start position:0%
preconditions and others will be larger and you know maybe like four bytes bigger or the same to me I don't know like to me it's like the you know it's called generalized. But it's not generalized type of thing you know it's kind of you know we want it to be generalized like a place where we can add more and more conditions. And then what. If I called it something less arrogant than general preconditions like you know relatives or relative general preconditions v1 or something I guess you yeah you ask for it. Because it's like. When people call the function you're smart something you know it's not smart right. But no no no I'm I'm just saying like. I don't necessarily think it's it's a problem I think it's more of a yeah the pattern like what what is the pattern, that we want to have here and I can see, that fairly you know maybe not in the far future future we'll have like yeah like some new conditions, that pop up and do I want to again like
00:28:00.000 --> 00:28:59.999 align:start position:0%
you know have like it's it goes back I guess to this other point about half the weekend yeah fractures right how much pain do you want to have in the yeah and I guess here I just I don't don't I don't agree, that the pain needs to be very very high I just think there's a there's like a kind of a bug in our ecosystem, that we make these union upgrades more painful than than they should be part for me kind of what I'm looking at here is. If we think, that this is a pretty reasonable representation of all the things we'll need in the near future like near future being like let's call it the next year I mean we lived with just sequence with just time bounds and single sequence numbers for like I don't know much longer than, that five years I guess so. If we think we're gonna make it, that kind of length I don't feel any need to go go super crazy making this complex and extensible extensible. But I remember seeing I don't know maybe
00:29:00.000 --> 00:29:59.999 align:start position:0%
it was in the actual proposal maybe it was in the notes for this meeting I don't remember, which discussion about whether we should be like implicitly elevating and, which is the way, that it's currently written you need to meet all the preconditions versus or. If we do something like. If we care about or. Then probably it warrants something more complicated. But I think, that or also might might might put you into people not being able to understand what they mean yeah I mean you're certain like foot guns and stuff like I mean like you know first of all I actually haven't yet come up with a an example where or you need or, that's not to say they don't exist and I would appreciate people speaking up. If they have any such examples you can also do or by just signing multiple transactions yeah, that's not impossible. So I would really like to I mean especially. Because I think like to the
00:30:00.000 --> 00:30:59.999 align:start position:0%
extent we want to go crazy we can do, that with claimable balances right like we already have a little or or we should like try to unify the languages right like, which is somehow make make like have a notion of precondition, that can apply to both clinical balances and regular accounts and stuff and once we start doing this I'm just seeing this thing like spiral out of control and I think it's like we're not like saying we can never do this like we can have like a you know a new we can add a new thing to the union like. When when we decide this is done. But like look like you know this is let's just try to be good and not perfect for this. Because because like what we have here is just simple it's easy to understand I think it's not going to be too bad to implement implement and I think it will be already enabled like a huge number of use cases you know I mean as oleg was pointing out this morning like in order to make lightning really work on on bitcoin they had to go through like four different soft forks or something. So like maybe it's not perfect and
00:31:00.000 --> 00:31:59.999 align:start position:0%
maybe we'll want to make other changes. But but we have, that ability. Because we have unions. So I think this claimable balance point is worth talking about for two minutes, though I mean do we think we're going to be be wanting to add this kind of thing to claimable balances I'm asking. Because I'm feeling the pain of clinical balances in horizon right. Now and how we wish we'd made the ids more general. Because we built everything around accounts. But it turns out claimable balances have similar properties to occur I mean the thing, that the the predicates on, climate balances have is, that they don't they they're less monotonic than this stuff. So kind of intentionally like things like duration and and like sorry min seek age and min secret ledger gap and stuff they they have a monotonic property, that they'll you know like once they're valid they'll they'll they'll stay valid right there's still a maximum time bounds. Because we're not going to get and get rid of, that in the ledger bounds. But and I think, that that monotonicity makes it a lot
00:32:00.000 --> 00:32:59.999 align:start position:0%
easier to reason about like. When you're sort of forwarding multiple transactions on the same source account you know whether they can all be in the same block you know we don't want to have situations where someone can kind of waste a bunch of bandwidth by causing validators to forward around invalid transactions and things like, that. And so the monotonicity helps with, that as well you know once you start adding in not in all these other other operators, that you no longer have, that and it just gets more complicated to reason about these things Nico and John any pitfalls, that you see in in see in implementing this whether it's a an SDF team or someone in the ecosystem trying to prototype this and still a core for, which part the the condition like the the I guess the only
00:33:00.000 --> 00:33:59.999 align:start position:0%
thing I thought. So so in terms of like thing I thought. So in terms of like the captain itself like at apply time I don't think there are like real problems from what I see like they are I mean it's a fairly simple change actually actually I'm still kind of trying to kind of really wrap my head around like the the coupling I guess in in some of those the coupling I guess in some of those things like the like does, that only work basically in for example like they are like the limitations on the flooding, that David added last night, that I read this morning in particular the the ones, that are in particular the ones, that are related to relative timelocks themselves I think this this really only works. If you basically do like the same type of setup or you have like two transactions where one kind of allows you to
00:34:00.000 --> 00:34:59.999 align:start position:0%
to gate the disclosure. And then the actual right you always have to do this right it's kind of and in a way it kind of bothers me a little bit, that you know we have those constructs and they don't work independently I mean like all one actually requires the other one one and I don't know it kind of sorry but, that's the point right you want, that you want to have to performing the action should require the disclosure right you know I understand. But it's in terms of the construct like you have this construct, that cannot be used outside of of the combination right like normally we try to make things, that like for example the sequence number thing, that can be used in any other source of context right the other one the relative condition has to be used with sequence numbers like I mean like actually like other transactions actually it has to be paired with some other scheme
00:35:00.000 --> 00:35:59.999 align:start position:0%
otherwise it's a food gun right like like like people will not realize maybe, that the you know it's actually a fairly subtle thing right, that you it you know. If some evil person is is constantly kind of pushing transactions in front of you. Then your relative time kind of keeps moving. But it's always you know not where you want it to be right and you're in in the it's not it's like you have to use it I mean there are other patterns where you could use it right you can imagine you know. If my account is idle for a year I want you know my family members to be able to like like access the the funds or something right. So you could just you could do it as a kind of a a trigger you could do it as a kind of a trigger for for idleness. So it doesn't have to be for, that. But it seems like the the most most of the cases do involve this this pattern of disclose. And then act
00:36:00.000 --> 00:36:59.999 align:start position:0%
but I mean I think it's kind of a very useful pattern right. So it is something something no the pattern is useful what I'm saying is more like like I guess you gave an example, that where I mean this is useful in a context. So we you don't pre-sign many transactions and maybe, that's okay right I don't know I mean maybe. So actually actually I thought I understood your point. But now I'm actually confused. So I thought, that your pro your problem was like well it's kind of inefficient. Because it like prevents you from pipelining back-to-back back-to-back transactions or something. But it's it was not an efficiency question it was more of a like a potential attack right like you pre-signed a bunch of transactions. And then you expect the, that last one to just work. But you don't realize, that maybe there are ways to touch the account basically
00:37:00.000 --> 00:37:59.999 align:start position:0%
basically. Because you have all like an example of a payment channel right like you can imagine, that you can actually. If there was no. If if the sequence number was not working in a way, that it would remove all transactions you would end up in situations situations in a situation where the timestamp would keep moving from all transactions right. So you end up invalidating invalidating basically your latest one and, that's not the one you you want to invalidate right we're not invalidating you're just delaying it like you sort of you're worried about something like a live lock situation situation where yeah someone has low signing threshold on the account. And so they keep keep you know exactly like this kind of stuff right yeah I don't know from my perspective on this it's kind of like. If you're doing pre-signed transactions like you better know what you're doing or you're probably going to screw yourself up no matter what the pitfall is
00:38:00.000 --> 00:38:59.999 align:start position:0%
but you can imagine a day where say someone provides a service, that does pre-signed transactions right where where some of, that difficulty would be concealed. But I still think, that you know like CAP 21 is only going to make, that less error-prone right. Because of the fact, that you sequence something less brittle. So I mean you know there are things you can do, that are would be weird with this. But but they would be weird anyway I mean like you could have a situation where like someone has low signing threshold in the account and they keep you know bumping a sequence number. And so my my idol thing. you. So my idol condition never kicks in and I can't execute this. But they could also use bump sequence to bump the sequence number to you know max 64 and lock the account too right. So it's kind of like you're already giving someone the power to shoot you in the head. And then don't you know I guess be happy. If they
00:39:00.000 --> 00:39:59.999 align:start position:0%
only shoot you in the foot instead of the head or something. But so can we just kind of accept, that yes there there are ways to I mean yeah it was more of a yeah like like I said like a concern, that we are adding more complicated things, that you have to know to use exactly right otherwise you know I mean I guess maybe, that's what John is saying like you know those are to be used only. If you really understand what you're doing and you know in a way like I think like. When I see the the actual payment channel protocol is actually super easy to understand like you can you know like it takes five minutes to actually get it right like and you know it's correct unlike you know like previous attempts. So you know to me this is like the big win
00:40:00.000 --> 00:40:59.999 align:start position:0%
Tomer had asked about you know implementation challenges and I agree with nikola, that the apply time part of it should be like super easy I mean a couple new. If conditions a couple of fields to update. But like there's not really any logic here. So it's I think it's actually probably the forwarding logic. So there's two places where, that's what I was going to say dude and the forwarding logic is like a little bit more complicated. But I think you know after I kind of thought it through and wrote, that new section last night, which yeah by the way thank you Nico for pointing, that out should have been in the the first version of this I think it's not too bad I think like the main challenge will just be you know the the forwarding logic is already complicated like there's lots and lots of of conditions on conditions and the main new challenge here is just the additional bookkeeping burden of things, that used to not be possible for example like you receive a trans transaction, that's like signum three to seven or minsek three seek
00:41:00.000 --> 00:41:59.999 align:start position:0%
number seven as David would prefer me prefer I specify it. And then the next thing you receive is min seek four sequinum six, and now you can actually add, that to the queue. And so it's all about like do our data structures allow us to do these things efficiently efficiently yes no I'm not sure probably not actually right. Now so we'll probably have to redesign, that stuff to make those things fast. But like it's probably within the realm of doable just the type of thing, that we'll have to do a kind of detailed study of like what do we actually have to do before we touch anything lots of positive feedback here yeah this is exciting okay. So in terms of my to-do things, that I should revise here it sounds like well I guess we never really resolve the union thing. If if I don't it sounds like. If i
00:42:00.000 --> 00:42:59.999 align:start position:0%
if I don't it sounds like. If I don't want to predicate this in an argument about like unions and ledger state I should just dangle the extension v3 off of v2, which is my favorite. But whatever i'll just do, that. If I have to sounds like there is consensus, that we should have a duration and time, that we should have duration and time point types, that these should be signed throughout. And so I can change, that in this cap. And then it sounds like there's also kind of reasonable consensus, that it's okay okay to stick with just one big structure with all the preconditions as opposed to trying to build a little language like for claimable balances and does it make sense for instance John you know you were saying, that you would need to to do a detailed study you would need to do a detailed study to figure out. If the data structure
00:43:00.000 --> 00:43:59.999 align:start position:0%
would allow us to do these things efficiently does it make sense to also start doing, that or is, that something, that should happen post these revisions yeah I mean our general goal is to try to do more stuff in parallel than we used to. So we can go faster we have a lot of stuff to do. So I don't know. When that's going to get onto our schedule David my guess is David will beat us. But in theory we we can start, that. But in theory we can start, that whenever at this point I would say maybe nikola descents. But I there's nothing blocking us from doing, that and we've we've been doing a lot of work on, that code recently. So it's very fresh in our mind. So it actually could be a a pretty good time to do it are not mandatory to to write kind of are not mandatory to write kind of like a you know like a quick dirty perhaps dirty prototype
00:44:00.000 --> 00:44:59.999 align:start position:0%
and obviously. If we accept CAP 21 in the future and and you know CAP 21 in the future and you know merge changes you know we'll need to optimize. But we can think about it let's do, that first cool cool this this CAP is premised on the idea, that it actually solves payment channels, though right. So we add another solution to payment channels we'd have to revisit whether this is something we want to do or or. If I mean we do have other solutions they just have undesirable properties right. So this was the best solution for payment channels it would go ahead but. If it wasn't. Then I guess we'd re-evaluate whether it was still worth doing is, that right yeah I mean or or we would do, that we yeah I mean or we would do, that we would tweak this. Because probably it seems unlikely, that a good solution for payment channels would not involve some kind of relative time lock it just could be, that there's some other feature we need to add or something something or there's some small tweak, that we need here. So yeah definitely feedback
00:45:00.000 --> 00:45:59.999 align:start position:0%
challenges like you know again it was great like lee came up with this idea of you know the one-way payment channels with different trade-offs. And so yeah. So maybe i'll keep thinking about, that too see. If we can push on, that to do like top-ups and stuff in there yeah I think what I imagine actually is, that there might be more work to do as people think in more detail about the closing like what really happens. When you close the payment payment channel like I know in the past a lot of the complexity in the in the starlight implementation was, that balances well we didn't have claimable balances balances. And then you have like yeah all the things, that can fail. And then you know there's no way to retry. And then you're kind of stuck and yeah like thinking about yeah like how to ensure, that things
00:46:00.000 --> 00:46:59.999 align:start position:0%
are safe even. If you go beyond the one transaction right like. Because in this case you have this one transaction I mean I think it probably works. If nothing fails. If everything is claimed our claimable balances but, that's kind of you know we'll know as we actually go a little further yeah I mean the major major pain point was, that like paying out to the responder could actually fail. And so therefore you had to make sure, that like you know it was a separate transaction from like restoring the account account, and now the claimable balances can't fail it's like it's fantastic right it's just you can do everything and just like one transaction, that like fixes the thing yeah what I'm saying is more like the limit right there's a limit of 100 operations operations in a in one transaction. So are there cases where you have to go beyond, that and. If so is it just a matter of like right. Now you do two times I maybe it's like three times I is, that all there is to it I don't know saying like yeah a payment channel with like 100 assets in it or something
00:47:00.000 --> 00:47:59.999 align:start position:0%
that, that would be interesting I think we actually could do well yeah or like it depends. If you do like multi-parties you know more than two parties like you know all this stuff right yeah. So yeah and I actually think all, that will work. But I could. If you'd like I could add a section on a like a multi-party multi-asset channel, that needs to span more than one trans closing transaction yeah I mean there's really no reason you can't just have multiple closing transactions with just kind of successive sequence numbers as long as they never fail right, that's kind of the thing no no they can fail actually Because because it still consumes a sequence number they can't be invalid. But they can fail right so. If it turns out you'd rather pay out with an actual payment instead of a create clinical balance you can still do, that it's just. Now you have to consider the fact, that transaction could fail. Therefore you can't pay out to multiple users in the
00:48:00.000 --> 00:48:59.999 align:start position:0%
same transaction you just have to have multiple closing transactions yeah. And then you have like the whole like what do you do with the leftover at the end and yeah you know the leftover at the end is you just the initiator gets control of the account yeah. But like, that's you know I guess, that's one decision you have to make make on, that front, which is. Because we don't have a way to like the only thing we can do is basically basically leave it leave full control at the end of the leftover to like a given party you know, which I think you want anyway. Because someone had to like put up the base reserve and stuff for, that account. So why not let them just get control it's also it has this other advantage, that it lets the initiator unilaterally top up right, that you don't have to like do some complicated protocol to top up like the initiator can just kind of throw more funds in there. And then it can either spend those or it'll get them back automatically. When it. When it closes the channel leigh are you raising your hand yeah I have a question back on. So i
00:49:00.000 --> 00:49:59.999 align:start position:0%
yeah I have a question back on. So I think we're getting in the details of like the specific payment channel implementation. But I just had a thought on something, that you were raising Nico about you know the foot gun of just, that min sequence age and I'm wondering. If like one of the early early proposals I think David, that you shared attempted to use claimant balances as like the relative timeline. So as opposed to having the relative time lock in the account it existed out in this external thing somewhere else in the ledger and I think, that has some like undesirable undesirable properties, that you know we wouldn't want to do, that with claimable balances. But but is is it worthless exploring, that idea of having relative time locks being like like like a very simple small thing on the ledger ledger they get created outside of the account and we can define things like. When they expire and. Therefore transactions yeah. So actually the this I you know i
00:50:00.000 --> 00:50:59.999 align:start position:0%
think we could still make payment channels work. If we got rid of the min sequence number. But actually it would have more foot guns right I actually think the min sequence number is there to reduce foot guns and to make a lot of things simpler by making sequence numbers less brittle brittle I'm also interested in lee's question, though it's something i've been wondering this whole conversation like are there things, that we can do beyond changing the account state, that might be more powerful than just changing the underlying account state like you know recording some other state or you know transmuting claimable balances on a transaction exactly I was actually referring to the sequence age. So I was actually meaning like move, that out of the account into like some you know you create a lock and, that lock is automatically locked for like a specific age or something like, that
00:51:00.000 --> 00:51:59.999 align:start position:0%
okay. So I mean I can tell you a couple things you could do. But they're all going to be more complicated. So one thing you could do is you could somehow guarantee, that a claim claimable balance will never be be valid and fail right. So then you could kind of use a claimable balances as a kind of synchronization primitive and be guaranteed, that you're not accidentally going to burn a sequence number another thing, that you could do is you could add a replay cache to each account. So you can have a new kind of transaction transaction, that instead of, altering the sequence number it like adds itself to the replay cache for, which you have to pay you know a base reserve. And then the transactions would get you know garbage collected from the replay cache based on their their max time or maybe based on like bumping the sequence number this starts getting complicated. Because you don't want a single transaction to
00:52:00.000 --> 00:52:59.999 align:start position:0%
be able to kind of delete a million things from the database just. Because then, that would be like an expensive transaction. So you'd have to kind of limit the per account number of entries in the replay cache or somehow ensure, that they can't all be deleted at once or or have some other operation, that deletes like only up to 100 things from your replay cache, that are stale so, that that again would, that that so, that again would, that would simplify things. Because again you could kind of submit transactions it would be more a little bit more general and useful than this. Because now you wouldn't even have to worry about the relative sequence of these transactions you could have two transactions on the same source account, that could be submitted in either order and they would both be allowed to to execute execute. So I'm happy to to cook up a proposal along this lines of a replay cache and I think it would be have some nice usability properties I think it would be much harder to implement and I think it would end up having some annoying warts owing to the
00:53:00.000 --> 00:53:59.999 align:start position:0%
fact, that we want to bound the amount of work, that any single transaction can cause validators to do. So there's either gonna be like limits the replay cash or limits to how quickly it gets garbage collected leigh do you have more to say I say you're still unmuted i'll leave okay on the replay topic I have tons of ideas about this David. If you want to talk about it, that I want to talk about in this context I actually drafted like a short proposal somewhere somewhere about this, that you could do this in a very like no storage kind of way on the ledger and still have no undesirable replay things things we could talk about it offline. If you want to okay would it is it was your proposal good enough, that we should consider consider instead of min sequence number or talk about, that no it's kind of orthogonal to min sequence number it's
00:54:00.000 --> 00:54:59.999 align:start position:0%
it avoids other kinds of problems. But it doesn't fix those problems. So but it does allow you to submit transactions without changing the sequence number it does okay yeah let's talk about flying about, that cool and I think we're pretty much out of time I mean I don't know. If there's anything anyone wants to say just at the end here. But it sounds like there's some pretty clear next steps any final parting words parting shots clever jokes awesome everyone well thank you for coming into everyone who's watching thank you for watching this was a nice deep technical dive into CAP 21 and and more to come on there. If you want to know what's going on you can always join the Stellar death mailing list and you can also look at the github repo and look at the actual drafts for these kinds of proposals and I appreciate everyone here for joining in the conversation thanks. So much
00:55:00.000 --> 00:55:59.999 align:start position:0%
you
WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:59.999 align:start position:0%
All right. I'll get started. I welcome everyone to today's protocol meeting where we'll be discussing some recent changes to two Core Advancement Proposal CAP 63 and 67. So first I'll start with some se several CAP 67 updates. The first one is, that we emit the set authorized event to give the unified events parody with the Stellar asset contract. There's also a change specified, that the inflation operation will emit a mint event for each each payout. There's also a change to prohibit mox source accounts and memos for Soroban transactions and the this is. Because like. So the the mox source is. Because like. So the mox source we're prohibiting the mox source to avoid any confusion confusion on events avoid any confusion on events and, that along with the memos are not signed in the o payload. So we're just prohibiting them altogether. There's also a change to have all diagnostics live in the single transaction level
00:01:00.000 --> 00:01:59.999 align:start position:0%
vector and remove the operation specific diagnostics vector, that CAP 67 originally originally implemented. And we also added the emu account support, that we discussed at the last protocol meeting and all these changes can be in the CAP 67 link can be seen in the CAP 67 link, that I shared below. And the last change is, that it's not a change, it's more of a detail, that we will discuss in this meeting, which is, that there's no specific event for fee refunds. And this it's conflated to the fee event. And And this is related to the CAP 63 change, that I I'll discuss in a moment. But before I move on, does anyone have any questions? All right. Then. Then I'll move on to the the CAP 63 change. One move on to the CAP 63 change. One sec. Can can everyone hear
00:02:00.000 --> 00:02:59.999 align:start position:0%
me? Okay. Yeah. Then yeah, I'll move on to the CAP 63 change. Which is the a change to apply the fee refunds after all Soroban transactions have been applied instead of after each transaction like it is today. So we this this was done. Because the fee source is not part of the footprint and this is an issue. Because it's possible for, that same account to be used in a Soroban transaction. So. If you apply transactions in parallel you would need to make sure, that the fee source doesn't conflict the the the refund doesn't conflict with a different transaction, that modifies the ex the native excellent balance of an account. So we had two options here. You would either need to make the fee source an implicit number of the read-write footprint or we just changed how refunds are are applied and apply them after all store run transactions have been applied and we decided, that applying the refunds later made more
00:03:00.000 --> 00:03:59.999 align:start position:0%
sense. That's what CAP 67 CAP 63 went with. And the relevant CAP 67 topic to discuss here is, that the refund is conflated into the fee event. So this is fine. If the goal is to just track balances at the end of every ledger. But. If a user wants to infer anything related to balances in a ledger or in a transaction. Then this can be an issue. Because imagine, that you have a contract as a example Lee mentioned. You have a contract where it the contract does an action based off an account falling below a certain balance. Because the fee was charged to, that account. But. If we emit the fee as the fee plus refund. When you look at the events later on like for example. If you're doing an audit you will never see, that the account dropped below, that balance, that the account triggered on
00:04:00.000 --> 00:04:59.999 align:start position:0%
that the contract triggered on. So this is an edge case and I'm not sure. If this like something we can discuss is. If this use case actually matters. But the alternative would be to maybe emit a a separate refund event. But we actually open up another can of worms here, which is, that. If you're the fees are applied before are charged before the the operations are charged before the operations are applied. So you would need to make convey the information about the ordering in, which the balances change in the events and currently the events are just a transaction level vector and an operation level vector. But we would need to make some changes where the structure, that's in TX meta, which is you have the you have everything, that happens during transaction application and everything, that happens post transaction application. We need to convey, that same information in the events and we should and. If we do need this
00:05:00.000 --> 00:05:59.999 align:start position:0%
granularity, that might be the path to take. So. So yeah. If does anyone have any questions about this or or have input? What I wanted to tell is, that like we don't have many people today. And we also don't have Lee and we don't have Nico and others. So I mean you definitely could listen to what folks who are present think. But yeah sounds like I can afford just yeah exactly yeah I'm inclined myself to just not do anything and just clarify in the cap, that events should not be used for modeling the exact balances during the ledger application time. Because fees are in general charged at different points in time.
00:06:00.000 --> 00:06:59.999 align:start position:0%
, okay. Here's Nicholas. Nicholas. yeah, it seems to me like, that's the thing to do here and. If someone has objections, you can discuss them async. Yeah. Because otherwise we would introduce a lot of structural complexity in meta for meta in events and we wanted events to be rather simple to consume and hopefully the consumers of events not worry about just reor operation. But yeah, that's my take on this Yeah. Yeah. I agree. I the use cases we've discussed with rel in relation to CAP 67 tend to be for just tracking balances
00:07:00.000 --> 00:07:59.999 align:start position:0%
which seems like you know tracking you updating your balance at the end of every ledger is what this was designed for. And. If you want to use this for. If you. When you do anything related to like audits or anything more granular, I feel like TX meta should be enough. And making this system more complicated to handle those use cases doesn't seem to be the right right move here. So I agree with you. Yeah. Yeah. Exactly. And agree with you. Yeah. Exactly. And I guess the bottom line here is, that like even, though the effects are. When the ledger has been applied, you still get the correct value for transaction. It just applied at different points in time. But then. When you're looking at transaction events, you'll still get the correct key charge, that corresponds to what happened in reality. you just don't know the exact details. When exactly has been charged. So, hopefully for most intense purposes, please. So yeah, I I
00:08:00.000 --> 00:08:59.999 align:start position:0%
intense purposes, please. So yeah, I guess we can write this up and update the CAP and yeah, we can update the CAP and respond in, that thread. Okay. Does anyone else have any input? We have a small group today. So unless anyone has any other questions, we can probably call it early. All right. Well, it was a quick one today. Thank you for joining and yeah, thanks Nemo for your input. All right. See you.
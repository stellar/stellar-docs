WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:59.999 align:start position:0%
Hello everyone and welcome to this week's Stellar Developer Meeting. Today I have quite a few guests joining the call from NMIX. So please please introduce yourself. Good morning everyone. My name is Chaved. The CEO and co-founder of Onomics where we are building financial institution infrastructure on chain on Stellar. We use the diamond proxy standard, which we will be talking to you about very shortly. And our entire objective is to allow a seamless transition of for asset managers to seamlessly transition onchain without ever realizing, that it's actually blockchain, that's running the show in the background. I pass over to Thomas and Sebastian. Yeah, my name is Thomas Brown. I'm here
00:01:00.000 --> 00:01:59.999 align:start position:0%
at Nomix. Been working on Sora, a project, that caught my eye as a native Rust developer. I've been doing it. Now for about 10 years, that is to say Rust. And. So far my experience working Stellar has been incredible. I had experience working on other blockchains and being a Rust developer and being familiar with the benefits the language I feel like Stellar's system makes it really intuitive for a seasoned developer and even those with lesser experience to just jump on board. So this has been a really fun and interesting experience for me. So far. Hi everybody. My name is Sebastian Shepus. I'm the CTO here at Nomix and I'm excited to be here. We've been working on this technology for a. While and we Thomas is one of the best
00:02:00.000 --> 00:02:59.999 align:start position:0%
Rust developers we know and we've had a really good time building this infrastructure. So we hope, that you enjoy what you see and find it useful. Excellent. Mason, you want to introduce yourself? Let me just wish my comments. Hello everyone. Good morning, good evening, good afternoon from wherever you're joining. I'm M Heather. I'm the head of engineering at Nomix. It's been quite a journey at Nomix, and now we see Nomix also working with solar pan and seller and my part here is to integrate, that into our overall auto deployer solution where we onboard customers within a 20 to 30 minute time frame and
00:03:00.000 --> 00:03:59.999 align:start position:0%
deploy them onto their target chain and we're quickly on wrapping them onboarding them onto chains as well. Great. Thank you for the introductions. Yeah, I really love tooling tooling and and yeah, what what can make your work as a developer and and and deploying your your smart contracts easier. That's something, that's really interesting to me. I have not had a chance to to play around with your solution. So I'm I'm super excited to see see your presentation and your demo. Sounds great. So to start off I believe we would like to share a little bit about the motivation for why we were developing the Soraban version of the diamond proxy standard. So like I mentioned earlier our mission at Nomix is to allow traditional asset managers and traditional finance projects to transition onchain in a manner, which completely abstracts away the complexity
00:04:00.000 --> 00:04:59.999 align:start position:0%
of blockchain technology where they don't even realize, that it's blockchain running the show in the background. We don't say the B word, There's no blockchain, no crypto. It just happens to run on blockchain based infrastructure. So one of the key challenges, that we saw. When we were going out there and refining our product market fit was convincing these asset managers to transition onchain. Because everyone has their preconceived biases about blockchain technology, which is hey it's immutable and once something is deployed on chain, that can never ever be changed ever again, which is great. When you're operating in the DeFi land where you know you've got pictures of monkeys on NFDS or I don't know you, you don't know me, and you're issuing a a random token, that I want to audit the code for to make sure I'm not going to get my token stolen or you're not going to dilute me just by issuing new tokens. But, that immutability is a double-edged sword. That immutability turns into a massive
00:05:00.000 --> 00:05:59.999 align:start position:0%
liability for financial institutions, that expect to update these smart contracts at a regular cadence. When either a zero day bug is discovered or whether regulations change. As you all know, we're in the very nent stages of tokenization as a industry, as a market segment. Maybe only three to five years tops. And. Because of this immutability, these asset managers were very hesitant to adopt. Because when you do smart contract upgrades in the traditional sense, which is you're deprecating the old contract and transitioning everyone to a new contract, it's a massive pain for the asset issuer. It's a huge poor user experience for the end user as well. So what we're deploying out there into the world looks, feels, and smells like a traditional brokerage account, that's built on these diamond proxy standard. One of the key reasons, that all of the tokenization initiatives
00:06:00.000 --> 00:06:59.999 align:start position:0%
to date, apart from a few very diff very few exceptions, have happened behind walled gardens is. Because of this feature. Because they want to carefully control the entire blockchain, that they're operating on. So. If they need to roll something back or. If they need to upgrade things, they have the complete cart launch to do so. But we all know, that there's inherent liquidity on public ledgers. And. If you want to democratize access to various financial instruments and increase your investor base, you need to be able to tackle these public blockchains. This entire concept, this entire challenge is why we decided to build the diamond proxy standard on Sora. I'll pause here very quickly for any comments from you, Carson. Yeah, I just want to say, that. If anyone watching here has any questions, please feel free to post them in the chat and we will try to take them as as they come in. But. But
00:07:00.000 --> 00:07:59.999 align:start position:0%
yeah, I think, that that was a, great intro. Maybe maybe just very briefly describe what the diamond pattern what what, that is for those who are less familiar with it. Of course. So the diamond proxy standard is functions similarly to how proxies work in the traditional web 2.0 world. If you're familiar with them. So instead of having a monolithic smart contract structure, you actually have something called the diamond smart contract, which basically. If you think about it all typically all of the smart contracts have their independent stoages and they're all hardcoded to each other to work with each other. If you've got a marketplace smart contract. If you've got a fee distribution smart contract, all of them are kind of linked together in a hard-coded manner, for the lack of a better word. What the diamond proxy allows you to do is have a common storage for all of these smart
00:08:00.000 --> 00:08:59.999 align:start position:0%
contracts. And there's multiple facets on, that smart contract. And each one of these facets are responsible for a specific kind of functionality. Now, at a 10,000 feet overview, and Thomas can get into, that a little bit deeper, at a 10,000 feet overview. When you need to change anything at all in a diamond proxy, you're simply able to shave away a facet and replace it with a newer facet without impacting the rest of the functionality of the contract or without having to do costly reissuances and migrations of those tokens. Great. Okay. So, I'll pause for any highle questions. And then I'll let Thomas take it away and get down into the nitty-gritty. Sounds good. Here's there was one question from the audience asking for a link to the standard. Now, did you want it in just like a GitHub repo link of our SCP
00:09:00.000 --> 00:09:59.999 align:start position:0%
filing. Because that's what we're going to go over next. Yeah, I can post, that one. Yeah. Okay, there we go. Yeah, there you go. So, yeah, we are proposing a set. We filed this up a couple of months ago, and now we're ready to drive additional eyeballs on it from the community and have it start to be adopted throughout the Soroban community as well. We'll also be going through Sor OpenZeppelin audits of the smart contract in very short order over the next month or two. So, yeah, Thomas, take it away. If you want to share your screen. Screen. Great. And just get this set up.
00:10:00.000 --> 00:10:59.999 align:start position:0%
All right, the diamond proxy standard. So before I get into discussing the jargon, that's used here. Because somebody looking at this for the first time will be inundated with all these new keywords. I think as a developer speaking to other developers, it makes the most sense to approach this from a common perspective. typically. When we're developing a smart contract, we can think of a smart contract as like a class of sorts. It's something, that runs and it's structured. You can add functions to it. You can add data fields to it. You can control how those data fields are accessed through different view modifiers. Modifiers. And in web 3.0 or in blockchain space instead of having a class just running
00:11:00.000 --> 00:11:59.999 align:start position:0%
on your local machine, which is the case for normal object-oriented programming. When you're talking about paradigms like Stellar or Ethereum anything like, that we have a distributed class so, that class file, that code is being executed across many machines at once. And so there's a beauty and elegance to the notion of smart contracts. Now, in order to achieve, that, you have to have consensus and there has to be pin to the location of where, that smart contract exists. And, that's, that's one of the reasons why we have to have the diamond proxy. Because it's great. You can go ahead deploy smart contract. But we quickly run into
00:12:00.000 --> 00:12:59.999 align:start position:0%
the problem in the web 3 space where say you have some business logic and you deploy it. A month down the road manager approaches you and says, "Hey, I would like this functionality changed." Well, in order to do, that, you're going to have to a redeploy and b change the pointer of the smart contract on chain and tell anybody who's using your system, okay, don't target this contract address anymore. Target this one. And. So you could have, let's say, some kind of layer, that automatically reroutes all, that for you. And people were doing, that for some time. But what. If there was a way to proxy and reroute calls on the blockchain itself? So how can we
00:13:00.000 --> 00:13:59.999 align:start position:0%
go from something, that is intrinsically immutable immutable to something, that is actually mutable? And. So it seems like a little bit like magic. But it really isn't. And therein lies the beauty of the diamond proxy is, that it is simple yet seems like magic. With the diamond proxy, what you have is you have several stable points points in me in in the decentralized memory. Those stable points are your proxy and your shared storage layer. As far as a user is concerned, their interactions are going to target the diamond proxy. So let's assume a very simple case. I want to deploy a smart contract. What I do is I make sure the diamond proxy is deployed
00:14:00.000 --> 00:14:59.999 align:start position:0%
and. Then I deploy the smart contract not directly. But through a proxy. So the diamond proxy through a function called diamond cut deploys the smart contract, which we call facet and initializes it. When it initializes the facet. In Stellar, we have a macro within our source code, that allows you to seamlessly integrate with this diamond proxy standard on Stellar such, that it injects another stable point in memory, the contract address for the shared storage layer. So whenever a facet is deployed through the proxy, it gets a pointer to, that shared storage.
00:15:00.000 --> 00:15:59.999 align:start position:0%
What does this mean? This means, that let's say you deploy a facet. And then you update the logic again. Because you have a shared storage layer, it doesn't matter, that you have two separate smart contracts. Now facet A and facet B can still access the data, that you had mutated within the ledger. That, that's, that's just great. We really want to give people the opportunity to have the freedom to change data without having to go through the hassle of having to deal with the issues, that exist with the immutability. And in reality, this sort of functionality is really what you want anyways. Because as any developer knows, you're never actually truly done with a
00:16:00.000 --> 00:16:59.999 align:start position:0%
program. You can get 95% the way there or 99. But there's always part of you, that feels like you can always improve it somehow. You can always do something else. And indeed in the world of business. When you have business logic and changing business requirements, you can't have, that immutability. When you're talking about the business logic. You have to have breathing room for it to be able to change. And. So the diamond proxy standard gives us the ability to go from a complex immutable setup to a very straightforward straightforward approach to maintaining code bases, that can be arbitrarily complex. So. So let us consider a facet. We have facet here and we want to be able to execute a function.
00:17:00.000 --> 00:17:59.999 align:start position:0%
function. Typically you would just you know using Sorabon you would invoke a function directly on this smart contract, which in this case we're calling facet A. But. When you're using the diamond proxy standard you don't call the function here directly. Instead what you do is you call the function through the diamond proxy and, that function, which within the framework of this the jargon we use is selector function equals selector for all intents and purposes. So you may hear, that interchangeably. When studying the diamond proxy pattern. You run the function through here and the proxy internally looks at a set of selectors and those selectors are associated with a contract address. Address. And. Because it knows where, that contract
00:18:00.000 --> 00:18:59.999 align:start position:0%
exists, it. Then proxies the call to the associated facet, whether, that be facet A or facet B. Let's say facet A has two functions alpha and beta. And then you want to update function alpha. What you could do is instead of redeploying a version of facet A, that just has alpha changed, you could just have a very targeted approach and deploy facet B. And facet B is much leaner. Because it has just function alpha. So the gas costs associated with deployment are going to be cheaper. And. When you call this, it's going to get the most recent version version in the storage of these selectors. So
00:19:00.000 --> 00:19:59.999 align:start position:0%
before. When you're calling function alpha, alpha, it's hitting facet A. But once you upgrade, you call function alpha, it's going to be routed to facet B. Now what about function beta? Well, function beta doesn't exist here. We deployed only function alpha within here. Function beta still exists here. So the diamond proxy will continue to route it. And. So as you could see there is a lot of room for flexibility here. Now. If the developer wants to they could still deploy a version of facet A, that has alpha and beta functions and beta doesn't change. But alpha does. And, that just means, that. When we call the function to the diamond proxy, it's almost as. If facet just doesn't exist. It's functions are not being called. But
00:20:00.000 --> 00:20:59.999 align:start position:0%
that's not to say, that. If any calls you made to facet A in any way mutated the information information, that you can't access, that mutated information anymore from facet B. No, you actually still can access, that mutated information. So you can imagine a scenario where as time goes on you get more and more facets over here to the right and you could have a very complex program. If you wanted to. And going back to the analogy of object-oriented programming in a class, you could even from like a non-upgrading perspective, you could just deploy different facets like different modules of or name spaces within your application to have a strict separation of concerns. So, not only does this allow you to have
00:21:00.000 --> 00:21:59.999 align:start position:0%
that upgradability, it also allows you to have, that clear differentiation between different pieces of logic, that represents your program. So, from a bird's eye view, this helps consolidate your software's architecture. And not only does it do, that, as we just discussed, it helps you upgrade something, that would otherwise be challenging to upgrade. There's a second part to this, that ought to be discussed and, that is the diamond factory. Now the diamond facto's job is just to create a diamond proxy. So. So why would we do, that? Why not just deploy a diamond proxy directly? Well, you could. But there's a little bit of a setup phase just like how there's a
00:22:00.000 --> 00:22:59.999 align:start position:0%
setup phase with facets. With facets, you have an init function, which receives a pointer to the shared storage. And similar here with the factory. When it deploys a diamond proxy, it ensures, that the diamond proxy has everything it needs to initialize itself. And. So internally, it's going to set up, that stable pointer to the shared storage storage smart contract. And, that there abstracts away any setup you really have to do. So as a user, you're going to use the diamond proxy. But you're going to first start off with the factory. You use the factory, deploy the diamond proxy. And then once you're at, that layer, you could just go ahead and treat this as normal. You don't have to touch the factory ever again. If you wanted to. Or
00:23:00.000 --> 00:23:59.999 align:start position:0%
you could use the factory to create another diamond proxy and, that diamond proxy in turn will have its own shared storage address. And so on. And so forth. You can use the factory over and over again. As it relates to Sora, there is another feature of this SEP filing and, that's the storage helper. So typically. When we're developing in Sora, we have access to three different types of storage. We have the instant storage, and finally we have the temporary storage. And. So you would do something like storage instance.get or something like, that. And the same thing for temporary.
00:24:00.000 --> 00:24:59.999 align:start position:0%
Well, I wanted in this to have a very similar paradigm. So. If you wanted to go from instance storage to shared instance storage, you would do storage.shared shared instance or storage shared temporary. And so on. So it creates a very familiar pattern for the developer. There's only a slight difference and, that's, that whatever you're putting in whether it be a key or a value. Because it has to exist within the storage of a diamond proxy to know where the selectors are and where all the metadata is. Is. It has to be serialized to XDR format, which as storebound developers know is the encoding format we use for
00:25:00.000 --> 00:25:59.999 align:start position:0%
networking transmission. There's another component to the diamond proxy and this is more of a a meta feature and, that's the loop facet. Now in EVM land they call it a loop facet. It's like a smart contract. But here it's different. We have it leveraging Sora's inherent capabilities and we have it sitting with the diamond proxy contract itself. So. If you want to know the address for selector alpha, it will return to you the address of facet A or. If you get upgraded. Then it would return you the address of facet B. And. So the loop storage allows us to
00:26:00.000 --> 00:26:59.999 align:start position:0%
just introspect upon the diamond and it also stores the state of the diamond itself. Itself. Whenever whenever one performs diamond cut, which as we recall allows us to deploy a facet or smart contract, that will get recorded within the loop storage. Storage. Now, did anyone have any questions? Yeah, there were some questions. If we go back a little bit, let me see. I think there was a question about. When data is being stored.
00:27:00.000 --> 00:27:59.999 align:start position:0%
Oh yeah, say silence asked it sounded like storage isn't written to until ledger closes in this setup. If that makes sense. Correct. Yeah. Yeah. Let's see what else. Yeah, I think, that was what I think Matias had a question too. I think we can continue. Okay. Yeah. Uber, I don't know. If you
00:28:00.000 --> 00:28:59.999 align:start position:0%
wanted anything to add to this. But. If not. Then I'll just move on to deployment flows. Yeah, let's just No, no, that, that was great. Thank you, Thomas. Thomas. Okay. All right. So, we've already discussed this a bit. But just to visualize what's going on, you start off, you're the user, you want to ensure, that you have your diamond factory. Factory. Oh, sorry to interrupt you. But Silence had a question. that said, that you would access access storage as storage shared. Yeah, you would I look want to see Oh, here we go.
00:29:00.000 --> 00:29:59.999 align:start position:0%
So we have a pattern here, that's pretty much just like before. So you do env shared storage.persistent and I believe I worded it incorrectly earlier. But the idea is, that you have just a drop in replacement. So instead of env storage, which is what we typically do we do env.shared storage. And then you call persistent persistent or instance or temporary on, that handle. Okay. Yep. And other important thing to consider is, that. When you have access to, that persistent shared storage handle, you need to make sure, that whatever you're putting in has to be serializable to XDR. Yeah. And. Then Silus also mentioned, that
00:30:00.000 --> 00:30:59.999 align:start position:0%
that this would require the end shared storage would require a cap. Cap. So. So but this is a a CAP proposal as well, right? So so. If required we could make one and we've been told. So far, that what we have here is a starting point, that shared storage layer yes we're going to need to have it ingrained within the ecosystem and an incrementalist approach does make the most sense. But yes it will require changes to multiple parts of Sorabon. Okay great. Yeah. So you have diamond factory and the factory just creates diamond proxies. The user calls deploy diamond.
00:31:00.000 --> 00:31:59.999 align:start position:0%
The factory deploys diamond proxy. And then the proxy goes ahead and it deploys the shared storage layer. So. Now you have a diamond with no facets. Facets. Now you want to add a facet. You want to start start adding architecture to your software. So you go ahead, you call diamond cut. Diamond cut will deploy the facet. And then it will call the init function on, that facet. And keep in mind this init function, it's a macro within Rust. So you just add it right on top of the contract imple macro and it will inject the init function for you. That way. When diamond cut is called, it's passing a pointer to
00:32:00.000 --> 00:32:59.999 align:start position:0%
this shared storage layer. The next step is after the facets's initialized, we update the selector or function mapping. That way, whenever somebody attempts to invoke a function, as we see here next, it will perform a lookup within, that selector mapping. So, we invoke the contract. After we call the function through the proxy, we might set some storage or get some storage update or delete. And then we return the result and the result has to be XDR encoded and, that's is the additional requirement, which is typical anyways. So you're just adding an additional layer and, that's why again it's
00:33:00.000 --> 00:33:59.999 align:start position:0%
considered a proxy. Are there any questions about this deployment process and the life cycle of working with diamonds? So. So I think Neil Neil Nish had a question earlier about how would you design an upgradeable contract. While managing storage efficiently. So, Milage I think we address, that later on down in the presentation, right Thomas? Yeah, we do. Yeah. And apart from, that, how would you design? Usually you have to migrate the storage. Similar concern to traditional web two development. Yes. So again, the same question came up again, that you know how would you handle storage? Excellent question guys and and the the entire intent of the diamond proxy standard is, that you don't have to manage smart contract storage migration. Yeah. That's, that was also my takeaway.
00:34:00.000 --> 00:34:59.999 align:start position:0%
Great. All right. So I go down and I'm just going to compare compare what we have here, the diamond proxy, to what already exists in Sorabon. And in general, there are pros and what one chooses depends on what one has as requirements, any preferences. So I'll start off with the first one, which I think we've already discussed, which is the notion of granularity granularity the ability for us to be able to define define in very compartmentalized terms or even very uncompartmentalized terms the design of our software In
00:35:00.000 --> 00:35:59.999 align:start position:0%
In Sorabon. If you want to update the smart contract, what you have to do is you have to call a function and, that replaces the entire smart contract. and for some people, that's all, that's needed. But. If you have more complex requirements, you don't want to deal with the headaches of let's say migration, which is the next comparison here. Then you're definitely going to want to use the diamond proxy pattern. And as discussed, we have, that shared storage layer means, that doesn't matter how many times you upgrade your facets, it's going to always have a pointer to, that shared storage layer. And And with Soraon, you replace a contract, you're going to have to manually manage
00:36:00.000 --> 00:36:59.999 align:start position:0%
how you access, that data and where, that data is going to exist. Those are things you have to consider. But with the diamond proxy pattern, in Stellar terms, you don't have to worry about, that. You can just act like the database is always there. It's abstracted away. The code size limits. Now this typically in my opinion the benefits to the diamond proxy here in terms of code size limits is, that you can have a very small set of code and you could just do incremental changes. So you deploy a facet. And then you deploy another facet and you keep things exactly as needed. You could do a monolith. A monolith is completely acceptable. The diamond proxy
00:37:00.000 --> 00:37:59.999 align:start position:0%
can certainly handle, that. In Sorabon you're limited by the maximum size of the contract code, which is fairly large. But with the diamond proxy pattern let's say the limit on Soroban is n well. Then then your program let's say is 2n what you do is you have several facets. Then the first facet is of length n in size and bite code. And then the second facet is also in size of length and of bite code and you have different functions for both and. When you call the diamond proxy it's going to proxy it to the right smart contract address. So you completely get over, that hurdle of the code size. And by proxy you have, that same
00:38:00.000 --> 00:38:59.999 align:start position:0%
principle applying to the method count. Now the number is still pretty high for both. But nonetheless just imagine typical code base, that may have nowadays thousands and thousands of functions. Functions. The diamond and proxy pattern you can go ahead and you could accommodate for such and you can have very large programs. theoretically. If you wanted to, you could have a diamond proxy pointing to hundreds. If not thousands of facets, that in total are gigabytes in size. it'd be very interesting in terms of a case study to see somebody go forward with, that. And really, the sky's is the limit there. And I think people will do some very creative things with this. We've only really just touched the surface here. And with the performance and security and stability
00:39:00.000 --> 00:39:59.999 align:start position:0%
that Rust provides, I really think, that in contrast to EVM, we're going to have not only Rust developers in my opinion are just more seasons, seasons. But they pay close attention to the fine details. They're very good at what they do and, that's reflected by seeing how elegant Stellar is and the Diamond Proxy is complimentary to all of, that. It's a simple and elegant solution, which opens up the sky for everybody and Stellar it's in its name. I think Stellar is meant to be married with the diamond proxy. Because in a way it's what allows access to those higher realms. So to speak. The other comparison between the two is modularity and we've already talked
00:40:00.000 --> 00:40:59.999 align:start position:0%
about this. You can design your software. You could have different categories of your business logic in different facets. And you can visualize it as you have facet A. And then you have facet A1, which is an upgrade to facet A. And then in parallel you have facet B, facet B1. And so on. And so forth. So you could could independently upgrade these parts and still still separate the business logic. So it's clear clear you have the ability to through loop functionality to introspect upon these functions and the addresses. There's no notion of, that directly. With a smart contract you can of course get the AI
00:41:00.000 --> 00:41:59.999 align:start position:0%
that's different, though with introspection this is live through actual transaction calls and keep in mind every time you call diamonds cut, which is deploying the facet again the diamond proxy is recording, that in storage. So introspection will just give you, that information, that it's recording. Okay. So it sounds like everything's good and all with Diamond Proxy. But as I mentioned from the very beginning, there are indeed pros and cons. One of the cons is, that. When you're setting up the diamond proxy, you're also going to set up the diamond factory. And the diamond proxy is going to have to set up shared storage. So, this is really just a one-time thing. So, you have a constant initial cost. And then you also have costs associated
00:42:00.000 --> 00:42:59.999 align:start position:0%
with deploying a facet. And. If on Sorabon you want to deploy a smart contract, it is direct. But here it is indirect. Because we have to call diamond cut. Diamond cut has to ensure, that the bite code exists on the blockchain. And then it has to run the functions to initialize it and, that also includes passing in, that shared storage address. So. Because of, that yes there is not only a constant initial cost. But there is a constant cost associated as overhead with each call to diamond cut. So on Sorabon you don't really have, that issue. It's just a onetoone deployment.
00:43:00.000 --> 00:43:59.999 align:start position:0%
It's not a one to two or three smart contracts being deployed. It's just one to one. And to be clear, that one to multiple deployments only occurs in the very beginning. When you set up the factory and you set up the shared storage. But once you have, that set up, you don't have to reinitialize the shared storage. You just pass a pointer to it. So really, you're just deploying the facet smart contract in the direct proxy. But. But one of the key benefits of doing it using the diamond factory is, that let's say you're spinning up something like a let's take the example of a DEX pool right. When you know, that you have to have the same contract replicated multiple times. If you're using the diamond factory, that will reduce your overall cost in the long run. Because instead of having to deploy the entire contract from scratch, you're actually calling the diamond factory, which the
00:44:00.000 --> 00:44:59.999 align:start position:0%
bite code already exists on chain to deploy those contracts. Thomas, correct me. If I'm wrong there. Good. Yeah. want me to continue? You want there? Yeah. No, no. did I not you guys not hear me? Oh, yeah, we heard you. Okay, cool. Yeah, no, go ahead. We just discussed, that there is a bit of complexity and yeah, that does entail, that the transaction costs are going to be higher, and the costs are going to be lower on Sorabon each time. This point the development experience this this this really varies in my opinion there will be an initial higher overhead
00:45:00.000 --> 00:45:59.999 align:start position:0%
simply. Because you're going to see all this jargon. What's a facet? What is loop introspection? What is diamond factory? What's the diamond proxy? What is all of this? And at first it might seem like a fire hose, that it's really overwhelming. But. If I draw our attention back up here, it's actually really simple. And once one goes through the process of using this and seeing it in action in code, it becomes something, that is just intuitive and simple. So there is, that initial hurdle and, that is why in the very beginning of this presentation I discussed discussed let's set aside the jargon and let's talk about this in terms, that we're all familiar with the notion, that we have a class in object-oriented programming and we want to be able to mutate it. How can we do, that in web 3 space? So I think
00:46:00.000 --> 00:46:59.999 align:start position:0%
going with, that approach. When teaching this to others is you guys will eventually do you guys continue to learn more about this and actually apply it. I think just sticking to a simple analogy is the best approach. Less is more certainly here. It should not be something, that one overthinks. I know I certainly did. When I first looked at this. But the end of the day it's fairly straightforward. And in terms of state sharing again we already discussed this. So I think I will omit, that one. Are there any questions about the paradigm of the diamond proxy being brought onto Stellar or any logistical questions? Anything we'd be happy to answer.
00:47:00.000 --> 00:47:59.999 align:start position:0%
Yeah. Matias had some questions about large systems built on this, that how do you handle DevOps and monitoring etc. Etc. And yeah he says I'm guessing you would also offer at least a tool to handle the orchestration. Orchestration. So in terms of DevOps. If you want to be able to understand what's happening to let's say you have a very complex program and smart contracts may be dynamically deployed based on criteria, you need to be able to monitor, that. And so, that is an excellent question and, that is one of the reasons why we have the diamond loop allows us to introspect. But there's another part to this SCP filing and, that's, that. When you perform a diamond
00:48:00.000 --> 00:48:59.999 align:start position:0%
cut events are emitted and with those emitted events we have built in Rust a Stellar indexer, that captures these events. Events. And. So you're wanting to do DevOps, you're wanting to make sure okay everything is good. There aren't issues and. If there are issues we want to see them right away. You have an indexer run. You pass the index or the contract address of the diamond, which as we know is a stable address. It's not going to change. Change. And your indexer will. Then listen to events and you will have some application then, that listens to specific types of those events and. If certain criteria are met, you can send an alert to pager whatever software you decide to use.
00:49:00.000 --> 00:49:59.999 align:start position:0%
So really it's through indexing and listening and diamond loop functionality as well as listening to just those emitted events, that we open the door. As for for do we provide like an actual toolkit, that allows one to monitor their diamond? We don't have like an actual program to do, that. We have some components, that allow one to build towards, that. And I think, that as a community working towards, that would be a a very important next step. Because then at, that point we open the door to organizations very large ones in fact, that they want to build out complex software. They don't have to worry about the immutability of blockchain as we discussed. They just hop on board. And then they already have this open-source toolkit, that does all this monitoring
00:50:00.000 --> 00:50:59.999 align:start position:0%
for them. We it's certainly something, that can be done. There are no limitations there. Good question. Yeah, there's another question. If you have a demo app, that's built on Stellar, that are using this. Yeah, we do. Okay. Yep. Before we jump into the demo app, Thomas, maybe it would also be good to show them the diamond looper, that we built for seller to introspect this. And then jump into the app. Oh, for this presentation as we discussed, we would just go straight into the, other app. But we do have a link to repository to show, that, and it is getting short on time anyways. So we will go straight into the app. No worries. Sounds good. Okay,
00:51:00.000 --> 00:51:59.999 align:start position:0%
Thomas question by silence there to say, that. If you made an app there must be a contract to handle shared storage layer correct. Because he's feels like he's having a fundamental misunderstanding misunderstanding. So you don't even have to worry worry about the shared storage layer, that's abstracted away. It's, that. If you want to access storage in Sorabon, you're not calling env.persistent. Let's say you're doing env.shared storage.persistent. Storage.persistent. That's the new pattern. So, it's very similar. yeah. Any other questions?
00:52:00.000 --> 00:52:59.999 align:start position:0%
Okay, that sounds silence. Once you review it, I think it'll make itself clear once you actually have a peek at the SCP. But go on, Thomas. Yeah. So, as we're developers, I'm just going to draw our attention to what this application application looks like from a more programmatic view. View. We have the diamond factory, that we talked about. This is what we use to actually deploy. And we have all these facets, that we've deployed. And these are going to be used in a way, that allows us to keep track of KYC. So in this application, we have a set of compliance rules. So we have some say base requirements, that a person
00:53:00.000 --> 00:53:59.999 align:start position:0%
identity must pass. They have extended KYC requirements. And then somebody could come along and say, "Well, hold on. I was just told by some regulatory agency, that we need rule rule 54b or something." So, we go ahead, we add, that in. We have. Now the set of constraints, that one must pass in order to pass KYC verification. Verification. You have, that on the ledger. Right. Now I'm pointing at says Stellar test net. But really it's pointing to a local quick start docker image for development purposes. You have trusted issuers. In this case, we just have the company
00:54:00.000 --> 00:54:59.999 align:start position:0%
name and the trusted issuer has an address and they have defined a set of compliance rules. And. If you look here, we have these rules and say want to add rule 54b, we can go ahead and do, that. And we update the trusted issuers's information. And. Now the trusted issuer manages these compliance rules. We have identities. These are individuals. In this case, several of us on the call, Uber and Sebastian are identities here. And And. If somebody wants to go through the KYC process, they would come here and they would would add in information, that allows us to
00:55:00.000 --> 00:55:59.999 align:start position:0%
keep track of what's going on. So, organization admin, this is called the admin portal after all, allows one to keep track of this in a way, that increases public trust. As far as how this relates to the diamond proxy, well, you can just imagine a case where we want to change the data structure. Let's say we want additional columns here in the data. If we just had an immutable smart contract, we couldn't actually just change it. What we would have to do is several things. We would have to create a new smart contract, redeploy it, take all the old data from the first smart contract and copy it over and, that's not fun. But with this approach, you can go ahead and you can upgrade it and it's still going to point to the same information.
00:56:00.000 --> 00:56:59.999 align:start position:0%
the only sense of migration really is just you keeping track of okay am I changing the shape of the data internally in any way and then, that comes down to the burden as always is placed on the developer to consider carefully their data structures inform the architecture of the overall program. So right So. So just wanted to address some questions, that came up. there was a question by Green here about us validating the demand with Stellar developers. U, no, we didn't, we the target audience for this wasn't initially the Stellar developers. We once we actually showcased this to the internal foundation team, they were excited about it. They wanted us to showcase it to the development community to be used in other Art of Leo tokenization frameworks where we did see a significant demand for it come from was from asset managers
00:57:00.000 --> 00:57:59.999 align:start position:0%
themselves people, that were actually. If you're asking someone to do RWA tokenization and you're asking them to transition millions. If not billions of their assets on chain this is something, that they felt comfortable getting behind behind and and secondly with respect to Nomics ID what Thomas just showcased to you is a digital identity framework. We'll also be filing an SCP for, that. And creating a standard for anomics ID on the Sora network. What the Nomix ID would allow you to do is create digital identities on chain, that you can. Then enforce these compliance rules on a token. Just cut off. Oh, hello. Can you hear me? Oh, yeah. Uber we can't hear you. I can hear you. Oh, okay. U Yeah. So. So what it would allow you to do is create these digital identities, collect the appropriate documentation, that you need against each one of these
00:58:00.000 --> 00:58:59.999 align:start position:0%
compliance rules, that's being set against a particular identity, and then. If you actually we we're running short on time here. But I'm happy to showcase this demo at a later stage. When you actually go to create or issue tokens, that are part of this diamond proxy standard, that also include the identity storage as well as the token storage itself. You're actually able to superimpose individual tokens with prerequisite compliance rules. So it gives DeFi a somewhat centralized flavor, which is mandated by regulators in order to facilitate the transition of RWA onchain. Right. So, so. So to answer your question in a roundabout way, I am green. The entire intent was. If we want asset managers, that have not interacted with blockchain technology, that are have no clue about the underlying tech. But they want to get on board with the tokenization bandwagon and they want to come into RWAS. Telling
00:59:00.000 --> 00:59:59.999 align:start position:0%
them, that their contracts are actually upgradable in a very modular manner gives them peace of mind. While still preserving the audit trail, that already occurred on the previous transactions in the previous iteration of, that contract. Great. Yeah, I think it makes a lot of sense. U this this may not be a good fit for all projects. But I think you you had some some good use cases where where this makes a lot of sense to to to build it this way. Right. No, it would all be article ways. Because otherwise you are adding unnecessary complexity unless you're creating a DeFi protocol, that you is more experimental and you're expecting to update it on a regular cadence, maybe, that would be a good fit. But. If it's just a oneanddone deployment project, yeah, you're better off just doing it the old way. But. If you are doing RWAS and. If you are trying to win clients in the RWA space, giving those clients this peace of mind. Because legislation always
01:00:00.000 --> 01:00:59.999 align:start position:0%
trails innovation. There's going to be more legislative rules and policies, that are going to come in place, that these smart contracts will eventually have to comply with. Yeah. Great. I don't know. If there's any last minute questions before we we end here. Here. Yeah. Now you get it. My apologies. We should have started with, that shared. The entire purpose of the shared storage is. Because if you upgraded a contract and you tell me all of my historical transaction data is gone, the SEC is going to be banging on their doors and it's gi well played. Game over. They will never adopt. This is a way to soften the blow for asset managers to bring them on check. Yes. By a whole lot. Yeah. Because before, that they didn't even want to talk to you. You. Neil, you say you have a question. What is your question? Is it related to the topic here?
01:01:00.000 --> 01:01:59.999 align:start position:0%
, yeah, I don't think we have any more questions. Well, oh yeah, learn American language. Okay, Okay, it's more of a statement than a question. Question. Yeah, I agree 100%. Learn Soroban. Yeah, great. Thank you. So much for joining today. This was super interesting. I I'm looking forward to see see the progress and and see how this will play out. I think it's it it there's definitely some some use cases where I see this has massive benefits. So yeah, super exciting. Thank you all for joining and thank you for everyone who viewed this live live stream. We'll be back again next Thursday. Thank you. Bye. Bye. Thanks, guys. And look out for comments from both Wald and Silence. Thank you
01:02:00.000 --> 01:02:59.999 align:start position:0%
guys. Guys. Thank you. Have a good one, guys. See you. Take care. Bye.
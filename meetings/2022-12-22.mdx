---
title: "Auth Next: Account Abstraction Proposal"
description: "Discussion of Soroban Auth Next, introducing account abstraction and standardized invocation authorization to simplify signatures, enable complex contract calls, and improve wallet interoperability."
authors:
  - dmytro-kozhevin
  - justin-rice
  - nicolas-barry
  - siddharth-suresh
  - tomer-weller
tags: [soroban]
---

import YouTube from "@site/src/components/YouTube";

<YouTube ID="DPdguoSmvAA" />

This session walks through the Soroban Auth Next proposal, focusing on how authentication and authorization can be redesigned to better support real-world smart contract usage. The discussion frames current pain points in Soroban auth—limited invoker semantics, fragmented signature handling, and poor support for multi-step or cross-contract calls—and explains why these issues hinder composability and wallet UX.

The proposal introduces a more general, protocol-supported approach that shifts authentication concerns away from individual contracts. By combining account abstraction with a standardized authorization payload, Soroban aims to make complex transactions easier to sign, reason about, and safely execute, while remaining extensible to future signature schemes and wallet designs.

### Key Topics

- Limitations of the current invoker model and SDK-based auth helpers
- Account abstraction as a first-class concept, separating addresses from signature logic
- Built-in account contracts for classic Stellar accounts, preserving existing behavior
- Custom account contracts enabling programmable wallets and new signature schemes
- Standardized invocation authorization payloads that describe entire call graphs
- Signing thresholds and bounds (not exact values) to support non-deterministic flows like swaps
- Use of preflight simulation to generate structured payloads for wallets
- Improved interoperability between contracts, wallets, and SDKs without bespoke auth logic

### Resources

- [Soroban Auth Next proposal document](https://docs.google.com/document/d/1J-J3ClTUkrsLiJag906OH4hmNkZI3Jk6_Y9ZYt_psAI/view)
- [Soroban design discussion examples referenced in the Auth Next proposal](https://github.com/stellar/soroban-examples)

<details>
  <summary>Video Transcript</summary>

[00:00] Hello everyone and welcome to today's Soroban Design Discussion once again we're here and we're talking about Soroban and sort of the key design decisions, that we need in order to, that we need to make in order to sort of get it across the Finish Line for those of you who are just joining us today we will be talking I'm just going to grab a link as soon as I can find it. If you look at the event invite you will see, that there is a link to a document called Soroban Auth Next and I am also just going to paste it right. Now in the live chat. So today we're going to be talking about this proposal, which I'm posting in the live chat right. Now oh Tom already did it. So this is a proposal for a new Soroban auth approach, that provides protocol level support for the account abstraction and an authorized subcontract calls and again there's a link to the design decision document

[01:00] that is, that I posted, that Tomer posted in the live chat. And so what we're going to do today is talk through this question sort of talk through the document and the proposal, that it makes and see where the discussion leads us the goal of these discussions is definitely to make substantive have substantive back and forth to actually ask and answer important questions and to start to move forward with design decisions and we do it here so, that you can ask questions either on the live chat. If we have a chance we may also be bringing people who raise their hand onto the stage. But to begin with we will talk through the actual design doc we'll talk about the decision, that we're trying to make and we will talk about the sort of like the background the problems, that we're facing the requirements and a suggestion for a high level design. And so now, that it's a little bit after the official start time I think we can go ahead and start and I believe, that today the

[02:00] discussion this doc was created by Dima. And so I'm going to demon to start walking us through it yeah hi everyone. So but maybe I'll start with a little bit of background motivation this. So described in the dog. But how quickly go through those. So just to remind like the current state of office in Sargon is, that we basically have to kind of officially supported ways right to do us in the contracts the first one being the invoker, which basically just gives you a handle of the classic store account who involves the transaction and, that's pretty limited it's like basically quite extra account can authorize only a top level contract invocation and only it and there is something more generic

[03:00] which is implemented in turban OS SDK and this is basically authentication and SDK, that supports a couple type of signatures, which are classic store accounts Ed 25519 and invoker as well to make things a little bit more generic and recently we ended up in this somewhat weird state of to approaches, that the initial philosophy was, that we want things to be like basically implemented as much as possible on the contract side and the environment doesn't make pretty much any assumptions about the toes. But then we kind of figured out, that these things are not quite straightforward especially. If you want to do something simple, which is why this working concept I've been talking about has been brought up. So

[04:00] and of course there is always synthesis smart contracts there is always a way to build whatever you want. So what are the problems with the state here. Now the invoker. While being a convenient to use it's very limited as I've mentioned it's like very narrow only operation can have only a single invoker right and it's also shell in a sense, that only a single contract call may be authorized and it's also restricted to basically classic accounts of course it also works with the contract navigations but. Because they got today's discussion I'd say nothing would change much for the Contracting workers. So basically. If contract wants to outrage some synonyms at the help of contract itself like no additional signatures are needed. So it is kind of not in the scope of the discussion at all. So we are talking

[05:00] about only humans or wallets calling into a servant here right. So for Soroban us well as we mentioned it's a pretty complicated. Because the contract needs to manage nonsense it needs to go into authentication methods provides the right arguments those upload correctly. While being pretty complex it's still limiting flexibility. Because we support only a few kind of Cherry Picked signature schemes right and. If you start doing things with Advanced for Banos like forwarding the signatures for subcontract holes Things become pretty tricky in terms of like actually signing the payloads, that need to be signed. Because you need several signatures and they need to have some very particular arguments and I believe I have seen some examples in

[06:00] servanton, that or dealing with, that. But I feel like still like this hasn't been expert to mentioned probably. Because it's pretty tricky to do and yeah I also don't think we have great science support anyway as of. Now so it's something you will be working on separately and of course. If you are doing something completely custom the risky risk running into it's a compatibility like some contracts use one authentication or authorization methods Azure contractors something else they like not being profitable or the SDKs need to account for multiple different Azure SDKs they need to interoperate with. So basically Things become pretty complex. If you want to kind of benefit from something else existing on the network. So yeah this is basically a review of the current approach problems and

[07:00] I've been thinking like. If it can come up with something better in multiple ways and this phase are described in the doc too and. If you really want to try for is the approach should be a general rights, that most or all contracts should be able to use their spring work and basically interoperate is a chatter without much friction. But on the other hand it should be extensible so, that we are not limited to a few for example signature schemes or a few wallets and whatnot. So there shouldn't be a way to extend the system outside of the protocol right it should also provide support for various use cases including the complex use cases. But at the same time it should be a straightforward as straightforward

[08:00] to use as possible given the complexity of the contract and from the lowest endpoint it should be usable too. Because as I mentioned like currently coming up with signatures for more complex contract invocations it's pretty tricky. So what would kind of should be able to write the signing code to basically sign the payloads without much prediction as well and something, that hasn't even been discussed before. But it's something pretty interesting, that there like we want to provide the both controls. And so outside and yeah this kind of already goes into account abstraction topic. But basically the idea is, that. If you stop for a moment and think about Us in general like in erc20 world for example right you have

[09:00] this for example token contract. So liquidity pool contract, that does something to the funds. But it holds also does some other things, that I could verifies signatures and the signatures use very specific algorithms and you start thinking about it kind of doesn't make too much sense right your liquidity pool function is about exchanging to tokens for example a token function is to keep balances right and doesn't necessarily like come natural, that they should handle the business logic of authenticating users at all visuals versus account abstraction, that comes from and it really opens up a lot of various interesting use cases and basically enables the whole type of the contracts the smartphone contracts, that can do really interesting things like providing

[10:00] arbitrarily complex multi signatures schemes or align users to control Hauser plans are spent based on who signs the transactions or given temporary permissions to some contracts and the possibilities are basically endless. So yeah this was it on the requirements topic and this kind of only started to come into the actual proposal and basically on the hair level it consists just of the two parts one part I've already started talking about it's account abstraction. So instead of letting every user contract to care about how they authenticate their signatures or how they manage nonsense. And so on instead you would every contract

[11:00] would use something abstracted away just some generic account, that knows. And so on how to authenticate actions on its behalf and this addresses the triology and extensibility requirements as well as forward usability and control and the second part is basically standardized invocation authorization, that would allow to sign things, that are on one hand more complex than just going into a single contract. But on the other hand it will be structured enough so, that the bullets I don't need to do anything too special. But like the non-smartboard just regular walls we'll be able to do the signatures relatively easily

[12:00] okay and let's go in turn a little bit more details on both approaches and I'll probably stop serve for some maybe questions and discussion on the general approach. So core current abstraction what's important to understand from the contractors standpoint is, that instead of like passing signatures into a medical calling into this and invoker we do now, which is like an educator in a cage all the contract interfaces would operate on two types one Echo account and, that's very cool address. So the relationship is, that every account has an address is something, that you can key your data by. the address or you can make a payment to an address and whatnot. So

[13:00] that's basically the unified address for any sort of operations, that are beneficial to the address right and the account itself is the owner of the address and it is the entities, that can authorize basically spending on behalf of this address right. So account needs to sign its operations and actions, that require like some mutations to the address, that are not positive for example making a payment right need to be authorized by the account. So this is basically what the contracts would do this and accounts may be implemented both in a built-in fashion for example classic store accounts would get an automatic implementation of this account contract. So from the classic

[14:00] server constant Point nothing will change significantly and the invoker would still be there for the sake of optimization right so. If you have a simple contract you can forward the classic transaction Source account to be the signer of this Contracting location to and again this is completely transparent from the contraction point and like it is. Now where you explicitly need to refer to the invoker. But also the part I've been talking about before the account can also be implemented by Mark contract custom Smart contract and here like things like new signature schemes like any cryptographic methods and basically anything can come. So it's the responsibility of the account to authenticate and authorize

[15:00] the Contracting locations, that's the key part about it and on the second part for standardizing the invocation authorization. So instead of like having some signature payloads, that are not necessarily standardized we would have a structured signature payload, that contains one or multiple Contracting vacations and the casing here is, that this payload needs to be assigned just once and it would contain all the contract calls the user wants to outrage. So for example the frequent use case. When you know you need to transfer some funds to the contract address. And then contract does something good for you right for example create a claimable balance for like just draw some amount from me and put it on contract balance to the Future withdrawal or swap some

[16:00] token with liquidity for basically it's like huge category of use cases for this exact same pattern right and. When in ERC 20 world like some things like approval permit would need to happen with this approach it is possible for the user to send a payload, that says hey call into function for example Swap. And then allow the function swap to this draw this amount of token from my account and since things are structured it's possible for example for the user board program to say Hey you are about to sign something, that will withdraw this and, that token in this in, that amount. So basically it is set things to the structure it is kind of both transparent to the user and it is possible for the host to actually verify, that the user is only calling into methods, that have been explicitly

[17:00] signed date and I'll try it and yeah important note, that came up during this document review is, that the signature pillow doesn't like have to contain all the contract calls and it doesn't even need to be like covers and full passing the code three of the contract it's just part of the parts, that has to be authorized on behalf of the user. So for example the slope example. If the user swaps some token with the contract this contract may be a code as a part of arbitrary as a contract for example you know you are signing, that you want just to swap some amount of token for some amount of other token. And then this can be invoked for example as a part of some more complex text construct and the laser doesn't even need to know about this contract. So what was the authorizing is a, that something has to be solved. And then

[18:00] some Upstream systems can decide how exactly this happens. So I think this is pretty much it on the high level before we go to the details I'd like to stop here and ask. If there are any questions or maybe some things need to be clarified yeah this is awesome thank you Dima I'm just for everyone who joined just. Now I just want to mention, that this is this meeting today is not about necessarily making decisions it's just about having Dima present this like off to or off next approach and you know ask questions and to figure out the details here this is a really interesting proposal Dima I think, that one question I have around account abstraction is one thing, that we're seeing in other ecosystems is, that account abstraction is also mentioned in

[19:00] the context of being allowing for like different accounts to be the origin of the transaction and I wonder. If this proposal also pays the paves the way for kind of like a non-regular Stellar account to be the origin of a transaction to have in like a native balance in XLM, which is something, that isn't mentioned here or is this not a consideration at all. So I didn't think about this much in terms of. Because this is more about us. But but you know I think it kind of comes back to the discussion we had about price twins for example like visor contracts should have tried to end. So whether contracts should have excellent balances I don't think, that it necessarily well I think it kind of

[20:00] makes things easier in a sense, that you know since every single operates on accounts. Now it is kind of more natural for the account to also have excellent balance they mean it will have like some balance in effect. So but. But I guess this question is more up to the design of the you know interactions with xlma I'm not sure we have some different decisions, that it basically once referred like it might make things simpler. But maybe not. Because the main problem is withdraw in any XLM from a contractors, that we wouldn't want to run a VM for, that. So I think, that the question, that needs to be resolved before we can go into this topic

[21:00] topic yeah I guess my question is should the XLM balance be part of the account abstraction or potentially facilitate this in the future right. So so basically I mean nothing prevents an account contract to have an excellent balance right the tricky part is how exactly do we withdraw this Excel and from the balance without invoking a VM and figuring out, that this account has actually not traced this so, that's the tricky Parton I'm not sure about it. So I mean interior like there is a very easy way with account abstraction to do, that the only issue is, that would require to actually call into account contract, which is a problem. Because we need to do this before applying anything, that's a little concern. So yeah maybe I can add a little bit to this like the kind of the type of challenges in the account abstraction in other blockchains

[22:00] they come from the like. When you try to use the contract to pay for its own fees right I can basically like you have like sequence numbers like nonsense basically and fees being paid back the contract and as you as soon as you start to get into, that game you need to basically execute the contract. When you're flooding the transaction. So before it gets processed by the network. And then you get into those like yeah like big challenges around okay how much like what's the maximum gas or whatever right, that I want to allow a contract to use outside of applying transactions and of course this gets quite complicated maybe like to go back to like to what Thomas was asking like would, that be the type of thing we can add in the future I mean I don't I think

[23:00] the current proposal doesn't stop us from doing, that. If we find ways to make this efficient like maybe like some of the things we could and this is related to the other conversation we are having on the token contract like should the Lumen balance for example attached to a contract be something, that is kind of first class so, that we can efficiently like even decide. If like. If if a contract has even enough balance to pay I mean this is one of the problems it's not the only problem. But you know it's one of those things, that maybe we could do early on anyways. But yeah, that's kind of where we are I'm curious. So there are two parts there

[24:00] are too many major parts or main parts to this proposal the first one is the account abstraction the otherwise the other is a standardized invocation authorization. If we focus on account abstraction for a second putting aside some of the details, that we just mentioned is anyone does anyone object account abstraction it sounds like it's pretty I think it's a win-win situation like we're looking at other ecosystems and you can see, that you know the Ethereum ecosystem is working very hard to retrofit account abstraction and you know regretting not adding this in the beginning and we're seeing a lot of like challenges, that come from not starting off with account abstraction. So it almost sounds like a no-brainer to me is there anyone, that opposes a account abstraction

[25:00] Dima from your perspective are there any downsides to adding account abstraction yeah. So it's a account obstruction in building fashion is definitely like a win-win in a sense, that you know like. If you're joking about things, that are supported by Fosters almost no performance cost and the contract interfaces become really convenient in terms of the custom abstract accounts I mean it's definitely a win from the functionality standpoint the downside is, that you know using them would require more gas obviously. Because you need to run mobile and you need some additional they are invocations. But I mean I feel like this is a fair price. Because it allows to achieve some functionality, that is not the chewable

[26:00] otherwise. But yeah basically the main cause to it is the performance cost and we need to be at work with and you know it's some party wants to you know pay for the contract notifications and they may have the same trouble with absolutely it's a custom account project. But yeah not sure is it's a big enough deal basically I think in gree Lake account abstraction could be implemented in some way even. If they didn't do anything on the cost site. And so it would be even slower and worse. So you know I don't think this downside is being cool enough to kind of state it shouldn't go for account extraction awesome okay. So I think we can move to the standardized invocation authorization yes people don't want to keep talking

[27:00] about account obstruction can I ask you just a quick question timer go for it yeah. So does this mean, that we are. If it sees white adoption for just regular accounts or maybe this is the most basic question, which is does this impact regular accounts can I take my Stellar classic account and put signing Authority on into a contract and. If so does, that sort of blur the line I mean we have this sort of clean separation between classic and Soroban. And so are we you know sort of opening up the sort of bleed over between those two systems wider and consuming you know forcing more sort seller transactions to use Soroban resources in a constrained resource environment is, that a downside I guess oh what Miss herpes actually this is not

[28:00] right like I don't think anything changes functionally much for the classic account compared to the current world. Because currently we already as I said provide this invoker method, that calls them to Classic Source account right and we also allow like we have SDK for the promoted in the transaction for the inbox Paul tries in the contract invocation on behalf of the classic accounts, that have been pre-signed. So you can pre-sign something using your classic store account with threshold and server they did. So nothing changes in, that sense and from the contrasting point what actually changes, that contracts themselves don't need to know about, that classic account existence, which I think is pretty good thing. Because like the as I said like there is really no good reason

[29:00] because I can't to worry about like how exactly something has been out right. So I don't feel like there's any functional difference. But seriously the positive effect of contracts being more generic without like specifically according to the classic accounts yeah I would add to, that like my mental model of this is similar to what we're doing with a Stellar asset contract on suraman basically all the interrupt with Stellar classic and all the you know idiosyncrasies, that come along with, that they are in this built-in contract, which applies both to the Token contract for the asset contract it also applies for Stellar accounts now, that we have proper abstraction all the finagling with Stellar accounts happens within this built-in contract to some extent it's actually a lot cleaner. Because it

[30:00] doesn't it doesn't pollute like the you know post functions like they don't need to know too much about Stellar accounts. Because all of, that is kind of like abstracted away and is mostly present within this built-in contract would, that be accurate them up yeah exactly Nick does, that answer your question yeah, that's, that's helpful thanks cool so. If there are no other questions on the account obstruction we can move on to the standardized invocation authorization this is definitely you know the more I think a fairly novel approach and I'm curious Dima what the potential downsides, that you see here are like one thing, that I will say is, that like one thing

[31:00] that immediately gives me pauses is are we putting too much on like the pre-flight process you know I think. When we were talking about pre-flight just for in the context of getting the The Ledger entries, that you're gonna touch, that's something, that's relatively easy to you know to predict. So for example. If you're going to do a token transfer maybe you don't actually have to call PreFlight you can skip, that. Because you know what's going to happen there in terms of the signature payload suddenly a signature payload appears to become like non-trivial at all. So are we building too much dependency on pre-flight here well I would say I would put this like okay let's talk about separate part. Because I don't think about it before. So what tomorrow refers to is basically the way I propose to enable this

[32:00] approach for the user can sign like complex payload with multiple contract invocation the main enabler for, that is PreFlight, that would basically run the Contracting vacation in like authorization trades and mode and return the signature payloads, that need to be signed by the votes and I would argue, that this is basically the satellite kind of an enabler of the approach. Because without, that the only thing, that we have left. If we want to do something more complex than one invocation one signature project invocation would require custom payload building, that is also contract dependently. So basically the proposal itself is about standardizing the payload format

[33:00] which in the first place say wait probably shouldn't be like really controversial. Because like the benefit of having custom rewards is kind of questionable right. But you know. If you wanted your pillow to be complex like what is a good way of building it and pretty quiet it's one of the answers to, that. But for the simple cases you know as you have mentioned like well what. If we transfer token the same can be said about the signature preload like. If you are in the same world where you just you know want to have a single account, that signs for a single contract code, that doesn't go into any sub subcontracts on behalf of, that account. Then the signature pilot is very simple and it's not trivial and again the benefit of having its standardized and structured is, that you know you can write a libraries, that

[34:00] would build simple payloads for you and, that would work again for every contract it is you can say framework creates a kind of search and stuff, which we hope to be almost any contract. So so I'd say like there is definitely some downside like in, that in case of a really complex invocations on behalf of the user the pre-pride needs to be used twice and it may be a little bit annoying. But you know the issue is, that alternative to, that would be World War everything needs to be built manually like prefighters basically is the best thing we can probably provide out with, that or you know just go with the approach of erc28 approach right therapy just always

[35:00] saying the single call. And then did do a lot of State manipulation to actually make things work. But I'm not sure, that's necessarily a good thing. Because it comes with its own set of problems, that again arguably should not be stopped on this level like we put some things into token interface. But what. If I want to write. Then a POI can include my grade all this set of different methods, that actually work around the limitations of like the signatures. And so on. And so forth. So basically the prepaid here is something, that actually helps us a lot I think and yes like made this Rich downside and maybe increasing a lot and it or it is rare cases where it cannot be used. But you know you can always build manually especially. When you like control will

[36:00] control exactly also contracts in your Coast Tech and you know exactly what needs to be signed. So I don't feel like it's big enough downside and also I wanted to mention, that like the approach here is a bit rough around the edges. So it's around some other things, that may be different in terms of implementation for example like maybe they could some logic a bit more. But basically yeah I don't want to go into details maybe just yet. But the point is like maybe we can make things a little bit immature and they are described. Now but yeah I'd say creep white is like I wouldn't look at prepare the downside it's actually quite an upside. Because also Alternatives we've looked at well discussing like

[37:00] what we how can we simplify building the payroll say would be kind of for example an alternative we have discussed with John a. While ago also aquatic contract could provide the methods, that says how exactly to build a payload for every call of the contract matter. But you know this is a lot of work to be done by the contract developers and again it needs to happen for every contract well here we kind of come up with a generic mechanism and you know the contract writers don't need to worry about the better homes they can just write pretty complex contracts without worrying about users not being able to ever build signature for one and you know it doesn't need to be part of the interface or anything it's like very naturally healed so, that's my sense on it I you know someone has more

[38:00] concerns about, that yeah maybe the thing, that yeah. When you mentioned like the whole like having to do this work for like contract developers having to do this kind of work for every single new interface type is kind of a is super important like I think yeah what we're talking about here is. If you look at like erc20 like you have for example the what's the Ikea 2612, that's the permit extension, that's for your C20. So like. If you think of like NFTs right they don't use this it's a new method. And then you have to basically support this both at the contract level like as a caller to, that contract you have to support this new this kind of way of wrapping and signing things right and you also have to of course do, that in the wallet in the SDKs. And so on. So the complexity is increases very

[39:00] quickly. When you don't have any standouts. So I think the being able to use PreFlight, that we have there available to us in this context is actually going to reduce friction around the adoption of like those kind of a encryption schemes at the right place in the different contracts in a way, that I think is maybe like a unprecedented in the ecosystem oh yeah, that's a good point and obviously. If if the ecosystem wants to adopt like in the ap2612 style you know permit based authorization they can do, that. But you know we hope, that you know we want to make something, that's batteries included one other question, that I have just like looking at the doc right. Now is you know it looks like we're signing all the function calls including the arguments it are there situations in

[40:00] which the arguments change slightly between invocations in a way, that invalidates the our signatures FEMA yeah. So yeah the testing discussed on the doctor. And so basically the idea is, that you probably shouldn't write your contracts in a way where the signature arguments change for the subcontract codes again it doesn't really matter what kind of your approach you're going with like even. If you go we are seeing 28 permit for example like you cannot say, that hey what are the arguments of current change a little bit like whatever has been signed has been permitted. So it is kind of similar and in cases. When you know some arbitrary amount of token need to be spent for example the proposed approach is use approved

[41:00] style method like we wouldn't remove it from the token interface it's too useful for cases like, that the difference would be like. If you do things like temporary storage for example this approve may be alive only during the top level Contracting location. So you know there are no problems with hey I've approved this token like a thousand units of the token. But the contract spend just 500. And then there is outstanding 500 approval for me and this contract, that someone may misuse or whatever. So instead what would happen you would atomically call a proof inside the contract invocation and it will only be active during this contract invocation the top follow one. And then basically after a proof has been executed the contract can spend up to approved amount of so. Because of the user and obviously not the whole amount

[42:00] needs to be spend. So this amount will just stay in the user account and zero won't be even an outstanding approval, that can be done with you some help. So basically the idea would be, that the user still needs to sign some upper bound on what is going to be spent and, that's basically the hope, that this is you know for the most contracts and again it's not like we can do much more besides maybe I don't know user signing, that they approve spending as much as contract wants. But again we don't remove this possibility either. So basically yeah I think like the contract should be reading just in a certain way to kind of allow for specifying an upper bound not an exact amount, that needs to be transferred from them this problem shouldn't appear much and it's kind of unrelated to this proposal it's like in general. If you

[43:00] want to do anything with outright subcontract both we will run into this issue and I think, that I was thinking also about, that like the there might be ways actually to you know once we have kind of the this kind of authorization model kind of figured out like we may actually do some tweaks to the standout token contract like I'm thinking like we could actually have like the for example the transfer method right. If it had like a max amount actually explicitly there. And then the authorization, that is done inside would be on the max amount on the on not on the actual amount this food, that I actually I think allow us to get rid of even the pre-approved and later pay you know with like some other amount, that's smaller

[44:00] I think, that we could do things like, that yeah maybe basically like to be clear like contract can require user outrights arbitrary arguments based on its input arguments. So it's not like you know we have said in each and every argument. So it's definitely possible to have methods where you assign one argument and the research, that just well passed around this. So you know again this similar to account abstraction like this opens up a lot of new approaches and tours and eventually like the token interface can be modified to account for this basically again I think the difference here from many other things is, that you know we want to make it easy to call things on behalf of the user and the source of interface you can come up with having this feature I think like more resources needed to actually come up with writing Pages for, that right. Because we can make things much simpler and safer than they are. When

[45:00] only a single invocation can be fine pretty much properly. So I think, that's more of a question to with to the interfaces and not necessarily. Because yeah I definitely think I'm not sure I'm looking at the document right now. If we can have like a detailed the like description for how this would work with like non-deterministic arguments like I'm looking at your like your main example of like swapped in transfer and I feel like you know. If the swap is a strict send rather than a strict receive. Then you know you're not going to know what the amount, that is actually being transferred in advance or even during pre-flight. So I think maybe just like unpacking, that example would help. So I have an example of the atomic slope right and what it does is basically what you sign is, that you want to swap an amount of

[46:00] token a for at least an amount of token B right this is what you're saying Yeah. So basically you send, that you want to spend it most amount of token a and at least the amount of token B, which I'm not sure, which and receive this message. But basically. Then the users who have signs, that can be they can have their tokens robbed atomically and the example I settle for the you know price for example. So not all the token is being withdrawn and as anyone ever use this Contracting week multi-stopper. When you have multiple parties like on both sides, that can solve it to each other. So basically my point is, that again the main thing, that you sign the thresholds not the actual amounts. And then definitely possible to just spend or receive business threshold without

[47:00] any additional input from the user. Because again these are just saying the thresholders, that kind of works got it demo one question from moots or statements in the live channel is, that moose would love to see address identifier and like byzen 32s all of these kind of like converge and I know, that people have been pretty frustrated with the existence of all these different ways to describe accounts does your account abstraction solve this yes definitely right like this is about what I do in my prototype already and, that's definitely something I've been looking into. So basically they said like. When you want something authorized you just needs account and you want an address you just use address, that's pretty much it

[48:00] so. If you want to do something for example on behalf of the current running contract you just call get current contract account, which is account type 2 right. So from the contract Traders standpoint where you don't have any additional it you may still need the contract ID for some use cases. But it will still leave this. But you know this is Project context. When you are interested specifically in the contract ID right. Then it will goodbye. But in all the operations, that involved with any manipulations I would say right you would just use a Content address types there is no identifier type anymore the bytes are just used for things, that are actually bites like a passual contrast City. But there's a not since involved into our spring work for the most part I said, that smart forward themselves

[49:00] okay I hope, that makes moons happy it does make me happy great are there any other questions either internally or from the audience Dima. If people want to learn more about auth off next what should they do besides reading the document what's the document has links to the examples I think examples definitely a photo kind of have a grasp of how things may look like again you know this is the two broad Stitch and it may change. But you can see some general ideas where you can see, that accounting addresses I used everywhere not in the first stuff like, that how the calls have been authorized. And so on. So yeah look at the examples too just kind of especially like

[50:00] luxuries like time work examples, that where you can see exact tips from the current implementation and the swap examples are something completely new, that is really painful to do right now, which is why we don't even have an example for example. So yeah I think, that's, that and yes and just ask me either as a document or Discord do you have things, that you think are not covered anywhere. Then you can answer it awesome. So after the holidays we're gonna meet up again and talk more about off and I think, that for today Justin do you have any other thing or is it a wrap no I think it's a wrap happy holidays everybody definitely check out the doc definitely watch out for more saurabhan design discussions coming up after the

[51:00] holidays and everybody have just a great holiday season

</details>

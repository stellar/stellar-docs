---
title: "BN254 Performance Upgrades and Closing the UX Gap Between Soroban and Native"
description: "We have one new CAP to discuss and that is CAP-80. This proposal adds BN254 Multi-Scalar Multiplication and modular arithmetic used in a variety of ZK proof applications."
authors:
  - carsten-jacobsen
  - dmytro-kozhevin
  - jay-geng
  - matias-wald
  - siddharth-suresh
tags: [developer, CAP-73, CAP-80]
---

import YouTube from "@site/src/components/YouTube";

<YouTube ID="TXuKiEEwEsU" />

This protocol meeting covers CAP-80, which extends Stellar’s BN254 host support with multi-scalar multiplication and modular arithmetic to significantly speed up ZK-proof workloads. The session also includes a follow-up on CAP-73, focused on improving Soroban interoperability by making it easier to create new accounts and handle trustlines intentionally.

### Key Points

CAP-80: adds BN254 G1 multi-scalar multiplication (MSM), BN254 modular arithmetic host functions, and on-curve checks to improve ZK performance Rationale: reduces expensive guest-side math and avoids repeated point conversion overhead from many add/mul calls Expected impact: major performance gains for contracts using BN254-heavy proving workflows CAP-73 follow-up: enables creating new G-accounts when transferring XLM from Soroban (still requires covering the base reserve) CAP-73 trustlines: proposes an explicit trust(...) function to create missing trustlines when authorized, rather than doing it implicitly during transfers Resources: CAP-80 spec/discussion and CAP-73 spec/discussion links for deeper review

### Resources

- [CAP-73 Allow SAC to create G-account balances](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0073.md) · [Discussion](https://github.com/orgs/stellar/discussions/1668)
- [CAP-80 Host functions for efficient ZK BN254 use cases](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0080.md) · [Discussion](https://github.com/orgs/stellar/discussions/1826)

<details>
  <summary>Video Transcript</summary>

[00:00] All right, Yeah, So we can get started then. So yeah, today I'll be speaking about CAP 80 and then after that demo will follow up with, some updates to CAP 73. So I just pasted the CAP in the chat, So CAP 80 adds some host functions to enable some more OK uses on Stellar. So in Protocol 25 we added G1, add G1. So in Protocol 25 we added G1, add G1. So in Protocol 25 we added G1. Add G1. Multiply and a pairing host functions. Which gave Stellar BN24 feature. Parody with Ethereum. But this CAP proposes some additional host functions. to allow for better performance, So the functions are some: BN254. arithmetic host functions. BN254 G1 multiscale multiplication. And is on curve checks for BLSG1, BLSG2 and BLS. BN254G1.

[01:00] BN254G1. BN254G1. So the know the with arithmetic, Host functions are expensive to implement on the guest side, which is why we're proposing adding these to the to. We're proposing adding these to the host, and the same applies for the on the host and the same applies for the on the host and the same applies for the on curve checks. We're also adding G1 multiscale multiplication. Because the cost of repeatedly converting points, between the external internal, representation can be expensive and these repeated add and multiplication, host function calls, do those conversions? On each call back and forth, which is pretty expensive. So this multiscale multiplication host function will allow a contract to only do this conversion, once at the beginning and the end, and we already have cost types for most, of these host functions. So the only one we need to add, is for BN2, BN254 G1 we need to add, is for BN2, BN254 G1 we need to add is for BN2, BN254 G1, MSM, MSM, MSM. So I don't think there's anything. that controversial about this change, We are. We're taking feedback from they are. We're taking feedback from the ecosystem on what, what they are.

[02:00] Ecosystem on what, what they're asking for. But I, yeah, I wanted to open asking for. But I, yeah, I wanted to open asking for. But I, yeah, I wanted to open this up to any questions. If anyone has any opinions on any other host functions, we should add: yeah, Are there any? questions? If anyone does have any opinions on you, know what else we should add? Or look, into for, for specifically for the into. for specifically for the like OK host functions, You, you can post in this discussion. right here, that I posted in the chat, Yeah, so doesn't, so there's nothing. else. No one has any other questions, or input, Jay, you don't have anything to add, add, add then. then, see, see, see, no, I think it's fairly. straightforward. And these:

[03:00] Straightforward. And these, yeah, these functions, or exist already. for BRS as well. Seems to be useful to have the reasons they didn't. They won't add it in the first place. Is likely, just we were trying to get it on. Likely, just we were trying to get it on likely, just we were trying to get it on par with in the first iteration and get feedback. So these are the second. on which makes sense to be added: AT&T. Yeah, makes sense. I see Mate. Furthermore, I see Mate. Matias is typing something. I can. follow up with the offline. Furthermore, I can. follow up with the offline as well- to. To send the-the discussion as well, to send the, the discussion thread to the people you think should be threaded to the people you think should be here that aren't But other than that. DIMM, if you're interested, if you're ready to present Cap 73.

[04:00] AT&T. Yeah, go ahead, Dina. AT&T. All right, thank you, I, I guess. one thing you could mention for CAP 80. is that it's actually about three. times: improvement in performance for the contracts that actually try to use this, functions and some interesting applications. So yeah, seems like a very application. So yeah, seems like a very cool thing to have, All right visit. Let me mail my link: cat 73 links, cat 73, link, cat 73 and discussion of cat 73. And I'm pretty sure I have presented, it before, but that was a while ago. So it before, but that was a while ago. So it before, but that was a while ago. So I will quickly, go over the summary of the CAP and then go over the summary of the CAP and then go over the summary of the CAP, and then I will move on to the proposed changes. So I just realized that CAP does. not have the most recent PR merged. Let

[05:00] Not have the most recent PR merged. Let me also, link the full request. That actually details the update I'm going to make. So CAP 73, is a CAP that basically closes. One of the gaps between turban and comic, operations, this gap being an operation, this gap being an ability to create new balances, for the G accounts from SAC, As you, may or may not know currently if a May or may not know currently if an account does not exist, you cannot. transfer XLM to it. And if a trust bank does not exist for a classic asset, you cannot use sack to perform an asset. You cannot use sack to perform a transfer to the respective G account, and this is a little bit annoying. because, in order to fix this,

[06:00] Because in order to fix this, behavior, you need to actually go out of Sora ban ecosystem and go back to the classic operations, just generally quite suboptimal developer, Experience, experience, experience. So what's a CAP? Oh, I see CAP has. So what's a CAP? Oh, I see CAP has. So what's a CAP? Oh, I see CAP has just been merged. What the CAP does in the current iteration is just two. small changes to what sack does, First change is when we are dealing. with XLM tag, specifically transferring XLM to a G account. That does not exist yet will result in: creation of that G account, with respective XLM balance. And this part of the CAP has always been there and it- the CAP-has always been there, and it never changed. So it both basically allows creating new accounts, new G.

[07:00] Allows creating new accounts. New G account from Saroyan and, in general, just closes the gap in behavior where now for XLM stack, you can just transfer to any address and if it is a G address, and an entry will just be created, which is a big win for the developer, Experience. The only caveat to be experienced, the only caveat to be aware about, is the transfer has to cover the base reserve for a new account, which is one XLM. So if transfer is below one XLM, it will still fail, as it. Below one XLM, it will still fail as it. Below one XLM, it will still fail as it does today. But there is really nothing you can do about it. It's just the can do about it. Furthermore, it's just the semantics of the accounts. What has been changed is trust and support. Before that, CAP had a couple functions. to deal with the trust lines and since then I just simplified this a lot to add. Then I just simplified this a lot to add. Then I just simplified this a lot to add only single function, and this function is called trust.

[08:00] And this function is called trust. and it takes in an address and maybe creates a trust frame. So if you're dealing with a C address as this, will always be an old because there is, no trust for C addresses for a G. address. If there is an existing trust line, then again it's an OP and only when an address has no trust line. You, will require authorization from this, address. And if there is the proper authorization, provided the trust lane will be treated and the reason for why we are not going for the automated. approach, as we do with XLM is precisely the authorization part, because it is somewhat non-trivial observations, that transfer may sometimes require like, if we may transfer to non-existent trust.

[09:00] We may transfer to non-existent trust. lines to request us from the transfer recipient and create a trust line That would result in a very non-trivial. developer experience. Because suddenly your transfers may sometimes require require additional loss from the recipient. But this behavior is like really an edge case, and it's hard to notice. So instead, CAP opts for a notice. So instead CAP opts for an explicit approach and the idea behind that is that well. If you actually do, want to create trust lines, you'll write: some code on the contract side to do that, and then you can implement your client logic accordingly to request the O from the recipient, And again, because of this OS requirement, I would say you do not expect this to. I would say you do not expect this to. I would say you do not expect this to be used in each and every protocol. because it is like non-trivial and

[10:00] Because it is like non-trivial and may not be desired to actually request, anything from the receiver. So it might be easier to fail. There are some specific protocols where it is expected for new users to be unrammed so to speak, to the asset, and for these protocols, this would be a useful protocol, this would be a useful addition to do things within, within, addition, to do things within the protocol. I guess there is still the protocol. Furthermore, I guess there is still a point of debate for the automated. solution solution solution transfer to a non-existent transplant. would always require us. I'm like not would always require us. Furthermore, I'm like not super settled on the current way, So would be interested in hearing any feedback. And yeah, I guess another thing that is important, important to mention, is that this new allow trust function doesn't allow developers to specify the limit of the new trust line, and the reason for that really is that.

[11:00] And the reason for that really is that. trust line limits are rather feature, that it is like about 2% of trust lines have limits, that are not effectively unlimited and the percentage may be even lower because they look at like one to the power of, they look at like one to the power of, they look at like one to the power of: sorry 10 to the^ of 18 trust lines, Really secure, could maybe even reduce, the threshold. So it is basically advanced functionality. And for what the CAP tries to do? It does not seem the CAP tries to do. It does not seem the CAP tries to do. It does not seem useful in any way. Like doesn't seem like contract developers can make an educated guess on what the new trust plan limit, should be, and a very safe default is and should be, and a very safe default is and should be, and a very safe default is an unlimited trust line. That users that do care about the limits can then manage, But I would expect such users to. actually set up the specialized trust, lines in advance, not being on ramp like some bridge protocol or something. So

[12:00] Some bridge protocol or something. So just trying to keep protocol simple here, and make it straightforward enough for developer to use this, yeah, of the function. Change this will profile. Well it is technically low trust does the same. thing that change trust operation, but with a very specific set of parameters, I think, the fact that it shares semantics, for special use case of change trust, operation should not impact our naming decisions. But of course I'm open to suggestions for a different name, But the change trust comparison is really just to define the semantics u based

[13:00] Just to define the semantics u based. on what we have in classic. It should no on what we have in classic. It should no on what we have in classic. Furthermore, it should no way impact how we name things and so on way impact how we name things and so on. Way impact how we name things and so on. Now for the allow trust name. I do now for the allow trust name. Furthermore, I do know there is such operation. Furthermore, I'm not known there is such operation. Furthermore, I'm not sure. Sure. Sure, if our decisions for bindings should, be impacted by classic names, the two quite separate domains in my opinion, But again, I'm open to propositions of, how this could be mean better. I mean, create trust maybe is an option. I, I mean, create trust maybe is an option. Furthermore, I find it a bit weird, not sure what? AT&T, but I shouldn't AT&T. So allow trust in on classic only Let you change the trust line flags.

[14:00] Let you change the trust line flags. right, like it doesn't actually let you create a new trust line. So it's a creation a new trust line. So it's a little confusing, AT&T- Sure, but does it really matter? AT&T. I think Le's point is just that you like AT&T. I think Le's point is just that you like AT&T. Furthermore, I think Le's point is just that you like, if you're already familiar with allow, trust, you might think like it's not clear what this function does. AT&T. Well, maybe, on this, rather that function. exists in, so I'm not sure if you should exist in, so I'm not sure if you should exist in. so I'm not sure if you should base naming on what we have on classic, and I would prefer to use whatever. name conveys what this exact function does, and all trust may by no means be a perfect name. I'm I'm just saying be a perfect name. Furthermore, I'm I'm just saying that like I wouldn't look back on classic operations, I would just name it classic operations. Furthermore, I would just name it in a way that is clear enough, Create trust is not very clear to me. but I know, maybe, if it's clear to, everyone. I find this is.

[15:00] Yeah, I guess we can. and maybe discuss this. Fine, Yeah, we, can just call it like you know, Trust this, whatever like we can name it. in any way that is appropriate s I'm just not sure like classic is. necessary, necessary, necessary, but but but AT&T. Yeah, I think it's just like, yeah, we can AT&T. Yeah, I think it's just like, yeah, we can AT&T. Yeah, I think it's just like, yeah, we can talk about this offline. Yeah, we can have a completely unique name for sort, of when I'm planning with that. What I'm really interested in is if anyone has any thoughts on automated trust link, Creation versus a separate function, because we still have a separate, function. And I kind of mentioned my motivation around that. But I wonder if anyone disagrees with that motivation. and thinks that you know it's actually fine to just always try to create a trust line unconditionally, And if a developer her cares about the

[16:00] And if a developer her cares about the scenario, just let them handle this on the client side. And if they don't care about the operation would fail in any case, whether we have a function or not. So, yeah, just curious if anyone has any thoughts, AT&T. But you're saying like in, like if, like a transfer, would automatically create a trust line like that scenario. Yeah, I feel like that would be a pretty. Yeah, I feel like that would be a pretty. Yeah, I feel like that would be a pretty big break from what we currently do I. I big break from what we currently do. I. Furthermore, I like I. I wouldn't be surprised if it is like I. I wouldn't be surprised if it is like I. I wouldn't be surprised if it would mess up a lot of like apps in would mess up a lot of like apps in would mess up a lot of like apps in the ecosystem. If suddenly you can create as many trust lines as you want, The other issue is accounts can only hold. AT&T. Sorry I. I must be clear. Like what I'm AT&T. Sorry I. I must be clear. Like what I'm AT&T. Sorry I. I must be clear. Like what I'm saying is allow trust function would be called unconditionally on transfers, so to speak, which means that we will still require authorization from the trust, line owner. It's not like we create trust lines without permission. We are.

[17:00] Trust lines without permission. We are not changing semantics. It's just about not changing semantics. Furthermore, it's just about explicit versus implicit. And here we do this explicitly so that creators of the protocols, put this line into their code, and they kind of know what they are doing versus an implicit approach where we require us from the trust line owner, and if you handle this on the client side, somehow then you can actually create the trust, plane, given the receivers authorization So yeah, it is basically just about being more intentional of being making, this automated and then letting people figure this out on the client side, only on the client side. So yeah, but the authorization requirements do not. change, change, change AT&T. Okay, Yeah, I see what you're saying.

[18:00] Matias? Which one do you think is better? Better than Which case is better than which case? Bit confused, I think. So are you comparing like the current? approach to the previous approach, in the cup, or are you comparing the explicit versus implicit approaches?

[19:00] Somebody ask: could you please expand on? your point? Because I'm a bit lost in which experience do you think is better? in your opinion? Cannot hear you, I guess I can hear you. Furthermore, I guess I can hear you. AT&T. Can you guys hear me now? AT&T. Okay, I can hear you now. Yeah, AT&T. All right. Yeah, Push to talk always. keeps me All right. And now I'm saying: all I'm saying is: it's the CAP makes it. All I'm saying is: it's the CAP makes it. All I'm saying is: it's the CAP makes it easier to work with, there It's. It's an easier to work with there It's. It's a straightforward way to just create a G. account balance-right account balance, right AT&T. Oh yeah, definitely Yeah. AT&T Within the contract. So that that's what I'm saying, Instead of just having to.

[20:00] I'm saying, Instead of just having to, build, you know the, the whole trust, lines on the outside, and then having that ready you have, then you're ready. to payment. This way, you just make your payment and done with AT&T. Oh yeah, of course. Yeah, I see a point. AT&T. Oh yeah, of course. Yeah, I see a point. AT&T. Oh yeah, of course. Yeah, I see a point. Like, if your feedback is generally about the cup. Yeah, totally, that's the idea. behind the cup. Is that we want to make behind the cup? Is that we want to make behind the cup? Is that we want to make it simpler to create trust lines in Saroyan or possible. And yeah, we only have some small technical things to work, out. But, yeah, thanks AT&T, thanks anyway. Yeah, AT&T okay, AT&T. It makes it very easy to interrupt with AT&T. It makes it very easy to interrupt with AT&T. It makes it very easy to interrupt with the classic site, the with the classic site. Yeah, Yeah, Yeah, AT&T, especially if you want to, transfer, if you're, if you have, if transferred, if you're, if you have is transferred, if you're, if you have, if you're set up on the server side, and then by any chance you have with a G, then by any chance you have with a G, then by any chance you have with a G account or create a G account to push forward payment, to say, or.

[21:00] To push forward payment to say, or something this way, you AT&T, I, had a lot of interruptions, but, but I, you had a lot of interruptions, but, but I, you had a lot of interruptions, but I think I kind of got your, u idea. Yeah, definitely creating G accounts, like specifically creating G accounts, is definitely going to be very simple and yes, there's no friction there, So that's like the most simple thing to. do. Okay, Lee has left some feedback, as well. Yeah, exactly So, basically this point. is pretty much what I've been, thinking as well, that it is surprising if transfer requires more. signatures, signatures, signatures, and u yeah, there is a risk of users just.

[22:00] And u? Yeah, there is a risk of users just and u? Yeah, there is a risk of users just not noticing it, whereas we allow trust, we only leave this functionality to the. protocols that can actually support this, meaningfully, which, as I've already mentioned, is probably just a fraction of the protocols. It's not something that everyone will be able to do, And of course, if ever, yeah, if in. the future, somehow trust domain, requirements are relaxed, then of course we'll revisit this, But for today, if we'll revisit this, But for today, it. seems like explicit is better than implicit. That's my opinion as well. So you folks are typing. Yeah, 8 to 20 rule. Yeah, I think I. Yeah, 8 to 20 rule. Yeah, I think I. Yeah, 8 to 20 rule. Yeah, I think it may be applied here. Yeah, I don't think everyone will need the trans, functionality. But for the excellent transfers: yeah, they'll work for everyone. So, yeah.

[23:00] Yeah, exactly, We can always do this in. automated fashion, if it proves to be more useful, All right, If you have any feedback, the link to. the description has been posted above. and yeah, please feel free to leave. any additional feedback suggestions or concerns there. And thanks everyone I do not think we have anything else. Furthermore, I do not think we have anything else. Oh, actually, one small thing. Let me just drop a link. There is no CAP for this one. It's more of an announcement there is this get wedge host function. That no one on chain is actually using. So

[24:00] No one on chain is actually using. So you may not even know about it and if you did not use it before, please do. If you did not use it before, please do. If you did not use it before, please do not start using it again, because what we want to do is to deprecate it and make want to do is to deprecate it and make want to do is to deprecate it and make it no longer work. Basically, just freeze it at some protocol version and the motivation is listed in the discussion itself, but basically the idea is that you cannot write a. contract that will benefit from this function. Like yeah, there is just really no way to use this function in really no way to. To use this function in really no way to. To use this function in a meaningful fashion and using it is likely a foot gun, which is why we decided that we want to clean this, up- there is no CAP for this yet, but up, there is no CAP for this yet, but up, there is no CAP for this yet. But you can imagine this will be a super. simple CAP, And yeah, we just open discussion a go to see if there is anyone that actually thinks that this is.

[25:00] Actually thinks that this is actually thinking that this is something useful. But we are pretty sure yeah, there is no way to use it. appropriately. So we just deprecated it. And yeah again if you have any, comments for this one. Please feel free to leave on the discussion just an. announcement, basically to bring everyone's attention to this and now, I think that's pretty much it for today's meeting, So thanks everyone, and the next part.

</details>

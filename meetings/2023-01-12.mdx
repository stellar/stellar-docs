---
title: "Auth Next: Proposal Review"
description: "A detailed review of the Soroban Auth Next proposal, examining account abstraction, standardized authorization payloads, and their impact on wallets, fees, and contract composability."
authors:
  - david-mazieres
  - dmytro-kozhevin
  - eric-saunders
  - graydon-hoare
  - leigh-mcculloch
  - nicolas-barry
  - paul-bellamy
  - siddharth-suresh
  - tomer-weller
  - tsachi-herman
tags: [developer, soroban]
---

import YouTube from "@site/src/components/YouTube";

<YouTube ID="-RE0gGD0oUw" />

This follow-up session revisits Soroban Auth Next with a deeper technical review and open Q&A. The group focused on validating the proposal’s core ideas against real developer and wallet concerns, especially around complexity, performance, replay protection, and preserving simple signing flows for common use cases.

Discussion emphasized how moving authentication into the protocol can reduce fragmentation while still supporting advanced scenarios like multi-step contract execution, delegated authorization, and programmable accounts. Much of the review centered on how standardized authorization trees, preflight recording, and host-managed nonces interact in practice.

### Key Topics

- Review of current auth fragmentation (`invoker`, `soroban-auth`, custom schemes) and why it scales poorly.
- Account abstraction model where contracts interact with generic accounts, not cryptographic primitives.
- Standardized authorization payloads that describe authorized call subtrees (not full call stacks).
- Preflight “recording” to deterministically build payloads wallets can sign once per account.
- How authorization forests allow selective signing of nested contract calls.
- Gas, performance, and depth concerns for large call graphs.
- Security considerations around partial authorization, front-running, and contract design pitfalls.
- Preserving simple invoker-style UX for common cases via built-in account implementations.
- Replay protection, nonce consumption, and the need for expiration or ledger-bound signatures.

### Resources

- [Soroban Auth Next proposal document](https://docs.google.com/document/d/1J-J3ClTUkrsLiJag906OH4hmNkZI3Jk6_Y9ZYt_psAI/view)
- [Soroban protocol and CAP discussions](https://github.com/stellar/stellar-protocol)

<details>
  <summary>Video Transcript</summary>

[00:00] Okay let's get started. So welcome everyone this is a Soroban Design Discussion in these meetings we discuss some of the core decisions, that we need to make. When we're building Soroban, which is a platform for smart contracts, that is in active development right. Now and is being integrated with Stellar today we're talking about off next, which is a proposal, that Dima put together to address some of our authentication and authorization needs on the network. So I think, that without further Ado this is the second time we're talking about off next the first time was before the holidays a lot of folks were out. So I think we're gonna start with an overview by Dima. Then dive into questions and ideally you will be able to make a decision or get close we would

[01:00] close without decision today. So Dima can you take it yeah hi everyone you hear me okay yeah okay sounds good thank you so a quick overview I will probably skip on the motivation for the sake of time I will just say, that the general modulation is, that we are aren't too excited about the state the others currently. Now it's a bit too fragmented and to limit it in some senses well it's too flexible in other cases and it's not necessary. So this proposal tries to build something into the protocol, that would be those flexible. But also standardized so, that contracts can inter operate and the client software can Implement certain things just once

[02:00] without tweaking them for every contract. So on a high level The Proposal consists of two big components the first being account abstraction and second being standardized signature payloads and invocation authorization. So to play on this point account abstraction is a well-known concept on in other chains and basically is, that instead of passing some entities, that are tied to some crypto algorithms such as some public keys or something like, that or instead of trying all those to say classic server accounts we make the contracts to operate on some abstract entities called accounts and from the

[03:00] contraction Point account is just an object, that has an address, that can be used to throw balances for example or for any account related information or transfer balances to this account and it has a way to authorize the invocations of the functions it's not the contract in the contract business logic how exactly the account does, that. So hence the abstraction and the accounts themselves can be implemented both in a built-in fashion some of our built-in tokens and the building implementation will cover the classic store account. So they will all get their default account contract right. But they also can be customized right for example. If someone comes up is a new cryptogram like this Quantum resistance

[04:00] for example right or you know there are Hardware votes, that currently don't support her at all it is possible to write an account contract, that will perform this custom authentication. But the possibilities are much better than, that it is possible to have a literally complex multi-6 schemes, that are probably currently not possible the class Explorer accounts for example it is possible to record different mode async or different tokens spent basically this is a smart contract I guess, that's the bottom line of it. So yeah this is the first component and the second component is about the signature payloads. Because again currently signature pivot system of preform we have like the SDK implementation of some structured

[05:00] payloads. But this is just in one SDK it's not 600 days in any way. So the proposal here is, that instead of relying on contracts to Define their own signatures schema we provide the generic ones, that should hopefully be flexible enough to keep all the use cases. So the payload obviously would include some context information such as network ID. But the main thing and the main Innovation here is, that instead of just signing a single contract call it is possible to sign a whole tree of course or even like Forest of trees nature okay

[06:00] basically from the contract standpoint. When the contract requires an account to authorize family vacation the Urban cost like the power wheel add this into a post deck of all Trace calls and build a context Tower. So basically. When authorized this code from some contract the payload for this call should contain obviously the currently executed Contracting function. But also the call stack of the authorized invocations leading to it and the contract provided arguments. So basically it's only since a contract needs to provide these arguments for the authorization and everything else is inferred automatically based on the current

[07:00] Coast Tech and stuff like, that The Proposal also includes, that generalized Finance Management okay I think we wanted today different this. But for the sake of overview ready is, that cost will contain we will manage nonsense per contract and per account address so, that basically neither regular contracts nor account contracts need to worry about, that and this comes with some benefits like nouns can be consumed only for the top level invocation and not any subsequence of contract calls plus Ledger access and more flexibility for the users, that's rather benefits uploaded. So now

[08:00] so these are two key Concepts and I think another interesting high level point is, that things housing is Paradise for the cases of complex contracts PreFlight can be utilized to build this the signature payloads this is like. When we are talking about the contracts, that have more than a single signature like it's a current world or modern single authorized and location it's a house next World it may be tricky to figure out like what exactly needs to be signed like the contract may be delegated to some contracts, that dynamically depends on their input and things like, that. So in order to figure out what exactly needs to be signed in order to be able to execute a certain contract call

[09:00] we introduce a mechanism in pre-flight, that we'll basically Trace those authorization calls and build the proper payload and the cool thing here is, that this stage like there is no signatures participating and basically no commitment to any security reasons from the user. So the only thing, that the private needs is the other addresses of the account, that participate in the invocation what else yeah I think, that's pretty much it on the high level I just think quite like. So there's a bunch of other things. But I think we would want to look yeah I think, that's a great starting point and we can open it up for questions I'm especially interested in the perspective of the dApp developer. So

[10:00] Paul. If you have any comments there I think, that the original auth, that we built or what we. Now call Advanced off the point in, which we realized it was a bit problematic is. When we had you know dApps and walls try to implement it and it became clear, that it's you know it's a lot to handle. So I'm really interested to hear about this one in, that perspective foreign talk a little bit more about what actually goes into the signature payload specifically like do wallets have to sign only the sub tree sections were like account the authorized is called or they have to sign every like cross-contract call or yeah as I've mentioned basically their trees over the coast not to exit full trees or whatever as a contract calls

[11:00] basically this is a subset of the whole country of the contract were the current account oh not currently there can't be interested in all Traders something. So let's say we have an account a, that once. So sorry we have a contract is, that once the user to authorize it. Then it delegates to contract BS, that doesn't touch right they return. Then B code CZ, that's authorize the users and, that cost tags are user Sciences a. And then C B will be omitted. So you know there is no time in a sense for all well it seems much more flexible right yeah, that's okay. So I feel like a exchange swap for example you would really only have to sign like the token withdrawal from your wallet yes sir like basically yeah you need to still approve your token to some router contract. And then router contract can

[12:00] route your token in any direction or vice versa like you may sign like some low levels of operation, that just swaps you with someone and you don't really care how exactly this is being routed again your signature is required under this bottom level operation. So both ways work and also an important note on signatures, that I haven't mentioned is, that wallets would sign the hash of the whole payload and this is mostly for the sake of compatibility it's whatever hard of our wallets and possible features basically we want to bound their signature pivot size like the actual signature go outside it's not premature yeah. So the wallets take the entire subtree hash, that. Then sign, that. So there's only one second sure okay cool thank you yes Dima yeah I have a question about and I'm going to steal a list questions

[13:00] What In the case, that you want to pass an invalid signature one of the subcontract with the purpose of taking a different path in the contact execution right and explicitly you want to fail one of them yeah this is here okay. So like I mean I'm interested to see like an actual use case for, that. Because from there like this only influences pre-flight right from the preference standpoint like I describe this feature where we can record the authorizations. But the side effect of recording them is, that we treat them all as successful it is not impossible to mock failures in the preferred API it's like basically not a protocol change I'm not convinced this is something we actually should do and it's really unclear to me why would you ever want this to be the

[14:00] game basically in my mind like. If it's fine for the authorization failures to be recoverable for example you know you want to clear like multiple trades and at once and in a general case trades may not clear for multitude of reasons one of them being, that signatures for the trades for this trade are incorrect and you don't want for example to fail other trades. If you're just patching things together right this is a fair case. But I think this case is only meaningful during the on-chain execution I think it is fine for the pre-flight for example to execute the hate this scenario. Because it will be probably it will consume more gas and build access knowledge your entries than do it in case of failure. So it will make it superset of what is executed in chain

[15:00] of course it is possible to write some really weird contract Logics, that would try to reorder trace the account. But again I'm not quite convinced, that ever a good idea and there won't be a good support for, that from the pre-flight standpoint for example and. But but I think there is a pretty good reason to not support it. Because you kind of have this recursive dependency where like you want your signatures to depend on the function input. But then. If your signature defines like what the signature should be you get this basically cyclic dependency rate. So I'm not convinced this is a good idea basically like what I would want contracts to do normally is, that. If you call contracts function with certain arguments it comes with a certain signature preload and this

[16:00] relationship should be deterministic right and it should not involve signatures in the input, which is actually one of the problems with the current Advanced awesome. Because we are like are we used to like include some information from the signatures. While building pillows for another signatures and it's pretty messy and how to painting and power. So yeah and another question this change implies, that you need to do the cryptographic verification posts transaction execution right are they very end right. Because you need to build the pre-image and in order to build a pre-image you need to run the contact right. So not on the simulate side but. When you actually go and execute it you need to run the entire smart contact

[17:00] three right and only at the end you have the pre-image, that you can verify with signature, that's actually not true right like it's a bit of an implementation detail and I think it may change. But in the current prototype what happens is, that since we kind of decouple authentication and naturalization well at first the whole tree has to be passed in some way along the transaction right. So the transaction should know in the first place whatever. If you are claiming you have time. So from the smartphone perspective for example it's possible to examine the whole tree, that's trying to or trades from the authentication perspectives there is just this curved payload, which is the hash of something and from the

[18:00] authentication standpoints the only thing we need to do to it is to basically verify the signature of this payload is correct and in case of mounted sync accounts find all the signers right. So basically the current implementation the authentication happens. So easily the first time the account writes to trade something and actually the same goes to evaluating the whole tree over the course in the vote like the latter part may I may not change. But I think yeah there is really no need to do anything until the end of the contract execution we just do verification as soon as possible. So basically you've like. If Thompson is not like. If some were deep in the subject there is a cause, that hasn't been authorized will find out about it as soon as we reach this point. But not

[19:00] I see. So the entire tree is effectively submitted as part of the transaction right yeah it is and yeah I have seen your suggestion on the dog, that maybe instead of passing like the whole show explicitly we made Parts ashes of its nodes, which probably may be fine in terms of the transaction sites. But yeah it really only matters for the transaction part of the things not for the actual execution yeah. So my concern here is, that people are going to use the existing contact a infrastructure to develop like deep executed contact tree right and. When that happened we can have several hundreds of contracts executed right per transaction and I just kind of like a horrified of the idea, that as a result of, that we're

[20:00] going to have hundreds of signature in each transaction account. So again there is only a single signature per account right and said like the signature flow is you take the payload, which is basically a network plus a vector of the invocations you want to or trade you hash it you sign the hash, that's it ah. So there is only a single signature. Then the first time execution time is the first time the account tries to try something we verify the signature. And then we will just do basically matching like weather resist invocation is present in the tree or not. Now to the Deep tree topic I don't think it's the new route it has any relevance to this. Because it's not like it's impossible to close up to contract. Now

[21:00] and the bank accounts versus these right like you cannot probably execute a hundreds of contract calls even. If they don't do any actualization shift. Because it will run out of gas before, that like we are going to have gasoline it on the transaction. So and I think it's completely it will always be a better idea to have a single contract than a multiple contracts than multiple contracts into these things and. Because cow in a contract comes at the cost. So yeah next week very differentiation yeah right thank you can I give us a question about the to do with this you know what gets signed in the subtrees and going back to deem of a example you provided. When you. When you're answering one of polls questions you describe a situation where an

[22:00] account is signing like, that you're calling a contract and, that contract is calling three other contracts a b and c and this account just wants to sign the call to contract a and the call to contract B in, that situation is, that does, that mean, that count a science two sub trees like separately. So they provide two signatures Play sign a and they sign b or are they. Because a few times it's been mentioned, that an account only ever provides one signature is there some way, that somehow they sign those two sub trees. But it's only one signature or how does, that work yeah. So basically as I said like technically you're not signing the tree you're a sign in a forest of treats. So for example. If you have a top level router contract, that doesn't require any authorization. But then you make two subcontract calls, that are authorized, that would spawn to all trees

[23:00] right. Because they will have different top level or trades nodes, which I think is fine like you still need just one signature over, that as I said I'm always saying like one signature per account here is an account object it doesn't mean like, that it's Unique so. If your transaction accepts two accounts and they happen to be to have the same address very long try to duplicate them. And then there are a little bit of signatures. So you know. When I'm talking about like single short per account, that's only in the context of, that account like in the context of the whole transaction there may be a return number of accounts and some of them maybe duplicates and they will have their own signatures too so. If you don't try to be any more collaborate here. So it's yeah one per account not more okay. So in, that situation where

[24:00] account one wants to sign contract a and the contract tree a c. But they don't want to sign the top level like the very top level contract call they would provide two signatures they would sign like the sub tree for contract a the subtree for contract C. And then they would include those two signatures is, that right okay. So at first I want to make points, that I think it's more like it's important to practice say, that it's not, that account wants to do something it's what the contract wants to do. Because the source of the signature pullouts in the first place is the contract it's not the account the count row is to verify the signature like an account contract account in a more broad context or always to sign stuff eight and seven. So basically depending on the call tree you

[25:00] will get different results for example. If you have a contract as I said, that calls independently into say contract B and contract c. But you provide it once at the top level you'll get a single payload. So let's say you have a contract a, that doesn't require authorization itself. But it does go into contracts bncs and direct prioritization. If you provide contract a. Then you will get a single payload with both invocations. But on the other hand you could just pre-sign contract B and contract C. And then write like you don't want to know the user to know about your top level contract. Then your top level

[26:00] contractual. When you take care about having two different accounts right. But it will be still possible to forward the signature. So basically it's whatever the contracts Define and whatever you try to prep white or build signatures for it's driven by the contract interfaces. So I mean it's probably a good idea to try to implement things in a way, that only a single signature is needed so, that you know we have some Atomic operation per account, that may involve arbitrary number of subcontractables. But nothing limits you from you know using small result present calls. But you will need to this needs to be reflected in the contract interface and implementation, that's right. So what you're saying is, that contract a could just sign the entire tree. If they wanted to

[27:00] yeah like you would need some criticize instead of so. If you just. So just ignoring PreFlight for a second just assuming, that the developers here know how to build these trees themselves they know how to do all the signage themselves I'm not really too interested in the automation just yet. But a developer could choose to sign the entire tree and they would be signing a b and c or they can choose to sign just the subtree A and Justice subtree C and include those two signatures basically yeah like as one is your Forest of trees corresponds to what has been authorized you should be fine. So you know. If but basically what you can do like. If you're in full control of all the execution paths you will just look at where your authorization secure and you would include all this into the signature pivot where signing it. And then you basically can embed this sub

[28:00] trees in arbitrary called trees you care about as well for example the same topology and a signature Bionic a signature on a tree will just mean, that whatever the address is for, that signature is authorized anywhere in, that tree where, that address shows up is, that correct authorized anywhere the contract calls all tries on it right. So there is anywhere contract requested authorization I have a question related to this about authorization context and the call stack so. If you invoke a contract a, that calls B and you know B is the only one, that calls authorized. Then a is not part of the context how long someone to front run a by submitting B I'm wondering. If there are any security issues or weird use cases here and. If we

[29:00] should consider requiring the full call stack by default with the option to authorize the subset the cost stack. And then the concern here is a high level. If it's possible for the front run to prevent I expected logic from running well it sounds right like at first, that was a consideration to include like the full cost tax. But the scenarios like we have just discussed such scenarios like it's rather limited and makes use cases like exchanges much trigger to implement properly. Because you know you may care only about like swapping the token and you don't want to care about like how exactly it has been solved and. And so from training some contracts would indeed need some front-end prevention in place. So for example you know coming back to the batching the operations example right. So let's say your contract clears multiple swaps and swap may Fail for multiple

[30:00] reasons one of them is run signatures another one is front run right someone front Trends is Swap and it's no longer valid right this case is really not different from any other failure like just write contract in a way, that it gracefully handles the failures and you should be good as for security issues I mean it is possible to write a contract in such a way, that you can transfer into signature for it and it's one to the right thing. But it's probably on the contract. And so I can implementation issue right normally what you should require is easier to sign should be it should be a some sort of atomic operation, that the user should intend to perform it shouldn't be some middle step. So for example. If I want to create a clinical balance for example a simple thing right I

[31:00] want to transfer the token to the contract and I want to create an entry on behalf of this user I could drive this incorrectly and take just the signature for a transfer and you can from transit signature quarter transfer but, that's obviously about what I should do is I should reverse the authorization the whole thing I'll use the pro or whatever. So I mean bugs would exist for any sort of authorizations. But I don't really see an inherent security risk here. And so on as you don't require the user to sign some non-atomic things, that you will build storage account. So let's say coming back to the swap example let's say you did something based on the swap outcome. Then probably you would want to or trades your top level contract, that does the swaps. Because it does something else will probably need to be or trade right and

[32:00] you don't want it to be functional right. So and also there's a front training prevention topic never mind okay go ahead yeah. So like the you said it makes sense like the one thing I'm concerned about is you know the authorization context is determined by the contracts right as you mentioned and the user is just going to sign whatever pre-flight returns. So and these bugs are not, that like you know. If you don't have a great understanding of how this authorization, that these authorization Mechanics Work you may not see it. When you look at the contract and the user is just going to sign whatever pre-file returns. So it may not be you know at any point easy to see what the issue is until it's too late so, that's just my concern I don't know. If no I'm still not sure. If this is. So go ahead yeah I know my intuition is, that again this is probably the case for any sort of traditions like let's say you understand the whole tree like do you really think, that add in

[33:00] like a bunch of stuff does a tree would like prevent some weird cases. When you sign something, that you didn't think yeah I'm not sure. But I think a great thing, that structural payloads are always it's it should be easy to implement a generic forward support for just parsing this tree and finding the relevant code you know like. If you send something to The Exchange, that it's supposed to sell token a for you and you get your payload and your vote says hey this is going to withdraw like 10x of the token a, that you actually wanted to trade. Then you know you probably won't find this and wait you wouldn't worry about this too much. So yeah there is definitely like more control from the interesting point in a generic scenario I agree, that some things might be vulnerable and

[34:00] these are wouldn't know about, that. But I'm yeah I don't have a good understanding of how prevalent would this be or how dangerous would this be. Because well. And so it could be contracted a flowed in multiple wage rate and you wouldn't know. So it's I guess the question of trust and you know only using the things, that matter and the fact, that we at least can easily know what the contract trying to go to your tokens or whatever other Commodities you have it's already a big wins here. Because like kind of limits the impact simulator yeah thanks Dina any further questions

[35:00] Lee yeah I have a question. But it's a little bit derailing. So I feel like I want to. If anyone else has questions, that are moral on the line of what we're already talking about, that might be best to do first the URL awaitly. So I'm interested in Anna have a proposal interacts with the simple invoker auth case, that we currently support today. So I think. When timer was describing before you know we developed the current version of sorbenorth we realized, that it's actually relatively complicated to use. And so then we went and had added invoker auth, which is basically the same as message.sender in the Ethereum world and the way, that it's implemented is the source account on the operation is the invoker. And so a contract can just say who's the invoker and they'll either get back and address they'll get back an

[36:00] address, which is either the source account on the operation or the contract, that's calling them yeah I saw I understand, that the proposal basically says okay there's the proposal replaces the complicated and the simple auth we have today and creates a single unified interface, that contracts use to verify, that the address is authorized I'm just wondering like. If there's a way, that we can retain the simplicity so, that for the vast majority of contracts enter the wallets and contract interactions they still have the simplest form of in terms of like what they need to sign it's like the simplest without needing to go and sign these call statues

[37:00] well I mean the host Tech tree for the case, that is currently an invoker case it's pretty much equivalent to just the conflicting location right. Because it consists only of a single invocation and you know you just add a vector around the things, that already exists. So even. If that call has like. So I'm calling just one contract but, that contract may be calling five other contracts as a part of its what it's going to go do those calls may be unimportant to me. So maybe they're just calling out to an oracle again some information again Nano Trace calls are not included in the payload wait this is an important point I want to reiterate again, that what these are Sciences only the authorized upset of the whole country

[38:00] country. So it doesn't include any in between or side calls even. If the authorized call is the top layer. So even. If I'm like the top call is going to be authorized Ultra is doesn't propagate anywhere authorize means, that I'll try this and only this added in the current context, that's it doesn't say anything about inside invocation so, that curse would not contain things, that are not done on your behalf. So whatever the contract calls into doesn't matter for the secret signature. So for the case where invoker is used currently I mean invoker cannot be propagated currently right you cannot forward the invoker to the other contract, which actually they have seen from discussion it's kind of a bit annoying and confusing right. Because you may sometimes want to propagate it

[39:00] but yeah this is a side like in this exact use case. When you don't propagate the top level account anywhere the signature pillow it will be almost exactly the same module of the different structure rate instead of like having a single contract and invocation you will handle it support into a vector and, that's pretty much it and you will have a signature a few different plates. So you know from adapt perspective it will be marginally harder to build this payload. But you know doesn't need to account for anything new. So just need to use a bit different structures and from the transaction State Savings endpoint like we are keeping the invoker making sure to like save on signatures and you know. If the source account thanks a whole transaction and the contract call it is possible to mark, that it is an invoker and do not

[40:00] require like a second signature. So the optimization part is there two and yeah the only thing, that kind of changes from the contract interface 10 point is, that yeah you need to pass the account explicitly and intercourageon account we may or may not introduce some sugar in SDK to simplify, that and make it. So you don't really need to type what you want to authorize. But you know it's like one line of code we also want to do this for the sake of Click so. If you can. But I don't think it's too big of a an issue to basically do this. But on the other hand like it is. Now possible to for the constant to do things on behalf of accounts in the sub course, which is not possible within local current, which I think is yeah of course

[41:00] yeah I think an optimization like. If if there is some way for us to retain an optimization where The Source account could still be used to authorize I guess the. Because I'm not really too concerned about, that one line of code, that a contract has to add I'm more concerned about what, that the story is for a dApp or a wallet developer yeah. But the transaction you know a number of things I need to sign like a you know like a hardware wallet needing to sign the Stellar transaction as well as this blob, which is like two signatures. So two rounds of signing they need to go through versus. If the. If 99 of contract calls really only just need, that Source account you know they really only. Then have to sign just the transaction once, which is yeah I think you definitely want to preserve, that it's increase, that for

[42:00] the signature key test. When you know you'll pay for the transaction, that your qualities or one contract it's definitely easier to just passing a signal curvy. So basically yeah it doesn't go anywhere. But it will be possible to do everything in this single signature how frequently this will be used compared to something else we don't know yet. Because we have discussed a lot of the cases and you know some third-party page for the fees. But you know, that's something you've got a secret you know it's a case for the user to just send a transaction to Samsung do to your business and this multi-help transactions hopefully possible to sign other corporations at once. While still being compatible with something

[43:00] are there any other questions either from anyone on the stage or the audience I have a minor question, that maybe like you can explain like in the Prototype why is authorize called authorized instead of something like verify authorization I think, that was done intentionally. But I don't recall the reason I no I don't think there is reasons okay yeah I mean odd trays it's like I don't know I'll try this current invocation but. If it's confusing you can use whatever name defines you to go to college verify, that's radiation as well check I don't know foreign

[44:00] okay. So I think there's yeah I think the last one we touched on, which is having to sign multiple payloads for the even for a simple case I think, that's a no-go I think we need to either optimize for, that or scrap this at the end of the day people are using external signing applications people are using Hardware wallets and we need to figure out for the simple use case how to sign a single payload yeah okay. So let's stay. So I'm yeah I'm not saying this is going to go anywhere. So as simple use cases will be possible. But you know for the complex use cases you may end up needing to send two things

[45:00] but yeah do you mean the simple use case would be satisfied by just keeping the existing invokerol with capability or are you meaning, that we would introduce an optimization into this proposal so, that the contract still uses the same method they still call Dot authorize or dot verify authorization yeah nothing changes somehow comes from the The Source account Yeah. So basically we don't truly awake the whole driver for this proposal was to kind of have unified account oh sorry unified Contracting rupees and you know I find it kind of problematic, that you kind of hard code your contract to use invoker right. If you don't use Advanced host on the current approach and, that's kind of bad right. Because if you want to use this in a different context you cannot it's hard cut a teas and Walker. So the contract interface itself uses

[46:00] what's next it uses accounts and addresses and the abstraction and you know one of the implementations of, that abstract account even, though it's kind of built into host. But it's just invokers rate it's just one of implementation of the abstract account contracts shouldn't worry about, that it's all implemented in the host and it's in the current prototype as well. So yeah let's Chooser and by simple use case I mean the cases. When there is only single accounts it needs to trace operations you know throughout multiple accounts and one of them can actually can be invoker but, that's reason to pre-size something. But they want me to sign the storage induction. So hopefully you know a majority of the case is only single signatures needed. So just to be on the same this is implemented in your host prototype for off next right. Now yeah it's in the Pro

[47:00] Tab right. Now so this is an important thing and it's important and is the way, that works, that you it's only the top level contracts but. If they call Dot authorize they would see the source account as being authorized yeah they actually will see wait basically the trees teeth sharing the transaction payload. But instead of cutting the signature you pass nothing and instead of passing the account ID you pass the flag. Because it's an invoker it's similar to how we handle invoker currently in advanced cars it's just move to the transaction structure itself right I'm just wondering. Because in Vegas today is only it has no depth like yeah. Now it has depth yeah. Now it will have depth. Because the transaction has the whole tree of the coast. So basically you are signing the tree

[48:00] itself, which is why it is safe okay. So so this the way it's currently implemented it's not really messaged us and it's like the transaction.origin from Ethereum it sounds like is the way, that it's working I'm not sure. But I think the key factor here is, that you explicitly you still explicitly out price calls right it's not like you just gave for a contract blanket permissions to call things on your behalf it is really just it's keeping the signature verification part. Because you. When you're assigning the transaction or operation you are also assigning the whole authorized call stack payload, that you've been talking about before. So yeah. So basically yes the world would need to show you, that hey as a part of this operation you

[49:00] maybe a sign in multiple token operations for example right. But you know from the signature standpoint it needs to still be sanctioned once. So it's basically like msg.center. But better. Because like energy the center is like contingent on the fact, that you have signed the top level and location here you sign all the invocations, that you need to try yep okay yeah I'm the reason I just mentioned, that the transaction of origin is. Because I'm just trying to think of. If there's anything, that we really need to worry. Because it feels a little bit more like transaction.origin in the you know you could you're the source account you call this contract either calls another contract you tell, that other contract, that you're authorizing as the invoker so, that other contract is authorized

[50:00] with the top level Source account yeah I think it's probably fine. Because you're right it's reflected in you still have to specify yeah right there is really no way no matter what kind of authorization you use. And so it's no way to somehow hide the subcontract call, that prefers authorization. So there is really no way to hide some token withdrawals number deep in the trade those still circuits no matter what or it will just fail. Because you haven't seen it yeah any other questions from the stage of the audience okay. So I think you know dima's done a great job at answering all these

[51:00] questions I think there's a still most of the concerns are around the you know what is the contract for the Gap developer and to get insights into, that I think we need to regroup and probably come up with some you know minimal prototypes, that help us understand, that. So hopefully, that's something, that we can put together soon enough and discuss again and. If no one has anything else they want to ask or to add. Then I think we can call it a day yes maybe. If you have a few more minutes I have one question it's yeah about the non replay protection. If a transaction fails. Because the

[52:00] call stack change will the nodes be consumed or not yeah the non-consumption is actually trick using may need to think more about, that in the current implementation nonce is basically tied to the top level or try it's called, which may or may not be the right thing to do, which means, that it's something fails basically okay. If the whole transaction fails The Ledger state is completely rolled back those announced won't be consumed. If a top level contractor tries succeeds. But some subcontract call fails and

[53:00] the top level contract handles is Grace collisions and not smart Bureau project thank you okay we may need to discuss this further. Because this can be an issue with like at some point the transaction fail. And then becomes available again. Because the code stack is available again someone can just run through you and replace the transaction doesn't make sense yeah I mean the transaction replay. But basically again frontrun is kind of weird. Because it's it shouldn't be an issue most of the time. Because someone would do what you wanted to do anyway yeah. But what you wanted to do at one point may not be what you wanted to do in the future. So let's say I want to transact with one inch to spend my

[54:00] money. Then these fails. So I spend my money with another Exchange. And then someone replay the previous transaction and spend my money again like we can discuss this more. But basically yeah I think like I think this kind of brings another topic, which is exploration, which I don't think we have discussed and they didn't do anything in the proposal it may be a generally useful feature to have you know for your signature to have expiration and, that even could be a part of the standard payload so, that we could distribute expired payloads. But yeah I think it's kind of complementary to our question okay yeah the Norms could be Ledger bonded or

[55:00] time bonded, that may be a good idea okay yeah we can discuss this and yeah it would be nice to try to come up with basically some Sooners and the sink they can get abused somehow. Because thank you thanks Tebow. So we are approaching time thank you so much for everyone and Dima especially for you for prepping this and for answering the questions we will regroup and update on Discord thank you all

</details>

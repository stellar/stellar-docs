---
title: "Open Protocol Discussion"
authors: [justin-rice]
tags: [legacy]
---

import YouTube from "@site/src/components/YouTube";

<YouTube ID="-dedknEnk10" />

- the changes that we're discussing today and what we're focused on now is relate to project jump cannon so it's a future protocol upgrade um these changes would be included in it and project canon uh is aims to bring smart contracts to stellar we've actually modularized a lot of these changes and so there's a whole slew of caps that are related to jump cannon caps 46 through 53.
- since this is a pretty technical discussion if you want to follow along i urge you to take a look at those caps if you're interested in joining the discussion i urge you to join the stellar dev mailing list and if you want to also follow along with jump cannon development more generally you can do so here in the jump cannon channel and also in the jump canon dev channel um and so today again we're focused on on jump cannon related caps there's a pretty uh there's there's a lot on the agenda a lot of small stuff but there may also be some bigger issues that we're talking about um if as you're listening if you have questions the best thing to do is to put them in live chat uh in text i'll do my best to monitor it i mean the goal here is to actually have substantive discussion that moves forward some of these changes and that answers questions and allows continued development so um we may or may not have time to address the the issues in live chat but if we don't do it now during this meeting we'll definitely take a look at that channel afterwards too so feel free to put your questions or thoughts there and that's the end of the intro um everybody here it looks like looks like we got a full house um okay cool so i guess to start off with we we have an agenda that has um like and i guess we can just like sort of start with what's at the top of the agenda i also know that there's some questions about uh interoperability that we may want to address i think maybe we start with 46 removal of box agenda item i i put a bunch of i i put a bunch of agenda items on here you can hear me everyone hear me yeah we can hear you at least i can hear you yes okay um yeah i put a bunch of agenda items on here um but they're all really straightforward so i can just grease them really quickly um boxes in cat46 it's a it's an object that contains a value i think this is actually just an artifact of the notion that we might have had mutable objects because uh i think as far as i can tell it's it's basically indistinguishable as long as we have immutable objects and we haven't ratified pointers there's no way to differentiate an object that contains a value from just the value so lee suggested that we get rid of this and i'm happy to get rid of it until we discover or some reason to bring it back in the future go on once go on twice i guess i have a maybe a question yep so is that does does that mean if if later we decide to have mutable host objects they would just have to be boxed like that that's right that's right that's it we'll just bring back so it's actually completely back i mean forward compatible but yeah we're just bringing we're just bringing the object like back in the future it's just that since we don't have any reason for it right now then we might not delete it yeah makes sense okay so yeah i just as a part of deleting this i want to get rid of the cycle this gets rid of our only cycle click reference in the structure when i get i want to get rid of the option on the box so we definitely can bring this back later on but if we do bring this later on we should put a little bit of effort into making sure that the xdrpp the c plus xdlib can do non-option cycling references which um there is already a plan for but yeah just calling that out yeah it's implemented in c plus plus 20 so either we can move stellar coordinates equals plus 20 or we can back port it to c plus 17.

This session started with a rapid-fire clean-up of the Jump Cannon caps: they agreed to drop the unused `Box` object from CAP-0046, deferred any delegation helpers until the base model ships, and made sure the host/guest boundary is as small as possible. Grady also previewed a CAP-0053 amendment that formalizes a `footprint` type so transactions can declare the ledger keys they plan to read and write.

After the housekeeping the room zeroed in on asset interoperability again. Engineers compared requirements for single versus dual balances, how allowances should be stored, and whether contracts should ever need a trustline. The debate set the stage for the July design summit on asset representation.

Key discussion threads:

- Removing stale concepts (like `Box`) from CAP-0046 and resisting the urge to add delegation features before the base runtime lands.
- Extending CAP-0053 with an explicit `footprint` type for read/write sets so tooling and validators can reason about state access.
- Rearticulating interoperability requirements: reserves, allowances, issuer controls, and how much of that should be enforced via trustlines.

<details>
  <summary>Video Transcript</summary>

[00:00] The changes, that we're discussing today and what we're focused on. Now is relate to Project Jump Cannon. So it's a future protocol upgrade these changes would be included in it and project cannon aims to bring smart contracts to Stellar we've actually modularized a lot of these changes. And so there's a whole slew of CAPs, that are related to Jump Cannon CAPs 46 through 53. Since this is a pretty technical discussion. If you want to follow along I urge you to take a look at those CAPs. If you're interested in joining the discussion I urge you to join the Stellar dev mailing list and. If you want to also follow along with Jump Cannon development more generally you can do. So here in the Jump Cannon channel and also in the Jump Cannon dev channel. And so today again we're focused on Jump Cannon related CAPs there's a pretty there's a lot on the agenda a lot of small stuff. But there may also be some bigger issues, that we're talking about. If as you're listening. If you have questions the best thing to do is to put them in live chat in text i'll do my best to

[01:00] monitor it I mean the goal here is to actually have substantive discussion, that moves forward some of these changes and, that answers questions and allows continued development. So we may or may not have time to address the issues in live chat but. If we don't do it. Now during this meeting we'll definitely take a look at, that channel afterwards too. So feel free to put your questions or thoughts there and, that's the end of the intro everybody here it looks like we got a full house okay cool. So I guess to start off with we have an agenda, that has like and I guess we can just like sort of start with what's at the top of the agenda I also know, that there's some questions about interoperability, that we may want to address I think maybe we start with 46 removal of box agenda item I put a bunch of agenda items on here you can hear me

[02:00] everyone hear me yeah we can hear you at least I can hear you yes okay yeah I put a bunch of agenda items on here. But they're all really straightforward. So I can just grease them really quickly boxes in CAP 46 it's a it's an object, that contains a value I think this is actually just an artifact of the notion, that we might have had mutable objects. Because I think as far as I can tell it's basically indistinguishable as long as we have immutable objects and we haven't ratified pointers there's no way to differentiate an object, that contains a value from just the value. So lee suggested, that we get rid of this and I'm happy to get rid of it until we discover or some reason to bring it back in the future go on once go on twice I guess I have a maybe a question yep. So is, that does, that mean. If later we decide to have mutable host objects they would just have to be boxed like, that that's right, that's it we'll just bring back. So it's actually

[03:00] completely back I mean forward compatible. But yeah we're just bringing the object like back in the future it's just, that since we don't have any reason for it right. Now then we might not delete it yeah makes sense okay. So yeah I just as a part of deleting this I want to get rid of the cycle this gets rid of our only cyclic reference in the structure. When I get I want to get rid of the option on the box. So we definitely can bring this back later on but. If we do bring this later on we should put a little bit of effort into making sure, that the xdrpp the C++ XDR lib can do non-optional cyclic references, which there is already a plan for. But yeah just calling, that out yeah it's implemented in C++20. So either we can move Stellar-core to C++20 or we can back port it to C++17. Yeah, that's a. So somewhat bigger kettle of fish. But I mean we have a workaround anyway. If we really

[04:00] need it we really need to bring it back we can move to an optional box like this. But this there this is motivated by getting rid of so, that'll actually make a lot of the on the wire stuff four bytes smaller okay second issue, which is very minor we went with positive i-64 as the we renamed u-63 like two weeks ago into positive i-64 to be a little bit clearer. Because 63 is a weird number and everyone who sees it is like what is, that why should there be a 63-bit number and it's actually just like a 64-bit number, that happens to be positive and John pointed out, that you know zero is in there and depending on, which mathematical tradition you come from zero is either both positive and negative or neither positive and negative and some people believe non-negative is the correct word to use. When you're including zero and a set of numbers, that include zero and all the positive numbers I don't personally care I'm perfectly happy to have the word positive in there I think it's reasonably easy for people to understand I could also put in non-neg or n or something like, that. But I figure terminology wise i've got you all here we're gonna we're basically gonna merge this right. Now so please commit to a

[05:00] terminology does anyone have a preference I think non-neg is fine. If that's more accurate. But I don't really care I personally I think u63 was fine. But yeah non-neg is fine too I did too I don't care I like u63 personally it's short and it says what it means literally everyone who sees it has like this weird sour note in their mind and is like why is, that 63 what is wrong with you, 63 is not a computer number 64 is a computer but, that is actually the correct reaction. Because it is a weird type. So like except it projects to and from i-64. So the the type, that you can convert to and from is i-64 actually why i-64 is not u64, that's the symptom of the language we're using too like you know. If we were writing contracts in zig u63 would actually make sense it'd actually be a thing I mean the thing is like I don't think the weird reaction is to the name i

[06:00] think the weird reaction is to the concept. But then in context it makes sense. So why not just pick the more accurate name. But this seems like a mega bike shed thing it is a mega bike shed i'll go back to u63. If everyone wants u63. But I will not entertain another comment on this after this meeting. So this is it yes thank you I mean it's like boolean right like boolean is not one bit in most like. If you have a variable like, that right it's already the same thing. So I'm fine with I'm actually I prefer u63 as well. Because it actually tells you what it is everyone wants u63 okay we're going back to u63 next issue was CAP 47 and CAP 53 we noticed part way through last week, that assuming, that we want some kind of mutability of contracts, which apparently we kind of do or even. If we don't want mutability of contract we still want a way to load contract from the middle of execution. Because we want to be able to call them. And so at a representation level

[07:00] the XDR, that represents ledger entries with separate ledger entries for code and data seemed possibly to be overkill. And so we talked about it and came to the conclusion, that it would probably be tidier we actually had like in the implementation we had pages and pages of sql code for both of these types and they're pretty much identical cedric and I worked through this stuff. And then they really only differ on a you know one field, which is whether there's an additional sub key. So we thought, that it might be nice to just merge those two and there's a single type of contract related entry, that still has a contract ID they all have a contract ID and has a sub key and the sub key has one magic value carved out we have lots of places to carve magic values and we can just carve them out of the sc static value set and we just have a designated key and all it means is the current contracts or the owning contracts own wasm code. And then we just do our

[08:00] binary and sc binary type. And so we implemented, that it seems to work fine I have not updated the CAP yet I want to run, that by everyone make sure everyone's okay with it it leans us a little bit towards mutable contracts. But I believe a lot of our design discussion has been drifting in, that direction anyway it does not wed us to, that we do not have to we could also special case it and just prohibit rights to, that key. But it sort of has, that tendency of treating code and data as the same thing, which at some level they are. So I spoke to Siddharth about this yesterday quite a bit in the afternoon. But one of the one of my main concerns around mutable code and this is much more about the mutable code aspect of it than about the merging them the merging it I care less about other than the fact, that it like makes them like default mutable and we. Now need to opt back out of, that which I'm about to explain like you can't just say the code is mutable without having some rules around what, that means and we have not successfully agreed on what those rules are

[09:00] what happens. If you mutate a code mutated contract, that's currently running what happens. If you delete a contract, that is running. Then call another contract, that called back into the first contract, which contract runs the second time like these things need to be well defined. So we should like start from the fact, that we can store code as data. But you can't mutate it. And then figure out how to mutate it. But like we don't have answers to those questions yet or at least I haven't heard answers to those kinds of questions yet no I agree we don't we did. However have in CAP 47 a function for writing a contract code entry. So whatever, that host function semantics are they're the same semantics here well the thing is, that yeah it's like what John is saying like currently right like. When you write a ledger entry the this is observable by anything after

[10:00] like immediately after whereas here I think we have to decide and we probably cannot make this actually this cannot be true I think. Because this is going to be probably scoped with the tied up to the lifetime of the of the wasm runtime, that's actually executing the code so. If you have like. If you call yourself type of thing we're certainly not going to hot patch the running one exactly yeah. So this is. But this is like a place where this is actually deviating from what we do for data. So we have to really you know specify this and think about it very hard, that's exactly what I was saying Nico you just said yeah no I know like it's kind of scary in a way, that I don't know what the right answer is on I know you see I don't actually think this is particularly scary I think there are really only two possible options and they're both fine and you know one of them is you do

[11:00] what unix does, which is, that you the executing process is essentially a disjoint as soon as it starts executing and so. If you rewrite the file, that's fine the next exec to, that we'll get the new code. But like. So did we actually decide on reentrancy for example like what you can or cannot do well actually you get you busy in unix no you can write a file. While it's running you get busy on windows the file's locked on windows. While it's executing on unix you can rewrite the file as far as I know. Because I do upgrades of running programs all the time and it works like. If I upgrade chrome. While it's running. If I do apt-get install bash it works in my backup I'm telling you I literally just tested this and I get e busy I mean this is kind of a

[12:00] side note. But I think what you're doing. When you upgrade is you're unlinking the file and creating a new file. But you can't like write to an inode, that's currently executing okay sure unlike you can re-link, that's fine well unlike and create a different I know my point is it's totally doable in some contexts and in other contexts you block it and those are the only two options here. So and I think they're both fine there are other options okay there's the only two reasonable options the other one is what hot patch your existing running program, which you're not going to do no there's at least one other option, which is like you can't update something. While it's running you have to delegate, that's blocked, that's what I just said, that's the other option block or allow what exactly do you mean by block I guess it fails you try to make the right and the right fails it's just the special case we just don't know, that's what right right to the running code fail. Because we decided. But then how do you actually do the update I guess like you're just saying you can't mutate it you can't take your own you can mutate someone else's okay. But like, that needs a lot of specification in and of itself

[13:00] and I was providing an example of how you can do, that you can't just like I can't just modify your contract right like there's obvious, that's obviously not acceptable. So but we have a we have like manage contract transactions right, that that's the out-of-band technique. But like, that doesn't work like it works in a very like very tight sense. But like what. If you're a dao, that's managing a smart contract you'd like to be able to manage it from small right okay. Then we there's like a whole bunch of space here, that I'm like it's like sure maybe you have two high-level options allow or block. But like block has many sub-options okay I don't see this is relating to the question, which is do we store this as a ledger entry or not I agree, that individual host functions need to have semantics defined for them. But okay I guess what I'm getting at is I would accept this change. If we make it so, that you can't mutate the code. While it's running right. Now and we can figure it out later okay

[14:00] but. If you're going to allow it right. Now then we need to do a lot more work and it's not a good idea sorry. If we're. If we allow rights to the currently running contract right we need to do more work okay. So what I'm going to specify, that agent files are currently immutable even. If it's stored as data no the currently running contract is immutable. But we as I just said we have no mechanism to write to a not running contract or not a good mechanism we should just make it immutable. If it's okay sure like what I'm saying is let's separate the mutability problem from the representation problem okay. Then we can make progress. Because like I don't want to approve this. If we don't have like I don't want to prove it in the mutable case. If we don't have a good story about me to build and we don't right. Now gotcha okay. So only reading only the read path works for this key right. Now and the right path just fails

[15:00] I have a question about not about the mutability. But the representation. If we're making it a ledger key, that you have to write and in the future we do decide to support mutability will it mean, that the only way to update the contract is to write the entire binary every time or. So like I'm just wondering about. If somebody. If we support mutability and somebody wants to write a contract where they swap back and forth between multiple implementations like rolling back or something like, that and just the cost of writing an entire contract, which might be a couple of kilobytes versus store. If this is just data storing this data under you know just like regular data. And then having a point into, that data

[16:00] does, that make any sense yeah it gets into what we talked about a little bit in yet another one of the threads this week, which is like is there any kind of delegation mechanism I think it's a little bit awkward. Because well first of all we actually come up with a delegation mechanism, that we can all agree on, which is going to be weeks of conversation. But also you wind up needing to pre-flight every single transaction in, that case. Because you need to resolve the current delegate well maybe you don't need to pre-flight them. If you can guess where the delegate is currently pointing. But anyway I feel like it sounds like it increases the complexity of this and, that's like I'm not interested in increasing the complexity I'm just curious. If we're just any sort of future limiting something we can do in the future I don't think so. Because again I think

[17:00] think 47 already has a function called write contract and it takes a binary like, that's the point here is to just absorb the two representation questions not necessarily to solve do we have proxy or delegation or whatever, which we might have. But you know. When we had, that conversation this week John was really adamant about like let's ship without and see what happens and you know I can live with, that. Because we it's true like we could make the wrong delegation mechanism. And then we'd be stuck supporting it forever. So make sense zoomed in focused on the representation question nobody has any real objections okay I think it's really not contentious okay. So the final thing I had on the

[18:00] agenda, which is the footprint type, which is like even less contentious i'll just be extending CAP 53 with a new data type, which is called footprint and it just contains two lists of ledger keys the only really possibly contentious aspect of this I think is whether ledger keys full keys should be there or whether they should be restricted to only contract data values or value contract ID pairs or something like, that something, that is a little bit tighter than a ledger key but. If we do, that it means, that we are essentially fixing the impossibility of interacting with other ledger entries into the protocol going forward and I think the interoperability question still leaves, that open. So I was assuming, that they would be a full ledger key at least, that in conversation with John he again fairly clearly suggested, that he would prefer to keep, that door open and I'm happy to go with, that. So does anyone feel strongly what do you mean by footprint here you just mean the like sorry like the footprint is a term, that

[19:00] was introduced in CAP oh the other one the data yeah it's what we have been calling up until recently the read write set I found, that actually the paper, that introduces this concept of deterministic execution uses the word footprint and I think footprint is actually a great word to use here. So i've decided to start using this one. Because otherwise you wind up with the read-only part of the read-write set and honestly linguistically it's a little bit clumsy nobody cares about the footprint okay cool i'll just make it a lighter keystone, that is the end of my agenda items I yield the floor to discussion of interoperability or whatever else you want to talk about thank you John is this a discussion, that you want to kick off have questions

[20:00] are we switching. Now on onto like asset and drop stuff is, that where we are yeah yeah. So I think, that all we've sort of gone through all of the existing stuff on the agenda and the only thing, that was a big question mark was the asset interoperability stuff and I think, that that's where we are at this point yeah I mean I think the only real thing to talk about here, which like we have not been able to come to agreement on is just like what are even the requirements what are we trying to achieve me Nico Tomer lee talk about this problem like this problem I don't know like three times a week right. Now and I don't even think we're all talking about the same thing. So I think we just need to talk about our feelings. So anybody can take before from, that yeah I love talking about my feelings. So i'll start yeah. So I think you know the basic

[21:00] requirement from asset interop in my opinion is. So let's maybe it's worth thinking about like the full spectrum of interop or about the edges and where we are in the middle. So you know I think like on one extreme interop thing we just do nothing right and this is you can look for example at like aurora on near, which is you know a whole blockchain running inside of the blockchain, that has like no interop whatsoever and. If you want to interop with the parent chain you need to go through you know various bridging solutions. So I think, that's a very extreme version, which is no interop at all and it basically means, that we're not taking advantage of the existing Stellar ecosystem at all. But it's extremely simple we just don't need to think about legacy interop at all I think on the other extreme side of interop you have full interop with every primitive on the current Stellar network. So you

[22:00] can do things like interop between smart contracts and AMMs and the orderbook and sponsorships and like the wide everything, that Stellar proposes and, that you know is great for like supporting legacy. But it's also terrible. Because it means, that we're bringing a lot of the you know technical debt and the idiosyncrasies and in the classic protocol to the new world. So I think we need to find somewhere in between and I would say, that even, though there are a lot of disagreements in this room I think the basic thing, that we agree on is, that assets are the main point of interoperability like we're not trying to bring the orderbooks we're not trying to bring AMMs we just want to make sure, that classic assets will operate in in smartland and you know basically like asset issuers still have their infrastructure intact and they don't need to make changes

[23:00] and. So we have you know service providers like you know Fireblocks and BitGo all these folks you know their services are still you know viable in working even in this world without a change does, that make sense to people oh maybe i'll pick it up. Because yeah like with the without a change it's kind of like, that's the part, that's right, that is kind of reloaded I would say like the like as soon as you as we say there's basically like there are two parts to it right there is the do I expect on day one as soon as we have like smart contract capabilities can I use any classic asset on the network kind of

[24:00] automatically right or not using smart and, that to me is like one version of, that extreme inside this box, that you described where you know no change is needed and I'm we've been kind of trying to and John probably can expand on, that. But like it seems to me, that. If we try to make it, that extreme we are kind of really over constraining what type of things you can do in smart in terms of those assets right. Because you expect those assets to be represented by trust lines and you have like all those things right, that comes with, that and you have like the semantics, that are really specific right to classic

[25:00] so, that there is like, that version I think there is a maybe a more nuanced you know version of this, that is yeah like what like what do you mean. When you say like no change does it mean, that yeah you want to have people, that issue tokens on Stellar they want to make sure, that they continue we don't break their compliance story or whatever they have right in terms of like what they are what they sign up for basically with the network right like we're expanding the set of capabilities and and this one is it sounds more to me like like there's like some room there where you can say well maybe maybe people need to like issue us in this context of classic assets need to have like a

[26:00] kind of opt into smart capabilities and maybe they have like a way to specify, which subset of the capabilities they are interested in and. When you do, that. Then you have like maybe a different way to represent those assets kind of like. When we introduce claimable balances like claimable balances are actually a good example of where we kind of introduced this way to kind of go in a way like, that was actually breaking a little bit in terms of compliance. But at the same time we try to be for tokens, that don't have a lot of restrictions claimable balances are kind of can flow freely right and to me like trying to do a similar thing with smart is probably like a

[27:00] would be probably a good middle ground. But for, that it's an opt-in so, that means you don't get automatically like everybody you know every classic asset kind of shows up on day one yeah. So I think claimable balances are a really good example you know they're a fairly novel concept and for the most part aside from you know a small set of like super specific Stellar wallets it we haven't even seen support for them and with major service providers. So it's worth you know. When I'm talking about minimal change I think it's worth dividing this into the different stakeholders, that we're talking about. So I think on one end you have the more kind of like institutional cross-chain services things like exchanges things like you know things like Fireblocks and BitGo things like

[28:00] you know even like circle as an issuer like these folks you know take the path of least resistance it's been even difficult to get muxed accounts implemented with these folks. So I would say, that from their perspective we like zero change is preferable. Now for the actual touch points for these smart contracts obviously it's okay to introduce change right like. If a wallet wants to interact with some crypto primitive some smart contract. And then obviously they need to introduce changes and it's okay you know. So you know on the wallet side itself and from a user perspective, that's trying to use the smart side it's definitely okay to introduce some changes and can I have actually have a question on exchanges like. When you say like exchanges don't need to make sure well like exchanges today don't most many exchanges don't support any Stellar assets other than lumen

[29:00] so like why is, that relevant in, that conversation it's relevant. Because of USDC it's relevant. Because there is a group of exchanges, that support USDC and don't right it's growing you know and it's growing. But like over time do you I mean wouldn't you expect people like. If they are like any good assets being issued on the smart side, that they would be supported by those exchanges. So it's not they are going to like a phone exchange it's a bit of a different story right they have existing things they're not issuing tokens right they are it's more like they have a wallet in classic and you want their wallet to continue to work right and I mean I think at some point. If they decide, that smart assets are interesting and they want to opt in to make the changes great. But they they're probably not going to be the first people to do it's probably going to take them a. While and it sounds like we just don't want to break them yeah, that's fine. But like I don't think

[30:00] none of the proposals. So far are saying we would break classic wallets no. But we are saying for example you know. If we're going to recommend issuing on smart going forward. Then the issuer has like this tough decision where they need to make a decision whether the issue on the old path, which maybe is not recommended anymore. But is what the exchanges actually know how to support or issuing on the classic side and you know based on our previous experience it's going to take you know a whole lot of time for service providers to start enabling something new I get, that I'm just kind of a bit skeptical about like the for exchanges in particular, that they won't do like basically I think

[31:00] there are two types of exchanges the exchanges, that are going to be supporting whatever the latest set of functions I mean they are going to kind of keep up maybe like you know with some delay. But they are kind of keeping up. And then you have others, that are very conservative and going to be slow and I think, that's why for example I think we don't have still USDC on coinbase I think right Stellar USDC coinbase according to foreign sources doesn't have any multi-chain assets right now. Because of extensive technical and product debt, that coinbase is a bit of a special case. Because they don't even support they don't support any like usd any non erc20 USDC. But we do have and like it's a pickle it's difficult. Because exchanges you know there's a bit of a chicken and egg, that you know they want to see demand. And then it's hard to create, that demand without you know these assets

[32:00] supporting supported domain exchanges. But I think like the main thing I'm trying to together here is, that like it's hard to get exchanges to do changes and the service providers as well like folks like BitGo Fireblocks right and right. Now is you know the way, that you issue assets on Stellar you know the actual distribution is just regular payments right. So you know you can do it on all these platforms. If you introduce a new way to do it. Then you basically tell issuers you can't use these service providers I mean, that's not really what you're telling them is you can't use those service providers. If you want to do it the new way right. So what you're suggesting is having like this

[33:00] like a split thing in the ecosystem where you say hey you can issue an asset in one of both ways this way will give you like you know like a shorter path to exchanges and you can work with you know various service providers and the other path will give you what John I don't know what it'll give you the power to do whatever you want the question is what do you want right. If they don't want those things you probably shouldn't do it right yeah like. If you think of what we have right. Now for the network right we are kind of optimizing for payments. If the token, that you're issuing is not meant to be used for directly supporting payments. Then there's no reason to issue it

[34:00] as a classic asset like think of like you know NFTs or all sorts of random things like, that yeah. So as I said like. If you issue on classic. Then you have the entire breadth of like classic tooling available at your disposal right. Now like every wallet every exchange everything, that supports on classic you have at your disposal it's. So yes it's about payments. But it's just about like the ecosystem support I think like payments are also just transfers. So I'm it's also not clear to me why we would even say, that NFTs don't care about payments. Because people do care about transferring NFTs yeah. But we're not going to have, that is actually kind of broken. If you're modeling like, that's kind of what we see today on the network right like the way your model NFT is on the network is extremely poor the experience, that you get

[35:00] I guess one question is like do we think, that kind of the value of the smart contracts is going to come from people implementing new assets or do we think the value value's going to come from like taking high quality assets, that are issued by people who are you know not you know, that are not particularly you know experimental. And then innovators are going to come and like make new use of those assets. So my suspicion is, that maybe this the latter is is better and so, that kind of it's more important to interoperate well with existing assets, that might be issued by somebody else and to be able to like program those assets than to be able to create some new ecosystem, that's not, that's more divorced from the existing one. So I think there are it's probably both David. Because you're gonna have

[36:00] you know the stablecoins USDC and such, that are going to be used heavily in these smart contracts. But you also are going to have things like governance tokens uni style tokens and these are going to be issued on the smart side you know we might say hey you know what we don't actually care about these assets being transferable as regular payment on the classic side and maybe, that helps with with implementation. But we will see these assets. But I mean I guess I mean put another way like. When I talk to people who are using Stellar right it's it's often kind of two things, that draw them Stellar like sort of the perception of like high quality assets and low transaction fees and so. If like those are the strengths. Then we want to kind of make sure, that those strengths are we don't want to kind of like sacrifice those strengths and create a completely new ecosystem right we want to be able

[37:00] to kind of maybe for higher transaction fees add more flexibility. But where like you can still do things with like low transaction fees and do things with like existing legacy assets right like, that seems to me like the the thing, that we want to optimize for of course it's going to be like whatever Turing complete in general. But the thing we want to optimize for, that's going to make this special is the ability to also leverage these high quality assets and low transaction fees for people who are just doing simple payments and, that's not going to work for everything. But but there are probably a lot of cases where like you know people are going to want to use USDC for example right and maybe we don't want to get circled to like write some whole new smart contract to implement this we just want somehow like unilaterally people can write contracts, that do things with USDC

[38:00] yeah I think we're getting into a lot of speculation and somewhat like religious discussions here John can you help us like fine tune like where do things get hairy in terms of interop and what kind of like you know decisions we can make to simplify, that I mean there's a couple axes of decisions one axis is like wrapping versus not wrapping generally makes everything easier implementation-wise like significantly. So but like the ux might or might not be better, that's up to your interpretation. If you don't have a wrapping interface so, that's one axis a second axis of is like should a classic asset. When used from the smart perspective look exactly like a smart asset used from the smart perspective should they

[39:00] look identical should they behave identically and the third main axis is like should you be able to take a smart asset and easily send it back to the classic side, that access is more speculative I think. But those are kind of like the three angles, that one might look at this problem one thing, that is noticeable in other ecosystems is, that there's definitely the canonical way of doing assets right on the Ethereum ecosystem even, though you can write your own contract everyone just you know copy paste the or imports

[40:00] the OpenZeppelin one you know solana has like the spl other ecosystems have like their baked in contracts for assets like people don't actually innovate all, that much with assets and like I guess my question to you is like can we make those like canonical assets on Stellar be the existing assets maybe I mean I think you'd be making a lot of sacrifices to do. So are they sacrifices worth making not to me what are the sacrifices I mean I think the biggest sacrifice is just like do we really want to have a 64-bit balance for everything

[41:00] the next sacrifice is like do you want it to literally be exactly what exists today or do you want to build on top of, that more. Because like you would need like to do the stuff, that's common in you know DeFi you would need an allowances system on top of, that anyway. So it's not what we have right. Now we have all this compliance stuff baked in it's pretty unwieldy for a variety of reasons do we want to be married to, that for the rest of eternity I don't. So I guess what I'm getting at is you can shoehorn anything into anything send you I have a really strong opinion about the should you question. But I do have

[42:00] I participated briefly the last time around and I just want to do ads since you're already doing requirements gathering here a somewhat narrow version of what feel like the requirements I would want to add to this question I don't actually have very strong opinions about the assets I do have fairly strong opinions about two minor points and I think they I think there's a wide variety of ways to achieve these but. If we're writing things down. If possible I would like to request, that users not be in charge of non-management unless they really want to I think. If we're in a situation where the user has to figure out how to operate a cryptography api safely and correctly themselves we're putting them in a very dangerous position and whether we accomplish, that by completely baking in a standardized path or just having a very easy to delegate standardized path or even just there's a host function, that has very simple signature, that's fairly impossible to misuse I'm kind of okay

[43:00] with most of those approaches. But cryptography apis become error-prone really quickly and I don't want to surface a lot of, that to users unless they ask for it unless they're going out of their way to say I personally want to do some fancy cryptography for the average person who's just creating an asset I really want them to not be forced to copy paste and possibly get wrong the use of a cryptography api, that's requirement slash desire number one and requirement desire number two is ideally. If that code is gonna be in every single contract and it's the only thing, that differs from one contract to another or. If it's a. If it's standardized preamble in every single contract on every single path it would be nice just from a code size and execution performance perspective to factor it out as well. So I'm just I know the authorization point is not the only part of interop. But to me it's the only part, that I actually care about I do not care about the other aspects

[44:00] right. So I think, that what you just described I think is, that's kind of what is touched on in all this yeah in CAP 52 the authorization model, though for for payments is and going back to, that right is it is different it's different and, that's why they are like things done in a certain way in CAP 52. But I do agree, that I know as we try to figure out like the actual interop story with classic it would be we can avoid having I mean having like a yeah like good solid base implementation, that people can just you know import in their thing. And then just works mostly without having to implement those things and. But like the key part of, that the absolute most

[45:00] important part of, that from my perspective is the authorization aspect of it you want to. allow or require people to fiddle other parts it doesn't matter quite. So much. But and user writing your own authorization group is just a disaster we have too many crickets can somebody make it I don't like well I do have a question. So returning to what tomorrow sort of started this threat this head where he started it, which was

[46:00] just other networks have a canonical way like economical representation of assets, that people just use his question was can you know the current or classic asset just be, that canonical representation on says you know he's not a fan of, that approach the question is it worth trying to think about other models, that we could use for the canonical representation of an asset, that we could discuss or is it premature to just to get into, that right. Now I mean in a way you know like in CAP 49 for example the wrapped asset is a canonical implementation you know of the classic asset. But it's actually something, that is modeled as a smart asset. So

[47:00] so it's non-neg people would have to reinvent a bunch of things there you can actually standardize on exactly, that thing and, that's actually what is interesting about this approach is, that you the way you do it is you actually write a standard you know like erc20 type of equivalent you design it as a as thinking about the semantics as smart semantics first. And then you make it yeah interop with classic assets and there's only one way to do it. But yeah you do have standardization happening in, that world I'm not. So getting back to, that like I feel like I'm the only one talking like it seems to me, that the standardization is not necessarily the

[48:00] sticky point. Because in all those proposals. So far there is actually a standard, that includes classic assets. So what else is missing right got it well are there other questions, that people want to bring up. Now in the last nine minutes, that would help sort of move the conversation forward or should we just call it I mean we got through a lot today i'll let people think for a minute

[49:00] okay I think, that's a wrap. Then so thanks again everybody for joining the discussion anyone who's watching obviously we're going to post this you know to archive it on youtube later so. If you want to re-watch this, which I mean who doesn't right I watch these things six or seven times you can watch them there on youtube and also. If you want to participate in the discussion or you want to follow along please make sure to read the CAPs please join the Jump Cannon channels here in the Stellar Discord and also sign up for the Stellar dev mailing list where a lot of these discussions will continue asynchronously and we will see you back here next week for another Open Protocol Meeting thanks everybody

</details>

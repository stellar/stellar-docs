---
title: "OpenZeppelin Smart Account, Vault, and RWA"
authors: [carsten-jacobsen]
tags: [spotlight]
---

import YouTube from "@site/src/components/YouTube";

<YouTube ID="-T3Ia32nnP0" />

Christian Santagata walked through OpenZeppelin’s three Q3 releases for Soroban and how they layer new UX, composability, and compliance tooling onto the Stellar stack.

The Smart Account framework pushes account abstraction into the default developer workflow so passkey-first and programmable authorization flows feel native. Signers, scopes, policies, and validity windows combine into “context rules” (up to 15 per account) so assets can be governed by friendly policies rather than rigid key lists. Delegated signers cover Soroban addresses via `require_auth_for_args`, external signers route through verifier contracts so new curves can be added without redeploying core logic, and even the policies themselves can be external, stateful modules. That enables use cases like multisig automation, subscription payment windows, AI/bot guardrails, and short-lived dApp sessions—while the community pushed for clearer naming and demo content to ease onboarding.

Vault introduces an ERC-4626-style yield interface so managed strategies share a single, predictable API. Deposits mint shares proportional to assets under management, redemptions burn them, and yield accrues by increasing assets-per-share. OpenZeppelin highlighted the rounding pitfalls that let “inflation attacks” steal value via donations plus zero-share mints, then showed how a decimal offset and consistent round-down/round-up rules neutralize the exploit. GS Maxi (Sentinel F) contributed heavily to the spec, which was merged during the call.

The RWA stack packages a base compliant token with reusable identity and compliance layers. Core token features include forced transfers, freeze (whole or partial), recovery flows for lost keys, and pausability. Identity is claim-based by default—trusted issuers sign residency/KYC topics (capped at 15) but teams can swap in ZK or Merkle-based attestations. Compliance logic hooks into pre/post transfer, create, or destroy events, and multiple module contracts can monitor the same hook so banks can share rule sets. Access control can stay simple (owner) or fan out into granular roles, and extensions such as Document Manager anchor off-chain legal artifacts via hashes.

### Resources

- [Smart Account docs](https://docs.openzeppelin.com/stellar-contracts/accounts/smart-account)
- [Vault docs](https://docs.openzeppelin.com/stellar-contracts/tokens/vault/vault)
- [RWA docs](https://docs.openzeppelin.com/stellar-contracts/tokens/rwa/rwa)

<details>
  <summary>Video Transcript</summary>

[00:00] Hello and welcome everyone to this week's Stellar Developer Meeting. With me today I have two guests, that have been around here before from OpenZeppelin. And what we're going to do today is we're going to take a look at what has been added to the OpenZeppelin tool chain and and the libraries, that are supporting Stellar for the last quarter. So I'm super excited. I know we're going to talk about smart contracts. We're going to talk about WAS. So. So yeah, please introduce yourself and let's get started. Yeah. Hello everyone. It's really a pleasure to be to participate again at the Stellar Developer Meeting. My name is Buan. I'm open source developer at OpenZeppelin. and I'm

[01:00] building the Stellar contracts library. Hi everyone, it's Ugun here. pleasure to be here. And I am also an open source developer at OpenZeppelin. We are a team with Voyan trying to bring trying to improve the smart contract ecosystem for Stellar Sorovan. Great. Thank you. So we've done quite a few hackathons this year and it's really great to see, that some of the developers they're starting to use open sin software and the the libraries and the tooling. And I think what what you're going to show today is going to be really interesting for a lot of developers. So. If you have a presentation you can share. Yes. I will start. let me show my screen.

[02:00] [clears throat] Yeah, there it is. Sorry. Sorry about, that. yeah. So I'm going to present to you today the [clears throat] smart account framework, that we created with released with the latest u latest release of of our library. Just to to mention, that yeah already a month ago. When with some of you we met at at Meridian in in Rio. How excited I was and I guess it was the case for everyone to use pass keys to have all this

[03:00] like wallet experience abstracted into into into smart account. So our ambition is to make this the new normal for Stellar. So yeah we are building this framework u with with, that in mind. So without further ado yeah let's dive in. First a point about naming and why we chose smart account and not smart wallet. First [clears throat] the Soroban SDK defines custom account and custom account interface and our design builds on top of it. So, that's why we we decided to to choose smart account as a naming and yeah smart account

[04:00] must implement this interface. Then why smart accounts are necessary? Let's just explore a very simple scenario. Where a smart account, that holds some fungible tokens and the owner of the contract wants to transfer some amount and, that's why they need to call a function on the USDC contract. In this case, they will make use of a cryptographic key, that is registered at this smart account to authorize the the operation. And by looking from this perspective, we the perspective of account abraction, we we are establishing a boundary between the account, that holds the sets and the keys, that control them.

[05:00] now let's try to define what a smart account is. So let's this is a smart contract first and foremost, that composes authorization intents, that are coming from multiple sources and this high level definition will guide us through the the the all the components of our framework. With this in mind, let's first see what are what the authorization sources could be. As in the previous example, an authorization source could be a cryptographic key or there could be multiple cryptographic keys for the same smart account or it could be a G account, that authorizes on behalf of of the smart account or it could be any combination of these cryptographic

[06:00] keys, G accounts or other smart accounts and smart contracts. The next part of the definition talked about authorization intents. What are and yeah we will see what are the core elements of of the authorization intent. We can examine this by answering these three questions. We can define who is allowed to act what are they allowed to do and how those permissions are enforced. Who is allowed to act? This might be already clear. Those could be some keys from different cryptographic curves also G accounts C accounts. What are they allowed to do? Well, here this can be literally any kind of action either a specific function on

[07:00] a specific contract or just transfer the transfer function on any SCP 41 compatible contract deploy deployments as well. So yeah, any kind of action how is this enforced also many different combinations are possible. It could be key one and key2. Key1 or key2 key1 and some other conditions, that are not derived from the from a cryptographic scheme and to give names to those groups. Who is for signers? What is the scope and how how is for the policies? How do we compose those elements? So we have signers scope and policies and we embed them in the entity called context rule. Here you see, that

[08:00] besides the signer scope and the policies we also have the the notion of validity. Context rules function like routing table for authorizations for every context. They they specify the scope and the conditions, that must be met before the authorization is granted and yeah we'll see how this this goes very shortly. So a a smart account is stores a set of those context rules and up to 15 rules per we can have up to 15 rules per smart account. We added this limit to ensure there a reasonable resource consump consumption and to encourage proactive management. For example, to encourage you to remove the expired or unused rules. And coming back to this authorization

[09:00] mechanism or algorithm, actually it's pretty simple. When the authorization from a smart account is required first we we gather and order all non-expired rules. And then we evaluate them starting from the last addit last last addit one. Now let's zoom into signers we have two types of signers delegated and external a delegated signer can be any Soroban address, G account or C account. And on the right we group all cryptographic types of schemes or keys in in the external variant. And we'll see just in a second why we call it external. But first how the delegated signer grants an authorization. Codewise it's very simple. We use the built-in

[10:00] require out for arcs function and. However there is a catch I of how we are actually constructing this this transaction I won't go I won't dive into this sketch I it's like you can find more information about it in the documentation and there are some code snippets explaining how to to get over it. Just mentioning it and, that the CAP 71, that hopefully gets included in some of the future protocol updates will resolve these issues. So yeah very soon I hope it will be a u no issue. The second signer type is the external one for authorizations coming

[11:00] from cryptographic keys. But before we look into into, that, I'm here providing a list of the curves on Stellar there the already available ones, that are supported and BN 256, that might get added with Protocol 25. And yeah, I guess there there could be many more in the future. And you remember the structure of of the external serer like to go back it's a tle of address and by and byes we could have defined its structure like this by enumerating all available curves and the [snorts] bytes, that should be interpreted according to the curve type. But you you would agree, that this approach is not very scalable. Because on every new curve, that is added

[12:00] you have to upgrade your account. If it supports it and this is not practical at all. Another drawback of embedding signature verification into the smart account is, that it binary size will grow and the code complexity will increase as well. For example, the ED the classical ED 25 119 like it's just one liner. But pass key verification for example is pretty much is more evolved and requires more like more code simply this pushed us to adopt a way more flexible and scalable approach, that is outsourcing and externalizing all type of signature verifications. So we have a verifier contract, that stands for this address and the public key, that is the bytes.

[13:00] this verifier contract is a special one. It is deployed only once per curve type or scheme and should be immutable. It's it shouldn't keep any state and in such way a single verifier contract can validate signature signatures for any any number of keys. And yeah this was made possible thanks to Protocol 23 and, that made the the cross contract calls really cheap. Now let's look into policies. So we have here one context rule with the scope, the signers and the policies. Let's say we have three signers, two cryptographic keys and one G account. And actually the policies they modify they customize the

[14:00] how signers behave. Here in this case we require any two of those three signers to sign so, that the authorization passes it's the policies also can modify some other aspects of of the flow here. In this case, we want those rule to be enforced only for once per month. So, that like you can for example pay for a subscription. So policies are external contracts as like verifiers. The verifiers are external. So policies are also external contracts. Policies can be stateful or stateless meaning they can map some state for a specific account and context

[15:00] rule. They can be shared across many different accounts or can be tied just for a specific smart account. And the other aspect is, that they have a four stage life cycle. Which is visible from the interface, that those policies must adhere to. Now. If we look into this spending limit policy, it is let's say it's a stateful policy and it is shared across multiple smart accounts. When this policy is added to a context rule, the install hook is called and this in its the storage for the calling account and sets the amount and the time period. For example, here we'll have 100 USDC and one month. This is the in in it params, that are pass can enforce

[16:00] is just a read function, that is invoked every time the evaluation loop runs. Enforce on the other hand it requires authorization from the already installed smart account and modifies can modify the storage and can emit events. Uninstall is called. When the is removed. So we are cleaning up the policy storage. So install and uninstall are used only once can enforce on every evaluation loop and enforce. When context rule is matched. So these are the main elements of smart account and yeah to sum it up we we have we can have up to 15 context rules per smart account and each context through contains signers and policies.

[17:00] So let's see some use cases. Yeah the most like trivial one is the multisix threshold bas based or like the weighted multics. We can have with this u setup we can have time limited app sessions. For example you install context rule, that is specific for a specific app and it's valid just for one day. So you don't. So you can interact with this app without needing to approve any any further transactions. You can add for example the keys for AI agent or bot to as a context rule and allow it to spend some like limited amount of your assets. So it can trade for example and you don't risk to get wrecked or

[18:00] you can subscribe for some services. So yeah let and here let's see how the subscription the flow the user flow for a subscription will happen. So I have a smart account and I have the sudo sudo rule like the the super admin rule, that is has a single signer my pass key and there are no policies and it's valid forever. Then I I'm going to u some dApp and I want to subscribe to a service. The dApp prompts me to install a context rule, that contains the scope of it is the USD contract. Because I'm going to pay in USDC. The signer is the D pub key. And the policy is some spending limit polic

[19:00] policy, that limits the the spending for up to 20 20 bucks per month and I'm subscribing for one year. So this is the single transaction I have to do u in order to subscribe for this service. And from this moment on the dApp developer for example they can use the OpenZeppelin monitors to subscribe to the install event on this policy and. When this gets triggered they will with a relayer they with the opposite layer they will charge the user smart accounts every every month 20 bucks. So the key takeaways this this framework is context centric framework. I will compare it as the I'm comparing it very

[20:00] often with the web to login experience. For example. When you are logging it with your Google account or your GitHub account like you authorize the third party with some specific permissions. We grant some scope permission. You don't grant the whole access to your data. But just to very like scoped permissions. So we are composing authorization intents through those context rules, that contain signers and policies. Another very important aspect is, that signature verification is not hardcoded into the smart account. So it is this is very flexible and very scalable and yeah like this framework enables programmable authorization in in, that manner.

[21:00] manner. So yeah. If you want to play with it I'm inviting you to go to our repo and to check our docs. And yeah I'm pausing it here for questions. If there are any. Great. It it was really interesting. We have seen a lot of interest in in using pass keys and I think there's. So many ways to do like there's. So many capabilities in Sora for authorization. But it's also complicated. It's not it's not straightforward forward and easy. I think the the wealth of opportunities to create custom policies and authorize your users in different ways. I think it it it's great. But it's also a little bit complicated. So, the framework you present here makes, that a lot easier. I

[22:00] think this will be be a great great way to to add a flexible authorization to to your dApp. So very interesting to see. I think I'll I'll drop the link to the repo or to the documentation. But. If anyone has any questions, I think yeah, Elliots has a question here. Yeah, did you say, that Ozair can be used to index track additions removal or Yeah. Yeah, definitely. I mean you there are some events, that you can subscribe on subscribe for those events on the policies or on the your smart account and yeah do do yeah trigger some actions according according to whatever you want to do. one naming concern, smart account

[23:00] will likely overlap with Stellar accounts and could confuse the idea, that this is a contract. Mhm. Yeah. yeah. I presented why we ch why we went with smart account. yeah. Mentioned, that that this is this may seem a better fit for for yeah this kind of entities Stellar accounts you mean the the classic Stellar accounts I yeah I suppose this is what you mean. But yeah I a smart Don't Yeah. We have to give it a thought. But I think we can it can

[24:00] be disting distinguished well enough. So not to be confused. It would be great to include a 15minute demo of building an actual d. Great suggestion. [laughter] I'm taking it. Yeah. Okay. Then I'm passing it to to O. Right. Hi again everyone. I'm going to be presenting the world token world and also RWA. So let me share the screen. Let's do entire screen. Please tell me. If it's successful. Because I don't see the streaming tab right now. Yep, we see your presentation.

[25:00] Great. Great. Let's try slideshow. So, what's it, that I'm going to be talking about? It's a uniform interface for integrating with various yield generating strategies also known as ERC 4626. If you are familiar with the Athereum ecosystem. The problem tokold solving is let's say you have a th00and USDC and what are you going to do with this? You can lend it, for liquidity or you can stake it, right? But these are all the options you can do or you can have a manager of your funds for utilizing the best option out there. But for every manager you will have

[26:00] different problems. There is no composability. The UX in general would be bad. So, vault tries to standardize all these and it still can be managed. So, this is what we are trying to do. So, you deposit your assets into the world. The world tries to utilize your assets in the best way and earn some interest and you will get shares in return. And you can always do transitions between shares and assets. You can convert them interchangeably. So how do we calculate shares and assets? So let's say you deposit your assets and you will get shares. The basic formula for, that would be we

[27:00] will multiply the deposit assets by the total shares currently in the world. And then we divide the this result by total assets in the world and, that whole result will be your shares. This will be very important. So now, that I'm going to do some basic math. But it's very basic. So don't be scared. First action Say Alice deposits 100 USDC into the vault. So for deposit assets it's th 100 total shares it's again 100 and total assets is 100. So let's say 10% yield is earned, and now the asset amount per share has increased. So previously one asset was corresponding to one share. But

[28:00] right. Now since the total shares have not changed it only the interest rate increase the total asset amount in the world. Then this ratio should change right right now. If you provide one share you will get 1.1 1 asset in return. Because one 10% of interest rate, and now Bob say Bob deposits 300 USC and we do this calculation and Bob will get 272.73 shares in return. So it's not one to one mapping as in the case for Alice. Because there was 10%. And this is still fine. Because if you multiply the shares by 1.1 you will get 300. So it is

[29:00] still fair. And let's say another 10% of interest has happened, and now Charlie deposits 200 and the amount for shares would be 165. The problem is in this previous slide is we have these decimals, right? This is not an integer. But it's kind of a floating number. This is problematic. Because how do you handle 3.33 shares for example? You cannot. So for shares we round up or down. When we do we round down. When do we round up. So let's say you are minting or depositing depo depositing we are rounding down your number of shares so, that you'll get slightly fewer shares than the exact ratio. The reason is

[30:00] world cannot overmint shares and we have to protect the world not the users so, that attacks won't happen. So this is the same this this rounding down goes for minting and depositing and the opposite one rounding up goes for redeem and withdraw operations for gold, which creates another problem, which I will demonstrate right now. Let's say okay this is the inflation attack. There is couple of versions of it. Let's say the attacker deposits one's troop. So he minted a share and right. Now one share will correspond to one's troop only. Then the keyword here is donates. It's not deposit. So since it's not deposit, it only increases the total asset amount

[31:00] but not the shares. So it's basically I'm just giving away this money to the vault and I'm not expecting any shares in return. Why would someone do this? You will see the reason. And. If you convert the USDC to stroops you know there are seven decimal places in Stellar. So we added after 10,000 seven more u zeros. And then we added the previous ones troop you will have this number for total assets, and now alice deposits thousands troops so. If you divide thousands troops to this total asset amount you will get something really small like 0.00001 or something like, that and this will be ultimately zero. Because of the rounding down, that I explained previously. So basically Alice deposited some money, which was non zero. It was

[32:00] thousands troops. But in return she got zero shares and. If the attacker redeems their shares they will get all the money basically stealing Alice's troops. The other scenario would be in here. So let's say again this the first two scenario are the same attacker deposited one troop. And then they donated 1 thou 10,000 USDC and after, that say Alice deposited 10,000 USD. So it's almost a half of the total assets right. But only one stroop short of it so. If you do the calculation it will be somewhat like 0.99999. But since we don't have any precision for the decimal points, it will again be round down to zero and attacker would steal all Alice's money like 10,000 USD

[33:00] due to this rounding down behavior. So this is the inflation attack. This is not only for our implementation. This attack existed through all ecosystems and fortunately we have a solution for, that. The most common one is decimal offset. So instead of this regular or the straightforward calculation we also add an offset to the power of 10 and it will be something like this. So. If you deposit one stroop instead of one share you will get this amount of shares. This is up to your decimal offset. So let's say 1 2 3 4 5 6 7 8 9 and in this case you will have nine for the offset and you will get this amount of shares and let's say for the same attack the attacker. Then donates 10,000 USDC

[34:00] they won't get any shares. Because it's a donation. Then Alice would deposit 10,000 strooss it would have been this small amount previously. If we didn't use decimal offset. But since we are using decimal offset Alice will get one share and attack won't be attack won't resolve. So basically there is no attack due to this decimal offset any questions about vault and I will just stop presenting and we'll move on to RWA after questions. By the way, maybe we can also share a link for the world implement. Yeah, just maybe we also want to shout out to someone who helped contributed to the

[35:00] implementation. I don't know. If he's on the call, GS Maxi from Sentinel F. So yeah, he he helped with this implementation. Yeah, laid the groundwork and we and he also helped us writing the SE for world. We just got merged today by the way. So we have a new SE guys for the world. All right, great. Then I can continue with RWA. So for this one, I'm going to be presenting over some text instead of slides. Okay. is the is it readable or should I make it bigger?, maybe just slightly bigger. Yeah, I

[36:00] think this is good. Great. So RWA as you know stands for real world assets and it's more like a switch of contracts compared to a single contract. So it's more complicated and involved for the base RWA token. You can think of it like a fungible token. It has the same metadata and core functions. But on top of, that we have forced transfer, which the admins can force transfers on behalf of the users. We have freezing both address level and partial. Partial means we can freeze some part of your wallet balance. For example, maybe you have 2,000 in your balance and we only froze 500 of it. And address level is your

[37:00] address is frozen for every like transfer, mint, etc. Operation. So basically you are on hold. We do also provide recovery mechanisms in RWA. In case of you lose your private key. Then the authorities can recover your wallet by sending your balance to another wallet and also all the account related information of you as well. For this recovery of course you have to convince the authorities by providing the necessary documentation. It's not part of the RWA standard. But this is how it will work on behi behind the scenes. And you probably already know about pausable operations for the utility for other tokens as well. This is the same for RWA token. We can pause the operations for the contract. So this base token contract is going to

[38:00] be interacting with two modules or stacks. One of them is identity, the other one is compliance. Identity stack will be responsible from verifying your identity basically. But it's also very involved and I will get into details later. And the other one is compliance. This is mostly for hooks post and pre hooks for the operations and this is this exists mostly due to allow organizations or governments or etc to include or embed their own business logic into transfers and means and burn operations. So let's go step by step. The RWA token as I told you is the main contract and it

[39:00] it communicates with compliance and identity verifier. The compliance is managing five hook types, which I will dive further deep into. And the good thing about compliance and identity verifier is they are multi-token support, which means let's say you have a compliance contract you can share this with multiple tokens multiple RWA tokens. So let's say there is another RWA token here. It can also go to the same compliance contract. I will give this example, which I like. Let's say you have bank A and bank B in your country and since they are in the same country probably the compliance, that they need to oblige to will be the same. So they can use the same compliance in this case. Identity verifier again this can be shared across multiple tokens. It validates the identity of the

[40:00] investors of this token. I will dive this into later. So let's skip for now. If you go for the highle basics for the token you need to provide the name symbol decimals and initial supply very standard basic stuff. Same with the fungible and on top of the fungible we will have the freezing mechanisms. We will have a recovery mechanism. We will have force transfers and possible operations as I told you. So right. Now I already told about how this compliance and identity stack can be shared. So I'm going to skip this one as well. So let's dive into identity stack. So there can be multiple ways to verify identity. The one we provide, which is the default one is claim based. So

[41:00] you can think of it like I'm from Turkey and I'm a Turkish citizen and in this RWA setting maybe the residency is an issue. So I must have a claim from the authorities, that I'm a resident of Turkey. So I need a residency claim issued for me by the authorities. And one downside of this approach can be. If it is not encrypted. Then all the data for everyone since this is onchain data can be seen by everyone. So this is very useful. But also. If you care about privacy it's it may not be the best solution. So there are other approaches as well like you can do Merkel tree, you can do ZK email, you can do your own custom approach. We do not provide these by the way. But they are for sure doable and we

[42:00] designed the architecture in such a way, that this coupling here is not tight. But loose. So you can easily plug plug this one out and plug your own solution for identity stack. Sorry here. So basically you can replace the stack here and plug your own. So what do we provide for the default identity? We provide claim topics. These will be non customer anti-manual laundering etc. For the topics we limited the topics by at most 15. We also have trusted issuers. These are all separate contracts by the way. Like this is a separate contract. And the issuers, the trusted issuers will be able to sign claims on behalf of

[43:00] the users so, that the users can use these claims. And we also store the information regarding the identities like. If they are individuals or organization, which country are they based in etc. So the identity stack is managing all the claims and the topics and also the account related information like individual organization country information etc. The compliance one. So these are the hooks. This is much more straightforward. We have two pre hooks and three post hooks transferred, created and destroyed. So I will start from the pre hooks. Say your organization needs to run additional business logic for transfers. So before any transfer operation

[44:00] happens, you want to run some custom business logic, you can do, that. We have a compliance contract, which will call this hook. When a transfer is about to happen. And for this hook to work, you can have your own contracts. We will call them modules. [snorts] And let's say you have a module for can transfer. So what you would do is you would link the compliance contract to your can transfer module contract and this compliance contract will call your module on every time there is a transfer is about to happen and the good thing is you can deploy many contracts per one hook. So for example, you can have three contracts, that will be called for can transfer. But five for can create, which

[45:00] for be minting. This is completely up to you. We decided to go with multiple contracts due to audit audit auditability and also separation of concerns. So. If you just wrote your logic into this scan transfer. And then you wrote another logic in the scan transfer by pure code. Then it would be cumbersome to manage and debug. So, that's why all business logics separated into their own contracts, which will be called by a relayer contract or proxy contract is a better architecture. The same goes for these post hooks. You can have additional logic for all of these. And, that summarizes the compliance module. So what about the access control? You have few options. You can go with ownership model or role based access control. So it's completely up to you.

[46:00] And for each kind of operation you can assign roles have very complex role based access control architecture or very simple one again completely up to you. We. Now only provide one extension for RWA, which is document manager. [clears throat] enables you to attach some legal documents etc to your token. Of course, we do not store the whole document in the blockchain like onchain. This will be inefficient. We are utilizing the hash. And you can also add your own extensions to RWA. That will be it for the RWA. If you have any questions, feel free to ask. I see one question. Is RWA design based on any existing stars? Yeah, of course. So we work with tokenia and ERC

[47:00] foundation also in collaboration with Stellar included. So all these companies came together and based on the RWA proposal for the Ethereum ecosystem or general ecosystem we made it specific to Stellar. So we made some few deviations from the original proposal and most of our proposals to deviate from it was welcomed and it will be adopted in the original standard as well. So we also contributed to the maturity of the original proposal as well. So it's not designed from scratch. If that's what you are asking. Okay, great. This was three really interesting presentations and I think it's very aligned with what we see, that developers are interested in doing.

[48:00] yeah the the pass key integration and use, that for authorization is something, that's very big focus on I think this framework you presented is going to help a lot of developers to create a robust framework for for authorization using pass keys the vault is something we've seen an increased interest in a lot of developers want to build in a way to earn for the tokens, that the the users are are holding in their wallet. So very interesting as well and RWA it's also super aligned with what what SDF is interested in. So I think this is a really this really hits right where the focus is from developer sites today. So super interesting and I think we we did post all of the links. But but otherwise go to `opensea.io`

[49:00] And then then you can also see all the documentation there. Let's see was one more comment. Yeah, I don't think there's any other questions. This is last chance. If anyone has a question. But but thank you both of you for for joining today. It's super interesting to see all the work you're doing. And I personally I think it's super interesting to see some of the libraries you're building, some of the frameworks and some of the tooling. When we go out to hackathons and. When we talk to developers, that we see, that they're being used. I think, that's, that's the greatest part of it. So. So thank you everyone for joining and thank you you two guys for being on here again and u I'm sure we will talk again sometime soon and follow up on on the latest development. But thank you for joining everyone. We see you next week.

[50:00] Thanks for having us. See you.

</details>

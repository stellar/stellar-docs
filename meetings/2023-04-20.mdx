---
title: "Soroban Design Discussion"
authors: [kalepail]
tags: [soroban]
---

import YouTube from "@site/src/components/YouTube";

<YouTube ID="Sw3ibgBbQa8" />

Soroban is a smart contracts platform designed with purpose and built to perform.

<details>
  <summary>Video Transcript</summary>

[00:00] Hey everyone I think we can get started. So this is the storybond design discussion in, which we discuss protocol changes related to Soroban our topic today is State expression we're going to keep talking about rent and temporary storage Ledger entries. So Garen can you take it away yeah. So I think at the talent of the last week's meeting we were discussing about what happens. When entries are delayed with outstanding run balance and we decided, that it was probably not a good idea to refund the outstanding balance and instead just have the balance be burned the reason for this is, that. If you allow rent balance refund. Then you open up a lot of kind of a malicious attack vectors for instance. Because entries automatically have a run bump whenever they're touched you can have a smart contract, that has every

[01:00] invocation of a function Touch One admin entry for instance. And then this adminant tree especially for a popular contract could have lots of rent balance. Because it's touched another function call. And then you could have an admin of this contract who maliciously deletes and recreates, that entry periodically in order to essentially steal this rent balance from the collars of the function and also this would be difficult for users to be able to detect or even see. If the stack Vector exists. Because for something like an admin entry it would seem like a normal operation for and not another contract to either create or modify, that entry. And so it'd be difficult to detect these sorts of attacks attacks also refunding my balance doesn't really make sense. Because many different users may pay for the rent balance only a single user benefits from the refund. And so for these reasons it seems, that the best policy for whenever an entry is

[02:00] delayed without standing rent balance is just for this rent balance to be burned. Now even, though we're burning on this outstanding Grant Balance we still want there to be an incentive to delete entries before they're archived. Because even, though we have the state expiration to reduce the size of The Ledger. When an effort a restorable entry or like, that's what we're calling. Now entries, that are eligible for archival. So in non-temporary entry. But whenever these entries run out for end even, though they're delayed from The Ledger they still have to be stored perpetually in the archive and so. If you have an entry, that's no longer going to be used it's significantly more advantageous for this entry to be deleted instead of being sent to the archive. Because even, though the archive is kind of like our deep storage and it's much slower and we have much more we're learning there for large amounts of state it would still be better just to have not have useless entries or entries, that will never be used again taking space in The Ledger or

[03:00] the eye archive. And so since we can't incentivize this Behavior via a rent bounce refund we're thinking instead of adding a base fee called the archival fee and essentially what this would be is just some flat fee probably tied to the size of Ledger entry, that you have to pay in order to create the entry initially and then. If you delete the entry before it gets archived you receive this as a refund. And so this allows you to have someone set up for deletion and then. If you don't delete an entry and gets into the archive. Then this archival fee is burned. And so the thinking being, that this gives users incessive to delete entries before it gets into the archive but. Because it is a fixed rate and is not something, that can grow to large amounts like red balance it can't be gained nearly as much and one of the drawbacks is, that this does make you know the answers more expensive and this also increases the size of the entry. Because we'll have to

[04:00] store the archival feed as a parameter. So it increases the size of all entries by about four bytes. But I think this provides a good incentive and can help us maintain the hygiene of the archive. And so I guess General thoughts on both the issue about burning rent balance, that's outstanding and also on this new archival basically foreign. So I think yeah I think on the red balance getting burnt I think we're pretty much in agreement unless someone else has a different opinion there there I am very much concerned about introducing yet another type of V for for the purpose of motivating people to delete their their entries especially. Because we already have temporary storage, which hopefully should take care of of like most of these cases like what is can you give us

[05:00] a use case for like. When a non-temporary non-temporary entry might get deleted and how often do these happen yeah. So just have to depend on usage patterns patterns. And so one thing with the temporary entries is, that their lifetime is fixed to a set amount or to a very limited time frame. And so this is built for security reasons. But also just for fee based reasons as well, that temporary entries will have a maximum life something probably on the magnitude of like months. So like three months or six months or something like, that the exact value happened on the side yet. So I think, that there's a use case for say you have something like a payment Channel Channel, that doesn't need to be preserved these don't want it to last longer than the maximum life of the temporary entry would be. And so I think for Android types like, that that aren't super important from the security standpoint. But have a variable length

[06:00] time or a variable length lifetime. Then there might be some advantageous here for deletion I think the second issue too is. If we have this archival fee it provides more incentive to use temporary entries as well. Because right. Now the savings you get from a temporary entry are relatively minimal. Because there's still essentially how we calculate the temporary entry fee is, that say. If your temporary entry lasts 128 ledgers what you do is, that we take a snapshot of the current rent fee multiply, that by 128 and, that's how much temporary entry costs. And so today a temporary entry and a restorable entry are very similar in price. And so I could see network incentives being well like well they're essentially the same. So just be on the safe side I'll use a restorable entry. When a temporary entry really could do so, that's the second advantage to having a space feed is, that by adding this fee to the restorable entry types and not adding this fee to the

[07:00] temporary entry types you also widen the gap between the cost of a temporary entry and a costly restorable entry to further incentivize more use of these temporary entries and lessen the restorable entry type have you considered any other options for widening the the gap between temporary entries and restorable entries, that doesn't include an archography archography oh. So there's like a there's an implicit savings. Because the rent fee snapshot and. Because rent fees tied to the bucket list size generally speaking at least for the access patterns you're seeing on starting classic. Now this might you know vary. Because we haven't seen soap on traffic yet in the real world. But the bucket list grows relatively linearly and so. Because temporary entries are locking into the fee and we expect the bikeless size and. Therefore the print fees to increase linearly you are getting a cheaper rate. Because

[08:00] you're able to snapshot, that being said especially for short-lived entries the settings are pretty minimal. Because the rent fee doesn't grow at a very fast rate. And so I think they're I'm trying to think. If there are any other implicit fee signs at the moment. But I think. If we want to incentivize temporary storage from a feed perspective we will have to add some additional costs to the restorable entry camera points counterparts. Now whether, that be a refundable fee or other fee, that's refunded on deletion or just a fee of creation, that's immediately burned I think either of those could work. But I think we do need to have some sort of price discrepancy in addition to the implicit discrepancy in the rent fee snapshot alternatively. If we think, that we don't need to incentivize these are temporary entries from a feed perspective. And then just the utility they provide is good enough incentive on their own could also

[09:00] go back route but, that could cause more archivable and restorable entry types than we want floating around the network and make our archives larger than they really should be okay yeah the question is how much bigger will will they get. Because this idea of yeah like creating like this this you know middle you know basically what you're saying you're like is is, that there's there's a whole category of like Ledger entries, that are like between temporary and restorable, that could theoretically like not be archived and we're going to introduce another fee mechanism specifically for them and and. But and we already have a fairly you

[10:00] know across the board we have a non-trivial like fee you know various fee mechanisms. So introducing another one is something, that I'm I'm not entirely comfortable with it yeah yeah yes any other potential saving is just, that the temporary entries never require proofs for creation whereas some types of restore boundaries require briefs, which is another difference, that could be useful. So for instance in the using storage type requires a proof of non-existence to create or temporary entries never require proof, that being said the recreational storage type does not require such groups I think temporary entries are a powerful primitive on their own. And so I'm not sure how much we need to incentivize their use from a fee perspective perspective. So I'm just curious as to people who know like the the smart contract

[11:00] ecosystem better than me are like the temporary entry is strong enough on their own and do we not need this additional archival incentive foreign yeah. So I think the you know the main use case we're we're seeing for for temporary storage is oracles we've talked with some of like the major Oracle providers who would love to see this this. And so I don't think even. If there's you know. If even. If there's like even. If with not a lot more fees they can get archivable storage I don't think they'll be interested in doing this. Because again their data is really short-lived is relevant for a short-lived time the other thing is, that. If like actually. If if we add this archive or fee people

[12:00] will actually need to reclaim it right so, that's like we're basically adding an operational burden on these entities to actually reclaim their fees through. But I mean I I'm. But this is sort of place temporary entries right. So with the Oracle use case still want you know temporary interest of course this doesn't replace, that I guess the the question is is there a good or is deleting a restorable entry happen often enough to to have the complexity of an extra fee and to add the additional four byte archival fee value right. Now I'm hearing no but, that's probably not a use case, that will happen very often and I kind of like appropriate and thinking about yeah I guess my my opinion

[13:00] understand is is clear is there anyone else with thoughts in the matter what is the cost of letting this go to archives like getting like a having a archival entry like go to the archives and stuff instead of again deleted also just the the thing about the archive is, that it never shrinks so. If an entry gets archived. Then you have to store, that in the archive versus. If the entry gets deleted. Then you don't have to store it in addition even once an entry is restored from the archive we still have to keep essentially a stub of its existence in the archive. So what happens is, that whenever an entry is restored it's Leaf node, that uses from The Ledger entry as nulled out. But the path to the node still needs to be maintained for all eternity. And so I think just given, that the archive is pretty much append only it is designed such, that you know this is like a slow data structure

[14:00] that's meant to be you know like the the archive nodes are essentially just like you know SSD base and they're meant for storing large amounts of data. And so it's not nearly as sensitive as the ledger size. But it is something, that we should probably keep in mind as, that. If we send something to the archive at least some of, that data even. If it's restored later will have to live forever, which is why. If there's an entry, that user will never use I would much rather, that interview deleted than having to store it perpetually in an archive even, though archives are kind of meant to store things perpetually based off of what you said like I would expect temporary like I think you mentioned, that the fee difference between temporary storage and non-temporary storage it like is like negligible. But I would expect it to be someone significant just based off what you said oh what do you mean like I mean like it would make sense. If we made temporary storage cheaper to incent to not incentivize what you're describing worry just like using

[15:00] recreatable storage well, that's actually another thing we could do is instead of adding an additional fee to archival storage what we could say is right. Now temporary storage is just the feed calculation it's just a number of letters to live times current rent fee what we could do is just say like numbers of ledgers to the times current rent fee times like 0.8 or some like temp fee you know multiplier such, that the temporary entries are still based on the current size of the bucket list. And so they can still increase or decrease in price as the Ledger state grows or shrinks. But they're strictly cheaper than archive entries by a significant margin and, that also kind of simplifies the fee story. Because we're not adding an additional fee type. Because we already have separate fees for temporary entries. And so this would just make them always smaller, that would actually probably be a much simpler better idea than I think having this refundable archival fee

[16:00] thing thing yeah I guess this doesn't incentivize the actual deletion of those entries. But I think you've seen less of them yeah I think. If temporary entries are significantly cheaper or at least substantially cheaper. Then we didn't don't really need to incentivize deletion. Because if you're thinking about like what what the use case for restorable restorable entries are especially for like the recreatable type is pretty much just balances and I mean the I think the amount of balance deletions is probably pretty small. And so I don't think it's probably a huge case of special case for it yeah I completely agree I think. If we figure out a way to Discount the temporary temporary entries the way, that you described, that will go a long way towards making people use them and in terms of you know the previous point on saving space for archivers I hear you the question there is like

[17:00] you know like how much like makes it worth it like. If we saved them you know ten percent of space like does does, that worth is, that worth the added complexity like obviously. If we can. save archivers you know an order of magnitude's base or a goose in order of magnitude the the amount of space required then, that is like a huge win. But I don't think we'll get there I think there's like a pretty narrow use case for these deletable restorable entries. So definitely my vote is for like the discount approach for temporary storage yeah I think I blame the discount approach too I think also just like on the our order of priorities we should prioritize kitten won't let your small and not prioritize keeping the archive small, that much especially. If it's like I think like a 10 decrease wouldn't be, that big of a deal. So I think I'm also leaning towards the the discount temporary entries approach as well are there any last thoughts before I

[18:00] move on I guess the conclusion was discount temporary entries and have no refunds for archival storage I'm thinking of is, that. If we go, that route right where we we basically say hey the archives are kind of a dunking ground of like like all abundant major entries I think what we have to maybe like take into account is I think it's probably okay like I mean imagine, that those nodes, that are going to be used as a to to back up those high value Legend trees yeah the problem will end up doing some level of filtering like they only for example people on the keep our own Villages for things, that look like balances for example or, that are related to balances

[19:00] as opposed to like random stuff. But I think even in, that situation I think they have to keep the full training around right or hashes yeah so. When how often does do we reset the tree is it like on a pair restart the the tree it's currently your epochs it's every year. So then the Assumption will be, that you know in a year we don't have too much of this craft accumulating accumulating, which might be okay I mean, that's kind of like the yeah like the I think for yeah for for those entries

[20:00] that are not like you know you were talking about it as a discount to get to the for the pricing of of of like you know attempts I think it's the other way around it's more like you you add actually. So there's probably like a constant term. And then a additional you know rate on top of the the price to to get to the restorable entry fee like the very first time you created and I think there's probably a constant Factor I did want to bring Ian from from the crowd to speak. Because he has some interesting perspective and is very passionate about it sorry I was. So passionate I've I've written papers on this topic for other blockchains as a paid service

[21:00] so I've done a wide breadth of study as well as deep diving into different trade-offs, that were done and this influenced their design decisions. But they're slow to move and slow to change change. So there's a couple different concepts here the first one I want to cover is dust and, that's the idea, that the value of a record maybe less than the cost of maintaining it and those records should probably be cleaned up automatically. But it's a problem on Ethereum. Because you can never quite spend out a whole wallet you always have a little bit left over and so, that little bit left over is referred to as just but, that's only one example of dust there's many of them the second kind of approach here is, that there's a huge ecosystem, that's growing around smart contracts and each of those ecosystem players has different data needs and

[22:00] there's no one solution, that fits everybody everybody and even you know other monolithic chains are are dealing with storage problems. And then any modular chain has an extreme storage problem and the storage problem needs to be addressed in a way, that you don't have nodes needing to install like four different protocols four different systems in order to access the data, that's being referenced sometimes it might be 10 or 15 different storage protocols in order just to access what was in a roll-up what was intended by the data, that was submitted to the blockchain blockchain for one second in in the context of the current state expiration proposal by Garand like what are you trying to say hmm hmm. So you need to have different tiers of pricing a rent model is insufficient and

[23:00] and. So is a couple other you know like sort of well we see this problem. Now what are we going to do there's not one solution, that fits it it's really important to give a lot of flexibility to the people, that are deploying on the network and give them as many options with pricing up front and they will simply do whatever is most efficient in order to save money up front. If you try to to add an incentive like later on there's a few problems one is, that your adoption is going to be very low and the second is, that you're going to you're not going to have what they're necessarily looking for. If they can just pay again to extend the lifetime of, that storage then, that's, that's the best of both worlds worlds ideally there'll be an external storage for large amounts of data for example blob data should be not stored necessarily on

[24:00] chain. But on a separate layer and you can incentivize the creation of those systems by limiting the amount of on-chain storage. But allowing pointers to exist. So your your best long-term solution. When people start doing crazy things with blockchain, which they're starting to. But they're struggling to. Because the storage costs are. So high is, that you're going to start seeing a lot of you know flexibility wins the day and so. If you have pricing tiers automatic expiration expiration optional renewal and you're charging by the byte by the day or in some cases by the minute. Then you're able to meet most of those use cases there are go ahead please I believe this is what we're pretty much doing I could be mistaken but. If I'm understanding your proposal correlates, that you have different tiers, that automatically expire. But the option to

[25:00] renew I believe, that's what we're doing with the temporary entries being automatically deleting and being the cheapest whereas the restorable entry types must be periodically renewed. So to speak I it is are you proposing something, that's different than this well I heard different proposals and I think, that I embrace what you're saying in terms of tier proposals I would just suggest number one, that there's a a large number of tears at least four and number two some of the data will be archived with no ability to recall or. If you excluded from archive with no ability recall some can be removed and not archived. But pay an oracle to recall it and some can be you know permanently archived. Now I'm confused by you say remove you can pay an article two

[26:00] call it what do you mean by, that I believe, that's how our accountable system is essentially R5 the archive is off-chain. And then you pay to restore something from the archive. So link to our archive proposal proposal is essentially the Oracle system you're talking about so. If it's an optional flag they can pay for it. If they think they need it. But your archive is still smaller the reason, that you might want to do, that is, that some people specialize in storage and they want to earn a fee for specializing in storage and by specializing I mean over 20 terabytes probably around you know a petabyte or. So okay. So I think Ian. If you can maybe refer back well we can drop a link here to the actual proposal and we'd love to hear feedback about specifically I think, that the type of

[27:00] issues, that you are or the type of solutions you're talking about are actually embedded there. But we'd love to hear. If you think, that's not the case we're talking to details. Now but I believe the archival system is pretty similar to what you propose actually. But you can definitely add some comments in the docs. So I guess are you ready to move on to Temporary entry issues okay okay. So I guess and the second thing and this is somewhat relevant to the previous conversation is temporary entries. So our current interface and I guess we've concluded, that the temporary entries are substantially cheaper than the restorable entry types. If I have some multiply or something like, that. If we have the temporary entries currently the interface is you define a key to find Value and Define a TTL

[28:00] measured in ledgers such, that our time to live such, that the entry is guaranteed to be deleted on the exact Ledger, that you specify. Now systematically under the hood the entry is not actually removed on, that ledger it persists in the bucket list for, that sometime. But it is inaccessible. Now one of the open questions we have is whether or not we should allow users to increase the TTL arbitrarily and in the current proposal we do not allow this there are two reasons there's a security reason and a gamification reason. So first for the security reason we suspect, that there is a strong use case case for temporary entries. When it comes to things like allowances or kyc where. If you specify an allowance, that should only last 10 ledgers mentioned the last exactly 10 ledgers and by allowing contracts to Define behavior, that increases TTL you can have

[29:00] foot guns where a buggy implementation might have some security a temporary authorization, that should only last a short amount of time. But by allowing life extension Primitives you are potentially allowing bugs for security purposes, that's issue number one issue number two is out of gamification. And so the whole issue with temporary entries is, that we want them to be cheaper. But we don't want them to be a way to game the rent system and what I mean by, that is. If continually extending the TTL of a temporary entry is cheaper than just paying rent, that kind of excuse network Dynamics Dynamics. Now I'm not exactly sure actually this is something we should avoid. Because temporary entries are self-deletion deleting. So maybe we should allow users to just continually extend the life and essentially have cheaper rent than. If

[30:00] they would create a restorable entry and just pay rent balances on those ledgers. So perhaps this is something we want to allow. But at least for. Now it seems, that that's a a somewhat unfair usage for the temporary entries and we wouldn't want temporary entries to be used and to be able to continually extend their TTL such, that they can drastically or pay significantly reduce the amount of rent. And so their print system we do not allow modification of the TTL. Now there is an implicit way to extend the life of an entry what you can always do is load the entry delete it. And then recreate the entry with the exact same value, that's still allowed. And so you can essentially buy this delete rewrite pattern specialized special case and extend the entry with the same key value. If you really want to. But we provide no way to essentially keep the same entry books in the TTL. And so I'm wondering. If there are any additional thoughts on this should we allow arbitrary detail extension should we not this is a slight side point maybe and

[31:00] kind of a question it seems like the difference between restorable entries and tempor entries is temporary entries you have to well this is your question I guess is should we allow rent bumps or do you is it prepay only for temporary entries. But it seems like the only real difference is restorable ones go to the archive and temporary ones do not go to the archive is, that roughly true or not quite yeah correct there's a couple of other differences like. So right. Now like temporary entries are prepaid up front. And so you get a better rate. Because you're paying essentially like for months like you're paying for a large amount of ledgers instead of one-offs one-offs I guess I'm saying could we just have one type of thing, that there's basically two different things there's how much Renta has, which is how long it stays on chain chain. And then whether or not you've paid for it to go to the archive after, that point or not right and. If you pay more rent up front for either of them you get a discount discount. And then this whole cheaper way to use it goes away. So I think we shouldn't Define a

[32:00] difference and, that's. Because the the primary difference and I should have mentioned this is, that temporary entries I have strict lifetimes whereas Right. Now restorable entries do not have strict lifetimes. And so just the way, that the buck list Works we have a variable per larger red fee and. Because it's you know variable we don't know what the Run fee of a given Ledger will be until, that ledger occurs, which means in order for the database to be up-to-date on the live rent values of every entry we have to iterate through the entire Ledger and decrement the rent balance of every single entry, which is impossible from an efficiency standpoint and so. Because of this we charge really much retroactively, which means, that for restorable entries they live and are accessible longer than they should be the exact number is, that we have about like on the lowest level bucket we have right. Now about 30 days of quote-unquote free rent where a restorable entry has out of rent. But

[33:00] it's still accessible in live temporary entries have very definite time timelines whereas they only exist for 128 ledgers no more no less and I think for, that's a powerful permit for security purposes, which is one of the reasons we want to distinguish between the two yeah okay. But were you just asking about we should do allow rent bumps for temporary entries entries well. So not necessarily around bumps. But but TTL extension. And so in the current proposal of the rent system applies to restorable entries whereas they have a rent balance, which is some about XLM, which is deducted form. And so their amount of legislative is not exact the the Quan quote web bump for temporary entries isn't increasing the rent balance. Because temporary entries do not have a rent balance rather it's increasing the TTL. And so even. If you allow changing of ttls you are it's not. So much a rent bump. Because you still have a very definitive timeline and very definitive depth

[34:00] Ledger. If you will. So I'll defer to you on, that thank you my bias is not to allow extending the TTL hey it's just another piece of functionality, that people need to wrap their head around. But also it doesn't sit, that well with how like my mental model of what a temporary Ledger entry is so. When I think about a temporary Ledger entry I think about a piece of information, that I'm like broadcasting to the world for the next end ledgers and, that's it so. If if I update, that like what what does, that actually mean like what is the actual use case for updating these temporary Ledger entries

[35:00] yeah I personally don't know what the use cases I think one possible advantage of updating the entries is. If you have a some a type, that is trivially recreatable. So you don't care. If it gets deleted. But you also want it to exist someone perpetually I can imagine a efficient solution where. If the TTL is below like say 100 ledgers or something. Then use extended arbitrarily and. If for whatever reason you miss a TTL bump and it does get deleted these arbitrarily recreated. And so in this case you want to use an archivable type. Because it's triviably recreatable. And so it wouldn't be worth restoring restoring. But also you want to use it perpetually. And so you would you wouldn't want a strip TTL. Now again

[36:00] you know we could also do is just like do a temporary entry set to the maximum TTL and then. If it doesn't exist just recreate it. And then again set to the max dtl, that's also possible for arbitrarily recreable data but, that's just a use case I could think of the top of my head I don't know. If anyone else has has perhaps more interesting or is more knowledgeable in the smart contract space wants to share their thoughts well I guess maybe like the with the CTL thing like why are we trying to babysit. So much like the you know like the the contract like like it feels like you know not allowing access of an entry right past its TTL, that's like like and not allowing bumps you know for, that reason sounds like we are stepping over the boundary in terms of responsibility like the contract you know. If the contract doesn't want something to be valid Beyond a

[37:00] certain time like, that should be implemented in the contract itself I think think and and. If we do something like, that I think. Then the the bumping, that we're talking about I think we just have to make sure, that. When an entry gets bumped the number you know the the the actual expiration time will match the the lifetime in the in the bucket list right like. So so like. If you're. So at creation time, that means we have to have like a a function, that allows you to to compute the like. If you want to go from a number of ledgers or a number or actually number of ledgers you can do, that of chain. But like or actually time is the same thing thing yeah like I guess bumping like where it gets a little bit complicated is yeah

[38:00] just you have like some number. And then you try to say okay extend it by at least 30 days. Because you won't be able to to actually do exactly 30 days. If we don't make, that strict TGI and you don't want people to pay to get free runs right for for whatever is the you know it takes too much, that that for to actually expire, that entry but, that seems walkable I mean those are like help of functions right like, that we can expose to the, that are basically like allow you to kind of Reason about about the bucket list list well I guess the the interface would be a little weird, though. Because essentially what you could do is the CTL you could make temporary entries. But it would have to be a power of four ledgers. So like four zero fourth one Etc. But with a maximum lifetime being 30 days

[39:00] days and, that just seems it just seems like a weird and not super user-friendly interface to to not have a a stripped thousand on a TTL. Because at least like I'm thinking of like use case it just seems from a contract developer perspective you know they don't have knowledge of the bucket list. And so it just seems weird, that you have this temporary entry, that can only expire on Powers of four for some reason with poor granularity and I think it's it's weird from a security standpoint. If you want something to only live 128, that you have this entrance type called temporary entries, that is self-deleting. But you on top of the self delaying temporary entry have to still in addition to, that Implement your own TTL. If for your use case it doesn't work to be on the exact boundary power of four it just seems, that like we're exposing too much of the underbelly of the system between the developers in, that case

[40:00] so just to be clear. If I use a non-power of what is it power for for remember it will still live until like past my TTL until the the next Power four yeah. So the way, that just. Because of the nature of the bucket list apocalypse DB we can only remove entries from the data structure on power of four ledgers. And so in the current implementation we have the TTL, which is stored as a field inside the entry. And so the entry itself does live on The Bucket List beyond the TTL in most cases unless it happens to be a power four. But we just like do a check whenever you're trying to access, that entry and. If the TTL Ledger has passed we just return nulls. If it doesn't exist even, though it does exist on The Ledger. And then we garbage collect on Powers of four four okay, that that makes a lot of sense

[41:00] so. So so I'm a bit confused as to what Nico just said like what the what's the confusing bit here also I think Nico is suggesting not to have the TTL field as part of protocol and to. If users want a strip TTL they must Implement, that themselves and essentially they're struck, that they store must have the TCL value and instead just expose an interface where temporary entries live and are accessible as long as they're accessible on the bucket list and so. When you specify a TTL you must specify a power for TTL Nico my understanding, that correctly yeah basically it's kind of like I mean you still have a TTL it's more like it's actually it's it's more it's represents the we were in a special case the like right. Now right like. If you have a. If you load an entry, that is in the bucket list but, that has an expired TTL TTL you consider, that it's not there and

[42:00] that we will get rid of, that special casing by doing, that and and just requiring requiring, that the the TTL, that you have is is is actually going to expire on the on a bucket boundary yeah like yeah I agree with with Garen I think this is the potential like we like there's only. So much we can expect from developers to understand the bucket list here and I think the the basic expectation from a temporary storage is is you know saying you know telling the platform this is how many ledgers I want this thing to live for and and putting restrictions on, that or repeat or you know telling people you can only use powers before and. If you want to do it like an exact detail. Then you need to write your own smart contract I think, that's not the ideal product experience yeah I think yes the reason I mentioned, that was to allow for bumping, that here. Because if you have actually

[43:00] if you're a number. If you want to allow bumping you have to take into account what is actually happening under the covers covers I don't know. If it's too complex. But I kind of think we're solving two different problems here I think there is the case of a temporary entry or, that has a certain deadline and dies. And then such as like kyc or like a an allowance you want to exist for 10 letters and 10 letters exactly, that's case one and there's a second case of you have the century you don't really care how long to live as long as it lives around this time. And then you might want to bump it on every access I feel like those are two different classes of storage and I think a temporary entry with a exact TL sells one issue. And so I'm wondering. If it might be reasonable to have like a flag say on on the recreatable storage to say archive or not archive

[44:00] because I feel like, that's a different use case than what at least in one on the temporary entry with the exact details getting at. But again, that might be too complicated having. Now like three or four different storage types you know or yeah I would rather not add anything else here I think, that the the the first case, that you described the one, that you know a contract wants to you know put a ledger entry for exactly n ledgers I think, that's the common case and, that's the thing, that we should, cater for. If they want to have more you know sophisticated situations in, which you know they can recreate or or or bump this entry once in a. While then you know they can write a smart contract, that that achieves, that functionality, that can be updated at specific times

[45:00] but I think we need to keep the you know keep the the main contract to something, that's you know like the common use case yeah I think. If if you want essentially like Implement, that behavior it's still possible or just like. If like the the ttls within X number of Legends just deleted and recreate the same value with a maximum TTL, that's very possible and especially. If we have a discount temporary entrance the deletion Recreation path might be at cost or cheaper than a restorable entry. So I think, that seems like a reasonable approach approach I think I'd rather not expose spotless powers for to any post-function or SDK okay it seems fine to not expose it. Then but at the same time like. If we focus more on the actual what is, that TTL is it a

[46:00] you know do we want, that to be a a more of a leave at least for you know a given time and, that way you can allow you know anybody to bump, that ledger entry or do you want to have, that be more like, that strict thing like, that you mentioned and. Because this strict definition of teachers seems super I don't know a bit too special I don't know like it doesn't seem like it's it's implicit it's unlike other types of storage, that we have. But but I disagree here like I think the the con the interface, that people are looking for is I want this to live for this amount of time and The Ledger number here is just a good approximation for for time like this idea of I want to live this I wanted this thing to live for at least this amount of time and the

[47:00] actual length of how much it lives depends on like the underlying implementation it's not, that's not the case anymore. Because what we said you know the discussion we had right before was hey let's let's move the use cases where people don't want archival through those temporary entries the TTL is not about having this strict thing right going on it's about I don't want to parent I just want to be you know cheaper and. If I have to refresh the thing and get it refreshed in some way and their contract in, that case is not the one necessarily responsible for refreshing the the teachers or any anybody, that cares basically in, that context yeah I don't know in my mind it still feels like Tom was talking about issue a

[48:00] and. Then Nico's tackling SUV does this seemed like two infernally different use cases it's not what we're saying is, that. If people don't want this strict TTL they are pushed to use a cable you know like those things, that end up in the archives and. Therefore I end up on some of the more expensive training. But what exists in this space between a strict TTL and archivable Energies what what would like give me an example like what lives in, that no this critical is is is another layer of like like like the strict ETL I mean I'm fine with this trick TTL it's more like the the what does it actually mean what do we mean by strategirl here like like it becomes a security feature I'm saying like. If we get rid of the security feature basically allowing the

[49:00] teacher to be expanded. Then we have something actually, that I to me seems to make sense. Because now we have like. If you want to get into archive use the you know recruitable thing and it's kind of a you know you just use run for, that or you use those temporary things, that yeah. If you want to refresh it's manual you have to do, that and you get a little bit of a discount. Because yeah yeah they don't go to the archive by default and then. If you want this trick like super constricting, that you know never exactly a TTR, that's exactly something and you cannot bump you have to implement, that in your contract contract. Because yeah again like in terms of use cases what type of Entry. When do you need something with a teacher, that is kind of Frozen, that you can never change well. If you're in Oracle and you wanna

[50:00] and you have you know you publish like hourly price feeds and you want them to live exactly for an hour. Then you put a TTL of a number of blocks, that constitute fairly like something, that approximates an hour you mean like you don't want, that thing to stay on Ledger or for longer yoga I mean as a record in, that particular scenario scenario you're going to override, that entry right well I think you're getting into the contract implementation you can see yeah I'm publishing some data and I don't want to pay for it you know after, that time time it doesn't mean, that you know it's not about I don't want to pay it's not just about I want to pay for it for an hour it's about this thing is relevant for an hour like I don't actually want this thing to be alive after an hour, that's part of the the payload like this expiration is the contract puts, that

[51:00] meaning like you're saying there are no use cases where you don't want this this strict thing thing from the chat a lot of people seem to disagree with, that notion. So what we could do actually is is. If I go for an extraction was just like round up to the the nearest power four or something like, that and just like allow like users to say arbitrary ledgers and it may or may not last longer longer. Because because I think as a storage medium I'm starting to agree more with Nico such, that I don't know. If we need to specialize a security feature

[52:00] feature in a storage interface. Because I think perhaps we should make the storage interface more General I don't know well what I'm saying is, that I I'm I think it makes sense to the usability aspect of of yeah. When you say the teacher is like 10 legends right. If you don't do anything after 10 measures, that team is basically appears to be deleted even, though it's still in the bucket list I think, that's an implementation detail right and I think, that's totally fine to have, that at the same time I think it should be possible to bump, that that, that TTL. If you want to go beyond energy and. When you bump it I mean, that means you have to pay for I mean it's not staying in the bucket list right it's not going to stay at the bottom it's basically kind of like a rewrite first of all we're going to implement it

[53:00] and. Then yeah in terms of security feature you wouldn't be able to rely strictly on, that layer for security for the for guaranteeing, that something is going to be to live exactly you know for for some time like. If you want, that you have to put, that in as part of your your attach it to your data basically okay. So Gary it sounds like we are at a bit of an impasse right. Now we probably need to kind of like regroup look at the pros and cons can you like summarize this this discussion and the pros and cons of the different approaches, that we've discussed and potentially drop, that on sir bondev later today and hopefully we can asynchronously regroup and think about this

[54:00] am I still on Gary can you hear me I mean I can hear you I don't know. If Karen can thanks Paul maybe Garen is having some troubles connecting and he's typing something no we cannot hear Garand regardless we are almost at time right. Now so I think this is a a good stopping point to regroup and and think about these things moving forward Garen will hopefully share this on Sarah Von Dev and we can continue the discussion there we can also people can feel free to stick around and live chat and continue talking thank you all for joining and see you all

[55:00] next week

</details>

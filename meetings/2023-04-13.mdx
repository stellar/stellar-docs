---
title: "Getting Started with Soroban and State Ejection"
description: "Design discussion and workshop covering Soroban state expiration, rent mechanics, automatic and manual rent bumps, temporary entries, and hands-on demos for writing and testing stateful smart contracts with Soroban tooling."
authors:
  - anuhya-challagundla
  - dmytro-kozhevin
  - garand-tyson
  - graydon-hoare
  - kalepail
  - leigh-mcculloch
  - morgan-wilde
  - nicolas-barry
  - paul-bellamy
  - siddharth-suresh
  - tomer-weller
  - tsachi-herman
tags: [soroban, tutorial, CAP-46]
---

import YouTube from "@site/src/components/YouTube";

## Rent Bumps and Temporary Entries {#part-1}

<YouTube ID="clVgQw__vss" />

This session explores how Soroban manages contract state over time through rent, expiration, and temporary entries. The discussion focuses on reducing ledger bloat while preserving developer ergonomics, walking through how rent is charged, how entries are kept alive, and how developers and users interact with these mechanisms.

Participants also dig into open design questions around rent bumping: what should happen automatically, what should be explicit, and where responsibility should sit between protocol, contract developers, wallets, and transaction builders. The goal is a system that is safe by default, flexible for advanced use cases, and understandable for developers and users.

### Key Topics

- Overview of state expiration and rent: entries must maintain a non-zero rent balance to remain usable
- Automatic rent bumps applied on access to contract data, contract instances, and WASM code
- Motivation: frequently used entries stay alive without manual intervention; rarely used entries naturally expire
- Manual rent bumps for infrequently accessed but latency-sensitive data (e.g. long-term token balances)
- Design tradeoffs:
  - Manual rent bump operations that specify ledger keys directly
  - Exposing a rent-bump host function to contracts to abstract key management
- UX and safety concerns with contract-controlled rent bumps (griefing, accidental overspending of refundable fees)
- Debate over responsibility:
  - Contracts know which keys belong to a user
  - Users or wallets should decide _how much_ rent to pay
- Emerging middle-ground ideas:
  - User-supplied “auxiliary rent bump” values combined with contract-selected keys
  - Leveraging transaction footprints to bound and make rent behavior observable
- Default rent for newly created entries:
  - Minimum required to survive initial bucket levels
  - Optional immediate bumping via transaction metadata rather than contract logic
- Deletion semantics:
  - Outstanding rent balances are burned on deletion to avoid refund gaming
  - Rationale compared to other chains’ storage refund models
- Emphasis that rent affects performance and availability, not correctness or security of unique/temporary state

### Resources

- [CAP-0046: Soroban system overview](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0046.md)

<details>
  <summary>Video Transcript</summary>

[00:00] Okay let's get started. So happy Thursday everyone this is Soroban Design Discussion an Open Protocol Meeting in, which we discuss design decisions for the Thor law and smart contracts platform to be launched very soon today we're going to be talking about State exploration. So without further Ado I'm gonna hand it over to Garand yeah. So I know we haven't talked about the expiration in a second. But I think before we were kind of talking high level what the interface wanted to be. And then now we're actually starting to implement pieces of it. And so kind of the timeline for this is first we're going to start charging for rent on futurenet. But not actually have any penalties for a rent balance of zero or negative just so, that we can make sure, that you know the rent is being charged correct and, that sort of stuff Next Step will. Then be to add ways to a bump rent. But again still with no consequences on futurenet. And then once we have the rent bump

[01:00] and the rent charging correctly implemented will actually enable consequences and essentially what, that means is, that an entry will need to have a non-zero or non-negative rent balance to be usable. But we still won't actually be sending entries to the archive and doing them from The Ledger for some time still in addition to, that once the rent system is in place we'll. Then roll out temporary entries, which are the entry types, that have a TTL, that expire after a certain amount of ledgers and the CTL is variable. And so I know we've talked about kind of like at a high level. But we're actually starting to implement this rent stuff. And so there's a couple of open questions both in the rent proposal and in the temporary storage proposal, that we want to talk about in detail so. When we initially talked we didn't have automatic rent payments on access and this was an implementation issue with the way the bucket list is structured. However now we've changed the way in, which we actually record rent balances on Ledger. And so we can bump

[02:00] rent on every access. And so with, that in mind we've changed the way, that we structure run payments how it currently looks is every data accessed in a smart contract call receives some small Baseline rent bump this isn't expected to be a very large rent bump. But it's something small and automatic. Now this includes not only contract data, that's accessed. But also the contract instance itself and also the contract wasm code. And so this also allows you to bump the smart contract itself and the smart contract code without needing any extra intervention or anything and. Because this is a small incremental bump, that's bumped automatically it means, that smart contracts and entries, that are used frequently don't really need to worry about rent you know something like USDC, that's used every day will have enough rent balance via these automatic bumps to never have to worry about doing a manual run bump. And so this automatic interface is a lot easier and covers a lot of the weird

[03:00] cases in ux kind of pain points, that we were seeing before. When we didn't have these automatic ram pumps. Now the open question here is with regards is what do we want to do to in addition to having these automatic ramp bumps what interface do we want to expose for the quote-unquote manual rent bumps. And so this we have two kind of fields of thought here. So what a manual run bump is say you have an entry, that's not accessed very often. So you have like a token balance, that you only use every six months or one year but. When you use it you want it to be accessible very fast. And so you want to be I'm not in the archive and remain on The Ledger. So automatic rent bumps are not sufficient for this use case. Because you're not accessing it very often. And so the automatic rent bumps aren't large enough to keep this wallet or this token balance on The Ledger. And so we want an interface where a user can do a explicit manual rent bump instead of doing the small

[04:00] incremental run bump say I want six months or one year or 10 years or something like, that of rent for this entry. And so kind of the two ways to do, that are either a via a manual operation where the invoker of the operation specifies the set of keys, that they want to bump. And so this is the most manual approach. But it's also has some benefits one of the significant drawbacks, though is, that the user calling this function needs to know what key belongs to them, which isn't always easy. So in for instance in a token contract you may be able to have just one entry and one key for each user's balance, that's relatively easy to discover you know like whatever my balance key is on USDC. But there may be other entries, that are also associated with your account in addition to, that balance entry. So for instance a token contract may also have a nonce, that's required to do transactions with your

[05:00] token balance and. If a user only knows about the token balance ID. But doesn't know about the non-sid they may pay a bunch of rent on their token balance and have, that active on The Ledger. But then in six months. When they want to do their transaction they didn't pay rent on the non-century. And so they still have to wait to get the nonce value out of the archive. And so one approach to this is to allow the contract to Define rent bump behavior and we do this by exposing a rep bump host function to the smart contracts and what this allows contracts to do is to codify on the contract itself rent bump behavior in addition to the automatic rent bumps. And so in our token contract example say, that there is both a rent balance and also a nonce, that are have separate Keys. Now I'm not saying this is a the most efficient approach. But this is an approach. And so what the contract could do is it could Define a bump my account function and this bumped my account function I will use the host function to bump both

[06:00] the token balance and also the nonce value associated with the user. And so in this way the user can just call the bump my account or about my account function. And then bump their account by six months a year the specified amount or. However much is codified in the smart contract and this allows the smart contract developers to abstract away a lot of the Run interface to the user. And so the user still can bump run manually. But doesn't need to know exactly what entries belong to them So it's a significantly easier user experience and also allows the contract to Define some sort of automatic behavior in addition to, that supplied by the protocol. So for instance the protocol might say a bump every access by 10 ledgers worth of rent. But then the smart contract developer might say oh for my use case I want to automatically Bump by a 100 or a thousand Ledger entries. And so they can use this rent bump host function to Define additional rent bump behavior in addition to, that automatic rent bump

[07:00] that the protocol has. Now even the benefits, that this can provide a better user experience. But this opens the door to either malicious griefing or just accidental overspending of fees this is kind of dangerous. Because it allows the contract to Define arbitrary rent to take from the user's transaction fee. And so this can't be gamed in a malicious way. Because there's no Financial benefit to paying a bunch of rent for other entries like there is no way for the attacker to steal rent fees in any way. But this could be a griefing aspect where a contract call could say pay one year rent for all these unrelated entries, that aren't important to you. But still take, that from your refundable fee. Now again code audits could catch these attacks. But it could be very difficult. Because for instance they could name an entry such as like they could give an entry in a inconspicuous name like

[08:00] author entry and have every call pay one year of rent to an off entry where it could be actually a different entry type, that's used maliciously. And so even, though exposing this host function could provide a better user experience it also opens the door to these kind of large fees, that contracts can Define. And so I guess, that's our first open question is regardless of. If the host function is accessible via Smart contracts it will be accessible as a manual operation call regardless. And so the question is do we want to just have, that manual operation call where the invoker has to specify every single key to bump or do we want to also open up this host function to the smart contracts and allow smart contracts to Define their own rent bump Behavior I have an opinion on this, that I want to talk about everyone else thinking. Because I've been thinking a person can

[09:00] involve this and I'm really biased towards just doing a single post operation as it is invoked in a standalone fashion and not go with contractifying pump Behavior at least 41. Because as Grant has mentions right really a lot of issues with houses can be misused. But also really even. If you think about the ux aspect of it like we are talking about some abstract user here I'm not sure it's an abstract user who does the bump it's rather some program in between, that does, that which is probably evolved right and for example. If you are talking about the token balances I don't see any significant technical difference between implementing bumping your balance entries rent why it's a great

[10:00] operational a separate contract call it's some sense it needs to be coded in the board interface right. And then provide it to the user like hey you know what your interests are about to expire and another thing is, that I really don't think there are too many entries, that user should ever care about pumping them I'd say this must be just balances and NFTs and you know even. If you have this Ledger key based approach it doesn't seem overly complicated to have support for them and have some basic white braces just builds the correct bump transaction for a given contract interface for example. So I don't see this as a pqx issue. But I do

[11:00] see a lot of issues with no exposing this to the contracts and it just doesn't seem like a super straightforward feature to communicate with how contract developers should use it like I don't think they have a good strategy for this. Now so yeah, that's my opinion here it feels a bit or slightly inconsistent the fact, that the current storage model definitely encourage access through host functions rather than directly through like Ledger entry keys. And so to have this additional system, that does encourage access directly to the Ledger entry keys, that sounds a bit inconsistent to me well we kind of abstract to let your excess away right to you like this adapt developers to need to care about with your Footprints and basically rent can be improved

[12:00] with some ideas floating around those were like maybe allow to specify pumps on the footprint for example or as Pro to the awake as a parallel entry to the footprint to, that you know you can do it as a transactional basically I think it's the main. And then the question is yeah whether we put this responsibility on the contract developers or on the engineers, that builds the transactions and I'm saying, that probably it should be on the side of whoever is paying for the transaction right. Because that's them who are pins are in and really for a lot of contracts there is no single strategies the contract Trader can raise realistically Define in terms of how the bump should be defined well kind of same stamping to do, that right. But in the end it's the entity, that pays for the transaction who needs to decide what to

[13:00] do with the rent pumps Delaney bumps at home right. But it's a contract developer, that has the full understanding of what in the contract State actually relates to a specific account right. So where will this information be captured well yes. But you know I'm not sure like it needs to do anything this is a bumps like I can see the functions just expose the entries, that need to be pumped. But I'm really concerned about just doing the pumps myself from the contract like having some metadata, that says hey you need to bump, that for a given address is fine. But fully programmatic access seems to be able to do much more and a lot of this doesn't seem like the right thing

[14:00] to do also it's been like you know pumpkin for thousands of ledgers. Then this might not be a user intention and yeah this just creates some pretty confusion ux for the contract users yeah current question. So a I do like the concept, that the end user oh no I should say the con the smart contract author can write his own function to modify the default Behavior I think, that's great I'm a little bit concerned, that the smart contract developer would need to write, that method it's something, that I kind of like not feel very comfortable around. Because it guarantees a user errors and ideally. If we could do anything, that

[15:00] would provide out of box experience where it would just walk. Then it would be much better even. If they just walk wouldn't be the optimal solution well I think in either case whether we expose the host function or not it will not be necessary to define the sore function. Because we do have the protocol floor automatic bump rent, which happens regardless. And so this is just for. If you want in addition to the automatic a small incremental rent payments do you want additional control over how you bump and I also won't clarify, that this doesn't overwrite the default Behavior will happen whether you use the host function or not. So say like the for instance just for an example the default behavior is to bump every entry by 10 Ledger's worth of rent. If you also in addition to, that say use the rent bomb function to add another 100 ledgers worth of rent to a token balance the

[16:00] resulting rent bump would be 110. The 10 ledgers, that were automatically bumped and the 100 ledgers added on top of, that by the host function. And so you're answer your question the automatic rent bump interface attempts to kind of give the best out of the box solution as possible with the thinking being, that the most accessed entries will have the most rent and be the most readily available. And so this is an addition to, that default Behavior. If that answers your question okay yes let's answer my question thank you. Now I think one interesting point, that moods is bringing up in the chat Dima for you in particular is, that should we allow contracts to Define initial rent balances. Because if we don't of newly created entries. Because this kind of has the same attack surface or I guess attack service isn't the right word. But perhaps the same accidental or purposeful misuse issue of exposing the rent bump function. But it's a really poor interface. If

[17:00] every newly created entry just has the minimum amount of rent and you need to immediately do a host function operation. If you're calling to create to bump the rent. So I guess what do you think with respect to newly created entries and should we special case, that even. If we don't expose the rent on post function again like I'll try to answer quickly. Because we wanted to say something. But I'm still not sure. If it's a good idea either I feel like I should think more in terms of how can say contract user provides a needed brand pump maybe as an additional fear as I said like maybe some annotation on footprint or something. Because really. If you think about it as a contract writer like you're writing a token contract what should be the initial rent balance on a new balance entry I cannot really answer this question for

[18:00] every user I'm not sure anyone can. So my intuition is, that for entries where we actually want to ever bump the rent balance it's highly likely, that it's easier to decide how much does it want to pump it. So yeah I'm really not sure like how contract writers would Define this initial balance in the same way, that's my opinion here yeah. So first of all I just want to say it is interesting, that we have, that we are discussing like these multiple approaches to essentially automatic for the user bumping the rim and I think whenever we do have like multiple things at play like this we do have this potential for it to become very confusing for developers about you know. When do they need to make get involved and do something themselves versus. When

[19:00] can they rely on the automatic. So maybe just something to keep in mind like. If we are going to have these multiple approaches, that's just something we need to think about like complexity. But to the idea of having you know the contract do the bumping it sounds to me like it's sort of owning two responsibilities and I'm not we're talking about those two responsibilities together and maybe we can split them apart. And so the first one is knowledge about the keys and, that does really sound clearly to me like something, that the contract is responsible for contracts decide you know what storage how to arrange their storage it's not really in the user domain to you know to know, that information. And so it does really, that makes sense to me, that okay contract should be responsible and sort of telling a user somehow, that you know these are the keys, that relate to you know I guess I sort of we sort of expose it already

[20:00] through Footprints I guess you know you can look at the footprint from your transaction and say like oh I've affected these entries. And so you know. If I want these entries to live on past some future point I probably want to bump them and you know what the footprint is ahead of the transaction. Because you have to provide it. So you know, that's maybe an interesting thing we can utilize. And then the second part of the contract function is decisioning about how much to bump or at least, that's one of my understanding Karen, that the contract would actually decide how much the month and, that seems less clear to me about where the responsibility lies. Because I agree with Dima like. If I'm a contract developer running contract or token contract or any sort of contract I don't really know how long this user needs this data you know you might be using the token contract for just this one transaction or for a short period of time or maybe you're you know you're locking up an asset for a long period of time it's really unclear to the contract developer. So I feel like

[21:00] if we can find a way to keep the decision about how much to bump in the hands of the user. While not needing the user to have knowledge about the keys or maybe using the footprint in some ways so, that users or applications, that users are using you know can use the footprint to you know to discover those keys yeah I think one interesting thing might be like say like we have like this automatic bump and just allow, that to be a user-defined field in the footprint. So for instance we could say like it must be at least 10 ledgers just for the health of the network no one should be able to you know avoid automatic payments. But then you can Define an arbitrary number. Now the issue is I think, that might be a little too not granular enough. So for instance say. If I want to. If I'm praying a token

[22:00] or creating a balance for the first time for a wallet and I want to last six months I say okay I want my default rent bump to be six months and so, that would handle you know all the keys I touch in the creating of, that new entry but. If we just have, that one number to encapsulate everything I would also be bumping the wasm by six months in the contract instance by six months. Because I touched those two as well, which is probably not what the user intended. And so I think I kind of agree with how you put it, that there's knowledge of the keys, that's the contract responsibility. And then there's the knowledge of how much you want to bump, which is a use case specific thing based on the invoker and the issue is like. If we just have one parameter, that for the default rent bump, that doesn't encapsulate knowledge about the keys. But then the issue is. If you want to say have Define a rent bump for every key in the read write footprint, that again is putting in this, that's putting

[23:00] essentially like the knowledge of the keys on the invoker again, which is kind of something we want to get away from well yeah I mean the invoker is potentially multiple parties. Because there's the you know user to the consumer the end user. And then there's an application, that they're using to interact with the contract and, that application they're using could potentially make some sort of broad assumptions you know maybe for token contracts a an application Level Up or might be able to handle, that granularity like as you're pointing out they might be able to identify okay the balances look like this you know have this key maybe I it doesn't really extend well to other contracts, though

[24:00] yeah. So I guess. So I don't know do we have any like key takeaways. Then I mean. Because I agree, that and I just feel like the barrier to exposing the rent interface to users can be somewhat High and I don't know. If it's a good interface. Now again like this might be you know acceptable. If you know like every like people are interacting with the network primarily through wallets and sophisticated kind of l2s like, that. But I don't know it just seems like a high onus to put on a user to essentially have to invoke periodic hose function operations in order to maintain state, that they are accessing through smart contract calls it just seems like the most reasonable interface for the caller of the contract is for the contractor to take care of the

[25:00] contract state is it possible, that maybe we could find some okay. So I agree with what you're saying. And so I'm wondering. When we discover what the footprint for contracts are I wonder. If there's a way for us to include without some sort of this is what the contract recommends you use and maybe this is this might get too complicated. But you know. If a token contract could say to a user this is somehow defined like this is the recommended rent pump for my contract. But usually still in control or maybe, that's pointless. Because then you know everybody's just going to do what the contract says and we're essentially building something, that we don't really need the flexibility around well maybe what we could do actually say actually okay I kind of. So I think the best of the Both Worlds is we want

[26:00] the contractor to be able to define the keys we want the user to define the amount. So maybe what we can do is instead of having the footprint parameter be the global footprint pump what we can do is we can define a new parameter called auxiliary rent bump it's just a single value inside the footprint. And then I guess we could expose this to the smart contract in some way. And then the smart contract could call the rent bump host function. But the value of the ledgers to bump must be the auxiliary value provided by the user. And so I think this still has some potential gamification or griefing. If the contract would use, that to bump keys, that are not relevant to the user I mean I feel like, that's just a, that's a class of bug, that just needs to be audited and I think, that's kind of you know there are many smart contract bugs, that fall into, that area. But then I think this might provide you like a good middle ground where the contract can still say

[27:00] what keys need to be bumped and the user can supply the value. And so say this value could default to zero just for safety reasons. But then say. If a user is accessing their contract or their token wallet they could say, that I want to rent Bump by six months everything, that the contract deems should be bumped, which they signify by calling like this auxiliary rent bump done inside the smart contract some thoughts on this approach yeah I think something like, that could work pretty well and either presenting, that how you just described as you know you just provide one Valley in the transaction or maybe you could actually just provide a value next to every footprint, which they'd functionally worked the same way. But you know it would give you a little bit of flexibility for some power use cases where maybe you maybe a power user is wanting to

[28:00] specify explicit footprint entries is having more. But I did I think, that ID does start to shift the responsibilities into the right places yeah I'm not necessarily against the footprints and it's always the same wondering about is how much more useful reads than let's say yeah separate cost functions it does the same Plus the contract and just a little bit worried about mix in a lot of things together right. So you have a transaction with a plus something useful make a payment for example right. But then you also have this another completely unrelated operation this transaction, which is Bump

[29:00] rent instead of relevant entries by kind of like by time periods you have defined. So doesn't really need to be the same operation maybe it is okay to just have this as two separate operations it can be composed needed well I mean what would, that look like then. Because I mean I think the issue is the set of the knowledge of the set of keys, that needs to be bound right where I think I agree, that like the per key approach could be good for power users I still think we need like a you know one size fits all I want to bump by this amount. Because I could see from a user perspective saying you know bump this set of keys by six months you have to define the set of keys and all, that sort of stuff but. If you're sending transactions and be like I want all my things to live for six months. So I can say send this transaction rent amount six months

[30:00] and. Then the smart contract developers determine what is important to, that user to fill into, that auxiliary space I feel like, that works for most use cases again we are kind of mixing up what user is like do people really like. If they think about how our contracts would be used right chances are probably there is some Gap, that like with some web apps, that actually builds the transactions for you like whereas the rain should fit it like I'm writing. So you had DEX right today really expose rent bumps in my UI to the users like how's it would work. So I think, that there's I think, that's a really good question Dima and I think there's there are two answers to this I think there's one class of interactions, that come directly from adapt front end and from, that perspective you're right like the dApp

[31:00] knows exactly what Ledger Keys an account refers to. Because it's the same developer who wrote the smart contract there's another class of interactions, that's like more generalized interactions these happen either through like wallet interface like General wallet interfaces or they happen maybe through you know various compositions like I'm not using an AMM directly. But I'm using it through some sort of like an aggregator or through like a balancer like contract, that actually splits my liquidity between different contracts. So I think the like what you're describing it like directly interacting with Ledger keys, that only happens in like the one case where the origin of the transaction is you know is kind of

[32:00] developed by the same developer of the smart contract but, that's not the general use case oh what I mean is actually not who knows the keys what I mean is what is the UI or ux for actually setting up zero. So let's say we go for this idea whenever you know you can somehow pass some additional rent balance as a part of your transaction, that does something else. Then the question is like no matter like who knows the keys how the user would actually Supply this number like I really feel like this should be progress about responsibility most of the time, that's really sometimes it you need to bump probably has something to do with something your own and this is something your voltage is responsible for. So I'm yeah I'm not sure. If it works well it's

[33:00] a model or some other entities and wallet builds a transaction. Because as I said like you're doing something completely unrelated leads like especially. When you are talking about some more complex religion scenarios right how would you even expose some brand pumps to the user leak just I'm sorry arbitrary they are about to trade these tokens okay how about bumping some random major entries I don't know doesn't seem like they're right you asked to me, which is why I was kind of arguing about this idea about just having a standalone process for this, which I agree has its own issues. But at least you know the your story is pretty clear here, that hey you have a vote for example and my interests you know balance lifetime very connectors maybe I'm missing something fundamental

[34:00] about what you like how things work. But he just really seems like two different things, that we want to bundle together in the same transaction and one of the things is not completely obvious to think to, that main use case as I think regardless of whether we bundle it or not the problem, that you're presenting you know who's responsible for it you know does the wallet just do it for you, that problem exists so. If we bundle it the problem exists. If we don't bundle it problem still exists and to Thomas point about you know the different use cases and your point about wood wallages too and I think, that's, that's fair like consumer wallets are probably going to make some default decision around you want to have six months or a year for your balance. And then you can recover from the archive and it's those other power users, that are maybe gonna or those other composition use cases where the rent is going to become more

[35:00] interesting. Because maybe in a composition use case you don't need, that balance to have a starting rent of it six months, that's it might be a waste of ease maybe you only need it for a day the thing is like from the for the wild example I think the issue is, that. If we don't Define or. If we don't allow contracts to Define rental Behavior the issue is token or wallet speak erc20, which is an interface whereas rent bumps aren't an interface issue they're an implementation issue. So two different tokens could just be erc20 compliant. But Implement erc20 in different ways. So token a might have two entries you need to bump whereas token B just has one entry you need to bump. So I feel like just kind of saying oh hey the you know middle the middleware software is sophisticated enough to know how to bump I don't know. If that's an assumption, that can be made I mean I think we'd essentially like for wallets we'd need like an erc20 rent version

[36:00] that defines rent behavior in a way. Because I feel like I just think, that just like the key structure is just. So integral. And so implementation specific I'm skeptical of leaving, that up to anyone other than the contract developer as long as there was an interesting question from what's in the chapter regardings something like a liability balance and I think and as we're end goal we haven't been talking much about this weather some cases the rent payments are needed at all. Because well interest can be unarchived and in case of this liability balance for example yes it's maybe not in the user interest for this entry to leave one kinds of Ledger but. If you are using the unique storage right it shouldn't be possible to at

[37:00] least recreate the sanction, which the contract developer could leverage I'm not really familiar with this liability bones use cases like how to force the user to actually pay your availability. But you know. If you want them to continue their contract you can just benefit from the unique entry and it doesn't really matter. If it got archived right. Because it won't be recreatable and users just won't be able to reuse the contract I don't know what is the other unfortunately mechanisms. But basically the point I wanted to make it's probably not super bad. If interest sometimes get evicted from the ledgers this is kind of by Design especially. If it's rarely accessible and it's a downside hopefully isn't is, that huge. So probably, that. While we are talking here about how bumps work we should recognize, that you know

[38:00] we should make sure, that the ux for actually restoring the entry in Ledger is saying. Now so, that even. If you cannot mess up the pump project you still not In Too Deep of a trouble, which I don't know. If anything something else for the liability use case in the liability case you know the library still exists right just it may not be unledgeable. Because it expired. So and anyone can recreate it. So I don't know. If it's a is, that an actual concern right as long as you understand, that the liability is there like you know you could anyone can recreate it and put it back in the Ledger or I think recreate's not the correct word here. But restore it. Because like in Europe in the example you gave essentially what would happen is. If it expired and a user tried to do it's you

[39:00] you. If you use the unique storage interface, which you should for this particular use case. Then the contract knows, that the thing is in the archive. Because that's one of the benefits of unique storage is, that it essentially provides information. If the entries in the archive are not. And so through the unique storage interface you know, that the liability exists somewhere. And so the transaction just fails. But the liabilities not live. Because you can't check it. And so I don't think there's a security risk in the rent. Because I think rent should never be used for like lifetime management or something like, that's a temporary entry concern. So I think like concerns as to like expiration are handled via the recreatable and unique interface rent is just more of a convenience factor. Because how you pay rent shouldn't have any functional differences it might just make your operation slower. If you need to go restore something. But I think high level here I think

[40:00] kind of what I'm understanding is we probably want to investigate rent information the footprint I think whether, that looks like a per key rent or an overall rent bump or something like, that is still TBD. But I think. If I understand correctly, that's kind of demo, that is, that kind of like I don't know fulfills your you're not allowing smart contracts to game the system. But kind of still allowing smart contracts to Define some behaviors at I guess investing is something the footprint is, that kind of the idea we want to go forward with on this issue yeah and is, that the way like I'm not necessarily against this. But like I see some issues with this approach. But probably it makes more sense than just you know asking contract developer to write the manual pumps it's both complicated and those are wrong yeah and I think we really need to

[41:00] think about the initial balances like even, though as I mentioned lately it might be kind of problematic to Define it in a general case we should think about what is the same default value very easily like even. If it's not customizable. Because it's kind of an interesting problem as well right like you don't want to create an entry, that lives like for a really short period of time, that you don't want to overcharge users well we actually have a implementation specific value for this, which is I think at the bottom of the rent proposal, which is based on the structure of the bucket list and how archiving Works minimum rent balance has to be enough rent for the entry to live into level six, which I believe is 4 000 ledgers. And so we can make the default higher than, that but, that is the absolute minimum just from an implementation standpoint the minimum has to be at least four thousand ledgers. If that value is too low then. If like

[42:00] I think, that's what four thousand times five seconds I think, that's like a day or something maybe 12 hours exactly. But I mean. If that's too low we can increase it. But we can't go lower than, that and but, that's kind of interesting right. Because if you think about something you can balance you would think like about months of life and five hours is like why less than, that. So yeah, that's what I'm saying like I guess we will need to see what's the actual prices will be. Because because it seems really counterintuitive, that the entries, that are kind of supposed to be permanent entries in The Ledger are at the same time very short Cliff. Because we hopefully will be able to create temporary entries, that are alive for let's say weeks right. But at the same time I think there's also a valid use case for a qualm quote short-lived short-lived for instance like. If I just want to initialize a cold store wallet I like

[43:00] initialize it transfer a million USDC. And then don't want to use it for 10 years I mean it makes sense to just give the minimum rent balance pay, that. And then let go into the archive. Because I'm not going to use it for a. While so I think, that there's still I think keeping the minimum low probably provides the most flexibility. But I guess kind of what I was imagining from a functional standpoint is you would probably want to just create all entries with the minimum rent balance initially. But then be able to essentially like bundle and immediately run bump was kind of what I had in mind from a from an implementation standpoint, that would probably be easiest now. If we don't provide a host function or. If we don't provide a footprint approach, that becomes challenging. Because you essentially have to bundle operations at, that point, which I don't think would be really possible to implement you'd have to implement, that not in the sore bomb. But somewhere else

[44:00] but I think. If we have some sort of footprint approach I think, that would probably be the best way is just to default initialize every restorable entry with the four thousand letters worth of rent and then. If the footprint defines any additional bumps provide those Bumps by the footprint interface yeah I think, that sounds really good I and I just sort of lean further on it I do think I assume we're still talking about the contract still is the one, that can do, that auxiliary bump. So ideally you know in the best case scenario the contract developer has given this thought and they're acting in good faith sorry they're doing the right thing and they're just using, that auxiliary bump for the records, that need to be used. So they might not exactly re-bump everything. But the worst case scenario is, that they do you know they don't really think about it and they do bump everything in the footprint. So as a user you do sort of

[45:00] have a some boundaries in place it's not like a malicious user can do lots of damage they can at worse only bump everything, that's in the footprint, which would be of limited size anyway yeah and in the case, that the contract is malicious. Then like a powerful a power user or. If a power user just thought they knew better than the contract they could always just set their you know auxiliary bump to zero. And then even. If the smart contract tried to bump everything in the footprint you wouldn't be screwed and you could just essentially get around the auxiliary Behavior. If you had motivation to do. So I think oh sorry timer no I just wanted to say, that I wouldn't put too much effort into protecting against like malicious smart contracts you know. If a smart contract is malicious there's like plenty of other ways, that it can screw you over. And so trying to protect the against malicious smart contractors trying to protect against like buggy smart contracts is you know it's a

[46:00] it's a fight you can't win yeah I actually yeah I think, that's yeah I wanted to say I don't fully agree with this. Because really. If you think about us like any token operations need to be explicitly signed and wait my concern about all this customizable pump stuff is, that basically you kind of are doing very implicit operation on a token, which is much added to interpret. Because other reason, that really things, that kind of can impact the user are probably out authorized explicitly. While here you have something implicit, which is why I'm more concerned about, that than about the contracts they just trying to please show like 100 XLM from you for no good reason. Because that's at least very easy to trace and explain whereas like

[47:00] you know with you're paying rent for something you shouldn't be paying rent for much harder to evaluate you'll be able to print everything. But I wouldn't just dismiss the same it cannot do anything I think we kind of can try to be a bit more conservative here I mean like it's not like this is you're signing a transaction this is coming out of your wallet I mean all of these fees are coming from refundable fee right like even. If you do like the you know auxiliary rent bump is still coming out refundable fee. And so you have an upper bound right. And so I guess feel like. If a contract is malicious or buggy I mean you pre-flight and you're like oh wow this refundable fee is like absurdly high you're not going to submit, that transaction. And so I think. Because we kind of have like this safe bound both. If we provide a parameter in the footprint to Define the amount of bump to rent, that's one bound plus just the amount of fees you

[48:00] have is another Bound in refundable fee. So I feel like those two things bound the damage pretty well such, that I think, that the rewards the ux rewards outweigh the potential drawbacks just. Because it's. So bounded and. Because it's fee based and not token based yeah I mean. If he exposes refundable fee in explicit Fashions and great kind of voluminous same book yeah just to be clear all rent payments come from a fundable fee both the automatic payments and the auxiliary rent bump host function would also draw the funds from refundable fee cool I think just responding to China's comment about you know let's not focus too heavily on malicious I get it I think this design does lender itself well to just

[49:00] separating the responsibility. So they land on you know the response to parties, that are best equipped to handle those responsibilities the fact and I think just naturally out of, that you know we get a slightly better story for what can a contract do malicious for you. But I don't think this is really fully solves, that problem like you said. So and nor do we nor can we I mean I think it puts sufficient boundaries in place, that any sort of malicious behavior wouldn't be outrageous. So I think we probably have a pretty good feel of the rent pump issue. If if there are any final comments I think we have like 10 minutes left. If we want to move on to a second topic any last parting words. So

[50:00] we don't actually have a second topic for today or I mean it might be a second rent topic I mean sorry oh okay there's the second one topic. And then the third and the fourth sorry yeah I think like it's very clear, that a it sounds like in terms of like implementing and move forward you know obviously it's the bumping by Ledger key is a building block, that we need anyway. So we can you know keep in implementing in, that direction and it does sound like we need to potentially like enumerate all the options for how the contract exposes you know more fine great information about you know what Ledger keys are actually associated with an account whether it's through the host function you describe whether it's through the Ledger footprint maybe it's even just I don't know like an ecosystem standard for you know there's a function you can call, that gives you

[51:00] all the Ledger keys, that are associated with an account. So I think we just need to like enumerate over all of these and probably like revisit them no I think, that makes sense I think we probably need to iterate on this design a little bit. But I think we have some good building blocks from the conversation. Now yeah. So I guess we all have a ton of time. But I'll introduce this I'm kind of the second rent related issue and we also have a temporary entry related issue, that we won't get to today. But for rent there's also an issue of outstanding rent balance. When things are deleted. So I think I don't know how often this will actually come up in practice as two entries being deleted with large amounts of outstanding rent balance. But initially it seems reasonable to refund the rent balance to the invoker of the delete operation

[52:00] this kind of provides network incentive to delete entries, which we do want to have. Because we want you know. If an entry is not going to be used we want to provide incentives somehow for it to be deleted before it hits the archive. Because once it hits the archive it stored in the archive indefinitely Or Intel restored at least. And so to keep the archive size small even, though it's not as big of an issue as having a large Mouse and The Ledger we still want to incentivize deletion the issue is. If you provide rent balance refunds on deletion you open the door to some sophisticated tax and to some kind of patterns. So the issue is, that even, though many different users might be contributing to the rent fund or many different accounts might be funding the rent balance only a single account redeems the rewards. When it's deleted and especially since we are defining this automatic rent bump at the protocol layer this could lead open the door to some interesting attacks. So

[53:00] for instance say you have like a contract, that's used very often like an AMM or a big DEX what they could do is they could just touch one key on every invocation and it could have like an innocuous name it could be called like off entry or like auth check or something like, that something, that would be difficult to detect in the code auditing. And then they could just like essentially have 10 XLM or whatever like or 10 letters worth of rent or the minimum rent balance just continually be added to this object. And then periodically the admin could. Then call an admin function, that just deletes and recreates this object essentially getting all the rent balance this is kind of a malicious attack. But even a non-malicious attack you could imagine where many different users are contributing to like some swap or something like, that the swap has a large amount of rent. And then whoever like liquidates the swap or liquidates or drains liquidity pull and deletes the entry can also get this additional rent balance, that was paid for by many different users and so. Because of these

[54:00] two issues it seems, that we don't want to refund rent balance on deletion just have any outstanding rent balance be burned whenever you delete something, that doesn't seem like a great interface. But there doesn't seem to be a good way of refunding rent without running into these weird edge cases, that can be gamed. So I guess thoughts in General on rent refunds and. If we should think about this in a different way just wanted to mention, that we have considered an alternative for we would record, which account has created the entry. And then refunds, that account. But besides the fact, that it doesn't avoid all the possible issues the problem with this approach is, that it's really like adding a significant amount of Ledger space and it's not obvious whether the additional fee incurred by the fact, that you are writing bigger entries will be offset

[55:00] enough with your refunds I mean we have discussed this in a bit different context. But I think it still applies here like we are increasing entries sometimes quite significantly and we want to refund someone. So it's not clear. If this is not positive or not, which is why, that's probably not a good option I would also say, that the, that particular alternative was in the context of temporary entries, which have a single pair I don't think, that approach would work in the restorable entries with rent balances. Because many different users in addition to the user, that created could be paying into rent fees. So for instance you can imagine like the contract admin created the entry with the minimum balance. And then every user the contract bumps it up to a very high state or to a very large amount of rent. Because it was used frequently in touch frequently it doesn't make sense, that the outstanding balance should go to the

[56:00] original Creator who only paid them rent. So yeah context of 10 Ventures, that works. But doesn't really work in the restorable entry context yes it's kind of fair. But also I want to say, that you do not allow the leading contracts currently and they I don't think people. So or this is not this is for contract data not for contract instances right yeah. But but yeah I imagine like the most common shared data is through the contract instance. But but yeah anyway I just wanted to say, that the alternative was out there and yeah as you said it doesn't solve those issues and it also has a significant cost attached to it, which is why yeah I guess are there any objections to burning rent or outstanding rent balances. Because it seems on paper to not be a great interface. But I think it's probably the best and most Fair way to go about things

[57:00] Garen how is this handled in other networks or is this just in the context of the state inspiration this is just in the context of State expiration no other network has like rent balances like this. So I don't think there's really any pre-context or right. But on the EVM you do get a refund for clearing space right yeah. So you'd still like get Base reserve back and stuff like, that. But I think it's difficult. Because I mean on the EVM there's still like one pair. And then the refund is relatively small whereas here the rent balance could be a somewhat significant value potentially and there's also multiple payers, which complicate things a little bit more okay. So I think we're at time and obviously I think we all need to think about, that

[58:00] some more. So maybe start a thread in sorobondev on refunds and we can revisit, that later sounds good well thank you all foreign thank you all and see you next week.

</details>

## Write Your First `Hello World` to Ledger Storage {#part-2}

<YouTube ID="EANFHlgJr0g" />

This workshop segment walks through writing and testing Soroban smart contracts using Rust and the Soroban SDK, with a strong focus on developer experience. Live demos show how to compile, invoke, and iterate on contracts entirely in a browser-based environment.

The session progresses from a basic “Hello World” contract to stateful contracts that store and retrieve data from ledger storage, demonstrating how Soroban abstracts serialization, storage access, and testing while remaining explicit about execution and state.

### Key Topics

- Writing minimal Soroban contracts in Rust using `#![no_std]` and the Soroban SDK
- Contract functions, return values, and logging via the host environment
- Using `Symbol` for efficient on-chain data representation
- Interactive contract invocation via a browser-based playground
- Ledger storage basics:
  - `env.storage().set()` and `env.storage().get()`
  - Handling optional values and type safety
- Storing state keyed by addresses instead of global keys
- Testing and iterating on stateful contracts without deploying to a live network
- Soroban’s “batteries included” philosophy for developer productivity

### Resources

- [Soroban Rust SDK](https://github.com/stellar/rs-soroban-sdk)
- [Rust documentation](https://docs.rs/soroban-sdk)

<details>
  <summary>Video Transcript</summary>

[00:00] Hello everyone. Paul can hear me. I can hear you. Yeah, can you hear jittery, is it okay? Let's see what about my volume? Is it good enough? Yeah, you're all good.

[01:00] Thank you, actually get out of the camera. Hi everyone, we are getting started. How is everyone doing today? All right, give us a minute here as we get set up for our sorbonne developer Workshop. We are writing our first smart contract on sorbonne and we have Morgan and Paul joining us on stream here today to do this Workshop. Hey, Morgan, hey Paul, how are you all doing? Hey, everyone doing good. Yeah, going good here. How are you new here? I'm doing well. I am in the SDF office. It's been so exciting. The DevRel team has been expanding and we're onboarding so many new developers and it's been exciting. Sorbond's really changing

[02:00] And we're innovating, and I can't wait to see what more is going to come out of this. But all right, oh, you were at Paris blockchain week, right, Morgan? So what is this? That's true, I, yes here. I feel like this is what the SDF office looks like. Everyone, anyone- yes, I think we should do like a live stream tour of SDF's California SF headquarters. I think that would make a fun: stream everybody's work and see what they're doing, just like, pop around and interact with people. I'd love to hear that. What's with them with the Media Kit in the background? Yeah, we'll find out with. Yeah, I know, but so many comments here. Cool single monitors only. Yeah, y'all, we have

[03:00] Only single monitors around in office. I will let them know. We need curved monitors. We need all that cool Tech. But, yeah, all right, without further Ado, Paul Morgan, I will let you all kick off about this workshop and talk about what you presented at Paris blockchain week, and I'll let you start off. Paul cool, yeah, I think I'm presenting here. How do I make that happen on the screen? There we go. Yeah, cool, that looked like it a second ago. Yeah, that's the one. Cool. Yeah, welcome everybody. Good morning, good evening, good night. Wherever you happen to be, welcome to live stream. I'm writing your first smart contract on sorbom. Here's what we're gonna be going through today. So, first off, we'll do a bit of an intro. We'll talk a bit about what is Soroban. For those that don't know, we'll have a cool hello world demo from Morgan and we'll talk a little bit about why Soroban's important, why

[04:00] It matters, why it's good, why you should build everything on it. And then we'll have a bit more for Morgan on his kind of journey and how he got to sorbonne and how I got involved with all this, and then Tyler will share a bit on how you can get involved, and then I will wrap up from there and we'll do some questions and stuff at the end. So first off, who are we right? My name is Paul. I will start there. I'm a Staff engineer at the Stellar Development Foundation, which means I get to work on Soroban every day, building and making it happen for all of you. So I'm really excited to be here today to share some of the stuff that I've been working on. What is the Stellar Development Foundation? If you don't know and you've somehow stumbled into this stream, anyway, the SDF works with the Stellar Community, which is all of you to build the Stellar network. is a fast and reliable L1 blockchain with finality in

[05:00] Just five seconds. The network's been live since about 2015. It and has seen sustained real world usage of 150 transactions a second with literally no problem just cruising along, which is pretty crazy to think about. It has a global network of anchors- it's what we call- which are on and off ramps, issuing on chain versions of assets from the real world, including cash access, which we'll talk about later. And for the last year, we've been building something new: sarban. So what is Soroban? So sorbonne is a new add on to the Stellar network. Traditionally, the vanilla stoneware network didn't have Smart contracts. There were. There was a few L2 attempts, right like Turrets that some of you might know, but they had some issues around that, like atomicity, yeah, and other things like that. So we wanted to open up more decentralized Innovation to the network and to open up new opportunities to the underserved and unbanked populations that Stellar's built to serve.

[06:00] And I mean my big thing is payments is- such a small part of the financial world. It's like an important thing to get right, but it's just kind of the base layer of what we can build here. So we announced the project that would come to be known as Soroban back in January of last year. Since then we've shared eight, I think, iterative releases- yeah, I want to preview eight. Now onto our experimental test net, known as futurenet, so devs can experiment, learn and contribute to the design discussions. We've been regularly running a program called sore bonathon- we'll hear a bit more about that later from Tyler- and we regularly discuss design choices and onboard new devs to the community on our Discord. The community interactions with all of you lovely folks who are now in the Stellar Community- sorry, I don't make the rules but I will enforce them. So you are going to be part of the community. Now. The community interactions and the public input has been really exciting to see. That's been my favorite part of this journey. It's been absolutely mind boggling

[07:00] It's impacted almost everything about sorbonne, right from naming to authentication- how does that work- to how Soroban should integrate with the existing vanilla Stellar network and while sarban isn't tightly covered, coupled to Stellar specifically, it is designed to work well with the network. So a bunch of stuff on that point. It's written end to end in Rust for Speed, efficiency and access to the ecosystem that exists there. It comes with a bunch of plug and play, SDKs for simple to complicated authorization models, and it's built to scale right because it has to keep up with the rest of the existing network. It can't slow down the network. But the thing I'm probably most excited about in Soroban and looking forward to seeing is how it's empowering all of you in the community. Now that you can build on Stellar completely Unchained- hey, I'm sorry if I didn't make that joke. Tyler said he'd fire me, so it had to happen

[08:00] Right at this point I'd like to introduce Morgan. He's a founder of useorbonda app. He's a Community member who's been building some incredible stuff to help onboard other devs to Soroban and he's going to show us a bit about what he's been working on. Hello everyone, I'm gonna start buying. Sharing my screen should have done this earlier. All right. So here's a thing that every developer starts their programming Journeys with. We all like to say hello and we all like to say hello to the world as the very first thing that we do in our programs- and you know, almost everyone starts their Journey that way- and, in fact, the time it takes for someone to say hello world in a specific programming environment maybe the determining Factor if they're

[09:00] Going to continue their Journey in that platform or not. So I definitely want you guys to stick around for the rest of the talk, so I'll just get started with the hello world part. All right, so what do we have here? As Paul mentioned, I am the founder of usurubond app which is this tool that you see right here. It is a developer playground for saurabhan smart contracts. Now, what do we see on screen exactly? Well, I'm logged in, so I have access to the Gated Alpha here and I have the ability to create a new project. So let's go ahead and do that. New project pops up and let's go ahead and delete everything, because we're going to start from scratch. What's this environment all about? Well,

[10:00] First we have a code Editor to the left here. This is where we'll just put our rust slash sorobong. This playground runs on Rust and the rest soar about SDK you'll, as you continue your journey, you'll find out that there's other SDKs for sword Bond available. For now we're going to deal with rust because that's the sort of reference implementation. All right. So we have the code editor, we'll put our rest in and sort by and then we have some widgets. So right now, console is open, code is open and let's get started with the hello world part. So how do we do that in rest? Well, I guess we write a hello function and we call the print line macro and say, hello, okay, compile it. And that worked. This is a rest program as it should be compiled,

[11:00] And I abstract all the details for creating cargo projects and the defining targets and so forth. So you just sort of write some code and click compile in. You know, you're Off to the Races. Morgan, I'm going to interrupt you for just one second. Can you zoom in a little bit more, because we can't see it? A little bit more. How about now? A lot more, yeah, a little bit more. I would say, yeah, it will be unusable if I zoom in any further. So I do apart for anyone: or we can hide my face, there's a lot of stuff on screen that's not the code. So we can just sort of focus on the code. Here we go, there we go, sweeter, like I'm almost blind. And there you go. Okay, sweet, we got one confirmation. I can see it. Fine, carry on. And everyone can hide the faces because, like, the vertical space might be useful,

[12:00] Nothing but the screen share. All right, perfect, thank you. All right, carrying on. So print line hello didn't work. Well, at least it compiled and didn't produce what we wanted. Why is the question? And well, we're working in a soybean environment, right? Soroban expects a certain kind of format for these things to work and everything that we want to be able to call has to live in a contract. So contracts are struck in. Rest, we're going to declare a contract struct. This name can be anything you want: call contract because it couldn't come up with a better name. All right, so we go ahead and Define an implementation for contract. Let's go ahead and copy this from here.

[13:00] Okay, all right, compile this again. And that worked again, no compiler errors. But the problem is we still don't see any hellos popping up. So that's not great. Ideally, you want to work with the SDK here, because you know, a structure like this is not really sort of buying. We got to tell it to do a little bit more, so for that we're going to use the Soroban SDK and we're going to import the contract implementation macro and that's going to do a bunch of things. But essentially this will convert this implementation right here into a Soroban contract. And okay, we have a few errors over here. By the way, Russ is super famous for really good compiler errors and in this

[14:00] Environment, which is enabled by Soroban, the way it's designed to leverage webassembly and rust, so we'll get those beautiful Russ. Compiler errors and we can see that there's some problems with the Panic implementation, although it's not entirely clear what's going on. So I'll just sort of skip the mystery here and solve this problem by finding this macro right here. So contracts on the blockchain have to be super efficient in how to use the available Ledger space and rest programs. Even though they're pretty light, they still carry a bunch of stuff that we don't really need as part of our contracts. So to eliminate everything that we don't need and just get the rest that you know, the basic rest of that is required for

[15:00] Contract logic, will we declare the no STD macro. This unfortunately removes the ability for us to use the print line macro to print this stuff, and okay, so let's get rid of that. Now we've back to a solid compiling contract here and let's go ahead and declare this function as a public function. Now we have something on screen up here that's looking like a button. So in this actions widget, which is sort of the a third of this interface in the middle, is where you will be able to click and interact with every function that your contract declares. So our contract right here declares a single hello function. We can call it and we'll see in the console a return value. So it's implied that a function without an explicit return value returns none in

[16:00] Rest. So same applies here and we're going to return value. Now I guess we can leverage this return Dynamic to finally say hello to everyone tuning in, and for that we will need a special type. So again, since we can't use the rest strain- it's unavailable- we have to figure a different way to carry our information and for that we're going to use a symbol, which is an efficient data type in sorobind for storing alphanumeric characters, essentially all the letters of the alphabet plus the digits and the underscore. So what we're going to do with symbol is we're going to initialize a short symbol that says hello, and short just means that this sequence of characters will be able to fit in a single 64 bit value, which is pretty

[17:00] Important when it comes to this context. Let's recompile this again and oh, thank you, rust compiler. We are returning a value, so let's make sure that we declare what we're returning and let's call this all right. So we have, a return value. Hello from this function right here. And this is sort of your basic, most basic implementation of a sorobind contract that says hello to anyone tuning in. Now let's make it a little bit more spicy and let's use a little bit more of the environment here. So let's say we're going to log a value. Everybody loves blogging. As a- you know someone coming in from a web developer background, I use console log all the time and console log is the best. So

[18:00] We have an equivalent in sorobind. It's called log, the log macro, and we're going to declare a new function called hello2. And what are we going to do here? We're going to gonna say hello to a specific name. It's going to be a symbol and we're not going to return anything. Okay, so how do we interact with this log macro? Well, it's a macro, so we use a bang, and then the first argument is the environment within which we're logging this value. And you'll get used to this concept of every single function that your contract has that interacts with anything else. Anything in the outside world will have to have an environment as the very first argument. It's kind of like your access to everything. So log accepts the first argument being the environment. So we're just

[19:00] Going to pass, in reference to the environment, next up we have a string and we're going to use hello, bang, and then we're going to provide the name. Let's compile this. Oh, we're missing environment in this import, and a handy feature is, if you're having problems with a specific type or you're missing something, you can go ahead and click links right inside of your compiler widget. That will take you to the documentation. So it's an easy feedback loop. So now that we've imported an environment, we can recompile this again and try saying hello to twitch- I guess is where most of you are. And in this console widget we can see that in between hello too, which is the function that we're calling, and the return value, we have a log that says

[20:00] Hello, twitch. All right. So I'm almost done with the first demo. Anyone and everyone that's tuning in you can actually test this on your phone. So this is going to be a multi modal demo and for that I'm gonna take my phone here. So I just popped up this share modal. I'm going to take my phone. This is an actual phone I have here. Bring up the camera. Hey, everyone and I'll go ahead and look at the QR code here. Tap on usurabond app and we can see we're taken to a version of usurubundan app, which is mobile optimized. And you know, we gotta work on mobile experiences just as much as a desktop experience and someone that's designing these apps. We've got to be mindful that's where our audience is. So this kind of interface will allow users to test this contract anywhere

[21:00] They are, especially on the mobile phone. So we have access to the same sort of widgets. We have the console open and actions is a sheet down at the bottom. We can go ahead and call hello like we did before. Quick access down at the bottom to the previously called functions, and we can call hello to and let's do twitch, confirm. And then we can call this function with the same arguments if we want to, or we can change the arguments and do YouTube. Okay, all right. So that does conclude the demo. Everyone that scan the QR code and we're able to interact with the app here. Congratulations if. Right now, this is still in a gated Alpha. If you want access to the current build, please tweet me on at sorobine Dev on Twitter and I'll make that happen.

[22:00] All right, so I'm handing it off Back To You, Paul. We go. Okay, I'm back. Thanks, Morgan. Can we get the slides up again? Cool, thank you, yeah, so that's. Morgan has shown us the basics of Soroban, but I want to go into what actually makes it so special and what makes it so exciting here. So, first off, it is batteries included for devs. That's our goal here, right, when we're designing it, everything we're thinking about designing it. That's our goal and that means we're including everything from Storage to authentication and authorization Frameworks to token minting and transfers. All that's baked in, right, it's ready to go, so you can focus on your

[23:00] Application and not spend ages trying to figure out how to like verify an ed 25519 signature right, like. You shouldn't have to worry about that. And secondly, unlike pretty much any other smart Contracting platform out there, because we're launching on the Stellar network, you get access to all the existing assets on the vanilla Stellar network- and I want to address a comment in chat, I think from Matthias said I should call it classic and not vanilla. And I'm calling it vanilla for a very specific reason: right, because the existing Stellar network is not going anywhere. Right, that's still all staying there. It's not being deprecated. It's not a classic thing, right, it's just a different flavor of the same thing. It'll still be the fastest, cheapest way to use the network. But if you need a bit more power, that's what Soroban's for. Okay, but building on the existing Stellar network means that from day one of launch, your smart contracts can hold and use USDC right and many other assets that are

[24:00] Already on the network. They also have access to Stellar's cash on and off ramp via our partnership with MoneyGram, which gives, which works in over 200 countries worldwide- right, so, putting this together, we could think of someone, let's say Julia. Right, she doesn't have a bank account. She can go to her local MoneyGram location, deposit cash into the kiosk. She receives USDC on the Stellar network in her wallet and now, with Soroban, she can take that USDC and deposit it into- I mean a lot of things. Right, whatever you're building, but let's say, an income generating DeFi protocol where she receives a portion of transaction fees for providing liquidity. Right, the partnership between Stellar's anchor network and MoneyGram allows users like Julia to move cash straight from their physical real wallet to a DeFi protocol and vice versa, which is something that I don't think's ever been seen on any other blockchain network so far. Yeah, and the third Point here I want to talk about, what makes Soroban super special

[25:00] Is the scaling optimizations that we're doing. So, when designing Soroban, we've been able to learn from the state of the art and hand pick the best solutions from each one. So we've designed the transaction execution model, the scale across multiple cores. We've calibrated the fee model to maximize throughput and minimize cost while protecting the existing Stellar network traffic. So we've designed a lot of optimizations around the contracts themselves as well that you don't see on every other chain. So, for example, if you look at near- not to pick on them, I love near, but they do this in the near contracts- you need to do your own serialization, the deserialization of arguments when you get stuff in and out. That means you need to compile that into your contract and deploy it as well, right, so you need to include that library in Soroban. We've pushed as much as we can out to the host environment where we can say: batteries included, right, which lets us massively reduce the contract size. And you don't need to pay to deploy that code. Or your

[26:00] Users don't need to pay to run it, right, We can take that a little bit further with built in contracts. So we have an idea in Soroban of built in contracts similar to like pre compiles you might know of us on other network. So currently this is just for the standard asset contract and it means that it runs Ultra fast and cheap right and it lets contract standardize on the interface within the ecosystem and that's the standard asset contract. That we have in Soroban is how Stellar assets are exposed in Soroban. They look just like any other contract to your contract, so it's really easy to integrate with existing Stellar assets. The last thing here: that's really cool. We're actually working on solving State bloat with our state expiration model. So on other chains you store some data on chain and it's there forever right. Well, forever right. In air quotes we have a rent based system with

[27:00] Evictions and Restorations to ensure the Chain's working data set stays as lean as possible. So once your rent expires your data gets evicted and you can pay to have it restored back on chain if you need it. We can do a deep dive on that another day. It's a bit involved and actually we're still designing some of those elements right now, literally right now, on the call on Discord. So at this point I think Morgan can introduce this a bit: how stateful contracts work on sarban and get some of the basics of those in foreign. I'm Paul's back too. Hey, Paul,

[28:00] I am muscle back. Yeah, we're waiting for my screen share. You are waiting for a screen share of Morgan. There you go. Okay, all right, thank you anyway. Yeah, thank you, Paul. So, like Paul mentioned, there's quite a bit of innovation going on sword I'm, and the deeper you go into it, the more you can sort of understand. Like you mentioned, there's a design discussion going on right now. We're about to wrap up. Every week, I think they go on, but anyhow, let's discuss the sore month State of Mind, specifically when it comes to storage and preserving things in The Ledger. So as I open this up, I want to hide my face and then focus on the code again, if

[29:00] All right, perfect. So we're back to a brand new project. I think we should rename this to: so we're working on the state, on the sword State, okay, so sooner or later, every developer finds themselves in a situation where their application is not working as expected, I would say: raise your hand if that happened to you, but I can't see you. So I assume everyone's had this problem and we all know the techniques of how to solve these things, like unit testing or logging intermittent values- using break points is a cool way to inspect stack frames and so forth- but unfortunately, smart contract developers often don't have a rapid workflow for finding bugs

[30:00] Or faults in the contracts and you know this leaves them with the only option of: hey, I want to test something out. Well, what do I take? The current code for the contract that I have and I either one of two options: I deploy this to the test net of your blockchain that you're working on and I test it against the wallet, and that's going to be, if you're a very efficient, under a minute or it could take a little longer. Or your second option: if the blockchain is well equipped for developers, let's say you can probably deploy to a local Docker running instance. So that's all fine and dandy, but air is the limit and folks, I guess, tend to not test as much as they're used to because of all the hurdles. And so Soroban takes the challenge, hit on by providing

[31:00] A guest environment right in the SDK. So you'll be able to see in the documentation, if you follow along this path, where you read a contract and immediately you read a unit test for a function, and this is using your regular rust cargo unit tests. With usurubon app I leverage that functionality of the of an environment provide features to rapidly test your contracts. So right here we're gonna explore. State because let's you know, face it, if we're writing hello world, probably bugs won't affect anything too much. If we're dealing with State, then bugs all of a sudden become an issue. All right. So let's begin. How do we store something on The Ledger? We're gonna head and start with the same

[32:00] No STD. So we're not going to import the standard Library. We're going to use the critical elements like contract implementation and environment Within. You know, and let's grab a simple as well from the SDK and we're going to declare another contract on track, okay. And then we're going to implement this contract with a couple of functions. Let's clear this upper way contract implementation, all right. So what do we want to test to sort of showcase this? Well, first, let's compile often, right, never too often to compile. We're going to have some data in the storage and on The Ledger and we're going to save and retrieve that data. So

[33:00] We're going to have a couple of functions. So let's declare save as the one that will put data Into The Ledger and we're gonna explore a number- it's gonna be u32. Now, save is going to return the same number, just for the sake of it, I guess. And we're gonna load a number environment and it's going to return that number. So it's essentially save and load, two functions for this contract. Let's compile this again. Make sure nothing breaks. Oh, okay, well, I guess I compiled it a little too early. Let's return some value here, okay. So we have

[34:00] Something of an issue. I remove this. Let's make sure this compiles again. Let me back out of this. Oh, we don't need to back out of this. We're just not returning a value before. Should have trusted the rest compiler errors. All right. So we call save. It takes in a number and, by the way, this is one of those nice abstractions that you get with an environment like usurubund app let's say, a function takes in some arguments, right, in this case it takes in a number argument that's a u32. Well, we have a nice modal that we can input our number to confirm and that's going to call our function. As far as integrating into soribine,

[35:00] There's another nice feature that's part of the, I guess, Soroban contract specification. So when you compile the contract, there's some amount of that byte code that's compiled, allocated for specifications. So let's say save something, rather save a number to The Ledger. Okay, let's compile this again. We can see that the modal now incorporates our comment for that function to describe what exactly this number does or what exactly this function does. So we're going to click confirm and let's add a another specification here or the docs for this function. Load a number from the layer, pile this again and oh, it doesn't take any arguments.

[36:00] It's not going to display that modal. That's fine, all right, let's return the number as our first exercise. It's gonna be u32 and 42. We got 42 in the console here and right. So now the magic part. How do we take the number that we provided in our modal here and put it into storage? Wow, we need a certain key, something to store it under, and for that we're gonna declare a constant and it's going to be a symbol value. That's why I'm imported symbol and it's going to be. I'm not original with names. Under these circumstances, I'm just going to use storage and over here we're going to pick the same

[37:00] Environment that we've used before for logging and we're going to reference storage. Okay, compile this. Oh, about the year I was expecting. So storage is a method, not a field, as we can see inside of this error message. We can go ahead and inspect what exactly storage is in the documentation and let's see exactly how to use it. So we can see that there is a set function under storage. It takes a key and a value. Okay, so, with this new knowledge here, since this is a method, not a field, we're going to call This And since we observe that it has a public function set, we're going to call that set function to store what we're storing. So we're going to provide storage as the key, right,

[38:00] And we're going to provide number, Something That We're storing or the value of this. So, save 42. Confirm, all right. How do we know that we did store this correctly? Well, that's why we have this load function here. And how do we retrieve something? Right, we used set to store it. How do we retrieve it? Well, we can go back to the documentation real quick and see that there is a get function associated with storage and it returns an option. That's a result that potentially has that value. So there's, you'll see that there's some unwrapping that needs to happen. Oh, so we go ahead and reference that same storage, and call the get method, and we want to get the value under storage, the key. So what do we get? We get

[39:00] An error because we're trying to return a u32, so let's return to u32. Now we get another area that says we want to have a u32, but we get an option. So whenever we're getting a value from Storage on sorobond, any kind of in a store buying contract, we don't know whether the value is there and we don't know whether that value is the value that we're going to return, in this case a u32, or it could be a symbol, we just don't know. So we can go ahead and unwrap this option and see if that works well. Then there's the question of returning a result. So at this point we unwrap the option. We're sure that there's a value there, but we're not sure whether that value is a u32 value. So we can do clever unwrapping here. But I'm just going to do a silly unwrapping so it panics if it's not a u32 and let's

[40:00] Compile this again. So let's go ahead and Save 111 and load, okay. So we just put a number onto The Ledger under a specific key and we retrieved that number from The Ledger- we had an experiment with 420- and load the value, do something else. It works okay. So there's a complication that I want to implement here, and it's a little bit different from what we did during Paris blockchain week. This is something that tolmer told me to do, and so I'm just going to see if this works. If it doesn't, well, hey, this is a demo, these things break. So here's the gist I want to store a number for a specific account, so

[41:00] I want to store numbers under accounts. I just don't want to store a single number. I want to store it as many numbers as I have accounts. So we're going to modify this save function here a little bit. We're going to take in a user argument or parameter. That's called user. Let's type address, so address refers to any valid blocking address on the Stellar blockchain, and then we're going to take in a number, we're going to return the same value and let's just see what this does. So if I call Save, I'm greeted with this second field here. So use oribon. You know, this modal expands to however many arguments that your function takes. And there's another cool abstraction here: when dealing with accounts on the blockchain, it can be like really tricky for someone just get getting started, right, how do I know how

[42:00] To generate one? Do I need the private or the secret key here? That's a lot for someone that's, you know, into JavaScript or something. So for that reason, you saw a line app completely abstracts away interactions with accounts by using just regular names. So how many users does the system have? It has three users: Alex, Bart and Cali. You can select either one, and that in the background abstracts it away into a specific address within the back, within the current environment which is running in your browser. All right, so we select Alex one. So nothing happened really. We just, you know, have a parameter that we're calling this function with, but we're not using it yet. So let's try and use this. Okay. So, under storage, instead of putting everything into the same key, let's try and

[43:00] Use user. Okay, so let's compile this thing, get compiled and let's call Alex and let's do pen, okay, so that sort of kind of worked. But how do we sort of debug this? Right, we can probably do a log here, although maybe we should just use the load function. Okay, I'll just do a little function here. So when loading, previously we only had one key and we have any number of keys that correspond to each user. So instead of using storage, we're going to use user. Here's an experiment. So let's, we saved. I think we saved. Let's save 10 under Alex again. So let's

[44:00] Load Alex. Oh, we got a 10. So that worked. Let's try. Bart, it trapped, okay. So the Trap means that the value doesn't exist, but we explicitly tell this thing to unwrap, not caring about the underlying value. So we can go ahead and sort of test this out. So here's this log macro that we used before and call this with an arrow, just to have some string value in there and let's see what that returns. We probably need to do some matching here.

[45:00] Foreign type. I think I'm going a little over the description here, but the point being is that we can store values under whatever key that we want, and the key can be anything. In this case, I just displayed that it can be a specific address, so we'll just go over each user. Alex is going to have 11, Bart is going to have 22 and Cali is going to have 33.

[46:00] And let's go ahead and check each one. So, Alex 11. Okay, Cali 33 and Bart is 22. So, this is much more elegant than what we had during Pierce blockchain week. Were you storing values under specific usernames? Thank you, Tomer, for this suggestion and sort of the nice deviation from the standard here. All right. So that concludes my second demo for the Soroban state of mind. If anyone wants to again experiment with this, please tweet me on Twitter at soribandev, and I'll make sure you have access. Thank you so much, Morgan Tyler. Yeah, let me bring Tyler onto stream. Howdy Tyler, how are you? Hello? All right, let's bring up your screen here. And, nice, tell us all about the 100

[47:00] Million dollars. Two opportunities sounds very interesting, so I'll let you take it off. Yeah, don't let me talk about much. They do. Let me talk about the money. So we've got basically two main opportunities here for engaging with Soroban right now. So we're in this phase between being on the future net, moving to test net, eventually be on mainnet later on this year. But while we're in this phase of developing Soroban and really trying to understand how to build it, in this malleable stage of solving difficult problems, and trying to build the bless the best blockchain smart contract value transfer protocol in the world, there's some unique opportunities here, and I'm going to talk about two inside of this 100 million dollar Adoption Fund that the sdfs put out. One is the one that I'm responsible for and that's fast, cheap and out of control. It's kind of a. It's primarily an

[48:00] Educational content generation engine where you can learn rust, smart contract development, how those two things come together under the sorobond umbrella. Right now it's a game that really takes you through Soroban contract development with the objective of trying to build fast contracts, cheap contracts and out of control contracts. Over the next few months, this is we're dropping a little bit of alpha today- we're going to be migrating a lot more attention to fast, cheap and out of control for sorobond development. Stellar Quest is going to become really for a vanilla or, if you're on team classic seller, that's where that education is going to be- and then for Soroban related material. It'll all be living on Fast, cheap and out of control. So make sure to keep an eye out on that. And the second one would be the Stellar Community Fund. Right, so we got our fast Jeep and out of

[49:00] Control. That would be your site for that- fca00c or ooc, I have all the domains for this. And then the second one: for the folks that are developing protocols or startups wanting to migrate existing DeFi protocols, Etc, over to the sarban ecosystem, the seller Community Fund is the place for you. We've really been optimizing Anka and the team have been optimizing the Community Fund for both the vanilla, classic, Stellar applications as well as Soroban applications. So there's a really nice clean process for getting onto the seller Community Fund, getting funding for different protocols or experiments that you might have for that. So those would be the two big pieces that I'd call out again the fast Jeep and out of control. For those who are either new to

[50:00] Rust, smart contract development even is the Soroban ecosystem evolves and grows. A big gap that I have felt, as I've explored the competitive landscape, is not just teaching people how to write rust or teaching people how wasm works or educating people on DeFi protocols or AMMs, but really trying to identify where our vulnerabilities coming from. How do we write good smart contracts? Where do standards come from? With someone- like where OpenZeppelin might have come from in the Ethereum ecosystem, trying to ensure that the contracts that we're building are good. So building out games and community events for tackling specific difficult problems so they're able to arrive, a good documentation and standards for writing good smart contracts. Developing a smart contract is very different than developing just a standard application and some of those differences. I don't think we've focused enough on solving

[51:00] Or teaching for, especially what the fcaoc is aiming to solve for, and then the Community Fund for funding folks that are actually doing application, startup, entrepreneurial type work. So that's those. Make sure to check those out and I will hand it back to Morgan, I believe. All right, sweet, I see here, Morgan, you got. We should definitely do weekly informal developer workshops. I think that would be awesome, and I think Matthias is slowly working on something that he's holding secret until he does, like a heart, build the beans. Matthias, I know, do you want me to share a screen here, Morgan? I think we're good. I don't have a slide to go with this, it's just gonna be my saurabhan story, I guess, and a little background as well. So no slides needed. And

[52:00] Yeah, by the way, very nice shout out in the Chinese or free access to viewers if you tweet at me on Twitter, all right. So my story about story. So my developer story, going back real far, started as a kid with a Fascination with computers and I remember I was 14 when I wrote my first line of code and for me that was, you know, that experience informed what I was going to do from that point onward, and I've made a career out of it in almost 20 years of frustration, followed with the joy of seeing something that you build come to life. So that's, I guess, any developers Journey there, and the reason I'm sharing the frustration with the joy part is because I feel this industry- and I'm talking

[53:00] Specifically about the blockchain industry- has not focused enough on the joy of building while providing ample frustration, and you can probably see that in your own experience there's a lot. So over the last two years, I've tried playing around with a few smart contract platforms, spending considerable amount of time with two of them and in the end I felt a little bit like Dorothy from The Wizard of Oz in a conversation with Scarecrow and Tin Man, trying to find out why one had no brain and the other one had no heart, and in my frustration, I continued looking for a platform that had both a heart and a brain. And just last November I found Soroban. The first sore bonathon was taking place and anuhe was hosting that and it was a beautiful experience. On GitHub, you log in and you know everybody's

[54:00] Sort of submitting their own ideas and thoughts and experiencing the joy of development, technology and right. Yeah, so I took part in that. I've jumped right on it and I found out about Soroban in the process. I found out about XDR, which is the data format for storing things on Stellar that Soroban uses, and then I started getting into rust, and it's a long journey and doing so without prior experience, mind you. And then, lastly, was webassembly the one of the key building blocks of Soroban, and my first projects were very simple, mostly to do with optimizations of the development workflow, one workflow or another, and I made some submissions along those lines. I think it was five in total. Yeah, there

[55:00] Were a lot of them. Actually, you were one of our Superstar submitters to silverwater thought, if I recall. Yeah, and it was a blast, and the community on Discord was great people were commenting and so forth. So that was a really soft and nice introduction to sort of buying. And my final project as part of sorbineathon- I think I submitted it last day- was a browser tool for interacting with the Soroban RPC server, something that a lot of folks do when interacting with any kind of blockchain. You don't go directly to a node you're running, you go to an RPC server for y'all, remote procedure call server. I remember the https from Bloomberg, gotta spell it out. So the RPC server thing: I wanted to build a great

[56:00] Developer experience for anyone building and testing their contracts, because deploying the contract, invoking the contract, is often tricky if you want to do it with arguments and stuff and especially if you're sort of coming in from a command line. And in doing that I spent countless hours working on various parts of the stack, from the wasm executable to the host environment. And then it hit me. I realized something: I had everything I needed to build a self contained browser environment for executing and testing sort of on contracts. And I just sort of blew my mind like I had everything. I needed to build the perfect playground experience and so seeing how coupling webassembly, the virtual machine, together with sorbent host environment specification, enabled

[57:00] That browser based developer tool that I had in mind, and many others that you can sort of picture, was my aha moment, and I just started working in seeing how I could build tools with you know, within the browser, that required no setup, no Docker. I'm no fan of like all these massive setups that take 10 minutes if you're efficient. No, nothing, just sort of log into a website and start experiencing sorbine like that and I, you know, immediately afterwards I started building it and I started debugging and engaging the community further and this was, I think, in February, when some of the programs that Tyler mentioned- SCF- I applied with use sorobond app

[58:00] Because at that point it was brewing for like two months and I got in and, with the help of the Community Fund, I was able to continue building this sort of- I call it the developer playground of my dreams, because it's everything I ever wanted from a smart contract playground, and all of this happened like from scratch to launching a community funded project in less than four months- yeah, like October, not even. I think it was late November, yeah, and then there was a gap in December and sort of you know, it's like light speed. So my experience so far has been Stellar and I really appreciate the community for allowing me to go through what

[59:00] I went through. So thumbs up. And yeah, that's my Soroban story. That was so wholesome and well put. Morgan, thank you for sharing that. Seriously, I think there's a question here about youth sorbom. Where can we make token contracts on new Soroban? Very soon, I will open it up. Sorry, go ahead. Yeah, I'll open it up. Next week There's a massive update and I'm working on ever since getting back from Paris and stay tuned. I'll keep you guys updated. Yeah, I mean Morgan's all into this. Y'all. Just clarify. I mean here's an awesome office now and he's like set up like an entire space and whatnot. It's a whole thing you saw about is like the next big thing here in the store of on ecosystems- you hear, you heard it here first. I see there's Matthias is saying that I'll blow your mind 2x, Morgan, thank you sore. Bomb plus test Runner plus Cooperative coding in that Dev environment. AKA vs code live

[01:00:00] Share. There's a lot of Minds ready to be blown, I think in the next few months. There's so much Innovation happening in this space. Absolutely, I'm so excited. Thank you for everything that you do for this Arbonne ecosystem, Morgan. So, yeah, I'm gonna bring Paul back up on here. Everyone, hey, everybody, right, I'm just gonna wrap up here quick. Yeah, I hope you'll All Join the community and we can blow mines together. Smart contracts bring a ton of new Incredible use cases and power and Innovation to Stellar. All right, for me personally, you know it's a hugely exciting new piece of tech, right, like what can I say? Like I'm an engineer, you know I can say that storybond will allow us to bridge the disconnect between developers and people on the fringes of financial inclusion, right? Or that there's a lot of chances to learn, Tinker, build, earn rewards with the Adoption Fund programs, like Morgan's doing.

[01:01:00] But what I will say is that I hope. the experimentation we're all doing will lead to building real businesses, real projects and real world use cases. On sorbonne to help further Financial inclusion: yeah, if that gets you going the same way it does me, then my job's done, cool, I can go eat dinner. But like, seriously, you know, if you're excited about this, right, you can start experimenting with Soroban right now. Right, it's live running on our experimental test net called futurenet and I want to encourage you all to consider how and where you might fit into what's coming later this year when Soroban launches for real onto Stellar's net, onto Stellar's mainnet. And if I were you, yeah, start coding right, check out you serve on. Tell your programmer friends to poke around, see if it's the right time to take a look at, Stellar. There's a QR code on the screen that'll take you to `soroban.stellar.org` that is the place to go to learn more. There's links to everything you need there: docs the Discord, join the Discord, keep up with developments. All the devs that are building Soroban every

[01:02:00] Day are on there answering your questions. Yeah, thank you so much for your time. I can't wait to see what you'll build. Back to you new here. Thank you so much, Paul. I do want to re emphasize here the fact that we are building Soroban out there in the streets as I like to think, and not in like some laboratory. So everything is out there. Join the developer discords, be active. As Paul had said it best, everyone on the stream that is watching or will ever come across is: you're already part of the Stellar ecosystem and Community here, so come on over, start building, tinkering and let's make this a vibrant and thriving community of developers. So yeah, thank you all for joining us on the stream. Stay tuned and we'll see you in the Discord. Take care. Bye, everyone.

</details>

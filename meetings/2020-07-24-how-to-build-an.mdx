---
title: "How to build an anchor with Polaris"
authors: [jake-urban]
tags: [developer]
---

import YouTube from "@site/src/components/YouTube";

<YouTube ID="Mrgdvk1oRoA" />

- hey guys um welcome to the the engineering talk uh we are going to begin momentarily um one thing i will say and i think uh our host has posted in the channel but uh if you have questions while i'm going through this talk go ahead and scan the qr code and you can send questions over and i'll i'll take a look at them at the end of the discussion um okay so uh yeah welcome this is uh this is a talk about polaris which is a django application and framework that allows you to build uh anchor servers uh according to the standards that we define uh that are called stellar ecosystem proposals or seps so django polaris is a tool that we use so that our tool that we build so that anchors can get their anchor service up quickly and with less work required so i'm going to go into the details of uh how to build this anchor but before i do i'm gonna go over a brief presentation that just describes what it is how it works and what you can expect in this presentation so uh let's go ahead and begin so like i just said uh polaris is a django anchor app or i'd like to say it's an extendable django app which means that if you know anything about django and hopefully you do in this presentation because i'm going to be going into django code but django is a system it's a framework that allows you to plug and play different applications within the project and so polaris is an app it's a reusable app that you can plug and play within django applications and it provides an interface an api that developers can use to insert and customize the way that the anchor server responds and handles information the reasoning behind this is that uh set 24 which was the original standard that we implemented this for uh has a lot of things that are standard about it every anchor is going to be doing similar things they're all going to have deposit endpoints they're all going to have info endpoints they're all going to have what the step describes and when i say the set sorry i'm just going to break out of my actually i'll stay in the slides until until afterwards but 724 is a standard and it defines an api for clients to be able to hit in order to uh in order to interface with the anchor and every anchor that implements sub 24 has the same endpoints the difference though is that every anchor has uh you know pieces of functionality that are custom to them so polaris what it does is implement the stuff that's standard that everybody's gonna do and then it allows people to customize uh their own instances with their you know their unique situation uh so overall it's less time for the anchor to build uh people can typically get this up within an hour because we're gonna do it right now um and we maintain it the sdf maintains it so we're gonna continue to upgrade this make sure it's up to date with the recent standards make sure it's up to date with the sdk upgrades and it's open source everything that i am going to use right now is viewable on github and we have links for the documentation and code in following slides so in order to understand polaris we need to talk about integrations polaris offers integrations or integration functions or classes that allow anchors to register custom functionality with polaris so polaris is going to facilitate you know the api endpoints and uh build out what a step 24 server would be but there's things that uh polaris can't automate right so polaris can't automate your banking or payment rails right uh if you're an anchor in brazil uh you know me as the developer of polaris i don't know what bank you're connecting with i don't know what api you're using i don't know anything about that so what you need to do is inject your own banking and payment rails code into the polaris framework uh in the same way we don't know what uh information you need from users so you may need email and that's it or you may need a photo of the ID you may need um you know a variety of different information social security number here in the u.s there's a bunch of stuff that you could you could need you could require in order to deposit or draw assets um and so kyc kind of goes hand in hand with user tracking you want to know who's using your service who they are how to reach them stuff like that there's uli customization so polaris comes out of the box with a decent ui but if you want to customize that ui you're free to do so and finally there's just transaction processing when when the transaction gets to a certain state in the flow you may want to update some of your own data models to adjust for the for the change uh and so polaris can't automate any of those things so it provides uh rails integration classes so you would in your code you would write uh you know within the rails integration class uh a a function that connects to your bank and actually makes payments to users and you're going to register that integration that you write with polaris and i'll show you how to do that so that transitions you know well how do you use polaris well we're going to do two things in this talk we're going to install and configure polaris and we're going to implement the integration points or at least enough integration points to get the anchor server up and running um and so there's going to be a few steps involved in that we're going to create a django project and hopefully people who are viewing this uh are familiar with django and are familiar with the seps i'm gonna brush over some details about the steps so you have some context but overall this talk is gonna assume that you know what i'm talking about when it comes to django and start ecosystem proposals you're going to install django you're going to install the django polaris package we're going to add polaris the django app itself to the project and then we're going to add a bunch of polaris settings and configuration options and finally we're going to register and add our data or asset that we're going to anchor within our database and in the asset that we're getting the asset that we're going to anchor in this database is a uh or on this anchor is our stellar reference token srt it's uh just a fake token on test net uh that doesn't mean anything but it's it's used as demonstration so you can show or show i can show how people uh you know build anchor services around an asset once we have all the configuration installation set up we're going to start implementing integrations so uh the first thing that we're going to do is build a an appropriate tomo file and if you're familiar with step 1 this is implementing that um it's basically a file that describes the organization that owns the anchor and uh and it gives a bunch of details about contact information and stuff about the asset that uh clients who are viewing the file are to need to know we're going to do a little bit of some banking rails so we're not going to connect to any particular bank and so we're actually going to kind of just mock this up but the idea is that you would fill this function in with actual banking payment rails code i'm just going to do what's required from a functional standpoint to make sure polaris is working once we have the tomol and banking rails integration set up we're going to register those integrations and then finally we're going to build the application with docker and get it running so hopefully that gives you a good overview of what's going to happen here and again remember everything that i work on here is open source and there are there's documentation available so if you want to check out the documentation it's available at djangopolaris.readthedocs.io and the code is available at github.com polaris uh and these these pictures are the are some pictures from our test server or our reference anchor server that shows you how to do it um it's basically an example and uh and these are just some some forms that plars provides out of the box so this is what the ui looks like if you didn't do any customizations um okay and we're gonna do questions after the demo um but for now i'm going to transition into coding and uh and i'll probably be hopping back and forth from the internet as well to reference the proposals and just demonstrate certain things um okay cool we are right on schedule um so this is pycharm i'm gonna be you know django polaris is a python application uh and what we're gonna do uh when we start off most python applications is create a virtual environment so actually sorry before i uh before i dive into the code here i do want to show you uh one thing and that's a demonstration of what you can expect an anchor to look like um from a user's perspective and uh and this is a little demo that we do so what i'm doing here is this is a little demo wallet that mocks like what a user would see and we're going to walk through a step 24 flow before we get started so you can just see what it's going to look like but we're just going to use our reference server that the seller development foundation runs and provides and we're just going to walk through a deposit flow on testnet so this is what we're going to ultimately build we want to get to this point uh by the end of this talk so i'm going to make a deposit it's going to go through the step 24 flow and it's going to open up the actual interactive page the user is going to see so if i was a user this is the first form that would be presented to me i'm trying to make a deposit onto into my account on stuller and and here is the amount field that's asking me you know to specify how much i plan to deposit and so i'm going to tell them that i'm going to deposit a hundred dollars and on test net uh anchors need to assume that uh deposits are actually sent right on testing everything's fake right so i'm not actually gonna send money to the anchor uh it's just gonna assume or or understand that it's on testnet and it doesn't need to wait for me to actually pay them it's gonna pay um or send you know stellar funds to my account uh and just to give you some like more context this con config option this is obviously the the reference server that we're hitting the url of it but this is the secret key of my account um and don't don't worry there's nothing you know fancy on it you can check it out on testnet but i'm just gonna deposit a 100 or 100 srt uh into my account on testnet uh so let's go ahead and do that uh and so now uh django polaris after i submitted the amount is going to go ahead and work on depositing that those funds into my account so it's executing on the uh the transaction as you can see and now it's complete so if i were to go to uh my account right now i could show you that i have at least 100 srt in my account and i'm not going to show you uh what that is it's not worth it but but this is a kind of a page that displays all the information on the transaction so i sent them 100 supposedly i was charged a dollar and one cents and the amount that i actually received in my seller account the amount of srt is 98.99 and it you know tells you when it was completed in the status and all that kind of stuff uh so this flow of being presented some forms filling out forms being presented updates as the transactions submitted and then finally getting a you know notification that's complete that's going to be the user experience behind the scenes blogs is going to be doing a lot more and i'm going to walk through what that is okay so that's the end of the demo we're gonna go into the code and uh here we go bear with me in case uh something happens because something always happens in demos uh but let's see how far we get i think we're gonna be able to do it so like i was saying with any python project you're going to want to create a virtual environment so i'm going to create a virtual environment right now using python 3.
- um and i have a little shortcut that activates the virtual environment um but let's just do it you know the normal way so i'm just going to execute the activate function for the virtual environment so this is dot vmv and activate uh okay so now i'm in a virtual environment this little enclosed box where i can install my own packages and make sure you know everything that i'm doing here is contained in here and it's not affecting anything else outside my project and before we do this actually i'm going to go to the documentation so this is the polaris documentation it's available at django polaris dot read the docs dot io and it's going to walk you through how to install polaris now i'm going to update this documentation in the future i'll probably have some kind of like tutorial page where it gives you a you know front to back how you set up basically what we're doing in this talk but for now i'm going to hop around these settings in these documentation uh pages because you know they have different information and it's not organized in one way where i can just kind of scroll through um so the first that we're gonna do we're just gonna copy and literally walk through these steps uh we're gonna install polaris uh and while that installs i'm just going to go over kind of what it holds you know obviously it holds django and it holds it really holds everything that you're going to need to run this application so you don't need to actually install g separately or anything like that everything comes with polaris and it's ready to go uh so that's done now and uh now that we have the uh django polaris package we have django installed now because polaris comes with everything and what we're going to do is we're going to create a django project now um this is yeah so i have this function called or this command line tool called django admin which comes out of the box with chango right so i'm going to create a django project start start project and i'm going to call it app it's going to be super generic okay now if i look i actually have an app folder uh and you can see it in my in my source tree uh if you look in app uh i have a manage.pi script and this manage.pi script is basically the entry point to all of django's functionality so whenever i run python within the django context i'm going to run python manage.pi some command and then within the app i have all the files that are necessary for a django application and we're not going to go over again this is a django tutorial we're going to assume that you know generally what this is but it's helpful to understand where we're at so um let's get started so now that we have uh our django project uh we have an app set up uh we are going to add polaris to our app to our project right so the first thing that we need to do is add these three apps here to the installed apps list in settings.pi so let's open up settings.pi this is a generated file that django creates for you it comes with a secret key that you're definitely going to want to keep secret so you would never want to check this file in to get you know it just being auto-generated you want to use environment variables and hide you know those those secrets from from users and developers um but uh but yeah this is a generated file for django and here's our installed apps list and we're just going to copy and paste the three apps that polaris requires into the list now let me go over what these are so uh this package called cores headers this is a different package outside of polaris that is installed with polaris it ensures that your server allows requests to set 24 endpoints from any uh service or client um so it just sets the course policy for the server um this rest framework is a uh it's just a another app that polaris uses to build out its api and then finally you install the polaris app and because we have our own app right because django so this is a project right this app is a project but within the app i know that the app and project word is going to get confused here but within the app directory we have a django application called app so i can change the name of this top level app thing that's the project directory and then within the project directory we have the app directory and the app directory is essentially the app that we are running right alongside the other apps that we have installed in our installed apps list so i'm going to also add app uh to the installed apps list too um the next thing that we're going to do uh is we're going to add the coors middleware so that course package that i told you about it requires a middleware component uh jingo comes default with a bunch of middleware uh and our documentation actually requests that uh the coors middleware is above the common middleware so this is necessary for django reasons um the middleware is the order matters i'm not going to go too far into deep into it but you want to make sure that we have all the components that we add and the correct ordering at least in this section um cool and then finally we're going to add a project root setting to our uh to our project and this is going to tell polaris essentially where the top level is and it's going to look for an environment an environment file at the top level of this uh project so i'm going to you know initialize project root and i'm actually just going to make it the directory containing baster so baster it was generated automatically by django but it's actually this folder right here it's the right or actually is it so there's the file it takes the absolute path of that it's the directory containing that file oh it's actually this file so this is the application folder that baster is referencing and so i'm going to take the directory that contains that directory so uh project root is going to be my actual project polaris anchor 3.

On July 24, 2020, the Stellar Development Foundation hosted "How to build an anchor with Polaris", a developer session for the global community. Builders traded notes on Anchor, Polaris, and Django.

hey guys um welcome to the the engineering talk uh we are going to begin momentarily um one thing i will say and i think uh our host has posted in the channel but uh if you have questions while i'm going through this talk go ahead and scan the qr code and you can send questions over and i'll i'll take a look at them at the end of the discussion um okay so uh yeah welcome this is

Key discussion threads:

- Anchor anchored the developer session as speakers compared real-world examples.
- Practical demos highlighted how Polaris applies to Stellar builders.
- Attendees outlined next steps around Django for upcoming releases.

<details>
  <summary>Video Transcript</summary>

[00:00] Hey guys, welcome to the engineering talk. We are going to begin momentarily. One thing I will say and I think our host has posted in the channel- but if you have questions while I'm going through this talk, go ahead and scan the qr code and you can send questions over and I'll take a look at them at the end of the discussion, okay? So yeah, welcome. This is a talk about polaris, which is a django application and framework that allows you to build anchor servers according to the standards that we define, that are called Stellar Ecosystem Proposal or SEPs. So django polaris is a tool that we use

[01:00] So that our tool that we build so that anchors can get their anchor service up quickly and with less work required. So I'm going to go into the details of how to build this anchor, but before I do, I'm gonna go over a brief presentation that just describes what it is, how it works and what you can expect in this presentation, so let's go ahead and begin. So, like I just said, polaris is a django anchor app, or I'd like to say it's an extendable django app, which means that if you know anything about django- and hopefully you do in this presentation, because I'm going to be going into django code- but django is a system, it's a framework that allows you to plug and play different applications within the project, and so polaris is an app. It's a reusable app that you can plug and play within django applications, and it provides an interface, an api, that developers can use to

[02:00] Insert and customize the way that the anchor server responds and handles information. The reasoning behind this is that set 24, which was the original standard that we implemented this for, has a lot of things that are standard about it. Every anchor is going to be doing similar things. They're all going to have info endpoints, they're all going to have what the step describes. And when I say the set- sorry, I'm just going to break out of my. Actually I'll stay in the slides until afterwards, but 724 is a standard and it defines an api for clients to be able to hit, in order to interface with the anchor, and every anchor that implements sub 24 has the same endpoints. The difference, though, is that every anchor has, you know, pieces of functionality that are custom to them. So, polaris, what it does, is implement the stuff that's standard, that everybody's gonna do, and then it allows people to customize their own instances with their- you

[03:00] Know, their- unique situation. So, overall, it's less time for the anchor to build. People can typically get this up within an hour, because we're gonna do it right now and we maintain it. The SDF maintains it, so we're gonna continue to upgrade this, make sure it's up-to-date with the SDK, make sure it's up-to-date with the SDK upgrades and it's open source. Everything that I am going to use right now is viewable on github, and we have links for the documentation and code in following slides. So, in order to understand polaris, we need to talk about integrations. Polaris offers integrations or integration functions or classes that allow anchors to register custom functionality with polaris. So polaris is going to facilitate you know the api endpoints and build out what a step 24 server would be. But there's things that polaris can't automate right. So polaris can't automate your banking or payment rails right. If you're an

[04:00] anchor in brazil, you know me as the developer of polaris. I don't know what bank you're connecting with. I don't know what api you're using. I don't know anything about that. So what you need to do is inject your own banking and payment rails code into the polaris framework. In the same way, we don't know what information you need from users. So you may need email and that's it, or you may need a photo of the ID. You may need, you know, a variety of different information: social security number. Here in the U.S. There's a bunch of stuff that you could need, you could require in order to deposit or draw assets, and so KYC kind of goes hand in hand with user tracking. You want to know who's using your service, who they are, how to reach them, stuff like that. There's uli customization. So polaris comes out of the box with a decent ui. But if you want to customize that ui, you're free to do so. And finally there's just transaction processing. When the transaction gets to a certain state in

[05:00] The flow, you may want to update some in your own data models to adjust for the change, and so polaris can't automate any of those things. So it provides rails integration classes. So you would in your code you would write, you know, within the rails integration class, a function that connects to your bank and actually makes payments to users, and you're going to register that integration that you write with polaris. And I'll show you how to do that, so that transitions. You know well how do you use polaris. Well, we're going to do two things in this talk: we're going to install and configure polaris and we're going to implement the integration points, or at least enough integration points, to get the anchor server up and running, and so there's going to be a few steps involved in that. We're going to create a django project and hopefully people who are viewing this are familiar with django and are familiar with the SEPs. I'm gonna brush over some details about the steps so you have some context, but overall this talk is gonna assume that you

[06:00] Know what I'm talking about. When it comes to django and start ecosystem proposals, you're going to install the django polaris package. We're going to add polaris, the django app itself, to the project and then we're going to add a bunch of polaris settings and configuration options and finally, we're going to register and add our data or asset that we're going to anchor within our database and in the asset that we're going to anchor in this database is a or on this anchor is our Stellar reference token, srt. It's just a fake token on test net that doesn't mean anything, but it's used as demonstration so you can show, or show I can show- how people you know build anchor services around an asset. Once we have all the configuration installation set up, we're going to start implementing integrations. So the first thing that we're going to do is build a an appropriate tomo file and, if you're familiar with step 1, this is

[07:00] Implementing that. It's basically a file that describes the organization that owns the anchor and it gives a bunch of details about contact information and stuff about the asset that clients who are viewing the file are to need to know. We're going to do a little bit of some banking rails, so we're not going to connect to any particular bank, and so we're actually going to kind of just mock this up. But the idea is that you would fill this function in with actual banking payment rails code. I'm just going to do what's required from a functional standpoint to make sure polaris is working. Once we have the tomol and banking rails integration set up, we're going to register those integrations and then, finally, we're going to build the application with docker and get it running. So hopefully that gives you a good overview of what's going to happen here. And again, remember, everything that I work on here is open source and there are there's documentation available. So if you want to check out the documentation, it's available at djangopolaris readthedocs io and

[08:00] The code is available at github com polaris and these pictures are the are some pictures from our test server or our reference anchor server that shows you how to do it. It's basically an example, and these are just some forms that plars provides out of the box. So this is what the ui looks like. If you didn't do any customizations, okay, and we're gonna do questions after the demo, but for now I'm going to transition into coding and I'll probably be hopping back and forth from the internet as well to reference the proposals and just demonstrate certain things. Okay, cool, we are right on schedule. So this is pycharm. I'm gonna be. You know, django. Polaris is a python application and what we're gonna do when we start off most python applications is create a virtual environment. So, actually, sorry, before I dive into the code here, I do. Before

[09:00] I dive into the code here, I do want to show you one thing, and that's a demonstration of what you can expect an anchor to look like from a user's perspective, and this is a little demo that we do. So what I'm doing here is: this is a little demo wallet that mocks like what a user would see, and we're going to walk through a step 24 flow before we get started so you can just see what it's going to look like. But we're just going to use our reference server that the seller development foundation runs and provides, and we're just going to walk through a deposit flow on testnet. So this is what we're going to ultimately build. We want to get to this point by the end of this talk. So I'm going to make a deposit, it's going to go through the step 24 flow and it's going to open up the actual interactive page the user is going to see. So if I was a user, this is the first form that would be presented to me. I'm trying to make a deposit onto into my account on Stellar, and here is the amount field that's asking

[10:00] Me- you know to specify how much I plan to deposit, and so I'm going to tell them that I'm going to deposit a hundred dollars and on test net anchors need to assume that deposits are actually sent right on testing. Everything's fake, right. So I'm not actually gonna send money to the anchor, it's just gonna assume or understand that it's on testnet and it doesn't need to wait for me to actually pay them. It's gonna pay or send, you know, Stellar funds to my account. And just to give you some like more context, this con config option, this is obviously the reference server that we're hitting the url of it. But this is the secret key of my account and don't worry, there's nothing you know. Fancy on it. You can check it out on testnet. But I'm just gonna deposit a 100 or 100 srt into my account on testnet. So let's go ahead and do that. And so now, django polaris, after I submitted the amount is going to go ahead and work on depositing that, those funds, into my account. So it's executing

[11:00] On the transaction as you can see, and now it's complete. So if I were to go to my account right now, I could show you that I have at least 100 srt in my account and I'm not going to show you what that is. It's not worth it. But this is a kind of a page that displays all the information on the transaction. So I sent them 100, supposedly I was charged, a dollar and one cents and the amount that I actually received in my seller account, the amount of srt is 98 99 and it, you know, tells you when it was completed in the status and all that kind of stuff. So this flow of being presented some forms, filling out forms, being presented, updates as the transactions submitted and then finally getting a you know notification, that's complete. That's going to be the user experience behind the scenes. Blogs is going to be doing a lot more and I'm going to walk through what that is okay. So that's the end of the demo. We're gonna go into the code and here we

[12:00] Go- bear with me in case something happens, because something always happens in demos, but let's see how far we get, I think we're gonna be able to do it. So, like I was saying with any python project, you're going to want to create a virtual environment. So I'm going to create a virtual environment right now using python 3. And I have a little shortcut that activates the virtual environment. But let's just do it, you know the normal way. So I'm just going to execute the activate function for the virtual environment. So this is dot, vmv and activate. Okay, so now I'm in a virtual environment, this little enclosed box where I can install my own packages and make sure you know everything that I'm doing here is contained in here and it's not affecting anything else outside my project. And before we do this, actually I'm going to go to the documentation. So this is the polaris documentation. It's available at django polaris dot- read

[13:00] The docs dot io and it's going to walk you through how to install polaris. Now I'm going to update this documentation. In the future I'll probably have some kind of like tutorial page where it gives you a you know front to back how you set up basically what we're doing in this talk. But for now I'm going to hop around these settings in these documentation pages because you know they have different information and it's not organized in one way where I can just kind of scroll through. So the first that we're gonna do, we're just gonna copy and literally walk through these steps. We're gonna install polaris and while that installs I'm just going to go over kind of what it holds. You know, obviously it holds django and it holds- it really holds everything that you're going to need to run this application. So you don't need to actually install g separately or anything like that. Everything comes with polaris and it's ready to go. So that's done now and now that we have the django polaris package, we have django installed now, because polaris

[14:00] Comes with everything, and what we're going to do is we're going to create a django project. Now this is: yeah, so I have this function called. Or this command line tool called django admin, which comes out of the box with chango, right? So I'm going to create a django project- start project- and I'm going to call it app. It's going to be super generic, okay. Now, if I look, I actually have an app folder and you can see it in my source tree if you look in app, I have a manage pi script and this manage pi script is basically the entry point to all of django's functionality. So whenever I run python within the django context, I'm going to run python, manage pi some command, and then within the app, I have all the files that are necessary for a django application and we're not going to go over again. This is a django tutorial. We're going to assume that you know generally what this is, but

[15:00] It's helpful to understand where we're at. So let's get started. So, now that we have our django project, we have an app set up. We are going to add polaris to our app, to our project, right? So the first thing that we need to do is add these three apps here to the installed apps list in settings pi so let's open up settings pi this is a generated file that django creates for you. It comes with a secret key that you're definitely going to want to keep secret, so you would never want to check this file in to get you know it just being auto generated you want to use environment variables and hide. You know those secrets from users and developers. But yeah, this is a generated file for django and here's our installed apps list and we're just going to copy and paste the three apps that polaris requires into the list. Now let me go over what these are. So this package called cores headers- this is a different package outside of polaris that

[16:00] Is installed with polaris. It ensures that your server allows requests to set 24 endpoints from any service or client, so it just sets the course policy for the server. This rest framework is a. It's just a another app that polaris uses to build out its api. And then finally, you install the polaris app and because we have our own app, right, because django, so this is a project, right, this app is a project, but within the app I know that the app and project word is going to get confused here. But within the app directory we have a django application called app, so I can change the name of this top level app thing. That's the project directory. And then within the project directory we have the app directory is essentially the app that we are running right alongside the other apps that we have installed in our installed apps list. So I'm going to also add app to the installed apps list too. The next thing

[17:00] That we're going to do is we're going to add the coors middleware. So that course package that I told you about it requires a middleware component. Jingo comes default with a bunch of middleware and our documentation actually requests that the coors middleware is above the common middleware. So this is necessary for django reasons. The middleware is the order matters. I'm not going to go too far into deep into it, but you want to make sure that we have all the components that we add and the correct ordering, at least in this section, cool. And then, finally, we're going to add a project root setting to our project and this is going to tell polaris essentially where the top level is and it's going to look for an environment file at the top level of this project. So I'm going to, you know, initialize project root and I'm actually just going to make it the directory containing baster. So baster, it

[18:00] Was generated automatically by django, but it's actually this folder, right here, it's the right, or actually is it? So there's the file it takes the absolute path of that. It's the directory containing that file. Oh, it's actually this file. So this is the application folder that baster is referencing, and so I'm going to take the directory that contains that directory. So project root is going to be my actual project, polaris, anchor 3. And this is important because we're going to add a dot m file and this is going to contain all of our environment variables that customize part of polaris deployment. So let's go into there. And polaris has a few environment variables right there that I need to just stick in the file. So you know, for the network that we're using, we're going to be using the test net, so this is the network pass phrase for that network and then this is the Horizon

[19:00] Instance or url of the instance that we'll be using, and then this is our host url. So we're going to be doing this all on localhost. So I'm just going to do localhost dot 8000. There we go and that's it for environment variables for now. And then we are going to add polaris urls, all the endpoints that polaris exposes to our django application so that it's actually exposed. So it's going to give me, It's going to complain to me right now because it doesn't have some of these functions. So we're going to import, include, and then we're also going to import polaris urls cool. And so I don't know if you're familiar with some of you maybe- but so we have this admin endpoint. That's already there. It comes default with every django deployment and then on top of that, at the root of the domain. So in order to get to the admin page, you would

[20:00] Go to your domain admin in order to hit any of the polaris endpoints, it's just straight on the domain. So polaris. So polaris comes with a bunch of urls. Oh, you know what it's cause? Pycharm doesn't know where my virtual environment is. I was going to go into the source code and show you what's offered. But polaris offers a bunch of endpoints. In fact, they're described right here. All these endpoints polaris provides, and those urls are going to be exposed at the root of the domain. Okay, so now that we have our urls installed, we're going to where's the documentation link? Okay, now that we have our urls added to the project, we're actually going to stop here, because this is a, this is set up. That's going to be required for every installation of polaris. But now we're going to go through the steps that we're actually going to deploy, so polaris can deploy any number of steps in

[21:00] Any combination. So you could you in polaris and just deploy step one, which is a tomophile. You could deploy polaris and just do step 10. You could do polaris with everything. You could do it with one of them missing, and so forth. Right, so we're going to set up polaris for step 1, 10 and 24, and that encompasses everything that's required in order to successfully run a deposit withdrawal. So let's go to step one. The configuration required is just to add it to our active steps list. So this active SEPs list in settings is a key setting in polaris. It basically signals to polaris what we're running, what kind, what standards do we want to actually run on our server? Because we're not going to run them all by default, right, you may just want one of them, So we're going to add step 1 to our active steps list, and we're actually going to add step 10 and step 24 as well, and this is going to tell polaris what urls to expose so

[22:00] That you don't have like a SEP 31 url, so when you're not using it. Okay, that's actually all that's required in terms of configuration. We'll go into the integrations later. Step 10 has the same thing, except it requires a few new environment variables. So let's add. So this is actually. This documentation is incorrect. It says: add the following variables to your settings file. You don't need to add these two to your settings file. I'm going to update. This should actually go in your environment config and if you didn't know that, django would complain to you about it, so you'd figure it out. But yeah, so for step 10 we have this thing called a signing seed, which is essentially the server's password for signing transactions. That then the client would sign as well and then the server would authenticate. So I'm not going to go too deep into what step 10 is, but it's just a way for servers to confirm that a user that's using their service holds the account that they're actually trying to

[23:00] Deposit to, and this should just be like a random key pair that you keep secret. So what I'm going to do is I'm actually just going to import Stellar's SDK import keyboard class and I'm just going to do a random key pair and then I just have the signing seed listed in the environment. So, again, this is something you'd want to keep secret. This would not be checked into git and this obviously won't be deployed, but the code that I'm writing right now will actually be available in on my github and I'll send a. You know, I'll show a link and maybe we'll actually have it in the description of the event. That'd be awesome too. So you can obviously reference what I'm doing here or just watch the video back. Okay, and then the

[24:00] Server jwt key. So once the client is authenticated, the server is going to return a token that's essentially the client's password for interacting and hitting the server's endpoints, and you just want to have a secret string that you use to encode the jwt. So we're going to have this super secret jwt string. You'd obviously want to make this something different, cool. So now we have everything we need for step 10. Let's go to step 24. Again. We need to have the step 24 string in our active steps. We already did that. But one thing that we need to do on top of that is configure our static assets. So, as you saw in that little demo, polaris comes out of the gate with a ui that's built in and ready to go for you to use and customize if you want to. And it does that by having the static files app installed and having static resources to use for the ui. And so we're going to configure the static resources in order to work and deploy. So,

[25:00] In order to do that, we're going to. So, white noise to our installed apps list, and white noise is a static file serving application. It just makes serving static files more efficient. So we're going to do that, we're going to go to settings. We're going to go to installed apps. Oh, actually it's a middleware. This is another thing I need to fix. The documentation will be updated by the time I release 1 0 django is her. Polaris is at 0 12 right now. It's a pre 1 0 release, but anyway, this is supposed to go in the middleware, so let's go to our middleware section. It should be above it should. It says it should be near the top of the list for best performance, but still under coors middleware. So we're going to go under coors middleware, cool. And we obviously want to make sure

[26:00] That the static files app is actually in our installed apps list. And then, finally, we have some more settings for our settings file, and these all pertain to the static files app. So we're gonna have a root directory to contain all of our static files. So each app that we installed rest framework polaris- even the app that we're using right now- has static files that it's going to use when it's running, and so what django does is it collects all those apps into one spot instead of having to fetch them from a particular app. So we're going to call a directory called collect static, which is the name of the command that we're going to use to collect those files, and we're going to have it be within the base directory, so it's going to be just outside our inner app directory. This is the url that our static assets are going to be available at for django. So I'm just going to say it's polaris static, and then we're using this storage component for

[27:00] The white noise static file serving section. So this is just one of the many ways that white noise can store files and then return them when they're requested by the client. Okay, and then, in order to collect those static files, we're gonna run our first command from manage pi and we're going to collect our static assets. Where did my camera go? Okay, there we go. Okay, so we're going to run that command. But that didn't work because we're not in the same directory as the app or the manage pi script. That's within our app directory, okay, so it gave me an error and it said: nope, you're not ready yet, you don't have a signing seed, environment variable. But we do. So what's the problem here? Oh, I know we don't have our settings file. Our django project isn't aware of our

[28:00] Environment, and that's that needs to be fixed. So we're going to import django, environ or environ. This is a package that comes installed with polaris and we are going to check. We're going to have an environment object. We're going to check if the path to our environment exists. So you remember how we are going to. I told you we're going to use project root to know if the environment is there, or that's where we're going to look. at the directory, the project group directory, and we're going to look for a dot m file in that directory and then, if it's there, we're gonna read that file. Okay, so now let's try this again and hopefully it knows that we have a signing seat. Now end

[29:00] Is not defined. You're right, it's because it starts off with the environment package. Okay, so now it's complaining about the server jwt key. That's in the same file as the other environment so or as the other variables. So I wonder why this is complaining about that, but not the signing seed server jwt key? Is it because we have this spacing between the environment and or the equal sign? Yeah, it was, I guess. Okay, we have one more step that I glossed over. I guess there's one more middleware. Oh right, okay. So before we so we set up so this page for this documentation is forcep6 and set 24, because they share a majority of the integrations that polaris offers. But

[30:00] There is some setup that's necessary for step 24, particularly and specifically. We have this same site middleware class that comes custom with every polaris deployment and this is more of a legacy component. We now suggest that anchors- or sorry, that wallets show anchors- interactive flows in pop ups but originally they were we instructed people to open them via iframes in order to have sessions within an iframe, you need to have certain http headers, and so this middleware class was born to inject those headers into every response. So this is required just in case clients open up your interactive flow in an iframe as opposed to a pop up so let's add this middleware class and then we can go ahead. Okay,

[31:00] Now it's added, and it's supposed to be above session middleware or, sorry, below. Oh no, session nowhere should be below same side middleware. Okay, and then, finally, we need this form renderer class, and this is going to allow for that, really for that ui that we provide, and it's going to allow you to override any of those assets. So this is needed if you want to, you know, overwrite any static assets or use the default ui, which you're going to want to do if you're running step 24. Okay, let's. Okay, we're done with configuration. Now, hopefully, this will allow me to compile my static assets. There it goes okay. So now we have a new directory called static or collect static, and it holds all the static assets that we're going to use within our application. So that's great, and I think, now that we have everything, and

[32:00] I think, now that we have everything set up from a configuration standpoint, we are free to go back to our database model section and actually create our asset. So let's double check. actually, yeah, let's- before we run the service. Let's create our database. So, in order to create our database, we need to run this migrate command, and in order to do that, we need to- make sure that we have a place for the, data to go. So we're going to create a data directory outside of our application and there's going to be a sqlite file that is stored in that directory. And polaris also comes out of the box supporting postgres, and if you want to use mysql or some other engine, you're free to do so, as long as you configure your database appropriately in the settings file and you install the appropriate connector. Django comes out of the box with psycho pg, which is a connector for postgres, but if you

[33:00] Want to use mysql or something, install your connector and then configure your database and it should be fine. Okay, so now that we're about to configure our database, we're going to do something a little different. Instead of having this config in database, we're going to use django environs db function, which is something that I like to do because it simplifies. It just simplifies the configuration. So, instead of having that dictionary, we're going to have a django environ m d or no, it's going to be m d b and then within. Actually. So I'm gonna look at a project that I ran through prior to building this, because I've done this before and making sure I'm doing it right. So let me look at the code here and just make sure I'm doing this correctly. Let's just copy that. So we're going to configure our database to use an environment variable to find the db and

[34:00] If that doesn't exist, then we're going to have an sqlite file that we use. So, as you can see, we're using environments database and we're going to look for the database url in the environment. If it isn't there, the default url that we're going to use is an sqlite path looking for data- db sqli3 within our project root directory. Now that we have our database configured, let's try to create our database with python app slash, manage pi migrate, boom, our database is created and all the migrations have been executed, so our database is in the appropriate state. That is awesome. So, again, polaris is a application. Right, it's not just an SDK or a framework. It comes fully implemented with endpoints, database models, you know, static assets. It's a full fledged app. The difference is that it also provides a framework or an api interface for you to customize its behavior. So

[35:00] It holds two different tables, two database tables- asset and transaction- and we're going to create our asset. Right now. This is the asset that we're gonna anchor on our server. So we're gonna go into the python console, load the model for the asset object and create nasa in our database. So we're in python from django, from polaris, we're going to import our model and in our model we're going to create an asset object with the code srt, because that's the code for the asset that we're anchoring and the issuer is going to be the address of the issuing account. And so when you're setting up your anchor, this is going to be different for you, right, you're going to be anchoring a different asset with a different code and you're going to need to actually issue an asset. And we have materials, documentation that documents how to issue assets. But for now,

[36:00] We're just going to use the srt asset here. So here is the public key for the issuer, and I'm actually that's all I'm going to do for now. I'm going to also enable sep24. This asset object also needs the distribution seed. So there's two accounts for every asset: there's an issuing account and there's a distribution account. The distribution account is the one that's actually going to be receiving and sending payments, and so we're going to need to control this account from polaris. So we need the secret key for that account, and I'm not going to show you right now in this screen, but I'm going to add it to this asset in another screen that you guys can't see. So, yeah, just give me three seconds to add that. And

[37:00] This distribution seed, by the way, is going to be stored in our database, and this is always something that you'd want to make sure is secure. It's going to be encrypted in the database. So whenever seeds are stored in the database, they're encrypted, but their own, but then they're decrypted when they're brought into memory. So I'm going to import or I'm going to add this secret key for the distribution account of srt and it's going to allow my polaris to control the distribution account. Cool, okay, so I just added the distribution seed and so now if you look at the asset in the

[38:00] Database, just look at the distribution account, it generates the account from the seed that I entered. So that's available as well. Okay, now that we have everything we need in that department, in the asset department, we're going to test out our anchor, so let's go ahead and do that. Okay, so we've configured it. Everything is correctly configured. So let's actually run our service and see what we got here. So I'm going to go to manage pi and run the server. Okay, cool. So, as you can see, django has a server running at dot localhost 8000 and so if we go there, you can see that we actually don't have anything on our route and that's okay. But we do have endpoints for step 24, we have the authentication server, which is septen, and we have the tomo file.

[39:00] So let's check out our tomo file. So this is a very empty tomo file. It has the standard, you know, pages that you would expect from an anchor, but it's a locking sum. So polaris implements the tomo file, but it allows you to customize and to add things to it. So this is the first integration that we're going to tell polaris that we have additional information to display in the tumble file. So we're missing information about the currency. Is it anchored? Is it a crypto asset? Is a fiat asset? What kind of asset is it what? Who is the organization behind this server? You know what's their contact information. This kind of stuff is missing from the tone when we're going to add it right now. Okay, so let's get out of our settings. We're finally done with the settings. We're done with the environment. The urls are set up. Everything's good there. Let's go to. Actually, we're going to create a new file, so let's stop our server process for a second.

[40:00] We're going to create a new file called app slash, integrations, and this file is going to contain all of our custom code. All the code that augments polaris is going to be in this file, and I'm also going to create an apps pi file. Now, apps pi is a special file that django looks for in every application that's installed in the installed apps list and specifically, it looks for a app config object within apps pi and it runs any code within the app config class before starting the application. So this is a good place for us to register our integrations. It's only going to do it once and it's going to make sure that polaris has the custom code that we write. So, from django app import, app config is

[41:00] Gonna inherit from app config the name of our application. And this is a django thing, by the way, if you look at the documentation, django outlines what this is and why you need to do it. So we're just gonna, again, our app is named app, nothing complex about it- and then we're going to have a ready function, and this ready function, is going to be run every time we start our application and it's just going to do any kind of setup necessary before running our service, and so what we're going to do is we're going to register our integrations here. So we're going to do from integrations import. Now we don't have anything to import right now, but we're going to import this tomo function first and then from polaris integrations we're going to import the register integrations function. Now it's actually not auto completing, which is kind of annoying. I'm going to see if I can configure, see

[42:00] If I can configure the virtual environment right now so it knows what django version we're using and actually auto corrects. And sorry, one second here: how are we doing on time? We're a little pushed, So, okay, this might go over a little bit for any of you who have just strictly an hour. I apologize, but we're gonna be in and around an hour. Hopefully I don't need the autocomplete stuff, but it will help for sure. Okay, yeah, no interpreter, let's use the local one in our environment, set it up. Okay, now we have django available in our ide and actually knows what we're using. So, register integrations: we're going to register our integration that we haven't even wrote yet. And

[43:00] Then why does it say that it doesn't have any of this. That's concerning I don't know what's going on with the highlighting right now. I thought I just configured my virtual environment correctly, but maybe I didn't. I'm not going to spend too much more time on this. Yeah, actually, this is not right. This is our, this is my system, python. Let's add the environment that I have in my. There we go okay. Now we're using the virtual environment. Let's give this a second to adjust. There we go okay. Yeah, but we don't have this tomo file still. But we're going to register our integration. So polaris provides this register integrations function and you can look at the documentation on it here. Registering integration: this is where you add the custom. You at this is where you add the custom code that you write to polaris so polaris

[44:00] Can use it, and so, as you can see, this is the exact same code that we're writing right now. We're registering our integrations and we're only going to register the ones that we have, so we're not going to register all the ones that are listed here, but let's get to it. So this is the code that's going to run, and it's only going to run as long as we have this default app config, environment or variable here. So I'm going to go apps dot, or, sorry, app dot, apps dot, my app config. That's going to tell django where to look for the code that needs to run before the application starts. Okay, let's go to integrations. We're going to just define this tonal function. It's not going to have any arguments, and we are just simply going to: yeah, that's all we need, actually. So let's let me show you what happens when we just have this. So we've registered

[45:00] The function, but the function has no code. Let's see what happens when we run the service. So it broke, and right now polaris is in debug mode. So you're seeing this nice ui that shows you what's going on in the code. Typically, it won't show you that. I'll just give an error page if you're in production. But what's going on here is that the integration that we provide, the tonal function- it's not providing what polaris expects, and so you're going to want to look at the tonal function that we need to integrate. So this is the step one integration that we're doing right now. We're integrating our tomal function, and our total function needs to have a dictionary returned containing any of the keys, the level keys, right here. So let's actually do that, let's return a dictionary and let's do the documentation section first. Now

[46:00] You can look at step one to see what fields that you can list here. So, within documentation, this is the information I'm gonna fill out right now. These are the properties that you can add. So let's add an org name. Let's add a- we don't have a logo. but I'm not going to get. We have a logo, but I'm not going to get it right now. That's our home domain and that's all I'm going to provide for the organization. But you get the point. You can add any of these other keys as well. Let's add some point of contact information. So polaris doesn't know who's actually building this and who's responsible for it. So that's why we have this tomo file in this, what

[47:00] They called point of contact or principles list. So it's a list, right? So we're going to have a multitude of these. We only have one, though, and that person's name is jake urban, and that's all I'm going to provide. I'm not going to provide my email or key base or anything like that, but again you get the idea. This is all information that's going to be injected into our tumble file. Let's re, let's add some currency documentation. So let's add a currency. We're obviously anchoring srt. Actually, let's just do: let's get the and

[48:00] We only have one asset in our database, so we're just going to get the first one, and then let's use the code of that asset and the asset issuer, okay. And then we're also going to add the status. So this, again, is a test token. Right, it's not actually real money, so this is a test token. Srt is the dominated using two decimal places, and we are going to give it a name. Okay,

[49:00] Let's see where we're at now. So, as you can see, our code is refreshing every time, or her service is refreshing every time we change our code. And now we have some more information on our tomo file. So congratulations, we've done our first integration with polaris. As you can see, it has a principles section. Now it has the name, that of the principle for this service. It has all the information on the currency section that we entered, and has some documentation about the organization who maintains this service. Cool, so that is so. This pattern of writing code, registering that code with polaris and then having pillars use that code. That that's the pattern of polaris. It has a lot of stuff that can do on its own, but when it needs extra information that it can't automate, it requests it from you via integration functions.

[50:00] Okay, so we are doing decently on in terms of timing. We have a couple more integrations to implement, so now we have our tummle. Let's see how far we can get in the demo that I showed you earlier. So let's go to this demo spot. Let's look at our demo site. Let's look at the config. We're not going to interface with our test anchor server on solar org anymore. We're going to actually work with our local machine. We're going to use the same secret key for deposit and withdraw of our srt and we're automatically going to walk through the process. I'm not gonna, you know, talk about exactly what's happening in the zep24 flow. So what happens here? Okay, well, that's good. So we have. So let's take a step back for a second. I will actually go through a little bit what's going on here. Our client, our wallet connected with our anchor. It hit our tomo file because it knows to expect

[51:00] A tomo file at our home domain. It determined that we have a transfer server. It got the information on our transfer server. So this is our, info endpoint and we actually haven't done any work here. Polaris does this completely on its own. Polaris responded with the client, or responded from, responded to the client all the information about the asset. So, as you can see, we're anchoring srt for deposit. It's enabled. We have a minimum maximum amount as well as a fixed fee in percent. This is going to be zero for the purpose of this demonstration, but you can change these. And then we actually went through authentication. So for step 10, authentication. You actually don't need to do anything either. Polaris influences straight out of the box and it also implements the deposit endpoint. So, once we got authenticated, we made a request to make a deposit, or the wallet did, and we responded. The anchor responded with a interactive url and

[52:00] The wallet opened up this interactive url for me, the user, to fill out. And so that's what this is: a out of the box default. Don't do anything. Polaris view here of this interactive flow. And so this is what the user would see. And I'm just going to say: I'm depositing a hundred dollars. There's no fee, right, so it's just a hundred dollars total. And when I deposit- okay, that's a pilaris thing. If you wait too long on the first screen, it can authenticate your session. So it's just 403. Let's go through this whole thing again so we have a fresh token and get through the flow. So 100, oh, okay, so this is actually a key piece of development locally. So it keeps on giving us 403, and that's because polaris, by default, expects to be working over https and if you aren't on https, it doesn't allow you to go into the interactive flow. We can turn this off by adding a environment variable called local mode, okay.

[53:00] So now that we have this process and we're running in local mode, let's see what happens. Okay, let's try that one more time. Let's restart this service. Oh, actually, yeah, I think that's still. That makes sense. The code, the service restarts when the code is adjusted, but not when the environment's adjusted. So let's do that now that we've added our local mode environment variable. Sure, okay, so cool. It successfully, or it accepted our deposit request and it's now the anchor we're building is waiting for me, the user, to send the funds to the anchor. Now, on mainnet, when you're doing this for real, you're going to want to periodically ping your banking connection and see if I have

[54:00] Sent the deposit that you have, that I have initiated, right, and so again, there's a process in the background that periodically pulls all the pending transactions, all the transactions that we know the anchor knows we can expect payments into our bank account for, and once they're there, once we determine that a user has made a deposit into our bank account off-chain, we're going to then going to deposit the same amount of funds on chain, and so that's how an anchor works with deposit. But, as you can see, nothing's happening right now. We're just continually pulling the anchor and it's still in this pending the user state, and that's because we aren't running a process on our server that checks for pending deposits. So let's get out of this interactive flow here. We're not quite done yet. Okay, let's stop the server. So this is a good point to talk about polaris.

[55:00] So polaris is a web server, right, it implements the api endpoints defined in step 24, but there's also a variety of other tasks that polaris needs to perform in order to function properly. One of those is checking up on pending deposits that we can expect from users, right, and so in order to actually check up on this, polaris comes default with a pull pending deposits command line tool. So what you would do is you would have the server running and you would also have this pull pending deposits process running as well, and it's going to loop. We could run this once and just check once for pending deposits, or we could loop and run this. I misspelled. It sounds like pull pending deposits. Okay, so complain to me, though, because I haven't implemented the integration. It says: you know, you're not ready to run this command line tool because you haven't implemented pull pending deposits yet, and

[56:00] You're right. So let's go to integrations. So our first integration was just a function that we pass to polaris, but this second integration is actually a part of a bigger class. So we're going to implement a rails integration class. So rails integration is a class, an integration class that we're going to subclass and implement the functions outlined in rails integration integrations. Okay, so we're going to define this pole pending deposits function, and it comes with a bunch of type ending that I don't have import imported currently, okay,

[57:00] And we actually are just going to return a list of all depending deposits. So this is polaris. So polaris is going to call this function periodically from the pole pending deposits process that we run and it's going to expect that we connect to our bank, look to see if there are any pending transactions that have actually been sent to us and then return the ones, return the transaction objects that are passed, return them back to polaris so players can actually submit them to the network, right and so, because we're not actually going to receive any payments on testnet, we're actually going to just return every pending transaction and mark them essentially as ready, and so this tells polaris to go ahead and move on and submit the transaction. So let's go ahead and run this again. Let's run our server function and now let's run our python

[58:00] App, manage pi pull pending deposits process and loop it. So it's always running okay, it's still giving me problems because I actually haven't even registered this function right. So now I have my tomo, but I also have my. So now I have my tomo, but I also have my rails integration class. So I want to register my rails integration class with the rails keyword of the register integrations function. Boom, so now my pole putting deposits code is registered with polaris and running the pull pending deposits function was successful and I have my server running. So let's go through a process again and see what happens. So this is the same as the last time. I'm going to just say I'm going to deposit 100 and polaris is just going to move on. It's going to assume that I sent it. So Stellar is actually executing the transaction now and it's actually on the seller network. It's

[59:00] Giving me srt in the tote in the wallet that I used. Boom, there you go, complete. So if I were to look at the account that I'm using for this wallet right now, I would see that I have at least 100 srt in my account. The polaris server, using the asset that I'm issuing, deposited funds into my seller account after me entering information. So there you go. That's the deposit endpoint. It's fully implemented, ready to go. It is 11 o'clock an hour on the dot and you have a deposit flow working. Now there are other integration functions that I need to implement for withdraw. I think at this point, I have to decide: do I want to in terms of timing? Do I want to go further down and build out the deposit flow, or do I want to build with draw flow and just not go into detail in the deposit flow, because there's a lot more you could do? I think I'm going to do the latter, so I'm not going to do this in the talk. But there's

[01:00:00] Tons of customization that you can do using the integrations that pilars provides for the deposit flow. So, again, you can customize the ui, you can make it a different color, you can change the forms presented and then you can add forms. So, right now, in this demonstration, we're just asking for the amount, but we actually don't even collect anything about our users and again, this is custom to each anchor, right? So polaris doesn't do this automatically. Instead, it expects you, as the developer, to provide django forms. That's going to be presented to the user and then you can process. So I'm not going to go through this, we just don't have the time. But this integration, this, these section of integration functions, are called form integrations and they're actually available on the in the documentation. If you go to step 24 integrations, set 24 integrations, and this form integrations section outlines what I'm not going to do in this talk today, which is provide content for every transaction. So this is providing

[01:01:00] Forms and ui customization for every form that you need to collect: on the user, so if you need name and email and photo ID and anything like that, you can ask that from the user using polaris, using these integration functions, as long as you register them. But we're not going to do that. Instead, we're going to prioritize having a withdrawal flow, work, and to do that, we're going to run the entire service, so not just pull pending deposits. We're going to run every process that requires, and to do that we're going to use docker and docker compose. So I'm just going to copy and paste the docker compose and docker file from this project that I've already written. So copy docker file, copy docker compose and I'm going to go into the anchor that we're building right now. So we have these two files now and, if you look at them again, all the source code for this is going to be on my github. But

[01:02:00] This is essentially a config file that's going to run all the processes that you need to run in order to run a deposit and withdraw: step 24 anchor. So, as you can see, we run the server, the thing that actually runs the step 24 protocol. We run the pull putting deposits or, sorry, pull pending deposits process that I showed earlier. There's also three others for withdraw, and I'm just going to speed through this because we're going to do some questions afterwards and I don't want to go too far over. So we're going to build. Actually no, before we build our application, we're going to implement our reg, our integration functions for withdraw. So withdraw has some integration functions that it requires on top of what it. You know what you have for deposit. Specifically, it has this outgoing execute- outgoing integration function that you execute the transaction, this transaction or this function- polaris calls expecting you to actually make

[01:03:00] A payment. So this assumes you've received a withdrawal payment from the user on the Stellar network and you're actually going to send the same amount of funds off-chain to the user via your banking rails. So we're actually not going to do any banking rails in this right. We're not going to connecting to any bank. We're just going to mark the transaction as completed and say that we did actually submit it to the bank, even though we didn't. This is just for demonstration purposes. On in, when you're actually doing this and writing your integration functions, you will want to connect your bank, just like in full penny deposits completed, and we're also going to update the fee for the transaction. So right before we execute, we're going to mark or we're going to calculate the fee that we're going to take from the transaction. So the user send me 100, we don't have any fees in this demo. But you can charge fees and but for now I'm just going to say zero, right, so

[01:04:00] This function is going to be called every time we need to actually send a payment to a user and then finally, actually that's all we need for withdraw, I think, and we're going to make this multi process application by building: oh man, I need to start my docker daemon. That's loading up, so docker's getting started. Okay, it's five minutes over. I'm going to try to build the rest of the service in the meantime. I'm open to questions if we want to. I will just probably be working through this and demonstrating that withdrawal flow as I answer questions. So, to the host of this event, if you would like to give me some questions, go ahead and I'll answer them as we're working on this. Okay,

[01:05:00] So the you know one question is: why use django? That's a good question. Django has the tools necessary to do what we're trying to do, so flask doesn't have this reusable app structure, right. So django is a project that can contain any number of apps that you can plug and play. Flask doesn't have this requirement, or flask doesn't have this functionality, right? You have a flask application and what the code is in flask is what it is right. You can't just add an app. You can install a package and use that package, but you can't just plug and play an app. So that ability to just plug and play polaris, that comes with database models and endpoints. That's unique to django, and so it just made sense for us to do it this way as long as we are using the python stack. So

[01:06:00] We have our docker process up and we're building our containers, our containers. So again, this is: oh, what's the problem here? Service server fail to build copy failed requirements txt oh yeah, we don't have a requirements file. Let's create one pip freeze requirements dot text, and this is just putting all our dependencies in a text file. So when we launch our docker image, it can build them according to the file. Okay, so we're installing our dependencies right now, and this is probably just going to take a minute, and once that completes, we are going to compile our static assets. I think is the next step let's look at this docker file. Yeah, so we're going to install system packages.

[01:07:00] We're going to make a working home directory. We're going to make a data directory for our database. We're going to copy our app code, copy our environment requirements files. We're going to install those requirements and then we're going to compile our static assets. Then, once we've done all that, we're going to run the run server command and actually run our application. Okay, so now if I run docker, compose up. Hopefully this works. Yay, okay, so now we have all these processes: pull depending deposits, watch transactions, the actual step24 server, and we all have it running. So let's go ahead to our demo and look at what the withdrawal flow looks like. Now, again, I'm going to deposit 100. There's no fee and for a draw, the wallet actually submits the transaction to Stellar and the anchor is going to receive that. The anchor's going to receive that payment. So I'm confirming that I want to send this payment to the anchor. The

[01:08:00] Wallet is making a Stellar payment to that anchor right now. The our anchor service that we built is going to pick up that payment via our watch transactions process and watch transactions is going to then mark it as ready for execution. The polaris will then call our execute outgoing transaction function that we wrote and it will mark the transaction as completed. And, as you can see, our transaction has completed and so we have effectively withdrawn funds from our Stellar anchor account or from our Stellar account, and we now presumably have them off-chain in our bank account, and so obviously we're not collecting the bank details. So, like typically, an anchor would say: what's your bank account number, We need to know so that we can actually send you this money, and so we're not collecting that. And again, the documentation is there and polaris provides that functionality, but we're not going to request that information right now in this demo. Okay,

[01:09:00] Cool, awesome. So we're 10 minutes over, not too bad, but yeah, that's how you build an anchor using polaris. There are a lot of other integrations. Polaris is pretty extensive and it's in the beta phase or not beta phase, but it's in pre 1 0 release. So there are still breaking changes that are being made occasionally, but therefore, ultimately to become stable and to make a 1 0 release that will be coming soon- okay, cool, I think we're done in terms of demonstration. Now I'm going to open it up for questions. So that is a good question. So there was a question about node js and whether or not we're willing to make a version for node js and the ques. The answer that question is: keep asking. We've gotten a handful of requests for it, but

[01:10:00] The reality is that at the moment it's gonna be a lot of work for our team to maintain two different versions of it, so it's not worth it for us yet, but if there is significant demand, then we might deem it worthwhile. So make it known if you want to use node and we can discuss that further on github or via key base or however you want to contact us. I'm trying to think if there's anything else that I should mention. So this we did step 24 in this case. Right, this is, polaris implements step 24, but again, it also implements a lot of other steps. One that we just added support for is set 31. Step 31 is a set or a standard that allows two anchors to facilitate international remittance payments. So the idea is that user

[01:11:00] A would send money to user b by giving money to their to one acre. That anchor would send money to a different anchor and then the receding user would- or sorry, the receiving anchor is going to send that money that it received from the anchor, from the sending anchor, to the receiving user. So it's this little like anchor or sorry, user, anchor, user flow, and the cool thing about this is that users don't even need to know that they're using Stellar. It's just a payment from one bank account transaction to the next, and so plars provides the integrations necessary to support a sep31 receiving anchor. So if somebody wants to send you payments from across the world in a different currency and you want to use those funds that sent to you to then pay your own customers in their home currency. You can do that using polaris, step31 integration. Okay,

[01:12:00] So I think that's it for questions. Thank you guys for tuning in and hopefully you guys learned a lot about polaris and how it works. If you have any further questions, I'm available. On key base. That's where a lot of our SDF employees live in terms of chat and yeah, all right, thank you for tuning in. Have a good day, guys.

</details>

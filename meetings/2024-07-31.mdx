---
title: "The Future of DApps: Building on Stellar"
authors: julian-martinez
tags: tutorial
---

import YouTube from "@site/src/components/YouTube";

<YouTube ID="pfviOwq9gOQ" />

- Hello and welcome everybody.
- My name is Julian Martinez, senior developer advocate and common man here at SDF and I'm super excited to get today's session kicked off where we're going to dive into the basics of building full stack DAPs using Stellar smart contracts.

On July 31, 2024, the Stellar Development Foundation hosted "The Future of DApps: Building on Stellar", a developer session for the global community. Builders traded notes on Contract, Token, and Function.

Hello and welcome everybody. My name is Julian Martinez, senior developer advocate and common man here at SDF and I'm super excited to get today's session kicked off where we're going to dive into the basics of building full stack DAPs using Stellar smart contracts. Um, so this is going to be kind of like a freestyle like ad hoc session.

Key discussion threads:

- Contract anchored the developer session as speakers compared real-world examples.
- Practical demos highlighted how Token applies to Stellar builders.
- Attendees outlined next steps around Function for upcoming releases.

<details>
  <summary>Video Transcript</summary>

[00:00] Hello and welcome everybody. My name is Julian Martinez, senior developer advocate and common man here at SDF, and I'm super excited to get today's session kicked off, where we're going to dive into the basics of building full stack dApps using Stellar smart contracts. So this is going to be kind of like a freestyle, like ad hoc session. I don't have any slides or anything, But we will be using the getting started docs as well as an examp, a common example damp that you may have seen building stuff in your journey throughout the ecosystem. We're going to be using none other than the Soroban example d. All right, So a couple of repos here or a couple of links here. First things first, the getting started QR code, or the QR code that will take you to the link of the getting started section of the docs, And Then

[01:00] Later, maybe in the second half, When we start signing transactions, we'll transition over to actually cloning the Soroban example dApp And Then we'll kind of like dive into the ins and outs of that one. But for now we'll get started with a very simple front end readonly function call from our hello world contract. Now let's backtrack a little bit. To get started, you're going to need to actually install the Rust tool chain, or it's going to allow you to use tools like cargo and other Rust tools available in the tool chain. The second one is going to- or the second command here is going to tell the compiler to compile the Rust smart contracts into WASM. And the third command is going to install the Stellar CLI. So a little bit of a refresher from the last session, If you haven't already done this, So you can actually scan the QR code at the bottom left right here, as I stated earlier, to kind of like help guide you along throughout this next 30 minutes to an hour or so.

[02:00] All right, Now I'm going to make it aware that I can't see you guys in the chat Because I am using a thirdparty app, But I'm going to go ahead and get right into it. So we're actually going to clone a pre existing kind of like project And for this we're going to run the command Stellar contract init, contract init. We're going to specify the directories here, Then we're going to create a space, Then we're going to say front end template and we're going to say https, forward slash, and we're going to say github, github, comstellar, and we're going to say Soroban, astro template. Cool, No demo effect today. As you can see, That went in to the

[03:00] Directory that I'm working from. All right, So let's see what happened here. We are initializing the project at the root directory. We have a new cargo toml file which actually kind of like injects a compatible Soroban SDK into our project. Here we have example which we're going to need to edit a little bit later. We have our source folder which has some components in it. Right, you should see some things that maybe you recognize, maybe you don't. You have this card file here which is just basically like a cool little front end component that you'll see a little bit later. The pages file here kind of like holds all the main logic that you'll be seeing a little bit later as well. But yeah, So let's just go ahead and keep working through the tutorial here. So, first things first, we have this NV example file. Now you can either copy this over and make a new one or just edit the existing title to just say end, And

[04:00] We're going to change some of the parameters here. So you see, the standalone or the public sorbar network passphrase is actually going to target the standalone network. So we're going to erase this value and we're going to go ahead and inject the Soraon endpoint here. So public Soroban network passphrase or, excuse me, not the Soroban RP. We won't be injecting the Soroban URL here, But the passphrase instead. So we have test SDF network, September 2015.. Is the passphrase- this correct passphrase for testnet net? Then we're going to go ahead and change our public Soroban RPC URL to the correct endpoint here, which is https- semicolon Soroban testnetstellar org. Okay, And we already have a Soroban account called Alice and we're going to

[05:00] Just specify the network to be test net. All right, So let's go ahead and clear this out, All right. So what do we have here? Okay, We're looking at our what's it called Our project So far, And we've also updated our environment file. So what we're going to do next is actually just install some of the dependencies. We're going to do that by running mpm install, All right, So let's go ahead and take a look at what's happening here. All right, So nothing special here. We're just running mpm install, installing the dependencies for the project, Sorry. So we're going to go ahead and run mpm, run init for the next step, And what this is going to do is it's actually going to run the initialize js file. So, While this is loading,

[06:00] Let's just go ahead and kind of just like: take a look at what's happening here. All right, So we're processing the public key, right. And Then we're actually going to use that to deploy the, the smart contract. So we're going to use that as the signer to deploy, to pay the fee for deploying the smart contract itself. All right, So we're using the CLI command, the Stellar CLI. All right, So we're going to generate a new account which we defined here, right, Soroban account equals Alice. So we're going to say Stellar keys generate. And then we're going to say Alice, But we've already done that. So you can think of this function here as kind of like recursively or redoing the step where we fund an account that we would pay for the deployment fees with, But we've already generated that, All right. And Then we're going to build the files, Right. So what does that mean? We're going to use Stellar CLI contract build, which is going to compile the

[07:00] Smart contract files right, again in contract, down to its WASM format. It's going to store it in the target directory here. Next it's going to use: So Stellar CLI contract deploy. It's going to specify the WASM file, right, And Then it's going to deploy that right to test net. Once it takes, once it deploys the contract to test net, it's going to record the contract ID And then it's going to build the TypeScript bindings. So you see here, contract bindings, TypeScript contract ID, which is going to be the previous ID that was recorded. And let me see If I can get here just to the function itself. So you see, CLI contract bindings- TypeScript contract ID is going to be the ID we recorded And then it's going to store that in the directory name which we've defined here in

[08:00] Packages. And just as a quick kind of overview, you see this function, bind all, and there's also, I think there is a deploy all, yep, So you can have multiple projects within this directory. For example, you can import the incrementer contract or incrementer project here. It'll actually compile that contract, deploy that as well and create the TypeScript bindings for that. But for this we're going to just use the Hello World contract, All right. So let's go ahead and take a look at the source directory here And Then let's take a look at the Astro page, Cool. So let's just go down from top to bottom. We see import card, right, And here's just like a simple kind of just card that holds all of the data Just makes it easier to like, contain some of the data that we're trying to illustrate Here. We see:

[09:00] Import hello world from contracts hello world. Now, this part is pretty important Because you see here that we're creating a client and we've defined this client using certain parameters. So, like, what exactly does that mean? Well, When we create a client, you can think of this as creating like a smart contract object. When we created the TypeScript bindings, we actually compiled that data to its own package, right. So what does that mean? Let's just go here into the package json file. You see workspaces, packages, right. And let's go back into the initialize js file. If you see here contract bindings, typescript output, directory name is just going to be the name of the contract packages And then alias. So you see here that we're ingesting the packages

[10:00] Directory. And what, When you call the command contract bindings or Stellar contract bindings, you're creating ondemand npm packages for the smart contract itself. So let's go back into index contracts hello world, import any as the client or as client from hello world. Now let's dive into hello world itself. So you see here in pack, in the packages directory, under hello world, in the dist directory, Let's just go down line by line and see exactly what's happening. You see some imports coming from the Stellar SDK. Well, that's Because you actually you create your own node module sets for the Stellar SD or for the smart contract here that should import the node modules from, or the Stellar SDK node module Here, you can see, is clearly titled at Stellar

[11:00] SDK. A cool thing here is that it actually records the network data. So you see, If you're using test net as a point of data for your syntax, here you can actually reference network passphrase and contract ID, which we do in the When we're creating the client object object And then moving forward, you see that we're defining all the functions here along with the arguments. So you see, hello only contains one argument, which is two, and it's defined as a string. So this makes it really easy to kind of just like create front end components that leverage the methods on these smart contracts themselves. The bindings function that comes with the Stellar CLI makes it easy to transform the smart contracts over from Rust version over to the front end version After it converts the code to the JavaScript or TypeScript

[12:00] Output. You also have these like backup or like the, these supporting SDKs to communicate with the Stellar blockchain, all abstracted away from your development process, saving you a bunch of cycles. Long story short, it's a really good tool. I love it. I love using the Soroban or Stellar smart contract bindings personally and yeah, it just really saves a lot of time. So let's do a recap of what happened. In line four, We're importing hello world from contracts hello world, And here you could see that we're using the client to define hello world. Right, Let's dive into the hello world directory a little bit. As you can see, here again we're we have our own node module for the smart contract and it in it includes the Stellar SDK, which is going to help communicate with the Stellar blockchain, Also contains information about the network and,

[13:00] Last But not least, it contains all the methods included in the hello world smart contract. All right, So let's go ahead and see how we're going to leverage this. So you see, const result equals await. Hello world, hello. All right, So simple enough. We're awaiting a function here and the method is: hello. We're going to define the front end or we're going to find the message as two. All right, So we've already run the initialize function. So let's go ahead and run mpm, run And we're going to say dev. I think this is going to run the initialize function again. All right, 4321. All right,

[14:00] Let me go ahead and drag this on over here. Make sure, Okay, Cool, So you guys can see. You guys should be able to see the screen here. All right, So we see. Hello you. To get started, open the directory source pages page and tweak the welcome to Astro message above. I don't think that really applies to us. So, con result equals await, hello world. Hello to you. Let's say hello and world. An error occurred Must be a host value. So, So believe it was the exclamation mark. All right, cool. So we have hello world. So we're actually able to change that. This is we're able to do this Because we're not actually making a call

[15:00] To the back end. So we're just using a simple JavaScript kind of like manipulation and we're able to see the changes immediately thanks to Astro. So this is kind. I don't know If this is exactly exclusive to Astro, But this is like a way that you can easily test the outputs of your functions. For example, in this case we changed the hello world call, the two argument from world. We can even say like Stellar, right. So it's a good way to test your functions on the front end, Very lightweight, doesn't involve any communication with the Stellar blockchain, right? So that's a quick intro, But let's take it a step further, Because that's not all we want to do here, right? We actually want to take this a step further. First, by seeing If we can read some wallet data. So I'm

[16:00] Going to open up Frraider, All right, So you can see, I'm connected to the test net. You can see my address is G75ZKTV. Okay, cool. So let's go ahead and see how we can connect our wallet data to the front end here, and we're going to use Freighter. So, first things first, we're actually going to install the dependency. I don't think we have it yet. We're going to say mpm, install Stellar for slash freighter API. And here we're going to create a component. We're going to call this connect And, oops, connect. And we're going to one last time, connect freighter. And we're going to say dot, astro. And for this we're going to create a couple of things. We're going to create a div And then we're going to give it a style and

[17:00] Then we're going to give it a script. So we're going to say div and we're going to say ID equals freighter, equals freighter Wrap and we're going to say: All right, stick with me, y'all Class. And we're going to say equals- Let's see If co pilot saves me. Here We're gonna say Arya, live, equals. And we're gonna say live, Cool, We're going to close that div out or we're going to keep that div open- Actually, we're not going to close that out yet- And here we're going to give another div. We're going to say div class and we're going to say

[18:00] Ellipses. Here We're going to close this out. Then we're going to say button- Yeah, let's close that out. I'm going to say data connect- Arya, controls, area controls. And we're going to say equals, freighter wrap connect. And it should say button. This needs to be in quotes, Should be good. So far, Cool. So we're going to create some divs here and we're going to get set up with our kind of like environment, If you will, our front end environment for

[19:00] Hosting the little area that we will contain the wallet information in. So let's go ahead and give this a style real quick. So let's say style and we're going to want a wrap, right, Going to say wrap, And we're going to say text align, Text align, And sure, why not give it a center text align? That's cool. We're going to close this out here And we need to bring this down a little bit, Okay. And Then we're going to give the ellipsus a some values here And we're going to edit the line height. Line height is going to be about 2- 7, and here we're going to say margin- This is going to be auto.

[20:00] And here we're going to say max width equals 12mm. Here we're going to say overflow is hidden. Here we're going to say text overflow and we're going to say text align and text align equals center. And last But la, not least, But we're going to say whites, space, no wrap, All right. So Now we've got our style defined. Let's keep on moving forward. Thanks for sticking with me So far. Let's go ahead and define this script, All right. So we're going to get into some of the logic behind using the, or some logic that involves using the freighter API. So first things first, we're going to go and define this: the imports that we need. So we're going to say import and we're going to say we need is allowed, we need get

[21:00] User info. All right, let's go ahead and dive into some what this one actually means. So here is where you're going to get the public key from the Freigher API. So you actually have to have Freigher installed on your local machine, on in your browser, for this to work and you can actually do that by visiting the Freigher website. There should be some download links to quickly add it to Chrome. But here is the function that's going to get the public key that we will be using to. We're going to be using this function to show the public key on the front end of the dApp, All right. So now that we have that imported, let's go ahead and keep moving forward. So we have const wrap equals, document, get element by ID, and no, we're just going to say query selector. We're going to say

[22:00] Query selector, freighter wrap. We actually want the to be hashtag right there. Okay, cool. We're going to say const button, query selector, data connect- Here we're going to say const ellipsis equals. We're going to say document and for this we're actually going to say document as well. Document, query selector, ellipsis, ellipses. We're going to say at freigher, rap and ellipses, Cool, All right. So we have our wrap defined, our ellipses defined and our button defined. Let's go ahead and get into defining some of these functions. Here We're going to say async function- get pk, get pk. It's going to take in any

[23:00] Arguments. Let's go ahead and see what is here for us from copilot. This is definitely not right, But very close. So we're going to say const and we're going to say public key await user info- Too easy, And we're going to return the public key- All right. Now we're going to say AC function and we're going to say set logged. Set logged in- Okay. And we're going to take in one argument: That's going to be the public key. Public key is going to be a string- Okay, All right, Set logged in. Public key is going to be of the type string. Now we're going to define some of the functions here. We're going to say the inner html is going to be going to say signed in as

[24:00] Right- Applause, why not? We're going to say signed in with and we're going to define this value here as the public key value. Is that not correct? Signed in with. And then, oh, I need to close this out. Too easy, Using the wrong kind. There we go: Cool Wrap, Okay. And Then we have here we're going to say ellipsis title and we're going to say equals public key. Cool, Ellipsis html. Ellipsis enter html, ellip, oops, ellipsis Set title. Do we not have this? Ellipsus, ellip,

[25:00] Ellipsus- Sorry y'all. Quick spell check Going to fix some stuff here. Ellipsis O. All right, What do we got here? Div class- Why is this failing? Lift this title: public key. All right, let's just move forward, Because I did have some errors earlier that I was just kind of working through. So let's say: But these errors did not affect the output, Let's just see what happens. Let's keep working through it and see what happens. So, as you can see, here Copilot has created a handy dandy function to complete the script. We're going to say is: If is allowed, is true, We're going to set the constant, We're going to set

[26:00] The public key to con public key. We're going to await that We're going to get the public key. There. We're going to say: If public key, we're going to say set logged in to the public key value. Or else we're going to wrap the inner html and we're going to say: freighter is locked. So let's just go ahead and do this here. If public key set, public key logged in. And we're going to say: here you can just kind of go in with astro and just type in the turnary statement itself. You say else wrap, enter html. Sure, We'll say: error getting public key. Why not? Okay If public key. And we're going to say set logged in public key, html- Okay.

[27:00] And Then we're going to say else here we're going to say, yeah, So we have some good legs to stand on. Here We have button add event listener, right click async function. That's true, This is all good. I'll just get rid of this. Maybe that wasn't as good as I thought. Button add event listener And let's say, going to disable that button Equals- true. Kind of want that button to disappear real quick. Then we want to say await- set allowed. Then we want the constant public key to be u, to be the return data of the function that we call earlier, And we're going to say set logged in public key- All right. So we should be all cleaned up here,

[28:00] All right. And again, I am having some issues on my side with the like, the errors and things like that. But let's just go ahead and see If this runs anyway, All right. So let's go ahead and run dev one more time. Again, thank you all So much for being here with me and thanks for hanging out. I know these things kind of like run on sometimes. I never expect them to go as long as they do, But they always exceed my expectations. And let's see. Let's see what happened here. All right, let's go 4, 3, 2, 1. Doesn't look like that was implemented Because we never went to the index page Right. So next up we have to actually import our connect freighter

[29:00] Button. So let's say import and we'll say connect freighter from components, connect freighter astro, And we're going to just kind of like plug this in somewhere. I don't know, We'll plug it in right here. We'll say connect freighter- Very cool Greeting, All right. So you should see signed in as GA75F. Again, let's go ahead and see exactly what's happening here. Connect freighter- Again, you see, in the script side we're importing is allowed, set allowed and get user info. The way that we're illustrating or like showing the public key is that we're saying this async function, set, logged in. We're saying that inner HTML is going to be the public key, right, And all the public key is the function get user info, All right. So that's a little bit about defining the functions on the right, using Astro to kind of demonstrate

[30:00] Some calls right Without calling the blockchain, And then also integrating Freigher Stellar's kind of like primary wallet. Well, Stellar doesn't have a primary wallet, So to speak, But the in house developed wallet Frraider, This. We went over how to connect that to the front end itself and we see that being reflected here. All right, So you guys have been with me for about 30 minutes, But we're going to keep it going. All right, we're going to keep the session going. As I said, every time I do, one of these I kind of like exceeds my expectations. So we're going to switch gears a little bit. We're actually going to go to a more advanced smart contract, kind of like undertaking, If you will, And what we're going to do is I'm going to share with you the Sora or Stellar- excuse me- example dApp. So let's say,

[31:00] Stellar- Applause- example dApp. All right, And I'll just do a quick little note: bash, sh. All right. So If you want to clone the example dab, all you have to do is run, get clone, and you're going to say: this guy right here, I don't have the link handy, But you can clone the example dApp by going to this link right here And I guess I could show you guys what's going on Here. All right, Here's the Soroban example dApp. You could see that it has a

[32:00] Readme. It needs to be updated actually, But it's a full stack boilerplate dApp that we aim for you guys to use this to create your own crowdfund applications. It's got a bunch of use cases particular to public goods funding, and we'll see how we can kind of tweak this to aim it towards a project outside of the original use case, which is to raise money for an art distribution, and we'll see what we could do here. So, without further ado, let's just go ahead and kind of like dive into it Again. If you're interested in following along, you can run the command get clone And then plug in the link here, And If you want to just check out the repo, you can check it out at the Stellar repo. Soroban DEX example dApp. All right Now. This is one of my favorite dApps Because it's one of the dApps that I learned very early on. So

[33:00] I hope my enthusiasm spills over and through the airwaves, So to speak, And, yeah, hope you guys learned something today. So let's go ahead and dive right in with the smart contract. First things first. You see some attributes you may be familiar with from the last session. Contract contract implementation is a new one, maybe token address and into val And then vow. So we'll explain. We'll dive into these as we go through the contract, But I may gloss over a few things for the sake of time. Here you see the public enumeration data key and this is where you're going to hold a bulk of the keys for the contract storage. Remember, as from the last session, each key has a value and each value is defined as a certain type. Deadline, recipient started, target token, user address and recipient claimed are our keys And we'll go ahead and see what

[34:00] Different types belong to these values a little bit later. Moving on, you see that we have the state of the smart contract here and it's just going to be defined by three values: running, success and expired. Now let me do a quick backtrack. I know I said that this example, dApp, was for a crowdfunding application and it is So. Some of the components behind the smart contract are that it has a deadline for the campaign to run, It has a recipient to receive the deposits for the campaign, the crowdfund campaign, The token that it's going to receive for contributions, It's going to keep track of the users that contributed And Then it's going to give some boolean values of whether or not the target has been reached, If the recipient claimed, etc. And these states define the or this enumeration defines the state of the campaign. So it can be either running, it can be successful. If it didn't reach the target, Then it will be expired.

[35:00] All right, So we have our getter functions here also known as utility functions. They're just retrieving certain data. Here You see that we're retrieving data from the ledger. We're getting the time stamp and here you see that we're just retrieving the value for it for some of the keys. All right, So these are our getter functions and we also have our setter functions, which are mostly defined here, But they're called actually in the initialize function. All right, So let's go ahead and take a look at the initialize function. You see, public function, initialize, passing in the recipient u value, which is an address, deadline value, which is a U64 target amount, which is going to be the amount that you want to get into the deposit or get into the campaign via deposits, The token address, which the address of the token that's being

[36:00] Transferred from the depositor wallet to the crowdfund contract. All right, So let's go ahead and just step right through. So, first things first, we're going to assert that the storage, the contract storage, does not already have a recipient, Because if it does, that would say or that would tell the user that this contract is already initialized. Contract can't be initialized. If you want to call the initialize function, we're just going through our setters here. You see esto storage instance set and we're setting values to all of those keys. You see recipient, claimed, started, deadline, target and token. All of these keys are being attached values that we're passing in through the initialize function. Cool, Good to go there. And this smart contract actually consists of two other functions that are kind of like the crux of the functionality

[37:00] Behind this entire contract success, really. So this is: the deposit function takes in two arguments: user and amount. Now I want to quickly highlight. On line 218 you see user require off. Now one cool thing about Soroban, the Soroban Rust dialect, is that we actually have an authorization framework, kind of installed or implemented, rather, in the Soroban SDK. So what does this mean? This means that the user has to have the address that is making the call. If I am user A, I can't pass in address B for this call, And this require off method ensures that the wallet being used to make the call is actually the one making the call. This cannot be another wallet's address, All right. So a simple way to assert that the wallet making the call is using the same value as the

[38:00] Address, All right. So you, you're saying the assertion here, the amount has to be higher than zero, Too easy. We're doing some other checks here, stating that the campaign is still running, The sale isn't running, Can't make a deposit, All right. So next up, let's take a look at some more interesting logic here. We're getting the user deposit balance, etc. But let's take a look at line 230. So you see line 230, let client equal token client new. Sorry, where was I see let client equal token client new. Where was I? Okay, let client token client new environment. And then token ID, all right. So this is cool Because you see token right and this is actually a crate that is implemented into the

[39:00] Soroban SDK that allows users to kind of leverage this functionality as an interface. So you see, token right, that's the SDK, that is the. That's, that's the logic behind the token contract, the Soroban or Stellar token contract. You see this client here which allows you to kind of create like an interface to lay over a contract address- new, obviously, creating a new one. And we're laying the token interface over the token ID. So we're going to call different functions via this token interface at a different address. So we're actually going to be making a crosscontract call- Cool. Now you see client transfer, right, And we're transferring from the user to the current contract address and the amount. Next you see contract balance, Get the balance And Then we're emitting a amount, pledge amount changed event here. All right. So that's simple enough. That's the deposit

[40:00] Function. Now let's go ahead and move into the withdraw function. Again, we're defining the state and recipient, doing some checks here and saying, Hey, If this sale is still running or If the campaign is still running, cannot make a withdrawal. Again, we're doing the client or we're defining the token here, calling transfer on the token, transferring it from the recipient or transferring it from the crowdfund contract address right over to the recipient address. And yeah, moving forward, we're going to set the smart contract storage, set user deposited to zero. All deposits across, all- excuse me- deposits across the smart contract storage should be reset back to zero And the events will be emitted to reflect the changes that were just made. All right, cool. So let's go ahead and

[41:00] See how this works in action. One cool thing about this repo is that it comes set up with some really easy to follow directions. Let's go ahead and dive into the package json file. Here you could see that there is a reset function that's going to run mpm run clean and npm run setup. If we look at mpm run setup, all that's going to do is run the initialize s sh script. So I'm going to go ahead and dive into the initialize sh script, or initialize shell script rather, and just kind of break down what's going on here. First things first, we're going to define a path, a new path, for a binary file. That's Because we're actually going to be installing the Stellar CLI as a binary file within the project directory itself. That way you can leverage a pinned version of the Stellar CLI to make sure that the kind of

[42:00] Tutorial, If you will, or deployment of all smart contracts and front end of the dApp does not fail. It must be pinned to a certain version that is compatible with the Stellar or the Soroban SDK. Rather, All right. So you see, in setup we are running the initialize sh file. Again, let's go ahead and dive back into that. Where are we at? Initialize sh? All right, So that's where we were. Line nine: we're defining the binary path file. That's Because we're going to use the Stellar CLI as a binary right. We'll kind of like gloss over this a little bit. Just know that it is stationed in the target bin directory, Cool. And that's going to run cargo installer, which is again going to install a pinned version of the Stellar CLI. Real quick. We're going to be able to pass in some values When making the call. If you look at here, we're saying initialize shell And then we're defining the network as test net. Excuse me, The

[43:00] Script here makes it super easy by allowing us to type in the value standalone, futureet or testnet net and we'll kind of have these preconfigured values for the endpoint and appropriate RPC host URLs defined in the script. So When you pass in the argument standalone, future or testnet net, it'll quickly plug those arguments in and define that for you to save you time a little bit later. All right, we're defining a network by using the RPC URL and passphrase And here we're actually going to write some of the data, the deployment data, to a folder in the directory called sorbomb. All right, so that's all that's happening there. Here on line 87 we're generating a new identity called token admin by using Stellar keys. If the Stellar token admin identity already exists, we're going to skip over this. But If not, we're going to generate a new

[44:00] Identity using the keys method- again, Stellar keys generate token admin, and we're going to do that on the test network. All right, So I'm going to start moving through a little bit faster Because we are reaching about 15 minutes out from the hour, So hang in there. All right, So we're defining the Stellar keys address as the token admin- was it called token admin identity we just created through the Stellar keys generate method. We're funding that. This should actually. This is redundant Because we actually fund it When calling the generate method. Next up, we're deploying the abundance token, which is just a Soroban token. We use this as a mock token for demonstrating a mint and deposit capabilities After this. So we deploy both the abundance token- So random Soroban mock token- and the crowdfund ID or, excuse me, the crowdfund smart contract. This kicks back a crowdfund ID which we Then use later to generate

[45:00] TypeScript bindings. All right, So we got some messages here, some success messages that kick back the ID, And then we write that ID to a directory calledsorbon. Last But not least, at the very end of the script we initialize the abundance token. We give the name abundance, a new symbol set the decimal places, give it the name abundance, And then we set the admin as the new identity we just recently generated. After this. Finally, last But not least, we initialize the crowdfund contract. We set a deadline for about one- 86 400 seconds is one week from now- And we say Stellar, contract invoke and we're calling the initialize function. So, going through the setter functions again, you we're setting the recipient key as the admin address. That's the value setting the value of the key deadline as the deadline value, target

[46:00] Amount key will be set to the value of I think this is 10 000 or 1 000 tokens, I believe, and the token is going to be the abundance token that we just deployed. So I say all that to say this: Let's go ahead and run mpm, run reset, and we'll just go ahead and see what happens here. By the way, thank you So much for sticking with me thus far. I know these sessions can be quite long, But I'm really hoping that you guys are learning a lot and, again, really happy that you guys are sticking with me throughout this journey. Real quick, I kind of wanted to do a re, a recap over the freighter connection kind of lesson here. So If you remember, we in. We implemented freighter through the following ways: right, We actually used the method get user info, right. So, If you remember, we use get user

[47:00] Info and we return the public key. That's exactly what we're doing in this application. Here We go to the wallet data component. You see use account and use is mounted. Now wallet data is going to use both of these hooks. But If we go back into use, accounting at the end of the day is using get user info right from the Stellar API And then return, returning these objects. So that's how we're able to use freighter to return the public key. And let's go ahead and dive into some of the main functionalities of the front end components that require some of the logic from Freigher to sign some transactions. Yeah, let's go ahead and do that right now. So If we look at the form pledge, I believe form pledge Is this it. Yes, We look at the form

[48:00] Pledge component here. This is actually going to contain a button that's going to allow us to mint the abundance token. So again, that mock token that we're using, this is how we're going to access the mint function. So If you see on click async, set submitting equals, true const transaction, again equals, await abundance mint. And again, we're able to do this Because when we create typescript bindings, we're creating node modules for our smart contracts, right? So the abundance smart contract has the method mint, which we're able to leverage Because of the typescript bindings. Again, they have the SDKs installed on the back side of the node modules and they're able to communicate with the Stellar blockchain by kind of creating the calls by hand using JavaScript. All to abstract away development cycles for you and save you

[49:00] Time. All right, So we have two, which is the account And then amount, And Then we're defining the public key that's returned by freighter And this is the key that we're using to sign. All right, And that logic continues with both calls. So you see, let me try to track this down real quick. So that was the mint function. And Now you should see the deposit function. Right, Crowdfund- Let's just go ahead and do a quick search. Deposits is not in this one. Deposits for molecules. Deposit, transaction set, balance, prop, address, form, pledge. We should see a deposit function in here. Yep, So transaction fund, deposit, And

[50:00] Then we're going to pass in the user and the amount, Same as before. We're calling the public key or await public get public key method to pretty much pass in the serer there And that's going to be Because of freighter. So we're going to say mpm, rundev. Let's hope everything works. I'm hoping All right. Shared contracts. One more one second, real quick, Let me go ahead and I actually have to run contract bindings, All right. So here we have to run yarn, run and say: bindings, Okay. So one quick hiccup here. During the deployment process, When we ran

[51:00] Initialize, it actually didn't run the binding script, Just full transparency. We're going to be deploying this to versel And there is a quick issue with the original package json file that comes with the pre install command. Now this pre install command will actually build the TypeScript bindings for you which is required for the front end deployment. So I deleted that call and that's kind of like why we're seeing that error here, Because there's no TypeScript bindings for the abundance contract. But let's go ahead and run this dev function again and see If that worked. It should work. Okay, that was very close. Good thing. The demo effect did not get us today, All right, and you can see my wallet address here. This means that

[52:00] Freighter is hooked into, or the freighter API is hooked into, the front end component. So this is refle reflecting properly. Let's go ahead and try this: mint, Okay. So Freigher actually doesn't allow websites that don't have an SSL certificate to make calls. So what we have to do here is we have to transfer this over to a production type of deployment. So stick with me here. What we're going to do is we're going to remove the target rm RF target, All right. So we're going to move the target directory and we're going to use Verscell to deploy the front end. So I already have Verscell on my machine. But If you don't, you'd have to run MPM I, Verscell or MPMI G to install Versel globally.

[53:00] Now I'll just quickly run Verscell. I have it installed globally Here. We're going to in: set up and deploy this app. Here We can say yes, Yep, I don't want to link to an existing project. I'm going to give this a new name. We're going to say u Soroban, example: dApp, So said. And we're going to say 07- Yeah, for July, So said07. We're going to go ahead and deploy this, Set up the project here, All right, we don't want to modify any of these settings. So we'll say no And we're going to go ahead and wait for this deployment to kind of build and be set up to production. It's going to take a little while,

[54:00] All right, just kind of waiting for a quick sec. I do want to open this up to the side to make sure that there's no problems. I don't think it should have an issue. Make sure freigher is logged in. All right, we're logged in- G7 CKTV, All right. So the deployment is ready. It did not crash And we can actually. You can actually access it through this URL here, So I'll be happy to share that. Let's go ahead and connect wallet- All right. So first time connecting to a

[55:00] Website, Freigher is going to send this popup and say: Hey, do you trust this website? I'm going to go ahead and connect it. I did click connect, But it doesn't look like it was updated, So I'll do a quick refresh. You could see my public key being illustrated here, being displayed here. I'm going to go ahead and click the mint 100 abundance token button. All right, And look at that fee: 189. All right. So Stellar is about 0, 1 cents right now. Right, So 10 cents And 0, 1. I mean you got to imagine that is such a low fee And that can really help out startups and just users in general, right? Why charge users an arm and a leg for fees, All right. So that call went through and you can see that the balance has been updated to 100 abundance tokens. So that was the mint function. And again, just quick recap Because I'm super proud of this: we went through the mint function earlier.

[56:00] Right, Mint function. We'll say, where are we here? Amount input, pledge- I'm So hyped I can't even remember where we were. Okay, So, amount inputs, author info button, connect button, deposits- right, Whoops. So let's just say mint, All right. So here we are in the form pledge. Excuse me everyone, But again. So again I was super excited, Couldn't figure out where we were in the code, But this is where we want to be: Line 49 in the form pledge file, into the molecules directory. You see, con transaction equals await abundance mint And that's what we called right from the front end When we called the mint function Right from here. This is all the logic that happened. We passed in the account, which was determined by connecting with freighter, and the amount

[57:00] Which is predetermined within the code itself. So we're just saying the amount is going to be 100, All right. So now that we have 100 abundance tokens in our balance, go ahead and back this project with 100 abundance tokens, let's go ahead and review the call And then we're going to see here that the contract is receiving the tokens and the sender is going to be the address or the wallet that we're using and we're going to be sending 100 Abundance tokens. So we'll go ahead and approve and continue, We'll sign the transaction and we'll hope it goes through. Boom, The campaign has made, or we've made, a 100 abundance token deposit right to the campaign and we have concluded

[58:00] The campaign itself, Because our goal was 100 abundance tokens And, yeah, as you can see, this was updated in real time Because of the subscription hook that is actually in the boiler plate itself. All right, so that is my time. In conclusion. You know, I highly suggest that you guys check out the docs, that you can find them at `stellar.org/developers`. And If you guys have any questions Then please join the Stellar Discord. There is a developer channel there. There's also a help channel there and we are always ready to answer any of the questions that you guys have along your Stellar development journey. Once again, my name is Julian Martinez, senior de. Excuse me, once again, my name is Julian Martinez, senior developer advocate and common man here at SDF. Again, thank you guys So much for being with me weathering the storm.

[59:00] It's been a great hour of diving into dApp development. I hope you guys learned something and until next time take care. Bye.

</details>

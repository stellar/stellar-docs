---
title: "Turing Complete Contract proposal for Stellar"
authors: [kalepail]
tags: [community]
---

import YouTube from "@site/src/components/YouTube";

<YouTube ID="T7FlHKbew4U" />

- all righty welcome to another episode of engineering talks my name is tyler van der Hooven and i'm gonna be talking today about a preset proposal for turing-complete smart contracts for stellar precept simply means that this is just some work that I've been doing on a stellar ecosystem proposal around this idea of turing-complete contracts and we're going to talk a lot about that today obviously that's what the talk is all about but it's important to kind of reset your thinking a little bit we all have an idea of what turing-complete or smart contracts means I'm gonna try and come into this without too much baggage and explain what I mean a bit along the way and I'm going to be using aetherium as our comparison project because most of us when we think of smart contracts have etherium in mind so this is not necessarily a competition against etherium it's simply a comparison of features that if this SEP were accepted and used how would you how you would accomplish similar sorts of things that you could on etherium on on stellar and comparing the functionalities and features that aetherium offers with what this Turing signing server SEP would allow you to accomplish on stellar so let's let's dive in today's gonna be a bit technical we're gonna go through Trent blazed through these slides pretty quick and then get into some examples and encode but it will be a little bit longer probably than we're used to for these engineering talks to stick with me it is quite interesting super excited I've spent a lot of time thinking and working on this problem myself as something that I very much need in my own development and I think would really benefit the stellar community at large all right so the problem is if the room has market dominance in an arena we're better suited to serve namely Finance so we have assets and the ability to have assets as first-class citizens where there in an account but often times financial architecture will be built in aetherium in instances where oftentimes it would be better to have that built in Stellar's it's going to be faster cheaper and you're going to have this capabilities and functionalities that are native in aetherium and you'll have to kind of custom build that yourself whereas in stellar they will often be built in kind of at the base layer so our solution ears to appeal to aetherium developers by bringing functional feature parity and that's a key phrase here functional feature parity this isn't feature parity it's functional so what you can accomplish in etherium trying to allow that same type of functionality in stellar in the in the financial arena and so the solution there for me the product there for me I guess is smart contracts now we have a concept of smart contracts and seller it's kind of using operations and this nature of stellar transactions you can accomplish a lot of different things atomically inside of a transaction so you can have lots of different operations that open things up and close things off all within the same transaction you don't have to do a bunch of individual things and then who knows what's going to happen inside because lots of things can happen in a single ledger you can accomplish a lot of very intelligent smart things and by using things like time bounds or pre assigned transactions you can get away with a lot of I would say complex big business logic and we've sort of slapped some our contracts on to that but in no way is that what most of the world thinks of at least most of the blockchain world thinks of when they think of smart contracts smart contracts as a concept is very different than what we tend to talk about when we talk about stellar smart contracts today so we're gonna be moving away from what most of us think of when we think of stellar smart contracts and moving much closer to what aetherium means when it says smart contracts so my definition is a smart contract as the ecosystem understands it so regardless of what wikipedia says the smart contract is the way that smart contract the word phrase is used as the ecosystem at large the blockchain ecosystem understands it is an arbitrary turing-complete program it's in complete programming executed on a decentralized network for the purpose of minimizing trust so you have this idea of a program that has arbitrary programming that does who knows what that accomplishes some sort of goal and that goal is better accomplished when it's trust minimized or there isn't a lot of third-party trust involved or it's decentralized and this is this is important to kind of for all of us to agree even if you don't necessarily agree with me on this that this is where I'm coming from when I talk about the smart contracts that I'm envisioning through this SEP that I'm building is this idea of trust minimize minimizing trust so there will still be trust involved there's always trust involved it's just who and how much and what are those parties that you're trusting and then arbitrator and complete programming the ability to do kind of any sort of logic that you need to to to create some sort of output instead you don't have that stellar is not turing-complete that allows it to be very fast and flexible in scale very quickly whereas an aetherium those things are bundled together where you have what we'll get to in a minute the idea of transaction creation creation and execution so what does that really mean was this ecosystem doing with smart contracts there are two things when it comes to financial smart contracts there's transaction creation and transaction execution so building blockchain mutations basically these are the instructions for how I want to change the ledger how I want to mutate the existing state of the ledger or blockchain by adding another block and then also the transaction execution which takes those instructions takes those mutations and actually runs them to perform the changes so you have the instructions and the execution the creation in the execution so we have that right in stellar and a theorem you can both create transactions and execute transactions both in stellar and aetherium so what's the big deal how how is what's the problem well the problem is decentralization in stellar there is no decentralized transaction create atheria m-- there is because in the virtual machines that run aetherium those are run all over the world anybody that's running an ethereal node and participating in the consensus the transaction creation and execution both happen in that process of arriving at consensus whereas in stellar only the execution of the transaction the creation of that transaction happens outside of the execution so you sort of give it very detailed in permissible instructions and then send it to the consensus protocol to actually execute that in aetherium you send a very minimum information and then both the creation and execution because assets are not first-class citizens you can build a whole program that will handle the kind of input that anybody might send it and then the ledger for your particular smart contract will be updated so both of those things happen the same time it would be one of the reasons that if your iam is built the way that it is and why some of the reasons or ways that it differs from something like stellar which what I'm going to get into that too deeply and I honestly don't understand it perfectly but with my new this set proposal that I've been working on we're gonna look at today we're looking at adding decentralized transaction creation so smart contracts do not execute this is really important it very something is very different than aetherium all that on adding or proposing that we add through this step is transact decentralized transaction creation which we will then tag on to the existing architecture we already have within stellar the decentralized transaction execution which would give us through this what I'm tagging is SEP acts if we add seller and this new sub X together we get feature functional feature parity with aetherium where we have decentralized transaction creation and decentralized transaction execution which would be amazing and we'll get to why hopefully maybe some of your wheels are starting to turn on what decentralized transaction creation would allow us to do some of the things that it would allow us to accomplish which we cannot do now but we'll we'll get into that so essentially sub X is Turing signing servers decentralized turing-complete trying action creation so a few weeks ago we had a engineering talk on Sept 30 which is the key recovery servers and we have Federation servers as well so we have this concept within solar ecosystem proposals of external servers or services which run to provide sort of additional logic or additional functionality common additional functionality across the ecosystem and so this would be an additional server that would be running the individuals or enterprises would run which would allow this decentralized turing-complete transaction creation where you have these multiple parties running something which will accomplish some goal in a decentralized way so still the smart contracts via sip X have three entities they have users contract creators and Turing server so some of these may be blurred at times the line between the two but they are distinct in the sense that regardless of whether they end up being the same entity or individual they will be serving three separate purposes so users submit transactions for final execution the final there the final interested party they have something that they want to do something that they want to accomplish and they interface with touring servers but it's typically transacting through a contract not the Turing server so they'll be contracts that users interact with and those contracts are hosted on the Turing servers so I will interact with a contract which is hosted on multiple turing servers and then there are contract creators obviously who create the contracts and either provide services or just innocuous features so we'll get to some of those in a minute but a contract creator doesn't necessarily have to be some sort of service provider they can just build a contract that anyone can implement and use to provide some additional decentralized functionality and so I have a diagram here which is 100% useless so we are going to break that down user wants to interact with a contract creator for the service right there providing save users and contract creators we have this concept already today where you have some third party that you're wanting to interact with with your stellar address whether you're making a payment or you want to provide some sort of functionality with some sort of functionality of the service providers offering and you have a very one-to-one relationship you send instructions or requests you interact with their UI and they send you back responses whether that sign this transaction or add this trust line or whatever that interaction might be it's very much one-to-one and this is where some of the issues are going to arrive this is unacceptable as a requirement oftentimes this will be fine but I think it's not the right thing to say this is the way it has to be right so it's unacceptable as a requirement as it leaves the user trusting a single entity and a contract creator liable for a high level of responsibility and involvement and ultimately it's not decentralized you could add more servers but ultimately the contract creator is controlling all of those servers and decentralization like at its core is mitigating trust or taking that trust and splitting it amongst multiple parties so that no one entity controls everything we split that up to where there's a level of trust because no one entity is the single trusted entity and so we are getting to that diagram I showed a little bit before we get we introduced if they're disinterested but incentivized third party service the Turing signing server which will act as a permission request arbitrator between users and contract creators to the server we upload a strict specific turing-complete program or smart contract which will create transactions they don't execute they create transactions so the contract creator will build a program which will create outputs it's basically just in in this in my case it's going to be a lambda function but ultimately it's just an API endpoint which when called takes an input and then outputs a valid transaction stellar transaction and then the Turing signing server as you can see here stores contracts and holds keys and those keys are seller keys which sign for the transaction that the contract generates and in stellar we have this concept the reason this works or is valuable is because in stellar we have the concept of multi-sig where you've got multiple signers which can be added to accounts and can sign for any transaction that's being originating or originates from that account so if I want to make a payment I can sign with my key or I can sign with somebody else's key if they've been added as a signer to my account and so as we start to we create this contract and we uploaded to a turing signing server when we upload it a signing key is sent back to us and that signing key is what we upload to our contract we add that signature to our contract or we gave it to our user to add to their accounts so that we can sign for some action off of off of their account now when we have just one Turing signing server we're going to see that doesn't get us any improvements but it's the duplicity the lots of Turing signing servers where we start to see the power come out but this allows for transactions and their signatures to be generated following the strictness of a codified contract rather than the trust of a contract creator entity and this is this is the big point here that's may seem a little bit abstract but it's it's really powerful because if I want to if I want to do something let's say I want under very strict specific circumstances I want you to be able to use my account to pay yourself a hundred dollars you know if if some parameter is met I can't ever give you my secret key because if I give you that you can do much much more than just pay yourself a hundred dollars so how can I give you access to my account without giving you complete access to my account it's only strict specific turing-complete access to my account well I get that through this contract creation where I upload a contract to a Turing signing server and then you interact with that Turing signing server and rather than you having access to the secret seed you have access to only perfectly signed transactions from those turning signing servers so I don't give you a secret key I give you signed transactions through these Turing signing servers and then you can interact with the Turing signing servers rather than directly with my account and that's that's kind of one example but hopefully that starts to make sense so the reason this becomes or how this becomes decentralized is we upload these contracts to lots of different Turing signing servers so it's the same contract across lots of different Turing signing servers and then through thresholds right so we're out of T signers multi-sig to accounts but each of those can have a threshold so I can say to make a payment you need a threshold of three so I need at least a weight of three to be able to make a payment and so when I upload all this same contract all of these turns signing servers they all send me back a key which I add to my account as signers but only with a weight of one so that no one turing signing server not even two turing signing servers could sign for or collude to do something with my account you would need at least three and through thresholds you can add any number of i guess up to 20 thresholds to agree very complex secure logic to account for whatever kind of logic you're trying to perform with your contract but essentially you're just going to upload this to a number of turing signing servers and then through thresholds decide how many of those turing signing servers need to add their signature to the transaction that's being requested and because it's the same contract it's producing the same transaction the same XDR and if any one of these gets a little sneaky and tries to you know make a payment to themself they would change the XDR and therefore the signature for all the other turing signing servers would be invalid if the requests that the user is making to the turning signing servers is different than any of the others it will be rejected it'll be spat out because it doesn't match any of the others and the signature therefore would be invalid when it finally comes to submission time and so now the contract creator is a nonentity they no longer really interact with the user the user interacts directly with the Turing signing server so contract creators don't even need to at this point run a server they just uploaded some arbitrary JavaScript logic or really any programming logic language logic to these Turing signing servers and so long as it's valid and producing good transactions and being used and not being nefarious the user can interact with Turing signing servers completely separate from the contract creator in a decentralized manner getting transactions which follow the pattern that the contract creator allowed for because they've added their signature to it and in this case following our example before the user can begin interacting and making payments to themselves for $100 so long as it follows the pattern that the contract creator allowed for so hopefully it's starting to make sense turning signing servers allow for secure decentralized transaction creation and signing through programmable contracts so again we need to we need to remember that Turing signing servers their goal is to create transactions not to submit them so they they perform the business of creating a valid signed transaction and that signing doesn't have to be and often I would say is not complete it's partial signing it's signing for some of the logic of the transaction that was performed but there's probably should be some piece that's left to the user whether that's paying the base fee whether that's in a you know a vending machine example you have to pay a hundred lumens to get a hundred of your asset back like Ana ICO model or some sort of token giveaway or there's lots of different instances where you're the user is going to be the final signer and so the transaction that comes back is signed and it's signed enough for all the interaction that deals with the contract creators account but there's still some piece that's left for the user account so it's just adding signatures to a transaction but not necessarily fully signed although that obviously could be again the business logic appears in the contract not in the XDR itself not in the stellar transaction itself so you can create all kinds of business logic that produces a transaction at the end of the day that could be any sort of thing and that's kind of what we're gonna look look through here now so again like the motto for this is you get what you permit so when you start talking about could I do this or could this be used in this case the answer is going to long as is related to like seller transactions and getting a payment and kind of really getting access to your account through a secure contract like so long as that's the question the answer is yes because so long as you create the right permissions it's you can allow for it you can build for something like that amazing the houses compared to etherium smart contracts will just look through this really quick so now with this FX would have along with the 3m decentralized transaction creation and decentralized transaction execution and then the difference here arguably is going to be again the safety over liveness that we have within the selection since it's protocol versus if you're in virtual machines anyway where the safety aspect to the contract control is it's just creating transactions it's not actually executing them and so you don't have to necessarily worry about your accounts or about the safety of your account so long as you've built your contract correctly and then the liveness aspect of it is going to come down to how well did you write your contract is your account funded all the things that are already limitations just within stellar versus the ethereal model which is once you upload a contract there's nothing you can do to really alter that because both transaction creation and execution are happening at the same time but that contract will always exist it will always be up unless you have some of those non decentralized back doors open so some of the core philosophical design differences stellar smart contracts nothing unacceptable can happen in a favor smart contracts nothing unexpected can happen and there's benefits on both sides really depends on what you're trying to build for those stellar smart contracts because that is just generating a transaction the final execution is in the hands of whoever the final user is whereas in aetherium smart contracts the final execution is in the hands of the contract so you you execute it hoping that it does what you expect whereas with a social on card track you execute it and then it spits out a final transaction which you have a final say and whether or not you want to submit it so finally the thing that we were all looking forward to examples and I think yes that is pretty much my last slide I'm going to switch now to my browser I'm going to open I've got some glitch demos here so fantastic little service here glitch and I'm going to open up all of these examples and then make this a little bit bigger so the first one I'd like to look at is a very basic kind of run-of-the-mill vending machine example so when we talk about smart contracts vending machines kind of a really good starting point where you give it an input and it gives a guaranteed output so in this case we're running a Tyler coin trade or swap where you send in a hundred lumens and you get a hundred Tyler coin back or it's always a one-to-one so if you did 50 it'd be 50 if you'd tend to be 10 so I've got an account here so if I can open this I've got an account here which I am making a payment tune and this is just a standard seller account that I've funded with friend bot there's nothing fancy that's been added to this there's a contract though that I've uploaded that says all the logic around when a transaction come or when a request comes in to this contract take a hundred lumens make a operation for taking a hundred lumens from this account and then send it ten all right send it ten top corner 100 for 101 to one and so we'll give it that hundred and then we'll generate the XDR so let me just pop in the code for this real quick we make that a little bigger so this would be our vending machine smart contract so essentially there's a contract that says when a request comes in and it has source and amount we're just going to build a stellar transaction and then spit out the xgr and that's going to be a payment for 100 lumens to me and then send back tot it going to the source account which is the account that we add right here and then it also adds the fee payment to the turrets so to the Turing signing servers so Turing signing servers again I mentioned that they are disinterested but incentivize third parties they have no benefit to get from collusion but they have benefit to get from collecting on fees so if you run a Turing signing server you can charge fees to execute these contracts as well as upload contracts so transact servers have a business opportunity but they're just interested in the sense that they don't care what contracts are being run so this is a very I mean 57 lines of code plus comments so very very small little contract but it does allow arbitrary logic and it allows me to safely say I can run an entire contract here of paying out my Tyler coin in exchange for xlm all through just this very basic JavaScript code so I'm going to upload this when I upload this contract to a Turing signing server they are going to send back a signing key because this is the account this is the contract address that is going to be paying out Tyler coin if we look this up in still our experts on the test net we will see the windows condemn when we upload it to the Turing signing servers they send back signing keys and those signing keys are what we add to this contract to allow for these contracts to actually generate signed transactions because the Turing signing server is going to generate an XDR and then add a signature using whichever signing key they have for that contract and then we have a threshold of three like I mentioned before so if three so long as three addresses sign off on this any any transactions coming from this contract we can generate a valid signature and the execution the transaction will go through in this case paying out toilet claim so let's go back here and generate that xtr that generate XE our button is going to call the Turing signing servers it's going to say hey this account would like to generate an ex TR and it looks like we have got a beautiful error so you know so is the way it goes but essentially what would have happened if it had worked would be the the contract goes out to all of those different addresses all those different Turing signing server sends back the same XDR with the signature the signatures get added to the transaction that comes in we add our final signature to the ex TR to the transaction and then we can submit it right so we have to we have we have this account we would have to sign for for that hundred lumen payment it pays out the hundred lumens and then the signatures that we received from the Turing signing servers for the Tyler coin are all valid all the signatures are there we can make this relatively complex payment all through a very simple Turing signing server smart contract so that would be our vending machine example the next one would be let's do this weather coin so this one kind of showcases but I would call Oracle eyes data but really it's just taking a third party API and using that information to generate a transactions a different transaction or our variable transaction so in this case we are using the dark sky API we are looking up the weather at my current location and if it's raining we are going to generate a transaction for rain coin and if it's sunny outside we're gonna generate a transaction that pays out Sun coin and so again we need the same address when I upload this the same thing happens each sharing sighting server sends back a different a new signing key we had that signing key to the contract and then the contract when we call it will generate signatures for this particular transaction so hopefully this one will work it's not raining at my house at the moment so unfortunately you can't get a any rain coin so in this case it's looking it up and it's saying because it's raining we're not going to be able to get any any rain coin so if it was raining you'd be able to get rain coin but because it's not theirs I think there's logic actually running in the glitch app which says if it's not raining don't generate the XDR so maybe a little bit of a letdown but still you can provide arbitrary logic to say because it's not raining in my house right now we're going to spit out and reject this transaction which is really cool because you allow that logic to say I'm going to give away like usage of my account but only under certain parameters and in this case it's an arbitrary third party API which is providing the information that's as well it's not raining and so because it's not raining we're not going to generate a transaction we're not going to add a signature for it we're throwing that out which is which is cool the next one would be the filter smart contract and this one's actually a little bit different because instead of adding signatures to a contract address we're actually adding signatures to an account to a user's account and this is one of those examples where a contract the ones we've looked at so far have been sort of third party services so somebody's actually trying to run a business off of smart contracts in this case somebody just created a random you know open source smart contract which provides filtering functionality and so maybe I have an account that I want to give access to someone for but only if they're xlm payments are below a hundred lumens so I've made a filter smart contract here which basically says when a transaction comes in so the input here is actually in xtr so we're going to generate a Steller's transaction which has to have just one operation which is a payment and it has to be an amount that is less than 100 because if it's great greater than 100 lumens the request will be rejected but in this case we actually want to attach this contract to a user's account not to a contract account so there isn't really a contract address here somebody's just created this contract and says hey I'm gonna upload this and if you would like to use it if you would like to get this filtering functionality for your account then you just need to add the signing keys to your address so if we take this xtr here which is a valid example we can look up the account that it's attached to so we've added the signing keys to this account and right now there's just two so we've uploaded this contract to tutoring servers taking their signing keys and attach them to our account we have a threshold of 3 which means we need all three of these both turning signing servers and then our own TFI signing key to sign off on and then we kind of have this escape base64 or sha-256 hash that if something terrible happens and we need to rescue this account we kind of have that in our back pocket that's not a turning signing server thing that's just good practice if you've kind of locked out your account to yourself but anyway sharing signing servers are going to sign for two so by themselves these turning saying servers can't do anything there's no collusion capability possibility because at most they would only have a weight of two which isn't enough to do anything they would they would need that final signer my sign my signature to actually do anything so however I can't also by myself do anything this account is useless on its own it needs those other tutoring signing servers to actually accomplish anything and those turning signing servers are locked in to only signing for this which is that the transaction is greater than or is less than 100 limits so if we go back here we can see this payment is for 100 xlm so if we go and we generate the xtr on this all of my examples are today this is not fantastic and we try the invalid one it works it doesn't it filters a transaction here looks like this one's not working I think I may have uploaded the beta X beta let me look real quick at the contract address and make sure I'm actually using the right contractors because this one is kind of cool so we edit our project real quick in our JavaScript know it's got the right one yeah who knows probably shouldn't have fooled with it too much before before doing the demo but anyway if you had a valid example which we this is valid X er but looks like something's up with my Turing signing servers this would be valid it would be signed you could view it in the laboratory and then submit the transaction to the network so long as it was under that hundred one more example here this on glitch is our hourly wager demo so I play video games occasionally and on Fridays will do wager pools so maybe like you know 10 lumens or 20 bucks or something like that and there that all gets pulled together and whoever wins the game gets the gets the pool you could also see it as a donation pool where or even like a Kickstarter or something where if if balance reaches over a certain threshold and the money's released there's lots of different smart contract logic that comes through these types of functionalities but you don't want a single entity holding all those funds with the risk that they could run away and so you might add multiple human signers to that but if one of them gets bitter and doesn't want to do the thing that you you know I go you cheated and it's I'm not going to sign off on this transaction where you could run it to issues when you have those human variables but if it's just machines and they're just following contract logic you remove that layer that risk and do the the perform that trust minimized aspect of things which is really what we're after and what turning signing servers exists for and so in this case you have a contract address which has the Turing sang service been uploaded to all of the turning signing servers with threshold of three again so you need at least three of these Turing signing servers and then individuals will start to pay this account you can see the payments coming into this account into the wager pool and then in this case every hour the contract will go through you'll be able to generate an xgr which will pick at random one of these individuals as the winner and payout the pool payout the pool to them so again if we go to our arrow the wager contract it's a little bit longer contract but not really still 100 lines where it takes into account the operations for this contract account looking at the payments and then we'll randomly select one of those as a winner every hour so those are examples in that case again you upload the signers in this case to the contract like we did before the last one that I think is really interesting is a recurring revenue model so one of the issues right now with recurring revenue models on stellar is that you have to pre sign loads of transactions and kind of bump sequence numbers and it gets quite hairy when it actually comes time to execute those as they have to give to pre sign loads of transactions especially if it's like shorter terms on weekly or monthly basis and you have a lot of these transactions just kind of sitting around hoping that they'll be valid valid whenever it comes time to submit them with Turing signing servers you can create a contract which takes into account when a payment when a payment was last made and for how much it was when it was made all the information around the actual payment and then if it's time if it's been a month since the last payment you can make another payment and so essentially you would create this transaction much like the filter transaction or much like the filter contract you upload this contract add the signers to a user account but those signers can only sign through this contract and so if it's been a month since the last payment was made you can call this contract and it will generate a transaction which makes a thousand lumen payment but as soon as you submit that to the network it's and you try and call it again and say hey I just want to keep collecting thousands of lumens from this account it's going to say hey it hasn't been a month since the last time we ran since we ran this contract so in that case you don't have to have any pre signed transactions you simply wait until the time comes you generate the transaction and you can actually generate it and submit it through some sort of third-party service the user wouldn't necessarily ever have to know other than they would still have ownership over their account and if at any point in the future they wanted to cancel their subscription they would simply remove your turning signing signers from their account and any calls to that account to make a payment would fail because the user removed this turning signing server signers from their account so I think if this account still exists we could actually look at the signers that have been added for this account it looks like I saw on that one I think it's actually yeah so we've got the two signers here but then it's also got a threshold of two so while we need both turning signing servers to generate that recurring payment every month if at any point the user wants to remove those signers they're able to do that because they have a weight of two set on their operation threshold so that's been a basic overview of what I have so far on turning signing servers it's still a work in progress obviously if that's something that seems interesting to you and hopefully it does I am looking for more people to get involved on actually building out smart contracts so I have quite a few turing signing servers just tests that turn signing server set up they're ready to be used ready for people to poker and see what's possible hopefully some of these examples have gotten your wheels turning but now is kind of the announcement for that we need some people to start using this thing to start poking it around to see if this makes sense as a septa see if we built the right thing and then towards the as that sort of happens and we sort of get a better idea of what this should be and how it works and doesn't work and what kind of contracts can be built using this we'll move into the actual draft the SCP draft portion where we write it all up we have the API endpoints we showcase how to build one of these servers and run it successfully and all the fees around it and how to generate revenue how to run a secure turning to a server but also how to create good contracts and then hopefully we can get it to an active state where it starts to be used more and becomes a normal sort of used active seller ecosystem proposal within the ecosystem where these Streng signing servers become possible where anybody can spin up a contract and upload it to a plethora of turing signing servers and then beyond that it's just the acceptance of it and it becomes a normal part of stellar development alright so that was long apologize for that apologize that the demos didn't work out great hopefully we'll have those back up and running so that everybody can play around with what we have so far should have that within the next couple of days and linked on the youtube let's go for questions I hope there's a couple of questions that you guys have for me as things pop up and I will begin to answer those and then we'll and then we'll close out but as you have questions for me feel free to type them into into the chat and we'll walk through them otherwise you can find me on Twitter and key base at T y VD H I would love to chat all right how is this relevant for cross-border payments where does this fit in decentralized finance well you kind of set it there in decentralized finance a lot of its going to boil down to what you mean by decentralized everybody kind of has their own idea of what decentralized means and when it comes to things like D central payments for cross-border payments or decentralized finance for cross-border payments it's gonna come down to like who's in charge who's in control and what what are the differences what layer's do you have when you're talking about ownership so in the case of an anchor for example and wanting to facilitate payments being made in and out of the ecosystem or putting up offers on the order book to maintain liquidity between assets right now all of that stun and a completely centralized way where an entity controls their order books and so long as those orders are out there they're free to take them down and when you have these cross-border payments moving back and forth that can become an issue if a large portion of the success happens on one entity maintaining liquidity so it would be possible that a liquidity provider could create a smart contract that creates order books that are decentralized where they don't have the ability to alter or remove the orders that it just runs the liquidity and doesn't remove itself doesn't have a capability to remove itself so a lot of it has to do I think with removing barriers towards trust and this is actually kind of interesting because that's one of the biggest barriers when doing cross-border payments is do I trust them are they going to do what I expect them to do by using turning signing servers are really by adding decentralization or trust minimization into your workflow into your business logic you're able to guarantee some level of trust because you relinquish some portion of control whether that's liquidity providing or making good on payments the more that you can guarantee through math that something is going to happen versus guaranteeing through goodwill or I have a good business plan I've done this in the past the better off you're going to be when it comes to winning people's trust like it's going to become true more and more as other businesses do that and say you don't trust us you verify through the code that we've written that we don't ultimately control weave or link which control of our secret key our ability to alter the state of the ledger to these transient servers which ultimately own the contract they run the contract through users interacting with it so in that sense depending on how it's implemented and at what level it makes sense for a company to add in trust minimization to their business logic pterence and insurers will be useful for cross-border payments or decentralized finance but a lot of it again is going to ultimately boil down to what is decentralization mean and is that actually helpful when it comes to trust minimization or making payments across borders is SCF going to run a turn signing server who runs strange signing servers without any incentive I don't think SDF is going to reconcile you server I mean I run a couple right now just as as testing demos but yeah there is tons of incentive to run a tutoring center we didn't talk a whole lot about fees or uploading contract fees but that's a big part of running a churning signing server it would be kind of a separate talk - what is it like to run a turning sign server but you can charge excellent fees so basically part of the XDR when transcending server spits out a transaction part of that transaction is payments to the turn sending servers so those are these small fees paid out to the Turing signing service as well as fees for actually uploading a contract so it might be ten or a hundred lumens or five USD to upload a contract to a turing signing server so there's both the incentive for people to upload contracts but also to run good Turrentine servers so that you can continue to collect on fees as cheering sighing servers are executing smart contracts don't understand why you need signed transactions with other party when you share your sign transactional attorneys sensor owner of training center to execute your contract only if that Turing something let me read the question I really don't understand why you need Turing signing servers to share signed transactions with other party when you share your sign transaction with Turing signing server owner of Turing signing server can execute your contract signed transaction to attack you again that's only if you allow that how did you write your contract because you some turing some contracts may accept a incoming XDR but it's not it doesn't have to be a signed transaction that's coming in it's just instructions or it's just a Turing it's just a contract it's just a that's been submitted to a jury in signing server but it doesn't have any signatures on it yet and if you write your turn signing server contract in such a way that the output is a partially signed transaction so not full where you still need to sign for the source account you still need to sign for those fees maybe but there's still another signature that's needed the the transaction is only partially signed it's not Val viable to submit to the network yet so what someone yeah a lot of it is gonna boil down to trusting all of the Turing signing servers together but you already trust that with the way the seller consensus protocol works where you trust the individual nodes that are running stellar so this idea of disinterested but incentivized third parties is quite strong and it has been proven to work quite well so ultimately it boils down to again you get what you permit and if you allow for the generation of a transaction that is completely signed and valid then yes the turning signing server could submit that but even that isn't necessarily an issue unless they're submitting something that you don't want them to submit it ultimately depends on what that transaction does what that transaction accomplishes but because you're splitting up your secret key between lots of different during signing servers any single one probably shouldn't unless you've allowed for it be able to do anything on their own they would need to they would need to collude with other turing signing servers to actually accomplish anything dangerous so what's the difference between sharing your signed transactions contracts with Turing signing server over traditional servers the only difference is they aren't their traditional servers just operating as turned sending servers ultimately it boils down to two owns the turing psychic servers because if you own them there's not two centralization there but if some other entity owns those some other entity is running those so long as again you're uploading it to multiples of those you're running sort of a it's not a clone but it's similar to how stellar works already where SDF and lobster coin quest all run validator nodes and you submit a transaction to their network and they validate the transactions and perform the operations within those transactions this is kind of the same thing where you have a secret key which is split up amongst lots of different servers and those servers then add their signature to any transactions coming from the contract and so long as it's valid and it's all the same and it's a valid signature it can be submitted to the stellar network how would you see this use for subscriptions like you mentioned before also does this support more than just JavaScript so I gave an example on the subscription model ultimately you would just have contracts that were built for different amounts or it could maybe take variable amounts I haven't thought too deeply about exactly how would we use my purpose isn't to be too stringent on how it should be used and more provide a platform that works and then allow other people to build on top of that so you kind of would have to think ok if I can either get ownership over someone's account but in a very controlled way through contracts only through contracts or I can give ownership to my account but only through strict contracts what does that allow for what are the capabilities there and then there's there's tons of them and subscriptions would be one of those with fee bumps I don't know I will be interesting to see if fee bums kind of gets rid of the issue with recurring revenue since you can pay sequence numbers and fees from different accounts now so some of the issues we had there may already be gone I haven't looked into that too deeply but when it comes to complicated or turing-complete recurring revenue models or you need to do much more beyond just paying fees and sequence numbers you actually need to do some some logic external logic or taking accounts of the person's account you know like refunds or oh they partially paid and now we have to perform some logic around some sort of partial payment or upgrades and you know more strike like functionality then you could use something like this to accomplish that through because the turn signing server or smart contract logic and again you don't do you need to do that I don't know that depends on how much your users need and value a decentralized option for something like this or a decentralized option and maybe they do maybe they don't that ultimately is up to the users and what they expect out at the services that they're that they're making use of all right do we have any other questions those were good questions and again this isn't this isn't set in stone this is this is very good discussion and we don't want to spend our time doing the wrong thing but at the same time all you have to do is spend a little time looking at aetherium to realize that smart contracts and turing-complete smart contracts is a very powerful tool that is very valuable and I think it's worth taking a look at is there opportunity doesn't make sense for us to include some sort of functionality like this functional feature parity that would allow for decentralized transaction creation where you don't have to trust the person who's creating the transaction you can you can mitigate that you can relegate that through other parties all right SuperDuper I appreciate everyone hanging out again feel free to reach out on key base or Twitter with follow up questions I'll try and get working links to these demos as well as some API Doc's for people to poke around if you want to get involved building these things or testing it out be sure and reach on them you know thanks again or for coming out and we'll catch y'all later bye

On July 10, 2020, the Stellar Development Foundation hosted "Turing Complete Contract proposal for Stellar", a community session for the global community. Builders traded notes on Turing, Complete, and Contract.

all righty welcome to another episode of engineering talks my name is tyler van der Hooven and i'm gonna be talking today about a preset proposal for turing-complete smart contracts for stellar precept simply means that this is just some work that I've been doing on a stellar ecosystem proposal around this idea of turing-complete contracts and we're going to talk a lot about that today obviously that's what the talk is all about but it's important to kind of

Key discussion threads:

- Turing anchored the community session as speakers compared real-world examples.
- Practical demos highlighted how Complete applies to Stellar builders.
- Attendees outlined next steps around Contract for upcoming releases.

<details>
  <summary>Video Transcript</summary>

[00:00] All righty. Welcome to another episode of engineering talks. My name is Tyler van der Hooven and I'm gonna be talking today about a preset proposal for turing complete smart contracts for Stellar. Precept simply means that this is just some work that I've been doing on a Stellar ecosystem proposal around this idea of turing complete contracts and we're going to talk a lot about that today. Obviously, that's what the talk is all about, but it's important to kind of reset your thinking a little bit. We all have an idea of what turing complete or smart contracts means. I'm gonna try and come into this without too much baggage and explain what I mean a bit along the way, and I'm going to be using

[01:00] Aetherium as our comparison project, because most of us, when we think of smart contracts, have etherium in mind. So this is not necessarily a competition against etherium. It's simply a comparison of features that, if this SEP were accepted and used, how would you? How you would accomplish similar sorts of things that you could on etherium on Stellar, and comparing the functionalities and features that aetherium offers with what this Turing signing server SEP would allow you to accomplish on Stellar. So let's dive in. Today's gonna be a bit technical. We're gonna go through Trent, blazed through these slides pretty quick and then get into some examples and encode, but it will be a little bit longer probably than we're used to for these engineering talks. To stick with me, it is quite interesting, super excited. I've spent a lot of time thinking and working on this problem myself as something that I very much need in my own development

[02:00] And I think would really benefit the Stellar community at large. All right, so the problem is, if the room has market dominance in an arena we're better suited to serve, namely Finance, so we have assets and the ability to have assets as first class citizens where there in an account. But often times financial architecture will be built in aetherium in instances where oftentimes it would be better to have that built in Stellar's, it's going to be faster, cheaper and you're going to have this capabilities and functionalities that are native in aetherium and you'll have to kind of custom build that yourself, whereas in Stellar they will often be built in kind of at the base layer. So our solution ears to appeal to aetherium developers by bringing functional feature parity and that's a key phrase here: functional feature parity. This isn't feature parity, it's functional. So what you can accomplish in etherium trying to allow that same type of

[03:00] Functionality in Stellar, in the financial arena, and so the solution there for me, the product there for me, I guess, is smart contracts. Now we have a concept of smart contracts and seller. It's kind of using operations and this nature of Stellar transactions you can accomplish a lot of different things atomically inside of a transaction. So you can have lots of different operations that open things up and close things off all within the same transaction. You don't have to do a bunch of individual things and then who knows what's going to happen inside, because lots of things can happen in a single ledger. You can accomplish a lot of very intelligent, smart things and by using things like time bounds or pre assigned transactions you can get away with a lot of, I would say, complex big business logic and we've sort of slapped some our contracts on to that. But in no way is that what most of the world thinks of- at least most of the blockchain world thinks of- when they think of smart contracts as a concept- is very different than what we tend to

[04:00] Talk about when we talk about Stellar smart contracts today. So we're gonna be moving away from what most of us think of when we think of Stellar smart contracts and moving much closer to what aetherium means when it says smart contracts. So my definition is a smart contract as the ecosystem understands it. So, regardless of what wikipedia says, the smart contract is the way that smart contract- the word phrase is used- as the ecosystem at large, the blockchain ecosystem, understands. It is an arbitrary turing complete program. It's in complete programming, executed on a decentralized network for the purpose of minimizing trust. So you have this idea of a program that has arbitrary programming, that does who knows what, that accomplishes some sort of goal, and that goal is better accomplished when it's trust minimized or there isn't a lot of third party trust involved, or it's decentralized. And this is

[05:00] Important to kind of for all of us to agree- even if you don't necessarily agree with me on this- that this is where I'm coming from when I talk about the smart contracts that I'm envisioning through this SEP that I'm building, is this idea of trust: minimize, minimizing trust, so there will still be trust involved. There's always trust involved. It's just who and how much and what are those parties that you're trusting, and then arbitrator and complete programming: the ability to do kind of any sort of logic that you need to create some sort of output. Instead, you don't have that. Stellar is not turing complete that allows it to be very fast and flexible in scale very quickly, whereas an aetherium- those things are bundled together where you have what we'll get to in a minute: the idea of transaction creation and execution. So what does that really mean? Was this ecosystem doing with smart contracts? There are two things when it comes to financial smart

[06:00] Contracts: there's transaction creation and transaction execution. So building blockchain mutations. Basically, these are the instructions for how I want to change the existing state of the ledger or blockchain by adding another block, and then also the transaction execution, which takes those instructions, takes those mutations and actually runs them to perform the changes. So you have the instructions and the execution, the creation in the execution. So we have that right in Stellar and a theorem, you can both create transactions and execute transactions both in Stellar and aetherium. So what's the big deal? How is what's the problem? Well, the problem is decentralization. In Stellar there is no decentralized transaction. Create atheria m--. There is because in the virtual machines that run aetherium- those are run all over the world, anybody that's running an ethereal node and participating in the consensus- the

[07:00] Transaction creation and execution both happen in that process of arriving at consensus, whereas in Stellar only the execution of the transaction, the creation of that transaction, happens outside of the execution. So you sort of give it very detailed in permissible instructions and then send it to the consensus protocol to actually execute that. In aetherium you send a very minimum information and then both the creation and execution- because assets are not first class citizens, you can build a whole program that will handle the kind of input that anybody might send it and then the ledger for your particular smart contract will be updated. So both of those things happen the same time. It would be one of the reasons that if your iam is built the way that it is and why some of the reasons or ways that it differs from something like Stellar, which what I'm going to get into that too deeply and I honestly don't understand it perfectly. But with my new, this set proposal that I've been working on, we're gonna look at

[08:00] Today, we're looking at adding decentralized transaction creation so smart contracts do not execute. This is really important. It very something is very different than aetherium. All that on adding or proposing that we add through this step is transact, decentralized transaction creation, which we will then tag on to the existing architecture we already have within Stellar, the decentralized transaction execution which would give us through this, what I'm tagging is SEP acts. if we add seller and this new sub X together, we get feature, functional feature parity with aetherium, where we have decentralized transaction creation and decentralized transaction execution, which would be amazing and we'll get to why- hopefully- maybe some of your wheels are starting to turn on- what decentralized transaction creation would allow us to do some of the things that it would allow us to accomplish, which we cannot do now, but we'll get into that. So essentially, sub X is Turing signing servers, decentralized turing complete

[09:00] Trying action creation. So a few weeks ago we had a engineering talk on Sept 30, which is the key recovery servers, and we have Federation servers as well. So we have this concept within solar ecosystem proposals of external servers or services which run to provide sort of additional logic or additional functionality, common additional functionality across the ecosystem, and so this would be an additional server that would be running, the individuals or enterprises would run, which would allow this decentralized, turing complete transaction creation where you have these multiple parties running, something which will accomplish some goal in a decentralized way. So still, the smart contracts via sip X have three entities: they have users, contract creators and Turing server. So some of these may be

[10:00] Blurred at times the line between the two, but they are distinct in the sense that regardless of whether they end up being the same entity or individual, they will be serving three separate purposes. So users submit transactions for final execution, the final there, the final interested party. They have something that they want to accomplish, and they interface with touring servers, but it's typically transacting through a contract, not the Turing server. So they'll be contracts that users interact with and those contracts are hosted on the Turing servers. So I will interact with a contract which is hosted on multiple turing servers, and then there are contract creators, obviously, who create the contracts and either provide services or just innocuous features. So we'll get to some of those in a minute. But a contract creator doesn't necessarily have to be some sort of service provider. They can just build a contract that anyone can implement and

[11:00] Use to provide some additional decentralized functionality, and so I have a diagram here which is 100% useless, so we are going to break that down. User wants to interact with a contract creator for the service right there providing save users and contract creators. We have this concept already today, where you have some third party that you're wanting to interact with your Stellar address, whether you're making a payment or you want to provide some sort of functionality of the service providers offering, and you have a very one to one relationship. You send instructions or requests, you interact with their UI and they send you back responses, whether that sign this transaction or add this trust line or whatever that interaction might be. It's very much one to one and this is where some of the issues are going to arrive. This is unacceptable as a requirement. Oftentimes this will be fine, but I think it's not the right thing to say. This is the way it has to be right. So it's

[12:00] Unacceptable as a requirement as it leaves the user trusting a single entity and a contract creator liable for a high level of responsibility and involvement and ultimately it's not decentralized. You could add more servers, but ultimately the contract creator is controlling all of those servers and decentralization, like at its core, is mitigating trust or taking that trust and splitting it amongst multiple parties so that no one entity controls everything. We split that up to where there's a level of trust, because no one entity is the single trusted entity, and so we are getting to that diagram I showed a little bit before we get. We introduced- if they're disinterested but incentivized- third party service, the Turing signing server, which will act as a permission request arbitrator between users and contract creators. To the server we upload a strict, specific turing complete program or smart contract which will create transactions. They don't execute, they create transactions. So the contract creator will build a program which will create

[13:00] Outputs. It's basically just in this. In my case it's going to be a lambda function, but ultimately it's just an API endpoint which, when called, takes an input and then outputs a valid transaction. Stellar transaction and then the Turing signing server, as you can see here, stores contracts and holds keys, and those keys are seller keys which sign for the transaction that the contract generates, and in Stellar we have this concept. The reason this works or is valuable is because in Stellar we have the concept of multi sig where you've got multiple signers which can be added to accounts and can sign for any transaction that's being originating or originates from that account. So if I want to make a payment, I can sign with my key, or I can sign with somebody else's key if they've been added as a signer to my account. And so as we start to, we create this contract and we

[14:00] Uploaded to a turing signing server. When we upload it, a signing key is sent back to us, and that signing key is what we upload to our contract. We add that signature to our contract or we gave it to our user to add to their accounts so that we can sign for some action off of their account. Now, when we have just one Turing signing server, we're going to see that doesn't get us any improvements, but it's the duplicity, the lots of Turing signing servers where we start to see the power come out. but this allows for transactions and their signatures to be generated following the strictness of a codified contract rather than the trust of a contract creator entity- and this is the big point here. That's may seem a little bit abstract, but it's really powerful because if I want to do something- let's say I want under very strict, specific circumstances- I want you to be able to use my account to pay

[15:00] Yourself a hundred dollars. You know, if some parameter is met, I can't ever give you my secret key, because if I give you that you can do much more than just pay yourself a hundred dollars. So how can I give you access to my account without giving you complete access to my account? It's only strict, specific, turing complete access to my account. Well, I get that through this contract creation, where I upload a contract to a Turing signing server and then you interact with that Turing signing server and, rather than you having access to the secret seed, you have access to only perfectly signed transactions from those turning signing servers. So I don't give you a secret key, I give you signed transactions through these Turing signing servers and then you can interact with the Turing signing servers rather than directly with my account. And that's kind of one example, but hopefully that starts to make sense.

[16:00] So the reason this becomes, or how this becomes, decentralized is we upload these contracts to lots of different Turing signing servers, so it's the same contract across lots of different Turing signing servers, and then through thresholds- right, so we're out of T signers, multi sig to accounts, but each of those can have a threshold. So I can say: to make a payment, you need a threshold of three, so I need at least a weight of three to be able to make a payment. And so when I upload all this same contract, all of these turns signing servers, they all send me back a key which I add to my account as signers, but only with a weight of one, so that no one turing signing server, not even two turing signing servers, could sign for or collude to do something with my account. You would need at least three and through thresholds, you can add any number of, I guess, up to 20 thresholds to agree very complex, secure logic to

[17:00] Account for whatever kind of logic you're trying to perform with your contract. But essentially you're just going to upload this to a number of turing signing servers and then, through thresholds, decide how many of those turing signing servers need to add their signature to the transaction that's being requested. And because it's the same contract, it's producing the same transaction, the same XDR, and if any one of these gets a little sneaky and tries to, you know, make a payment to themself, they would change the XDR and therefore the signature for all the other turing signing servers would be invalid. If the requests that the user is making to the turning signing servers is different than any of the others, it will be rejected, it'll be spat out because it doesn't match any of the others and the signature therefore would be invalid when it finally comes to submission time. And so now the contract creator is a nonentity they no longer really interact with. The user interacts directly with the Turing signing server. So contract

[18:00] Creators don't even need to, at this point, run a server. They just uploaded some arbitrary JavaScript logic or really any programming logic, language logic, to these Turing signing servers. And, so long as it's valid and producing good transactions and being used and not being nefarious, the user can interact with Turing signing servers completely separate from the contract creator, in a decentralized manner, getting transactions which follow the pattern that the contract creator allowed for because they've added their signature to it and, in this case, following our example before, the user can begin interacting and making payments to themselves for 100 so long as it follows the pattern that the contract creator allowed for. So hopefully it's starting to make sense. Turning signing servers allow for secure, decentralized transaction creation and signing through programmable contracts. So again we need to remember that Turing signing servers their goal is to create transactions, not to submit

[19:00] Them, so they perform the business of creating a valid signed transaction and that signing doesn't have to be- and often I would say is not- complete. It's partial signing, it's signing for some of the logic of the transaction that was performed, but there's- probably should be- some piece that's left to the user, whether that's paying the base fee, whether that's in a- you know, a vending machine example- you have to pay a hundred lumens to get a hundred of your asset back, like Ana ICO model, or some sort of token giveaway, or there's lots of different instances where you're, the user is going to be the final signer, and so the transaction that comes back is signed and it's signed enough for all the interaction that deals with the contract creators account, but there's still some piece that's left for the user account. So it's just adding signatures to a transaction, but not necessarily fully signed, although that obviously could be. Again, the business

[20:00] Logic appears in the contract, not in the XDR itself, not in the Stellar transaction itself, so you can create all kinds of business logic that produces a transaction. At the end of the day, that could be any sort of thing and that's kind of what we're gonna look through here now. So, again, like the motto, for this is you get what you permit. So when you start talking about, could I do this or could this be used in this case, the answer is going to long as is related to, like seller transactions and getting a payment and kind of really getting access to your account through a secure contract, like so long as that's the question, the answer is yes, because so long as you create the right permissions, it's you can allow for it. You can build for something like that amazing. The houses, compared to etherium smart contracts, will just look through this really quick. So now with this, FX would have, along with the 3m, decentralized transaction creation and

[21:00] Decentralized transaction execution, and then the difference here, arguably, is going to be again the safety over liveness that we have within the selection, since it's protocol, versus if you're in virtual machines anyway, where the safety aspect to the contract control is it's just creating transactions, it's not actually executing them, and so you don't have to necessarily worry about your accounts or about the safety of your account so long as you've built your contract correctly. And then the liveness aspect of it is going to come down to how well did you write your contract, is your account funded, all the things that are already limitations just within Stellar, versus the ethereal model which is, once you upload a contract, there's nothing you can do to really alter that, because both transaction creation and execution are happening at the same time. But that contract will always exist, it will always be up, unless you have some of those non decentralized back doors open. So some of the core philosophical design

[22:00] Differences: Stellar, smart contracts: nothing unacceptable can happen. In a favor smart contracts, nothing unexpected can happen and there's benefits on both sides. Really depends on what you're trying to build for those Stellar smart contracts, because that is just generating a transaction, the final execution is in the hands of whoever the final user is, whereas in aetherium, smart contracts, the final execution is in the hands of the contract. So you execute it, hoping that it does what you expect, whereas with a social on card track, you execute it and then it spits out a final transaction which you have a final say and whether or not you want to submit it. So, finally, the thing that we were all looking forward to, examples, and I think, yes, that is pretty much my last slide. I'm going to switch now to my browser. I'm going to open- I've got some glitch demos here. So fantastic little service here, glitch, and I'm going to open up all of these examples and then make this a

[23:00] Little bit bigger. So the first one I'd like to look at is a very basic kind of run of the mill vending machine example. So when we talk about smart contracts, vending machines- kind of a really good starting point where you give it an input and it gives a guaranteed output. So in this case we're running a Tyler coin trade or swap where you send in a hundred lumens and you get a hundred Tyler coin back, or it's always a one to one so if you did 50, it'd be 50 one to one so if you did 50, it'd be 50 if you'd tend to be 10. So I've got an account here. So if I can open this, I've got an account here which I am making a payment tune, and this is just a standard seller account that I've funded with friend bot. There's nothing fancy that's been added to this. There's a contract, though, that I've uploaded that says all the logic around: when a transaction come

[24:00] Or when a request comes in to this contract, take a hundred lumens, make a operation for taking a hundred lumens from this account and then send it ten- all right, send it ten top corner 100 for 101 to one, and so we'll give it that hundred, and then we'll generate the XDR. So let me just pop in the code for this real quick. We make that a little bigger. So this would be our vending machine smart contract. So, essentially, there's a contract that says when a request comes in and it has source and amount, we're just going to build a Stellar transaction and then spit out the xgr and that's going to be a payment for 100 lumens to me and then send back tot it going to the source account, which is the account that we add right here, and then it also adds the fee payment to the

[25:00] Turrets. So to the Turing signing servers. again I mentioned that they are disinterested but incentivize third parties. They have no benefit to get from collusion but they have benefit to get from collecting on fees. So if you run a Turing signing server, you can charge fees to execute these contracts as well as upload contracts. So transact servers have a business opportunity but they're just interested in the sense that they don't care what contracts are being run. So this is a very- I mean 57 lines of code plus comments. So very small little contract. But it does allow arbitrary logic and it allows me to safely say I can run an entire contract here of paying out my Tyler coin in exchange for XLM, all through just this very basic JavaScript code. So I'm going to upload this. When I upload this contract to a Turing signing server, they are going to send back a signing key because this is

[26:00] The account, this is the contract address that is going to be paying out Tyler coin. If we look this up in still our experts on the test net, we will see the windows condemn. When we upload it to the Turing signing servers, they send back signing keys and those signing keys are what we add to this contract to allow for these contracts to actually generate signed transactions. Because the Turing signing server is going to generate an XDR and then add a signature using whichever signing key they have for that contract. And then we have a threshold of three, like I mentioned before. So if three, so long as three addresses sign off on this, any transactions coming from this contract, we can generate a valid signature and the execution the transaction will go through, in this case paying out toilet claim. So let's go back here and generate that xtr, that generate

[27:00] XE. Our button is going to call the Turing signing servers. It's going to say: hey, this account would like to generate an ex TR and it looks like we have got a, an ex TR and it looks like we have got a beautiful error. So you know, so is the way it goes. But essentially what would have happened if it had worked would be: the contract goes out to all of those different addresses, all those different Turing signing server sends back the same XDR with the signature. The signatures get added to the transaction that comes in. We add our final signature to the ex TR to the transaction and then we can submit it right. So we have to. We have this account. We would have to sign for that hundred lumen payment. It pays out the hundred lumens and then the signatures that we received from the Turing signing servers for the Tyler coin are all valid. All the signatures are there. We can make this relatively complex payment all through a very simple Turing signing server smart

[28:00] Contract. So that would be our vending machine example. The next one would be. Let's do this weather coin, so this one kind of showcases, but I would call Oracle eyes data. But really it's just taking a third party API and using that information to generate a transactions, a different transaction or our variable transaction. So in this case we are using the dark sky API. We are looking up the weather at my current location and if it's raining, we are going to generate a transaction for rain coin, and if it's sunny outside, we're gonna generate a transaction that pays out Sun coin, and so again we need the same address. When I upload this, the same thing happens. Each sharing sighting server sends back a different, a new signing key. We had that signing key to the contract and then the contract, when we call it, will generate signatures for this particular transaction. So hopefully this

[29:00] One will work. It's not raining at my house at the moment, so unfortunately you can't get a any rain coin. So in this case it's looking it up and it's saying, because it's raining, we're not going to be able to get any rain coin. So if it was raining, you'd be able to get rain coin. But because it's not theirs, I think there's logic actually running in the glitch app which says: if it's not raining, don't generate the XDR. So maybe a little bit of a letdown, but still you can provide arbitrary logic to say, because it's not raining in my house right now, we're going to spit out and reject this transaction, which is really cool because you allow that logic to say: I'm going to give away like usage of my account, but only under certain parameters. And in this case it's an arbitrary third party API which is providing the information. That's as well. It's not raining, and so because it's not raining, we're not going to generate a signature for it. We're throwing that out, which is cool. The next one would be the filter

[30:00] Smart contract, and this one's actually a little bit different because, instead of adding signatures to a contract address, we're actually adding signatures to an account, to a user's account, and this is one of those examples where a contract- the ones we've looked at so far have been sort of third party services, so somebody's actually trying to run a business off of smart contracts. In this case, somebody just created a random- you know, open source- smart contract which provides filtering functionality, and so maybe I have an account that I want to give access to someone for, but only if they're XLM- payments are below a hundred lumens. So I've made a filter smart contract here which basically says: when a transaction comes in, so the input here is actually in xtr. So we're going to generate a Steller's transaction which has to have just one operation, which is

[31:00] A payment, and it has to be an amount- that is less than 100, because if it's great, greater than 100 lumens, the request will be rejected. But in this case we actually want to attach this contract to a user's account, not to a contract account. So there isn't really a contract address here. Somebody's just created this contract and says, hey, I'm gonna upload this and if you would like to get this to use it, if you would like to get this filtering functionality for your account, then you just need to add the signing keys to your address. So if we take this xtr here, which is a valid example- we can look up the account that it's attached to. So we've added the signing keys to this account and right now there's just two. So we've uploaded this contract to tutoring servers, taking their signing keys and attach them to our account. We

[32:00] Have a threshold of 3, which means we need all three of these, both turning signing servers and then our own TFI signing key to sign off on, and then we kind of have this escape base64 or sha 256 hash that if something terrible happens and we need to rescue this account, we kind of have that in our back pocket. That's not a turning signing server thing, that's just good practice if you've kind of locked out your account to yourself. But anyway, sharing signing servers are going to sign for two. So by themselves these turning saying servers can't do anything. There's no collusion capability possibility because at most, they would only have a weight of two, which isn't enough to do anything. They would need that final signer, my sign, my signature- to actually do anything. So, however, I can't also, by myself, do anything. This account is useless on its own. It needs those other tutoring signing servers to actually accomplish anything. And those turning signing servers are locked in to only signing for this, which is that the

[33:00] Transaction is greater than or is less than 100 limits. So if we go back here, we can see this payment is for 100 XLM. So if we go and we generate the xtr on this- all of my examples are today- this is not fantastic- and we try the invalid one. It works. It doesn't. It filters a transaction here looks like this one's not working. I think I may have uploaded the beta X beta. Let me look real quick at the contract address and make sure I'm actually using the right contractors, because this one is kind of cool, so we edit. our project real quick in our JavaScript. Know it's got the right one. Yeah, who knows,

[34:00] Probably shouldn't have fooled with it too much before doing the demo. But anyway, if you had a valid example which we- this is valid X? Er but looks like something's up with my Turing signing servers, this would be valid. It would be signed. You could view it in the laboratory and then submit the transaction to the network, so long as it was under that hundred. One more example here: this on glitch is our hourly wager demo. So I play video games occasionally and on Fridays will do wager pools. So maybe, like you know, 10 lumens or 20 bucks or something like that, and there that all gets pulled together and whoever wins the game gets the pool. You could also see it as a donation pool where, or even like a Kickstarter or something where, if

[35:00] Balance reaches over a certain threshold and the money's released. There's lots of different smart contract logic that comes through these types of functionalities. But you don't want a single entity holding all those funds with the risk that they could run away, and so you might add multiple human signers to that. But if one of them gets bitter and doesn't want to do the thing, that, you know I go you cheated and it's I'm not going to sign off on this transaction where you could run it to issues, when you have those human variables. But if it's just machines and they're just following contract logic, you remove that layer, that risk and do the perform, that trust minimized aspect of things, which is really what we're after and what turning signing servers exists for. And so in this case, you have a contract address which has the Turing sang service been uploaded to all of the turning signing servers, with threshold of three again. So you need at least three of these Turing signing servers and then individuals will start to pay this account. You can see the payments coming into this account, into the wager pool, and then, in

[36:00] This case, every hour the contract will go through, you'll be able to generate an xgr which will pick at random one of these individuals as the winner and payout the pool to them. So, again, if we go to our arrow, the wager contract- it's a little bit longer contract, but not really still 100 lines- where it takes into account the operations for this contract account, looking at the payments, and then we'll randomly select one of those as a winner every hour. So those are examples. In that case, again, you upload the signers, in this case to the contract, like we did before. The last one that I think is really interesting is a recurring revenue model. So one of the issues right now with recurring revenue models on Stellar is that you have to pre sign loads of transactions and kind of bump sequence numbers and it gets quite hairy when it actually comes time

[37:00] To execute those, as they have to give to pre sign loads of transactions, especially if it's like shorter terms, on weekly or monthly basis, and you have a lot of these transactions just kind of sitting around hoping that they'll be valid whenever it comes time to submit them. With Turing signing servers, you can create a contract which takes into account when a payment, was last made and for how much it was when it was made, all the information around the actual payment and then, if it's time, if it's been a month since the last payment, you can make another payment and so essentially you would create this transaction much like the filter transaction or much like the filter contract. You upload this contract, add the signers to a user account, but those signers can only sign through this contract and so if it's been a month since the last payment was made, you can call this contract and it will generate a transaction which makes a thousand lumen payment. But as soon as you submit

[38:00] That to the network, it's and you try and call it again and say, hey, I just want to keep collecting thousands of lumens from this account, it's going to say, hey, it hasn't been a month since the last time we ran, since we ran this contract. So in that case you don't have to have any pre-signed transactions. You simply wait until the time comes, you generate the transaction and you can actually generate it and submit it through some sort of third party service. The user wouldn't necessarily ever have to know, other than they would still have ownership over their account and if at any point in the future they wanted to cancel their subscription, they would simply remove your turning signing signers from their account and any calls to that account to make a payment would fail because the user removed this turning signing server signers from their account. So I think, if this account still exists, we could actually look at

[39:00] The signers that have been added for this account. It looks like I saw on that one. I think it's actually yeah, so we've got the two signers here, but then it's also got a threshold of two. So while we need both turning signing servers to generate that recurring payment every month if at any point the user wants to remove those signers, they're able to do that because they have a weight of two set on their operation threshold. So that's been a basic overview of what I have so far on turning signing servers. It's still a work in progress. Obviously, if that's something that seems interesting to you- and hopefully it does- I am looking for more people to get involved on actually building out smart contracts. So I have quite a few turing signing servers, just tests that turn signing server set up, they're ready to be used, ready for people to poker and see what's possible. Hopefully some

[40:00] Of these examples have gotten your wheels turning, but now is kind of the announcement for that. We need some people to start using this thing, to start poking it around to see if this makes sense as a septa, see if we built the right thing, and then towards the as that sort of happens and we sort of get a better idea of what this should be and how it works and doesn't work and what kind of contracts can be built using this. We'll move into the actual draft, the SCP draft portion, where we write it all up. We have the API endpoints. We showcase how to build one of these servers and run it successfully and all the fees around it and how to generate revenue, how to run a secure turning to a server, but also how to create good contracts and then hopefully we can get it to an active state where it starts to be used more and becomes a normal sort of used active seller ecosystem proposal: within the ecosystem where these Streng

[41:00] Signing servers become possible, where anybody can spin up a contract and upload it to a plethora of turing signing servers and then, beyond that, it's just the acceptance of it and it becomes a normal part of Stellar development. Alright, so that was long. Apologize for that. Apologize that the demos didn't work out great. Hopefully we'll have those back up and running so that everybody can play around with what we have so far. Should have that within the next couple of days and linked on the youtube. Let's go for questions. I hope there's a couple of questions that you guys have for me as things pop up and I will begin to answer those and then we'll close out. But as you have questions for me, feel free to type them into the chat and we'll walk through them. Otherwise, you can find me on Twitter and key base at T. Y VD H. I would love to chat. All right, how is this relevant for cross border payments? Where does this fit in decentralized finance? Well, you kind of

[42:00] Set it there. In decentralized finance, a lot of its going to boil down to what you mean by decentralized. Everybody kind of has their own idea of what decentralized means, and when it comes to things like D- central payments for cross border payments or decentralized finance for cross border payments, it's gonna come down to like who's in charge, who's in control and what are the differences? What layer's do you have when you're talking about ownership? So in the case of an anchor, for example, and wanting to facilitate payments being made in and out of the ecosystem, or putting up offers on the orderbook to maintain liquidity between assets, right now all of that stun and a completely centralized way where an entity controls their orderbooks and so long as those orders are out there, they're free to take them down. And when you have these cross border payments moving back and forth, that can become an issue if a large portion of the success happens on one entity maintaining liquidity. So it

[43:00] Would be possible that a liquidity provider could create a smart contract that creates orderbooks that are decentralized, where they don't have the ability to alter or remove the orders, that it just runs the liquidity and doesn't remove itself, doesn't have a capability to remove itself. So a lot of it has to do, I think, with removing barriers towards trust. And this is actually kind of interesting because that's one of the biggest barriers when doing cross border payments is: do I trust them? Are they going to do what I expect them to do? By using turning signing servers are really by adding decentralization or trust minimization into your workflow, into your business logic, you're able to guarantee some level of trust because you relinquish some portion of control, whether that's liquidity providing or making good on payments. The more that you can guarantee through math that something is going to happen, versus guaranteeing through goodwill- or I have a good business plan, I've done this in the past- the better off you're going to be when it comes to winning people's trust, like it's going

[44:00] To become true more and more as other businesses do that and say: you don't trust us. You verify through the code that we've written that we don't ultimately control, weave or link which control of our secret key, our ability to alter the state of the ledger, to these transient servers which ultimately own the contract. They run the contract through users interacting with it. So in that sense, depending on how it's implemented and at what level, it makes sense for a company to add in trust minimization to their business logic. Pterence and insurers will be useful for cross border payments or decentralized finance, but a lot of it again is going to ultimately boil down to what is decentralization mean and is that actually helpful when it comes to trust minimization or making payments across borders. Is SCF going to run a turn signing server? Who runs strange signing servers without any incentive? I don't think SDF is going to reconcile you server. I mean I run a couple right now just as testing

[45:00] Demos. But yeah, there is tons of incentive to run a tutoring center. We didn't talk a whole lot about fees or uploading contract fees, but that's a big part of running a churning signing server. It would be kind of a separate talk. What is it like to run a turning sign server but you can charge excellent fees. So basically part of the XDR: when transcending server spits out a transaction, part of that transaction is payments to the turn sending servers. So those are these small fees paid out to the Turing signing service, as well as fees for actually uploading a contract. So it might be ten or a hundred lumens or five USD to upload a contract to a turing signing server. So there's both the incentive for people to upload contracts but also to run good Turrentine servers so that you can continue to collect on fees as cheering sighing servers are executing smart contracts. Don't understand why you need

[46:00] Signed transactions with other party. When you share your sign, transactional attorneys, sensor, owner of training center to execute your contract only if that Turing something. Let me read the question. I really don't understand why you need Turing signing servers to share signed transactions with other party. When you share your sign transaction with Turing signing server, owner of Turing signing server can execute your contract signed transaction to attack you again. That's only if you allow that. How did you write your contract? Because you some turing some contracts may accept a incoming XDR, but it's not. It doesn't have to be a signed transaction that's coming in, it's just instructions or it's just a contract. It's just a that's been submitted to a jury in signing server but it doesn't have any signatures on it yet. And if you write your turn signing server contract in such a way that the output is a partially signed transaction, so not full, where you still need to sign for the source account, you still need to sign for those fees maybe, but there's still another signature that's needed, the

[47:00] Transaction is only partially signed. It's not Val viable to submit to the network yet. So what? Someone? Yeah, a lot of it is gonna boil down to trusting all of the Turing signing servers together. But you already trust that with the way the seller consensus protocol works, where you trust the individual nodes that are running Stellar. So this idea of disinterested but incentivized third parties is quite strong and it has been proven to work quite well. So ultimately it boils down to again: you get what you permit. And if you allow for the generation of a transaction that is completely signed and valid, then, yes, the turning signing server could submit that. But even that isn't necessarily an issue, unless they're submitting something that you don't want them to submit. It ultimately depends on what that transaction accomplishes. But because you're splitting up your secret key between lots of different during signing servers, any single one probably shouldn't- unless

[48:00] You've allowed for it- be able to do anything on their own. They would need to collude with other turing signing servers to actually accomplish anything dangerous. So what's the difference between sharing your signed transactions contracts with Turing signing server over traditional servers? The only difference is they aren't their traditional servers, just operating as turned sending servers. Ultimately it boils down to two owns the turing psychic servers, because if you own them, there's not two centralization there, but if some other entity owns those, some other entity is running those, so long as again, you're uploading it to multiples of those you're running sort of a. It's not a clone, but it's similar to how Stellar works already, where SDF and Lobstr CoinQuest all run validator nodes and you submit a transaction to their network and they validate the transactions and perform the operations

[49:00] Within those transactions. This is kind of the same thing where you have a secret key which is split up amongst lots of different servers and those servers then add their signature to any transactions coming from the contract and so long as it's valid and it's all the same, and it's a valid signature, it can be submitted to the Stellar network. How would you see this use for subscriptions, like you mentioned before? Also, does this support more than just JavaScript? So I gave an example on the subscription model. Ultimately, you would just have contracts that were built for different amounts, or it could maybe take variable amounts. I haven't thought too deeply about exactly how would we use. My purpose isn't to be too stringent on how it should be used, and more provide a platform that works and then allow other people to build on top of that. So you kind of would have to think: ok, if I can either get ownership over someone's account, but in a very controlled way,

[50:00] Through contracts, only through contracts, or I can give ownership to my account, but only through strict contracts, what does that allow for? What are the capabilities there? And then there's tons of them and subscriptions would be one of those with fee bumps, I don't know. I will be interesting to see if fee bums kind of gets rid of the issue with recurring revenue, since you can pay sequence numbers and fees from different accounts now. So some of the issues we had there may already be gone. I haven't looked into that too deeply, but when it comes to complicated or turing complete recurring revenue models, or you need to do much more beyond just paying fees and sequence numbers. You actually need to do some logic, external logic, or taking accounts of the person's account. You know like refunds or oh, they partially paid, and now we have to perform some logic around. Some sort of partial payment or upgrades and you know more strike like functionality. Then you could use something like this

[51:00] To accomplish that through, because the turn signing server or smart contract logic and again you don't do. You need to do that. I don't know. That depends on how much your users need and value a decentralized option for something like this or a decentralized option, and maybe they do, maybe they don't. That, ultimately, is up to the users and what they expect out at the services that they're making use of. All right, do we have any other questions? Those were good questions and again this isn't set in stone. This is very isn't discussion and we don't want to spend our time doing the wrong thing, but at the same time, all you have to do is spend a little time looking at aetherium to realize that smart contracts and turing complete smart contracts is a very powerful tool that is very valuable and I think it's worth taking a look at. Is there opportunity, doesn't make sense for us to include some sort of functionality like this functional

[52:00] Feature- parity- that would allow for decentralized transaction creation where you don't have to trust the person who's creating the transaction. You can mitigate that, you can relegate that through other parties. All right, SuperDuper, I appreciate everyone hanging out again. Feel free to reach out on key base or Twitter with follow up questions. I'll try and get working links to these demos as well as some API Doc's for people to poke around. If you want to get involved building these things or testing it out, be sure and reach on them, you know. Thanks again or for coming out, and we'll catch y'all later. Bye.

</details>

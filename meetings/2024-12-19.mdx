---
title: "BLS12-381 Building Blocks and CAP-59 SDK Updates"
description: "This overview highlights SDK updates."
authors: [carsten-jacobsen, jay-geng]
tags: [developer, CAP-59]
---

import YouTube from "@site/src/components/YouTube";

<YouTube ID="51SitOUZySk" />

In this meeting, Jay introduced the new BLS12-381 cryptographic building blocks added in Protocol 22 and explained how they enable advanced verification workflows on Soroban. The discussion focused on what the primitives are, why pairings matter, and how these host functions map into SDK interfaces developers can use today.

Jay also demoed practical examples: verifying aggregated BLS signatures and validating a Groth16 zkSNARK proof on-chain. Along the way, he highlighted key SDK ergonomics (like checked vs unchecked operations and `pairing_check` design), plus current gaps and improvements still being worked on.

### Key Topics

- What BLS12-381 provides (G1/G2 groups, pairings) and why it unlocks encrypted/advanced verification patterns
- CAP-59 overview and the set of new host functions introduced for BLS12-381 support
- Hash-to-curve and domain separation tags (DST) for safely mapping messages onto curve points
- Field operations (`Fr`) for scalar arithmetic used by curve operations
- SDK surface area: `bls12_381` module and near 1:1 mapping to host functions
- Difference between unchecked point ops vs checked variants that enforce subgroup membership
- `pairing_check` approach (vectorized checks) to avoid expensive `F12` pairing result materialization
- Demo: aggregated BLS signature verification (multiple signatures verified efficiently via pairings)
- Demo walkthrough: generating a simple Groth16 proof off-chain and verifying it in a Soroban contract
- Expected performance costs (high CPU budget) for signature aggregation and zkSNARK verification
- Clarification on scope: on-chain verification is supported; proving remains off-chain and toolchain-specific
- Notes on current UX gaps (e.g., storing serialized point bytes, point negation conveniences) and planned improvements

### Resources

- [CAP-0059: BLS12-381 Host Functions](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0059.md)

<details>
  <summary>Video Transcript</summary>

[00:00] Hello everyone and welcome to the Stellar Developer Meeting this year and on the agenda for today we have two things we have Jay from the core engineering team they'll talk about some new additions in Protocol 22. And then he is going to give some demos. So I will invite Jay to join me here on stage hello can you hear me yeah I can hear you okay great hi everyone I'm Jay core developer today I'm going to walk you through the building blocks, that we introduced in protocal 22, which went live U this month a couple weeks ago specifically around the The cryptographic Primitives namely bs2 381

[01:00] so yeah. So the CAP for bs2 3d1 is [CAP-59](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0059.md), which was introduced I would say three or four months ago. But today I'm going to focus on just like a high level overview of what you can do with different types of functions introduce as well as the SDK interface and I'm also going to show a couple examples simple ones to illustrate how you can make use of these core functionality today to build useful applications. So let's get started first let me share my screen okay. So yeah walking through u a few things

[02:00] so first just briefly take you through the CAP since this is not a protocol meeting I'll just be really brief and not spend any time explaining the details and nuances you can read more about them. So yes. So this [CAP-59](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0059.md) is about. So yes. So this [CAP-59](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0059.md) is about bs12 381. So the brs1 123 3d1 is a new curve, that's added. So the well it's not a new it's not one curve it's rather like a family of Curves U there's namely the G1, which Curves U there's namely the G1, which is the base field. And then the G2, which is the extension field and what's useful about this curve specifically is, that you can compute pairings, which is taking a point in G1 pointing G2 repair them

[03:00] and. Then it Maps into a different point in a higher degree space. So at a high level what why is this useful you might ask. So just like cryptography we wanted to compute like we want to do computations and we want we don't want to do them in a plain manners right just like ecdsa you utilize the properties of eliptic curve. And then the particularly the discrete logarithmic problem is hard to solve meaning, that. If you multiply a point a certain times on the curve and get a different curve it's really hard to invert, that process to get the number, that you multiplied with, which makes it useful for private key and public key. So same principle here B2 C1 is just eliptic curve and it can

[04:00] it can used it can be used for signatures, which I we show in our first example later on. But it's also it can do a lot more. So yeah. So the high level G of this is, that using the new curve you can do encrypted computation, that follows certain rules and these are the basic building blocks, which people use to build more advanced and interesting applications such as CK knock all right. So yeah. So here are the new host functions introduced I think the total is like 12. If I remember correctly there's a yeah the basic ones Point addition G1 Point multip multiplication with a constant MSM, which is basically a scaler like a

[05:00] vector multiplication, which is yeah just multiplying a vector of number by a vector of points. And then add them up. So and. Then so these ones the hash to curve in map to curve these ones are. If you use. If you want to use a digital signature scheme like. If you want to map a random message onto the curve and map to a point perform the cryptographic functions on it you first have to take, that message and you have to Hash it onto the curve internally how it works very briefly is, that it there's a h this hash function sh 256. And then you also provide something called a DST, which is the domain separate Separation The Domain separation tag, which is just a tag, that you append to every message such, that your applications domain

[06:00] separate from say like Ethereum's application like. So it's always good to have a unique DST for every application to avoid some kind of intricate attack. So the basically how it works is, that it just hashes like repeatedly hashes, that message into a certain lens, which corresponds to the length of the point on the length of the point on the curve. And then it checks. If that point is on the Curve and then. If not it add one and repeat. And then once it is on the curve. Then it multiplies by some co-actor to send this curve to the correct subgroup. So this is just getting a little bit into more detail is, that these curves obviously they are Prime like they Prime field. So the it's the numbers Prime field. So the it's the numbers on this curve are modulus of a on this curve are modulus of a large Prime in this case the prime

[07:00] number is 381 bits long thus the name U BR is 12 381 and the subgroup is different subgroup is the number of points, that we pick or like the definition of the curve pick such, that these operations are defined. So the subgroup is a subset of all available points on the BS 81 curve. And then the for this particular case the subgroup size is 256 bit so, which is very convenient to be represented as a big U 256. And so yeah some of the host functions here actually. If you look at they're called f, which basically takes some U 256 vales. And then like add them together like these numbers represent the scalar in the

[08:00] represent the scalar in the definition of this particular curve where the modulus of the scaler equals the subgroup size. So this is useful for manipulating the points like multiplying them. And then making sure, that this scaler is actually like represented by the points on the curve like yeah. So we just covered hash to curve. And then yeah. Then we repeat for G2, which is different group of points same thing here map to G map to G2 hash to G2. And then the important one or I guess the most interesting one, that the applications built off of is the pairing. So

[09:00] so what the parent does is I'm. to borrow some other slides here. So this is a this is just like a onepage explanation for BL signature, which will cover in a bit in our example and here is just the definition of a pairing, which takes a point in the first group point on the second group pair them up and send it to a different group the interesting about the paing is, that it is bilinear, which means, that it is linear with respect to both the first U term as well as the second term. So so here you see pairing of P plus s is equal to pairing of P times pairing of s and same here on the pairing of s and same here on the second term Q Plus R you can pair them separately and multiply together. So the reason here is a multiplication

[10:00] again this is just some details is, that. Because the paing result is sent to like a higher degree the 12th degree, that's part of the name BR is 12. So we need to get to the 12th degree extension field, which is a multiplic multiplicative Group, which means you can perform like multiplications instead of a additive Group, which is our G1 and G2. So just some details. But important fact is, that you can these relationships can hold. And then by the extension of it. If you have a u on the left side. If you have a p repeated eight times this is essentially multiplying the result eight times and then, which is equivalent to taking the this paring result the plain par result of p and Q and exponent take the exponent a. And then you can

[11:00] move this a either you know on the left side or move it out it doesn't matter. So the pairing this pair relationship can be quite useful as we see in the example of both signature as well as a SN verification okay. So I think, that goes over well we just covered the FR, which is the field this is just a very simple like modular arithmetics. But with a very specific module like addition subtraction multiplication power inversion and, that's, that's all. So now let's look at the SDK. So how does this look inside the SDK, which is what you'll be interfacing with is so. If you look at

[12:00] the SD there's a it sits inside the crypto library. And then there's a brst 381 module. So the all the functions are exposed inside the BRS 12 381 module. So the few additional functions like checking. If a point is in the subgroup. But overall there is a pretty much one to one correspondence between the host function and the SDK function oh and also one interesting to notice is there's a two addition method one is just a plain addition. And then the other one is the checked Edition. So so the reason for, that is. So remember what I said earlier was the BL 12 381 points are defined over a particular subgroup. But but. But just the addition operation

[13:00] but just the addition operation can perform on any point on the curve doesn't have to belong to the subgroup. But in order for, that addition to be useful for our pairings and for our other like a SN operation like they have to be in the subgroup. But the subgroup check is kind of expensive so. If you have a contract, which does like a number of these additions and only you want to make sure the end result is on the subgroup. Then you can use the plain add function, which is not taking the check it's just point doing the addition whereas. If you wanted to be safe. And then you wanted to use the checked ad, which performs the subgroup check in the end

[14:00] modifcation yeah these are all very standard yeah repeat for G2 parent check oh yeah okay one thing about the parent check here like I mentioned earlier in this equation this is a parent check it's check checking a pairing of two points equals some relationship of pairing like with a either like a result of a pairing multiplied by each other or like additional terms. But the pairing additional terms. But the pairing result itself is a point on a higher degree in a higher degree extension F12. And then to compute, that F12 is very expensive. So the parent check is intended such, that we can perform multiple pairings together

[15:00] and. Then check, that this the end result equals to one, which means this pairing returns true or false. If it satisfies true otherwise it's false the benefit of, that is, that these intermediate result they can be performed on a much lower degree be performed on a much lower degree, which is much more efficient and only at the very end do you have to or you don't have to. But like internally the algorithm will send, that to the 12's order. And then do the comparison check with the U the number one in 12 extension. So the reason for, that is in most of the applications either in signature checking or in SN verification you checking or in SN verification you only need to do pairing to check certain relation hold like in a SN for

[16:00] example you are checking, that your polinomial contains a certain structure by, that you are Computing some polinomial relations. And then you're checking, that the left side equals right hand side this relation hold. So you in. Now the point you hold. So you in. Now the point you actually need, that 12 degree extension Point all you have to do is to make sure the left side equal right side. So far I haven't heard of any application, that specifically needs the result of the pairing so, that's why we went with this design of just passing a vector of G1 Vector of G2 perform pairwise Che pairing. And then check the result in the end. If it's equal than equal to one. Then return true otherwise return false. So it's just a it's other line mass is the same. But

[17:00] just you know something to be like it's not taking a single point pair with a single point. But taking a vector of pair with a vector. And then these ones we covered okay. So I think, that's it for the building block oh it took 20 minutes it's probably should probably speed up a little huh okay. So let's talk about the useful applications U first of all the applications U first of all the BRS signatures. So I think I went through this in one of the protocol meeting earlier. So I just keep it a little more brief. Because the other ones I think more interesting. So the BR signature the way it works I'm trying to find the paragraph, that does explanation. So yeah. So so here there's a explanation. So yeah. So here there's a there's some kind of secret key And then oh sorry this is a public key

[18:00] okay. So the public key is some number times the point the generator point. And then the signature is point. And then the signature is the public key times hash of the message and by the parent property. If you just. If you do the public key and the. If you do the public key and the hash of the message. And then you move the Scala part around in the end you just you get a check, which is the generator. So the, which is the generator. So the pairing of the public key and the hash of message equals the pairing of the generator. And then the signature. So yeah. If you it's fairly straightforward the public key here sorry I don't know why you call PK it's actually just a secret key here you can move it appears on the left in the beginning

[19:00] but you can move it on the right. And then this becomes the signature. So the left and right must hold. If this signature is valid and the good thing about it is, that. If you have the same message. And then multiple public Keys signing the message. Then you can essentially just aggregate all the signatures together and aggregate all the Public Keys together do this off-chain and all you have to do is just to verify one pairing. Then you can you know verify potentially hundreds of signatures all at once and this is only this is. If the messages are same but. If the message are unique. Then for every message like M number message there will be like M plus one parent checks so, that's the general idea of the UHS signature. So let's see the example. So so we have

[20:00] here hope you can see the code here. So this one example is already in the s bomb example repo you can look at it today I try to keep it documented I think it's fairly straightforward in the it's a pretty much as increment contract. But the increment is requires an O, which is a for every time you increment it will check called check or. And then check some the signature payload and the. And then the public key. So inside here is basically just loading the aggregate public key loading your domain separation tag. And then construct the vector and call pairing, that's all, that is. And then you can look at the test, which is doing most of the setups here it contains 10 pairs of signatures

[21:00] applying the aggregation and signature aggregation. And then here just runs the test, which invokes the check all with some random payload. If I run, that yeah the signature passes. And then it dumps out the budget. And then yeah. So this simple operation is like 31 million CPU instructions. So yeah remember this is 10 different signatures on the same payload. So 31 million to verify 10 signature you can do also more. If they more so, that's a very brief walk through of the V signature. So through of the V signature. So now I want to go and do something. Now I want to go and do something new and the potentially interesting, which is the cross 16 verifier. So in

[22:00] which is the cross 16 verifier. So in order to show, that we have the building block to build real ZK applications I went and generated a very simple proof. And then Ed a very simple impementation of the grass 16 verifier to verify, that proof and I want to walk you through it. So I don't know. If we have enough time for me to actually. So do we have time how much time we have yeah take the time you need yeah okay yeah. Because I time want to just walk you through the steps, that's required to generate the proof and see it in action. Because a lot of this is looks like magic. When you first run it like just dump dumped a

[23:00] bunch of things. So okay. So here don't know. If you can see the link here. But I'm basically using circum U circum doio. If you just search for it at the installation the getting started guy. So circum is a tool. So circum and snjs is a pair of tools one is for defining the circuit, which is a arithmetic relation of what you're trying to compute. And then snjs is a tool, that allows you to take in the circuit and do all kinds of computations and generate the proof and also verify the proof. So what we're doing is we're going to just follow this exact guide here generate Define the circuit do all the setup necessary generate the proof. And then once we have the proof we will

[24:00] write our own contract to verify it in soron instead of verified in snjs okay. So let's see okay going to make this just screen all right hope you can see my both of my screens. So so I did little bit of preparation. So here's a brand new folder I have these two files these are the exact instructions here it tells you to copy the input copy the circle I just did in advents. So we don't have to go through, that. So the first thing it wants you to do is to install these dependencies, which I already did. So we can skip, that and the second one is, that

[25:00] it tells you to Define the circuit in the circum language the circle is in the circum language the circle is really simple it's the simplest you can get basically multiplying two numbers. And then output the result of the multiplication. However the interesting part is, that these inputs A and B are private inputs. So in the end your proof will prove, that this computation was done correctly without revealing What A and B is. So only the only public output will be C the number the result of the multiplication. So what we did here is just copy this exact program into this multiplier

[26:00] file. And then the next one compiling the circuit. So yeah. So scales gives you the Circ instructions how to do, that. So this is basically just writing this circuit in some formats and so, that it can be understood by the other tools. But there's one thing we have to change on this command, which is BRS 12381. So the reason, that we need to specify this is the circuit compilation needs to know the range of like the range of prime number. So it needs to take the prime number the 3 381 one bit number associated with our curve right

[27:00] associated with our curve right this B 12 31 and use, that as a this B 12 31 and use, that as a curve to generate this circuit otherwise it I don't know what happens, although I haven't tried. But you should do, that. So once you do, that it will generate the multiplier in this R1 CS format. And then some other stuff. So the R1 CS is a rank one constraint system why is it called. So so think of any why is it called. So think of any complex computation like a know a squ complex computation like a know a squ \* Bal C something like, that you can always break it down into simpler computation by creating intermediate Gates. And then assigning intermediate gates to you know more intermediate. And then like in the end you just compute two things to an output. So so the process of R1 CS is just comp deconstruct a complex

[28:00] computation in something into something simple as a left hand side times simple as a left hand side times right hand side equals an output whereas both left hand side right hand side and output are rank one, which means the highest polinomial degree is one. So you can have like a plus b. But not a square so, that's what it is okay once you do, that the next step is to compute the witness. So at this point we have the circuit, which is our structure of our computation. But in order to compute it like in order to be verifiable we have to comput it with some inputs. And then generate the proofs and all, that. So here is just defining the input I did here defining the input I did here, which is exactly what it's using. So it Tak 3 \* 11. So the output will be 33

[29:00] but we don't we won't know about this three and 11. So once we have, that we will enter the JS Library okay it's empty right it's generate yeah some other AO generated code to compute stuff. So what we do here is actually copy this one. But I'll input this some okay. So this one is just generating the witnesses. And then you can also do this with C++. And then once you do, that you have the witness file I don't think we can load it yet. But it's just a yeah the witness is just the

[30:00] yeah the witness is just the input basically like I think the witness is it private or just probably I don't I forgot the exact terminology. But it's possible, that the witness is just a public output U. So so. So only the C part 33 is contained in the witness okay. Now comes to the proving part. So yeah. So so here there's a part. So yeah. So here there's a bunch of commands. If you do it for the first time it will look fairly weird. Because it's telling you to generate a power to ceremony. So what it really is. So in order to what it really is. So in order to compute the proof. So okay. So remember we have the R1 CS file. And then the R1 CS is just a system with equations of different nodes. And then every equation is just a simple

[31:00] rank one left right equals output multiplication and. And so the multiplication and. And so the next step in order to make, that into some kind of provable structure is to convert this into a qap, which is a qu quadratic arithmetic program what it does is to on each side the left right and output it fits a number of polinomial, that evaluate to at certain points. So the number of equations is a number of constraints and at each constraint the polinomial will evaluate at a different points. So to keep them separate. And then a pol polinomial is the aggregation of smaller Pol polinomial defined over each unique node. So what you think in the and is just a instead of left times right

[32:00] a instead of left times right equals output you have a left side polinomial of some degree which matches the number of constraints and same for right hand side and the opposite side and in order to verify this and in order to verify this polinomial computed correctly we. So here's a key concept U is in order to verify the computational polinomial all you have to do is to verify the computation of a polinomial at a single random Point. So this may sound little you know counterintuitive in the beginning but. If you have polinomial of degree two. Then there can be only two roots and then. If you have two polinomial of degree two you subtract them together it can still only have two Roots so, which means, that it can the two polinomial can only be identical at n

[33:00] number of points where n being the degree of the polinomial. So even. If we have you know hundreds thousands of constraints in our circuit the space the total space of our SN the prime modulus or rather the subgroup is 200 56 bits long. So it is impossible for any Collision to happen in real chance. So this a happen in real chance. So this a key concept of how to like how to convert this polinomial into a u into a non interactive check, which is you just need to make sure, that it's evaluated at a truly random value. And then this the verifier or anyone can just take the output of, that. And then make sure. And then check the verification, that the polinomial equality holds with pairing what we introduce here. So this is what it does. So so the power of

[34:00] this is what it does. So the power of to here the long story short is just the steps necessary to generate, that random point at, which the polinomial are evaluated, that's really what it is. So I'm going to spe speed around through these steps here it's not really, that interesting there's a lot of output you can look at it later sorry B 12 31, that's the first step contribute to ceremony some random text it's going to compute set up some ceremony. And then the gr 16 requires a public a Universal setup, which is for the whole like you have to do once

[35:00] and. Then the per Circle specific setup so, that's the second step here

[36:00] so this was the last command prepare phase two. And then yeah just set up the circle specific stuff okay. And then contribute to the another text okay. So now we have the proving key and the verification key set up for this circuit and the next step is to generate the proof okay. So in the end we have this proof

[37:00] yeah, which contains ter terms, which is like encrypted evaluation of polinomial at some point. Then there should also be the public. Json do we get, that oh I think I sent it to the previous folder. But yeah the public should just have one value here, which is 33. So to verify a proof to. So what we need to do is a proof to. So what we need to do is to write a contract this here it makes really easy for you to do. So there's a step where you can call to generate a Ethereum u Solidity contract for verifying. And then

[38:00] four yeah okay. If we just look at it here yeah. So the cont itself is it's not, that interesting I'm not familiar too much with Solidity. But most of the logic here is just packing bits into memories. And then in the end it's called this caring on you know a bunch of terms. So we can easily convert, that into a Sor Bond and the output of you know our contract is just this much it verifies the proof takes a verification key, which is some like G1 G2 points. And then approve, which contains also points in G1 G2 public signal in this case just one, which is 33 encoded into the scale a field number. And then aggregate the input

[39:00] and. Then yeah construct the back to check paing and, that's really it. And then I did I copied all of the outputs it's a it will be a different one than what we gener earlier. Because there an entropy I. Because of the random randomness. But but I did this random randomness. But I did this earlier I just copied all these the pro the proof part and the ver. If ification key part this is proof. And then this is the VK. And then construct the key construct the proof. And then just call the verify proof and assert, that this result must be true. Because the we've putting you know the output at 33 so, which is matches our public output. So let's run this test okay. So it finished and you can see, that this verifying the ZK proof takes around 30 like 41 million CPU

[40:00] instructions it performs four parent checks per some addition multiplication in G1 space so. If you have more public input. Then there will be more multiplication and additions here. But the pairing is only there's only four pairing. So the total CPU is roughly this amount yeah I think that's it sorry for taking longer than expected. But this is it and hopefully, that you can see, that this is you know exciting stuff, that you can use to build DK application today you may ask what's the use of it you know the real interesting part is in the circuit interesting part is in the circuit part. So instead of proving you know a b and c you can write a much interesting one like you know proving hash like comput computation of a hash

[41:00] or knowing a pass in a Merle tree, which is like proof of possession or something like, that. So all the Innovations you know a lot of it can happen on the Contra side, which is what you guys you know are, that stuff. So yeah really looking forward to seeing what comes out of it and yeah let me know. If you have questions we also have a Discord threat feel free to post it there and I'll hand it over to cin great thank you so much this was really good I think the examples and walking through the code really made it U easier to understand and see potential with. So I know we have one question let me see Elliot was asking a question earlier about. If the host functions are all, that's needed for CK snarks on Stellar or. If there's still additional functionality, that's missing I don't know. If you have an answer for, that yeah

[42:00] to verify the SN it's all we need okay. So there are some quoes okay. So there are some quoes in SDK, which we build it like in SDK, which we build it like in the like we provide the most generic like interface to expose this for. But there's a little bit corks like you like for example ear U see in order to try to store, that I have to store the Bice instead of the G1 G2 but, that's the fix and also to compute the negation of a point you have to do it on the contract side. But yeah in terms of verification all the tools are there. But there may be some ux gap, which I'm discovering and should be fixing soon and also with your guys help we will be able to make it better yeah. But in terms of verification, that's it. But in terms of pro proving. So as you see proving has to happen offchain and then, that's quite elaborate toour set

[43:00] and also like different Suites of you know there's different Frameworks of U like Marin you know gr 16 Plank and all the other tools, that you and all the other tools, that you can use. So we haven't provide any of, that and we don't endorse any of it I was just using the snjs as a example. Because that's one of the you know most well known. And then yeah, that also the public ceremony aspect yeah we don't have it on chain. So but yeah you can verify it. But not there's no proving tour CH available at the moment okay great any other questions feel free to put them in the chat I don't think, that's the case we are kind of running out of time. So

[44:00] I will save the walk through of will save the walk through of quick start for the next meeting. But yeah. If there's no other questions. Then I think U we will stop it right here let's see yeah okay well thank you Jay thank you for your presentation it was really good I think going forward. When we add new functionality in protocol. When we upgrade the network I think it's to maybe spend some time in these meetings to go over some of in these meetings to go over some of the new functionality and some of the things we can do as a developer. So yeah look forward to more of. So yeah look forward to more of this kind of presentations. But thank you J Jay and thank you for everyone who joined have a good holiday thank you guys happy holiday bye

</details>

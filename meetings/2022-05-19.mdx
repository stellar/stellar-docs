---
title: "Invoke Contract Authorization and Aliasing"
description: "A deep-dive protocol discussion on Soroban contract invocation, authorization models, and aliasing, focusing on CAP-50’s invoke contract transaction and its interaction with earlier smart contract CAPs."
authors:
  - david-mazieres
  - graydon-hoare
  - jonathan-jove
  - justin-rice
  - leigh-mcculloch
  - nicolas-barry
  - siddharth-suresh
  - tomer-weller
tags:
  - legacy
  - CAP-15
  - CAP-46-1
  - CAP-46-2
  - CAP-48
  - CAP-49
  - CAP-50
  - SEP-30
---

import YouTube from "@site/src/components/YouTube";

<YouTube ID="RVzqxokp-a0" />

This discussion continues the Project Jump Cannon series, focusing on how Soroban smart contracts should be invoked, authorized, and identified within the Stellar protocol. The session introduces and debates CAP-50, which defines a new `invoke contract` transaction that separates the classic transaction source from the runtime contract invoker.

Much of the conversation explores the implications of this shift for developer ergonomics, security, and ecosystem interoperability. Participants examine how Ethereum-style `message.sender` semantics can coexist with Stellar’s existing account model, while also surfacing concerns around aliasing, multisig compatibility, replay protection, and user-facing complexity.

### Key Topics

- Overview of CAP-50 and the new `invoke contract` transaction structure.
- Nested signature model: separating the transaction source account from the Soroban invoker.
- How `get_invoker` enables delegated execution, reusable signers, and contract-to-contract calls.
- Aliasing risks when the same public key may exist in both classic and smart-contract contexts.
- Interactions between CAP-50 and asset interoperability proposals in CAP-48 and CAP-49.
- Trade-offs between single-signer efficiency and classic Stellar multisig guarantees.
- Wallet and UX challenges around account migration, key reuse, and preventing lost funds.
- Replay protection and authorization semantics for contract calls that move assets.
- Ongoing debate over protocol parameters (e.g., contract code size limits) versus fixed XDR values.

### Resources

- [Project Jump Cannon Blog: Choosing WASM](https://stellar.org/blog/developers/project-jump-cannon-choosing-wasm)
- [CAP-0046-01: WebAssembly Smart Contract Runtime Environment](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0046-01.md)
- [CAP-0046-02: Smart Contract Life Cycle](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0046-02.md)
- [CAP-0048: Smart Contract Asset Interoperability](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0048.md)
- [CAP-0049: Smart Contract Asset Interoperability with Wrapper](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md)
- [CAP-0050: Smart Contract Interactions](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0050.md)

<details>
  <summary>Video Transcript</summary>

[00:00] Welcome everyone we're trying out something new by holding the Stellar protocol meeting here on the Stellar stage in the Stellar dev Discord we've been experimenting a bit with platforms the goal is to try to have these meetings in public so, that people can see what's going on and can ask questions and can understand the thought process behind changes to the Stellar protocol. But we also want to make sure, that the platform is not buggy, that it works, that it's easy to reproduce the meetings and it's, that it's easy to attend them. And so we're hoping, that this works we've tried a few different things. If this doesn't work we'll keep trying things until we get the right fit. But we'll see what happens today. So bear with us I will say, that these meetings the Stellar protocol meetings are designed so, that we can discuss upcoming changes to upcoming versions of the Stellar protocol in order to advance the protocol to meet ecosystem needs. So a lot of the times what we discuss are CAPs Core Advancement Proposal and this

[01:00] is where sort of new features, that we're going to add to Stellar are big changes to the Stellar protocol start right and they are essentially technical specs, that outline changes, that we plan to make to the Stellar protocol and anyone can read these CAPs they're in a public GitHub repo the discussion for these CAPs happens on a public mailing list and some of them also here in the Stellar dev Discord again. If anyone is interested in this process or in understanding the CAPs or in leaving feedback about them or asking questions we encourage you to do. So and in fact. If you're going to follow along with this meeting it's a very technical meeting. So I would suggest taking a look at the CAPs in question at the moment we're focused on Project Jump Cannon, which will bring smart contracts to Stellar and there are actually we've sort of modularized our approach to this we're taking different segments of the engineering work, that needs to be done to make changes to the protocol to allow for smart contracts and created a series of CAPs each of, which sort of

[02:00] addresses a specific portion of, that work. And so at the moment there are actually five CAPs, that relate to smart contracts we have 46, 47, 48, 49, and now 50. And over the past week there have been some changes to [CAP-46](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0046-01.md) and 47 and [CAP-50](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0050.md) is a new CAP today we're going to start to continue the discussion about these things and you know as part of, that we certainly again encourage you to take a look at the mailing list and we in these meetings try to address some questions synchronously, that are important to discuss together. But a lot of the work also happens asynchronously. So I encourage everyone to follow along with, that. And so today it's a fairly open-ended meeting and I think I don't know I'm not even sure the exact best place to start I know, that there may be some stuff to discuss on

[03:00] [CAP-47](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0046-02.md) I don't know. If we're ready to discuss [CAP-50](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0050.md) yet or. If we still have open questions about [CAP-48](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0048.md) and [CAP-49](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md). So I guess the first question I have I guess lee is not here I know, that there were a few questions about [CAP-46](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0046-01.md). But it looks like sid you may have addressed those questions maybe we can get a quick review by John over [CAP-50](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0050.md) and the latest changes made there perfect thank you let's do, that done great we can open up there, although I do think we probably should go back and talk about 47 what's in earth later I don't think we've actually spoken about it much in any of these meetings. But let's start with some overview of what's going on 50. So [CAP-50](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0050.md) is. If you saw the first draft, that came out I don't know about a week ago maybe a little more than a week ago it was really focused on just like

[04:00] the question of like what does it mean to sign smart contract transactions on Stellar the scope of it over the course of the week as I thought about it and talk to people a lot of times really change from just like what does it mean to sign. But more of what does it mean to do and what is the ownership model, that we think should be like the default basically of owning it like basically like what does it mean to take an account take an action where your action affects some assets, that you probably own. And so basically like in terms of what's in [CAP-50](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0050.md) and what has changed in the most recent edition basically it opens up with let me actually look at it. While I'm talking about it opens up with some comparisons against like why the model, that is used in Ethereum is really effective the model being basically like you can take actions in general for message.sender in Ethereum

[05:00] there are some exceptions you know where you use signed messages and stuff. But you know prc-20 tokens for example kind of a bedrock aspect of Ethereum are based on this notion of like. If you're a message.sender you control the assets and you can do whatever you want. If you need to delegate, that control you use transfer from, which works via an approval message where first you were message.sender to commit, that approval. So this is the same kind of model, that I. Then propagate to Stellar. And so we introduce some new types of transactions basically, which I'm talking about here is like an invoke contract transaction this transaction starts off looking just like a classic seller transaction source account sequence number fee all the stuff you're expecting to see. Then the next set of parameters are basically like what contract do you want to interact with what symbol are you looking up what parameters are you going to pass, that function, that corresponds to, that symbol. If it exists. And then a read write set, which I don't talk about at all and has nothing to do

[06:00] with this CAP and it's really more to do with [CAP-46](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0046-01.md) I'm not going to talk about it. Then the next thing, that introduces like okay well like who is running this transaction like. When I ask who is message.sender or the terms I'm using is like this get invoker function host function what is it going to return. When I run, that contract. And so basically there's a new signature slot, that basically identifies, that person, that key. And then there's one more layer outside of, that which has your normal Stellar decorated signatures and there's a ton of justification about like why, that's a good model why certain things are done like this like why do you have this like three deep nesting of structure and all this other stuff why shouldn't you know just do signature verification in every contract why shouldn't you do replay perfect prevention every contract all the stuff kind of ties into it but, that's kind of what's in here

[07:00] so John one thing, that strikes me here is, that it's a fundamental shift from the Stellar the current Stellar account model in the sense, that you know it doesn't have the all the kind of like the high level stuff, that you get in a Stellar account it really boils down to like a single signer account right yeah exactly and I think there's like a lot of merit to this model mostly. Because like one of the things you get from like having a Stellar account is this like ability to have multiple signers. But like in reality we use like 80 25 519 and you can do a threshold scheme for, that anyway. So like you can just sign with a signal a single signature on chain, that is like produced to be a multi-party communication multi-party computation off-chain get a lot of the same results as you know having an account with multiple signers

[08:00] signers the other things, that are on the account there is like. When you're running a smart contract you don't have access the way, that I'm proposing, that we've been talking about things right. Now you don't really have access to like your native balance your native trust line directly. So there's no need to have an account to store, that balance instead you would potentially do like a [CAP-49](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md) wrapped XLM type of thing you don't like you can use a different account sequence number you don't need like. If you want to have a sequence number you with the same key you can. But you don't need to. So basically this is just like a strictly more flexible model, that's going to be more efficient on chain. Because everything boils down to a single signature, that's my stance at least yeah it's worth mentioning, that even. If you use threshold signatures. If you want to rotate keys you still need to modify the key, which is basically not an option here

[09:00] that is sort of true there are two ways you could do threshold signatures I'm like not an expert on photography. But like. If you want to rotate the underlying key like for example. If you're like underlying secret key was compromised. Then yeah you definitely don't have, that option here but. If you just want to rotate the key shares, that's actually possible in a re-deal in like a in a threshold system, that supports redealing. So so it depends what level of security you're looking for here interesting and what's the relationship between the classic Stellar accounts and these new Jump Cannon accounts none whatsoever like you might have an account, that's like gabc and you know you might want to sign for you know your smart contract interactions as like gtomer assuming, that you actually had the

[10:00] secret key for, that vanity basically like in terms of becoming the invoker the message.sender you don't need a seller account to exist for, that purpose it's totally completely logically separate I guess as long as you control the key you can become message.sender I think the distinction is not the Jump Cannon there are Jump Cannon accounts and there are Stellar accounts I think the distinction is, that there are Stellar accounts and John cannon doesn't actually have accounts Jump Cannon just has signers or signatures, that's a really good way of putting it lee well you still have a concept of an account on the jumpcat side. But it's more of an like it's like an emergent behavior thing right it's like the sum of everything, that this signer you know owns in different contracts

[11:00] becomes the account it's like an abstracted yeah I mean you couldn't describe it like, that. But I think there's no physical representation yeah I think there's like what the protocol defines and the protocol doesn't actually define an account in the encounter in the [CAP-50](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0050.md) proposal. So I mean the ecosystem and tooling can all refer to these things as account they can treat them like accounts they can display them in, that way. But the protocol doesn't actually enforce, that like it does today in principle. If everybody hated this get invoker mechanism even, though it's like very it's exactly parallel to the message.sender message.sender mechanism in Ethereum. But suppose, that everybody in the Stellar ecosystem totally hated it the proposal actually described. So you could just completely ignore it and like everything would work. Because oh, that's actually, that's one thing I should point out compared to the earlier

[12:00] version, that you and I have discussed Tomer this version actually makes the invoker signature optional, which was something, that came up. When I was talking to Nico about like there are lots of times. When you just like don't need an invoker signature like the contract will never ask who the invoker is. Because it's not relevant and the invoker's saying friends in ed25519 where you need to reveal the key also ends up being like 96 bytes and you just like y sign with some random key for no reason you could just do nothing so. If people don't like this mechanism ignore it I'm still trying to wrap my head around the interaction between like from the user perspective you know they have like a an account on the Stellar side and like what happens. When they move you

[13:00] know let's say we're in the world of [CAP-49](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md) not, that I'm suggesting we should do, that let's say we're there and I move an asset to the smart side and let's say, that my classic side has some sort of like multi-sig baked multi-sig scheme like what would be like the behavior here the expected behavior, that's a really good question I think it depends on what the wallet kind of wants to do for me the kind of same thing to do would basically be to let's say this is the first time you're interacting with smart the wallet generates a new key for you or it asks you. If you want to use some key, that you have. But probably it should just generate a new key for you. And then like somewhere in this proposal there's like a lot of stuff here. Now in the like compatible with [CAP-49](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md) section wrap it basically what you end up doing is

[14:00] you end up signing with the whole multi-sig configuration on classic, that you need you run this rap and it'll be at the medium threshold I should say you run this wrap operation it wraps it up into a smart asset in the [CAP-49](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md) cents and it sends it to, that address whatever address you specify now, that's the address, that owns it on the smart site. So I'm expected to migrate to a new account ID. If you don't have multisig setup you don't need to. If you do have multi-sig setup and you like you uniquely control the key you don't need to like for example like imagine, that I have like you know three hardware wallets and I need two out of three of them to sign to do anything on my account well it's perfectly fine for me to do the public for me to use the master key I'm the only one who knows it

[15:00] but like. If I'm not the only one who knows the master key then, that's not going to work. So it really depends a lot on the configuration of your account. But you should propose address is going to be the same no do we propose a new stir key for the jumpcat inside for these account IDs I don't know, that's a good question homer they're maybe we should yeah I mean you will need that anyways for yeah. If you want to deposit into contracts. So I think the like the dangerous thing here is, that I have an account on the classic side it's a account it's a multi-sig and let's say, that the master signer is nullified, and now I ask someone to send over an asset on the smart side they use, that

[16:00] like the public account ID, and now I don't have, that. And so I'm screwed indeed. If that happens you are completely screwed sounds like a pretty big footcon I mean in general on smart and this is like this is not unique to Stellar this is like true on Ethereum with the rc20s too. If you send money to the wrong address bye money like it's not like seller where we're just like oh, that account doesn't exist sorry yeah but. If the wrong address is the right address and it's on classic, that's, that's problematic yeah, that's, that's the big problem the fact, that they're like two domains and you have like these addresses, that are valid in both domains. But actually mean different things, that's, that's like a huge foot gun. So I do think. If we're going down this route I would

[17:00] definitely say, that we need a new sturkey for accounts on John cannon well and or a new way a new type of account on classic right the people should create deterministic accounts on classic, that don't have a master signer. So you can't accidentally use the master signer. But yeah having a different circuit I guess would mostly do the same thing huh, that's actually not a terrible idea it just seems kind of wasteful to me to require a classic manifestation of an account to do stuff on smart there's actually no dependence on, that thing having any physical manifestation. So like requiring it to come from a deterministic account just seems like super unnecessarily fast like a lot of them you know I'm just saying. Then you can't interpret a deterministic account

[18:00] as a you know. Because like a deterministic account would have a difference turkey right. And so people kind of moved over to, that I mean I guess the question is the plan to kind of like completely junk classic and get ready for is a plan, that like you know classic will form the basis of like a super low cost like high performance DEX and payment network right. So in the latter case it seems worth it to like say, that. Because these smart contracts are designed to interoperate with classic we should like make use of the you know this author did the we should have like a single sign-on. If you will for both sides of the network but. If the plan is eventually to deprecate classic. Then maybe it makes sense not to have single sign-on I mean like single sign-on is a myth no matter what in the world of smart contracts what. If I just build a smart contract, that doesn't use the same scheme like what. If I wrote a smart contract, that actually just does

[19:00] the same thing as the current get invoker scheme you know it does it by you know you submit a single signature I validate, that signature and, that's, that yeah I mean you know of course you can implement crypto schemes, that aren't even supported in classic or whatever you can do anything it's a smart contract well the question is what are we going to make like super easy and what are the idioms, that we're going to kind of train our developers to use effectively yeah John I definitely agree with David here. Because if you look at both [CAP-50](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0050.md) and [CAP-49](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md) there is you know they kind of imply, that you know we expect everything to kind of like move to the smart side in reality. If we want them to coexist. Then you know [CAP-49](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md) [CAP-50](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0050.md) are I would say simple from a protocol perspective. But they introduce downstream complexities across the

[20:00] ecosystem of having you know two types of accounts and two types of balances. So the question is you know does it actually make sense. If we do think, that they'll coexist you know what David proposes like for like having this like another new account, that you can migrate to it's a minimal it's a different type of account it's a minimal it's a single signer account. But it actually has representation on both sides, that might be you know something, that's worth considering. If we expect classic and Jump Cannon to coexist yeah I actually just want to jump on, that and just emphasize this you know, that two sets of keys like two sets of accounts I think we have to evaluate this in the context of the goal of equitable access. So this is a like all of this complexity for users is maybe easy for someone who is

[21:00] immersed in the crypto like in the blockchain space. But for your average user who is an immersed in blockchain technology, that's a pretty high bar of complexity to navigate yeah and it's not just the absolute complexity. But kind of the shape of the curve leading there like in an ideal world the sort of the expert there's kind of a smooth line of like the amount of expressivity you gain versus like your expertise right. And so like. If you start just using classic and you want to write your first smart contract it's actually there's like a relatively gentle on-ramp to get you doing, that right versus okay. Now create a new account type and whatever and I don't know what I don't understand is David's proposal doesn't eliminate the need for

[22:00] having two sets of keys like you just end up with like okay like. Now I have a classic account a normal one a g account i'll call it in the terminology we're using an eternity ago. When we were talking about deterministic accounts, and now I'm going to create another account, that's a d account, that has a different key and I'm right back where I was. So I don't know my interpretation of David's proposal is not to maintain these in parallel. But you know you get an option to migrate to this new account type you know the account this d account is a single signer account, that's valid on both sides and from, that point on the user doesn't actually interact with the g account anymore like they have like this one time migration and presumably new accounts are this d type. But by the way I don't actually think this is necessarily better right like I think, that our you know maybe the concept of just like you know account authority

[23:00] is something, that makes sense to just kind of expose in the smart contract world right and say like well these aren't smart contracts and avoid their smart contracts intended to interoperate with the legacy Stellar accounts. And so to just kind of like expose, that the way you know we expose single sign-on across multiple services is a useful thing is there like again what's the driving force for like why we can't have this key signature be the decorator signatures we have today and instead of having the source account be message.sender. So like the account the classic account ID being message.sender, which means contracts still are only dealing with a single identifier like you know they're dealing with

[24:00] with account ID or contract ID as the message.sender message.sender. And then the protocol just hiding the fact, that you know for the most of the time, that's going to be the master key. But sometimes there might be a multi-seek key. But contracts don't actually get exposed to, that. So from the contract from the Jump Cannon side it's the same experience it's an account ID or it's a contract ID and, that's it and like I think. If I understand correctly the thing we were going for with key signatures is, that accounts don't have to exist. And then we just say, that an account ID doesn't have to actually exist on the classic side for it to be usable on the well I guess it does doesn't it okay sorry no it doesn't like it's this it's actually the same in classic right like you don't have the account doesn't need to exist to use it like you can. If it's a single key like you know like you can always reference it and use it in different schemes like you know as a signer for

[25:00] example it's just a key. So i'd intended to write about this before this meeting today there wasn't enough time it's on my list of things to talk about like why it should work this way and not be just the account signers signing for it. But at the end of the day my justification just comes back to pre-signed messages all the time for this, which is, that. If we don't expose what the account signers are what does it mean to have a pre-signed message let me give you an example imagine, that you're writing an erc20 token, which is all my examples nowadays. Because it's like super fundamental token, that we're all familiar with you have these operations you know you have balance of and allowance and approve and transfer from and blah and in this model everything still works based off of message.sender. So now what I do is I sign with my account let's say, that I have a two out of three multisig account like I was talking about before with like you know

[26:00] I own three hardware wallets I sign with two of them, that's how I do stuff the account only gets message.sender, which is my source account in this model okay. But now I want to implement eip2612 permit how do I do, that like how would you even default how would I even define either 2612 permit also I'm seeing people complaining about my mic volume okay David. Then you should just adjust your just my volume for you everyone sounds good it's just some people are much louder than others. So I have to like constantly adjust my volume, which is annoying but. If you right click on me you can adjust my volume to you anyway

[27:00] anyway oh awesome thank you yeah I got you. So how would you even do eip2612 permit like the way, that works is it works based off of signing a message for the public key and, that was message.sender message.sender okay. So basic and like what signatures do I use. Now like do I use the account signatures. Then it's not transparent I have to go and actually look up the account find its signature find the designers check them against, that blah or do I just use the single signature for the public key, which is the very much more computationally efficient thing to do. But it would be wrong it wouldn't convey the right access controls can we maybe like I think there are like two problems, that we are, trying to deal with here there's one around I think and I think this one exists even in the

[28:00] current version of [CAP-50](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0050.md) like regardless, that is. When I give somebody my address right like my public address how does it look like. If I decide to upgrade my account you know. When I say upgrade to my account to a smart wallet like I really want to move all my balances and stuff right under my wallet. So how would, that look like I don't think the current proposal kind of allows you to deal with this type of situation. And then for the signature scheme like why not. So right. Now we have keyed signature now, that it's actually inside I think what we can do is actually make add a new case, that would be like classic scheme or something right, that is just account ID. And then threshold. And then and. Then the decorated signatures

[29:00] and, that's it. And then you can actually use your like the invoker can be an a classic account ID, which means you can actually use, that as a you know. When you as a recipient for anything really. And then you have the threshold like you do on classic great. But then right back to the eip2612 permit like you still have to go and act like. If I'm a contractor implementing the ip2612 permit I have to actually go and read the account look at all the signers check the signal no you do you wouldn't do, that like you. Because you never sign like to sign something like. When you sign a payload what you the statement, that you have is here's a binary blob right, that you want to sign as a specific invoker right. And then here the signature is fresh like basically you have to sign

[30:00] a statement, that says those signatures. When you add them to. When you yeah like evaluate them in the context of this account you reach this threshold you cannot guarantee, that I don't understand how the account could not go and like could avoid going and checking the contract could avoid going and checking I just I don't see how, that yeah well it's the same like well, that you mean verification wise is, that what you're asking, that's, that code is yeah, that would be like we need a function of source, that is like verify right, that is suppose the classic scheme I think, that's kind of all there is to it but, that has quadratic complexity yeah, that's okay like it's really not no like it's all about what is it no like it's gas codes right like. If people want to do, that they're not blocked from doing it

[31:00] but it's like really expensive whereas like just checking a single signature I'm not saying to remove the single signature I'm saying, that you have a way out of the like my public address is g whatever and I don't. If somebody you know like sees my public address and decides to send me funds using smart I want, that to not go to the devnet. And then you want the contract implementer to go and implement both verification methods I mean what you think is we could also have like a you know like a parameter type or something like a signed blob or an account authenticated blob, that would be you know it would be checked independent before executing the contract basically like maybe we don't need to verify dynamic data like all the signatures can be checked statically we're getting into the area of being like super parental and telling people

[32:00] how to write their contracts. When as a matter of fact you know they already have especially things like the type of bridging applications, that need this type of capability they already have implementations on other networks we don't want to be to parental I think I'm on John's side with regards to keeping simplicity you know as a core value and really like zooming in on these like single signer accounts. But I'm really concerned about the interoperability aspect you know for the ecosystem and I do think, that having migrating to some sort of like a new account, that is a single sign or simple account, that you obviously you can only migrate to you know. If you have a single sign or a current account. But having, that being existing on both sides is something, that the ecosystem can tolerate

[33:00] it's a little bit more complicated than, that tumer it's not just, that you can only migrate. If you have a single signer it's, that you can only migrate. If the only signer is the master key and, that means lots of accounts will be locked out yeah. So I. So what I see is you know like your wallet can you know obviously there's like a migration thing and your wallet can tell you hey. If you want to work on smart you need to migrate to this new account most accounts by the way are just you know like single signers and they do have a hundred percent of the like master weights. So I don't actually think, that's a problem. But you know your wallet can tell you hey like this is you know this is like the new type of account. If you still want to maintain your multisig these are like other ways you know you can do multi-sig in like this brand new world. But but the thing is, that migration

[34:00] happens once right I don't have to actually as a user as a well. While developer need to I don't even think about this every time I move between sites yeah I think it makes it pretty difficult for wallets either today or, that are developing for standards like sub 30 for example to be able to. Then it will also interact with this world like we're still sending people down this track of like you need to have two sets of keys. Because the migration path is not particularly clear I think otherwise or we're saying like you have to migrate all the way to this only smart only Jump Cannon cannon construct like how would you have multisig on Jump Cannon and multisig off on classic at the same time with the same account is, that doable

[35:00] I'm proposing like not to actually ever like having just a single migration. And then you're in this other world, which is both classic and jump canon. But it's on a simplified account model now. If you have a multi-sig account on right. Now on Stellar. Then then we can think about ways to either you know either do threshold signatures or just actually deploy a multisig contract the same way, that multisig contracts are on you know Ethereum and other ecosystems what you're describing is every account, that exists on the network today, that uses multisig deploying their own contract on Jump Cannon, that is one option again, that's only. If you want to interact with Jump Cannon right so. If you're a vibrant user and you don't you know you're not using any smart contract

[36:00] like these are not things, that we need to have figured out like the first you know like at launch and yeah it does not have to be like one contract per wallet right it can be obviously the parity wallet is not a great example. But the parity wallet was like a single contract, that provided multi-sig for a lot of accounts right you hear, that. While it's super secure in fact nobody's ever been able to get their money out of it yes it is super secure I mean I still don't understand the whole like I call immigration thing how does, that I mean like. If if you look at some of the interesting accounts, that are multisig right issuers like are we saying, that changing the issue are probably key no I'm not saying, that at all I'm saying you only need to

[37:00] to migrate to a new type of account. If you want to interact with Jump Cannon and [CAP-49](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md) proposes, that exactly. But like to a much greater extent right you need to every time you move between the like I'm talking about the issuer why would the issue where needs to need to migrate well they don't want to have like any presence in Jump Cannon they will have to use a different account I guess I think like there will need to be a distribution account potentially, that. If they want to interact with smart contracts they need to be on smart. But I you know I think, that depends a lot on the asset interoperability story, which you know we still need to think about

[38:00] can you just tell me what this migration looks like I want to mic you know I want to migrate from my classic account to a smart account what is what has to happen I actually have to like somehow move balances or does it just like transmute balances and annihilate the classic key the very simple happy path for something like this is, that you log into your wallet tells you hey we have a lot of new functionality on smart contracts. But for, that to work you need to migrate to a new account let's call it a d account it takes you through the process and once you end it you know effectively like merges your account and I'm saying happy path meaning, that it's there's just a single signer and it's a and it's the master signer. And then you know. Now you have a d account and you can either operate on regular Stellar classic

[39:00] you know make classic payments and such or you can operate on smart contracts. But it's a simple account you cannot you can never actually do on-chain multi-sig the way, that you did with your previous account I don't know. If we need to explore necessarily like yeah like in this meeting like the actual this actual migration flow it sounds like it will have a lot of edge cases like I'm thinking like from a kyc point of view right like you have a bunch of trust lines like you probably I mean you need those d accounts to have the exact same public key. Because that's what got kyc all you deauthorize trust lines you know, that's another option. But you know things like, that yeah again like happy path constitutes of accounts, that are very simple they

[40:00] have a single master signer and assets, that are for the most part you know the overwhelming majority are not asset not auth required or and can easily be moved cool yeah just, that's all I was hoping for was a very quick explanation to like help clarify in my mind what it was, that we were talking about thanks I mean like I need to think about it more I'm like i'd really what I really would need to do is go and like look at what the current like configuration of accounts network wide is you know there's like 6.7 million accounts or something like

[41:00] that, that can most people actually just migrate to a new public key meaning, that like their master weight has weight one all the thresholds are equal to one. If that's the case or I said migrate to a new publication migrate to only their public key. If that is what most accounts are like. Then like maybe this is reasonable. If most accounts aren't like, that or even. If many accounts aren't like, that. Then I don't think it actually gets us anything there's no worth poking holes in it. Because it's just like not general enough to be worth considering. So I need to go and like you know hit up hubble and figure out what the situation is wait hold on quick I think the alternative people still can't use smart except. Now they could lose money. If people accidentally send the money on smart i'd rather have a world where most people can't use smart But it looks like they can. And so money gets

[42:00] destroyed yeah I also just want to point out like we can research this with hubble. But what we should also evaluate is there may be a lot of accounts on hubble, that are not actually meaningful and whereas we should also have a look at products, that are getting developed either recently or in the future, that we know of, that are getting developed on Stellar are they using things like SEP 30 how are those products like what's the story going to be for products, that are just setting out. Now with multisig. Because if we do just have a look at just hubble we may find a large number of accounts, that only use a master key they also may be inactive accounts maybe accounts from the past accounts, that are not actually relevant to where we're going from here yeah. But lee like we're not saying we're not annihilating the idea of multi-sig right we're just saying

[43:00] that like these you know we need to find like a different multisig construction for these accounts moving to this new account type well it sounds like on some level at least, though doing some research is a good idea to understand how people are using multisit currently right any other thoughts on this issue I mean we have about 14 minutes left and we can stay here or we can move on. Now i'd like to go back to like the first thing. Because maybe, that's what, that would be a different approach to this problem, that is like the question I was asking earlier, that is how do we think about like I don't know how this is solving Ethereum like. If you have this

[44:00] flexible invoker thing like. If I decide to take my account and move my assets into a smart wallet my public address in a way I think right. So so how does the money gets routed. If somebody sends money sends funds to my old key. If you have the address and only you have the key you just go grab it public key no what I mean is, that well it's kind of funny right like does it mean I have to even, though I decided to upgrade my you know my setup to a smart wallet I still have to keep this kind of single key setup around forever upgrade to a smart wallet you also have a smart wallet welcome there's no way to stop using, that

[45:00] address other than to tell everybody to stop sending money there like I mean it's no different from. When you move houses right like people will keep sending mail to your old address much to usps's display unless you tell them not to. So you can do forwarding right in, that case so, that's kind of what I'm getting through there's no way we're going to do, that probably like no. But like for like. If we had to support those type of scenarios some way to do forwarding you could do forwarding for those multisig accounts why do forwarding, though just keep the key around until you don't want to forward anymore and go and collect the money like we don't need to be dad for these people. If they know. If they want to switch to a smart wallet they should know what to do no I'm just trying to kind of compare the complexity of like migrating to those d you know whatever accounts to

[46:00] to having a way to kind of make it easy for people to change their keys basically and even in smart. If you make it easy for people to change your keys you're just gonna end up right back at the okay well. Now I have to go and read this other thing and check the signatures based off of, that and everything becomes less efficient like do we care about performance or not. If we don't care about performance let's just glue on the EVM and get 13 tps I don't understand why we're working. So hard. If we care about performance we can't do, that and we have to do better but, that means we should be making decisions, that matter I mean it's not just about performance right it's about like the whole reason we are talking about this is for usability right like making it, that people don't have those food guns you know everywhere. But I mean I think, that we care not. So much about performance in absolute terms as the scalability of performance in terms of cores so. If we

[47:00] can kind of split it up into work, that can be parallelized and work, that can't be. Then as long as there's a way to do the signature checking such, that it can be paralyzed I don't care. If it's you know i'd rather have it be four times as expensive. But embarrassingly parallel as like you know four times faster and like it's competing for like the same cpu core as like all the other logic and all the transactions sure. But i'd also rather it just be embarrassingly parallel and not four times slower and like what I'm saying is like these the discussion we're having right. Now doesn't change the parallelization well it probably makes it a little worse. Because there'll be more contention. But it doesn't like it definitely doesn't make it better, that's definitely like Nico's proposal will not make it better. But it does mean there's more work for everybody to do. So it's definitely going to be slower should we just add bls signatures the other thing is like do we have a particular it seems like not all implementations of threshold schnorr like people like cut some corners like do things, that like

[48:00] we don't know how to attack. But they don't they prevent the proofs from growing through. So there's the fact, that like the multi-state we have. Now is it may be slow. But it is very simple and very easy to understand the security and. If you want this level of security you can still use a smart model you just pay for it and. If you trust the threshold schemes and. If you're happy having a single key you use a single key same thing I said before like I don't need to tell people what to do in the land of smart contracts. If they don't like the thing, that I told them to do you know what they're going to do they're just going to do it slower differently right anyway you can make it easy for them to do right. So you can make it very easy for someone to use it in a smart contract to check, that something's been authorized by a particular classic account right and. If

[49:00] that is something, that's easy to do. Then people will use it where it's appropriate and there'll be more coherence across the two worlds do we want to talk a bit about contract lifecycle today we have like eight minutes. But I mean there are some open questions, that came up during the in the dev mailing list, that I can talk about. If we think we have enough time I think we should start on it and. If we run out of time we can bring it back up at the next meeting okay

[50:00] okay. So one of the questions we're still discussing is. If the contract code vector should be like the size should be fixed in the XDR it should be configurable by the validators and you know the advantage of having it configured by the validators is. If for some reason we think it's you know. If there's an issue the validators can. If there's an overlay issue for example and fix it through the values instead of you know updating the XDR, which would require a I believe require a protocol upgrade does anyone have any thoughts on this I think John is John's advocating for it to be fixed in the xcr and Nico was advocating for it to be configurable well you need a parameter upgrade either way right or are you suggesting, that different validators have different thresholds no. So yeah you yeah. So you would need you need to be a parameter upgrade and like an upgrade to the validators

[51:00] or a protocol upgrade right. So either way it goes to a consensus in one you don't need to recompile, that seems reasonable to not have to recompile I guess or to pick maybe we don't pick like four gigabytes. But we pick something, that's much larger than we think people should need in the XDR. And then we enforce a lower limit in validators, that's what I was thinking yeah I'm just like my big concern about this is like it's not safe to ever make the number lower you can only ever make it bigger and I'm just like what is the point of this work like why shouldn't we just choose a number, that makes sense and basically. If we want people. If people want to write bigger contracts just split your logic up among two contracts I mean it's not a big deal like do we really want people uploading this upload like a gigabyte 100 megabytes

[52:00] like what's the number, that we're happy with people uploading in a single operation choose, that number and call today likewise what's the number, that we're happy loading up into the vm as a single operation we'll call it a day great and I can see you're talking I can't hear you at all I don't know. If anybody else can hey can you hear me. Now yes cool yeah I just wanted to point out we have the same issue basically with like there's gonna be quite a lot of fixed numeric parameters in the system it's really not just one, although the cost factor is all the memory limits all the parallelization factor. When we get to parallel execution there's gonna be a big bucket of numbers, that are just constants, that the system runs on and there's gonna be this is a CAP coming at some point we haven't got to it yet. But there's going to be a parameters block

[53:00] we're not going to have a single parameter in the ledger header for every single one of these. Because the ledger header will get gigantic a new magic ledger entry called smart contract numeric parameters and people are going to have to vote on, that on a regular basis. So I would just say it is a number. But we would have to agree it's a number, that can only go up. Then never forget no I don't agree or it can go down with we have to have a policy, that like we'll give you two months notice before we reduce it or something. But no I don't agree with, that it cannot go down you can break somebody's smart contract by making it go down even. If you say like I'm still willing to run a smart contract, that's, that's longer than this was uploaded before what. If that smart contract itself is a factory, which deploys new smart contracts no there's no question, that there's going to be perimeter changes, that will break existing smart contracts, that is, that's guaranteed

[54:00] because. If we change gas limits at all in any direction some smart contracts will begin passing, that didn't or and, that implicitly means some will fail, that didn't. Because they were expecting the other one to pass there are ways in, which you break people's code by changing parameters guaranteed there's no way to just make it one-sided, that's not going to work I'm not clear on why changing the gas factors would break people's code like you could always just run it with more gas right. But like it's something, that you expect to work on one set of parameters will work differently on another set of parameters sure, that's fine as long as I can figure out how to still run it is fine. But like. If you lower the size fact, that you can like fundamentally break never to be recoverable a factory contract it's totally recoverable you just have to convince everyone to raise the number again. So right. So it's only possible to go up as a consequence without breaking people's okay no this

[55:00] no I just know I completely disagree with your premise these numbers affect whether I mean seriously suppose your contract relies on you call two contracts in order and it's really important, that the first one fails for some reason. Because you didn't notice, that it fails. But it's part of the semantics of your system working, that the first call fails we increase the element now, that. Now it succeeds your system stops working like people can rely on things in the wrong order. If there's no and there's no fix for, that. If you want the numbers to only ever go up right like yeah you sometimes you have to redeploy things back. If you want to fix them. Because there's no other way you've set a specific set of parameters, that you've defined as the ones, that my thing works in and. If the parameters change it is possible everything will work I mean I think it's. When it comes to all those yeah like weird parameters I think they're like especially. When it comes to any kind of limit I think they will always have like

[56:00] you know. When it comes to coming down right like from those limits like. If you're close to, that limit yeah I would say like you may get broken like by some weird tweaks like, that like. If you want to be safe just play in a much smaller you know much further from the limit well I think it's totally reasonable to expect, that something like code size is not gonna like there's no pay-per-view reason why we're going to start reducing, that over time it's probably the case, that would stay the same and go up and I think it's a reasonable assumption. But it's no different than saying you know, that your set of pre-signed transactions, that you know can only have a certain fee, that they work under and they won't work. If the base fees increase or something like, that like there's ways we were actually concerned about, that problem grading yeah and we

[57:00] were. So concerned about it, that nobody wanted to raise the base fee and we actually did [CAP-15](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0015.md) fee bump transactions to fix, that problem. So like, that's actually like an example, that like proves the point, that this is a problem I'm it will continue to be a pro there's I just there's absolutely no way you can fix this by saying it can only move in one direction, that doesn't fix the problem. So as far as I can tell you're demanding, that we fix a problem, that can't be fixed I think we need to just set expectations appropriately right. If we tell people your contract we promise never to break your smart contracts it's going to be a problem right. Because we will end up breaking them and we'll also end up not innovating in ways, that we should have innovated. And so you know like people validators may vote, that they're not interested in seeing a particular parameter upgrade, that's, that's fair right it's not like us making parameter changes it's like

[58:00] us collectively the entire network right it's not just sf making these changes but. If a change happens and all the validators vote for it the validators could vote to migrate to a new protocol version, that turns off smart contract you know there's changes, that can be made among the validators, that will break existing functionality I guess the core of my argument here is there are things, that we should, that are like worth promising not sorry, that are worth not promising to break and there are things where we it's like completely reasonable to make a promise not to break your stuff and I think code size is definitely an example where it is completely reasonable to promise not to break people's stuff you said it yourself you can't foresee a reason why we would want to make the code size smaller not a really simple one. But I mean. If you give me a couple of minutes I could probably come up with something I just don't think it's lightly. But you know there's a difference between likely and what i

[59:00] think we should be promising I don't see why, that promise is more important than any other problem there are. So many other promises we could be making, that are also not reasonable this is just another one, that this really feels like we're bike shedding at this point like let's get a thing built. And then like how hard or easy we make it to tweak one number like, that's something we can figure out it's just not an important thing at this point I think David gets the final word in this meeting. Because we're out of time. But we'll reconvene next week and obviously there's still activity happening here on the Stellar dev Discord and on the mailing list. And so anyone who's watching obviously feel free to jump in there or to see what the discussion where it's tending anyone in this meeting obviously will also talk on those lists and get back together here next week. But we're out of time for. Now

[01:00:00] you

</details>

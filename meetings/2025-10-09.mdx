---
title: "Demo of OpenZeppelin UI Builder"
description: "OpenZeppelin demonstrates UI Builder for quickly generating React-based UIs to interact with Soroban contracts, followed by a protocol discussion covering CAP-66/CAP-67 follow-ups and CAP-75’s approach to Poseidon/Poseidon2 support via permutation host functions for ZK-friendly hashing."
authors: [carsten-jacobsen, jay-geng]
tags:
  - spotlight
  - CAP-66
  - CAP-67
  - CAP-74
  - CAP-75
---

import YouTube from "@site/src/components/YouTube";

## Generating React Interfaces for Soroban Contracts {#part-1}

<YouTube ID="-uTKQIQpwAU" />

OpenZeppelin’s segment showcases UI Builder, a tool for rapidly creating usable interfaces for Soroban contracts on testnet or mainnet. The demo walks through selecting a contract, choosing a function, customizing form fields, previewing the UI, executing a transaction, and exporting the generated UI as a React app or reusable component library.

The session then transitions into a protocol meeting focused on upcoming changes and draft specs, including continued work around transaction fees/resource limits and adding ZK-friendly primitives for developers building Merkle-tree and proof-based applications.

### Key Topics

- OpenZeppelin UI Builder demo
  - Build contract interaction UIs from a contract ID (supports WASM and Stellar asset contracts)
  - Pulls contract state for inspection (demo references `stellar.expert` as a source)
  - Form generation workflow:
    - Select a contract function (e.g., `set_text`)
    - Customize labels, placeholders, required fields, hidden fields, and hard-coded values
    - Choose an execution method (wallet connection vs specific account)
    - Select a wallet UI kit (OpenZeppelin kit vs Stellar Wallets Kit)
  - Live interaction: execute a transaction and refresh to confirm on-chain state updates
  - Export options:
    - Download a full React app (zip) for immediate use
    - Use the UI Builder as a package to compose components in an existing React app
  - Local management:
    - Saved UIs stored in browser local storage
    - Export/import as JSON for sharing or moving between environments
  - Mentioned tooling: OpenZeppelin Relayers and monitors for automation, gasless UX, and event-driven reactions

### Resources

- [OpenZeppelin UI Builder](https://builder.openzeppelin.com)

<details>
  <summary>Video Transcript</summary>

[00:00] Hello and welcome everyone to this week's Stellar Developer Meeting. We are finally back again after Meridian and lots of hackathons and activities. But I'm great to it's great to be back. And with us today we have Steve from OpenZeppelin. You have probably heard about it. Maybe you've even tried some of their tooling. But they're building some really great tooling, that's compatible with Stellar and built for Stellar. So I'm really excited to see a demo of the latest tool, that developed, that runs the UI builder. So Steve, yeah, maybe just introduce yourself really briefly. And then yeah, we can jump into the demo. Yeah, thank you so much. I really appreciate it. It's nice to be here and to be with you all here today. So again, my name is Steve. I am doing developer relations with OpenZeppelin. And so I handle a lot of things anywhere from documentation or interacting with a lot of our ecosystem communities and you know showing you guys how some of the stuff works and yeah I think it's going to be really fun.

[01:00] Okay, I'll share the screen here. Maybe you can zoom in a little bit. Yeah, I think I can do, that. And my screen is a little big. There we go. I think, that should be good. Yeah. Does, that look better? Yep. Sweet. Awesome. Yeah. Well, like I said, today we're going to be showing off the OpenZeppelin UI builder. Essentially, this is a tool you can use to interact with contracts, that you have on either Stellar mainnet or Stellar testnet. But it's actually goes a little bit further than, that. It's honestly like a React component library, like a UI library. And. So once you've created these forms or got the basics going, you can actually download it as an entire app or you can install the library as a package and build these UI elements yourself. And it just takes a lot of, that weight off of you. When you're trying to build interactive elements, you know, with your contracts. So today, I'll just go ahead and show you what it

[02:00] looks like. You can visit this today. It's live at builder.openzeppelin.com. And you'll be landed in this, you know, new contract UI screen. And all you have to do is just go ahead and select the Stellar tab. And. Then you select Stellar test net or mainnet. So I'm going to click test net right now. And from here we just go ahead and paste in a contract ID. It does work with both WASM and Stellar asset contracts. The main difference is, that these will pull directly from source. But these since they're not you know all the API and things like, that are not with source will actually pull, that from GitHub directly. But both of them work. So you'll have no problem there. But we'll go ahead and pull this one in. And right away, you'll see, that we go ahead and pull in a whole bunch of stuff. First, we pull in the contract state here. So, this is the current state of the contract. This is kind of like our we call it our kitchen sync contract, that has all sorts of variables and functions just to test a lot of different, you know, possible interactions. And we're pulling, that directly from `stellar.expert`.

[03:00] Stellar.expert. Really cool. And so, from here, we can go ahead and click next. And this is where we start to decide or build out our form. And the first thing you'll want to do is select a function. What do you want to build a form for? What piece do you want to interact with? And there's a whole bunch of different stuff. I'm going to select something pretty simple, just a set text right here. So I just hit select here. And from here I can start to kind of customize this. So I can say like set greeting. I can change the description, things like, that. from there I can go into the fields and have like field labels. I could do field types and you know. If we need an email or input, there's like a whole bunch of different types here. So I'm going to say we'll just call this greeting and say placeholder hello. And there's a whole lot of stuff you can do like required fields. You can hide from the UI, use hard-coded values. It's very customizable. And. So once we have, that,

[04:00] I'll go ahead and do an execution method. So from here we can decide. If we want to allow any wallet to connect with this and start using it or. If we want to require like specific account to interact with it. We also have the option to do OpenZeppelin relayers. If you haven't checked out relayers, I would highly recommend you do. You can check them out at docs.openzeppelin.comrelayer. And essentially they're managed services kind of like a back-end server, that can relay transactions for you and can automate certain things and you can do things like gasless transactions. It has full Stellar network support. So it's really cool stuff. Would highly recommend checking it out. But for. Now we'll just stick with like a standard account. And. Then from there we have a UI kit. So you can basically choose, which wallet kit you want to be included. So right. Now I have just the built by OpenZeppelin standard one. It's kind of like a very minimal, nothing really fancy. So I can see my accounts connected here. I could disconnect. But. If you wanted to, you could also use the Stellar wallets kit.

[05:00] And. So you'll have, you know, a different experience. You can kind of customize, that and choose, which one you like. I'll just go ahead and switch to OpenZeppelin. And once we have everything ready, I can either just go and hit next or at any point. When I'm in this, you know, building phase, I can hit preview form to view it and test it out. And then go back to building it. So once we have it set, I could actually go ahead and give this a shot here. So I can say hello world or something like, that. Go ahead and do execute. And, that's just going to have me sign, that transaction. And there we go. It's successful. And what's really cool is, that we can just hit this refresh button here. And you can see we have our hello world, that's been updated in our contract state, which is really cool. And from here, we can go ahead and export this. If we want to. This is going to export it as a like zip folder. And once you unzip it, it's going to be a V react project. And you could just install the dependencies,

[06:00] build. And then you basically have a app ready to go. Now, that's only half of it. Because that's like a really simple one form piece there. If you wanted to, you can even go to our GitHub here, which is open zeppelini-builder. And from here, you can actually download package dependencies. You could build these and use them in your app yourself, the components themselves. So, there's a lot there. And just to show you too the some of the other things, that the UI builder has to offer is once we created this UI, we can see it here under our contract UIs here. And. So as you build these forms and let's say you're doing multiple different tests or multiple different forms, they're all stored in your browser as local storage and you can actually click on them here. So, here's a different one, that's a much more complex form where I can put in an account address. I can put an account label, key values. There's a whole lot of stuff you can put here. And so, these are all kind of stored. And. If I

[07:00] wanted to, I could click on the three dots here to rename, duplicate, export. And all of this is basically just basic JSON data. So at any point I can actually export all of my current UIs into a JSON file right here. And. So from there I can import it and. If I ever needed to bring it back or something like, that, it's all dated. Just click import. And it brings in those forms, that I just had. And. So we can just go ahead and delete those. And yeah, that is the basics of the UI builder. And again, I think it works really great. If you're working with our wizard and you're like maybe putting together a contract, maybe you've deployed it. From here, you can just paste in, that address, interact with it, and test it out. Or. If you wanted to build your own web app, that has those UIs built in. Yeah, that's pretty much it. Great. If there's anyone, that has

[08:00] any questions, please feel free to drop them in the comments. I think this was a really interesting demo. Are there any limitations or anything I should know as a developer? If what is the what would be the common use case? Is it some someone who's playing around with the UI and they can drop it into their own UI as a component or what is a typical use case you would say? Yeah, I think there's actually a lot of great use cases for it. One of them, like you said, is. If you're just playing around and you want to test around or try out a contract, it gives it a really easy un interface to start using it. But we've seen some other people as well where like it could be used in a team application like for instance to help manage liquidity pools or build more complex forms, that might be used internally. There's all sorts of things I think you can do. But I think you know for people who are just starting out just wanting to build and get experience I think it's great for, that

[09:00] use case personally. Yeah, I can definitely see it. Developers in like early in the developer journey. If you build a smart contract, it sometimes it can be a little bit complicated. If you're completely new to Stellar to use the CLI to invoke the contract and get all the formatting correct in the invoke command. Definitely makes it a lot easier to be able to quickly spin up a UI and interact with your smart contract and test things out. But. But you said it's built in it was built in React. Yeah. Yep. It's all basic React UI components. I think we use Shad CN UI components under the hood as well. So I think we have a lot of visions too about what, that might look like in the future and how you might be able to import them into your existing app or something like, that. They are packages, that you can install to an existing React app and just start building right away. If you'd like to, which is really cool. Yeah, it definitely makes it easy to

[10:00] drop it into to. If you're building a React application. Then drop in the forms to interact with the smart contracts. I think personally, I think we'll see a lot of use of this in hackathons where you have limited time to accomplish something. It's a very it's it looks very easy. I had a chance to play with it yesterday and it was just in a matter of minutes I had a front end for my smart contract. So really great experience. I see we have a question here. I see it as a good starting point for building deps for your customers to interact with your C contracts. Yeah, absolutely. Yeah. Absolutely. I even see it sometimes. I do a I in my role as a dev as you know from yourself, we get to play around with a lot of new stuff. Sure do. And and a lot of time just for the convenience of it. I think this could be a great way for me to

[11:00] to test out some new features in smart contracts and. When we try to roll out. When we roll out something new. And I like to be testing things early on. But I don't necessarily want to build a whole dApp around it. So I think this has some great opportunities for both people playing around who's experimenting. But also building the dApps. Because they can drop in the their the components in their Next.js or their React application. Yeah, absolutely. Then there's a question does it support the new release of React, which includes a compiler demonstrated a few days ago at the React Summit. Let me see. I think as of right. Now we might be using React 19. So probably close. I'd have to double check. If we can actually get to using React compiler. But yeah, I'd be interested to try and see. If that does work. I know

[12:00] that's still pretty new. Yeah. Great. Any other questions? In the meanwhile, I will say you mentioned relay. I think we are going to do a presentation about, that in about two weeks. I think it's Oh, excellent. I don't think it's on next Thursday. But I think it's in two weeks. If I remember correctly. But we are definitely going to do a developer meeting around the relay and have a demonstration of, that. So, I'm looking forward to, that as well. Yeah, don't miss, that. That's, that stuff is pretty sweet, very helpful. Okay, can you maybe just talk a little bit about what Relay is? Yeah, it's essentially like a it's like a Rust backend. So, it's written in Rust. It's very nice, fast, it's efficient, and it's very easy to set up in my opinion. You basically clone the repo. There's like a build command or a setup command you run and it creates like a single binary, which you can run you know in most environments and it'll basically create

[13:00] like a API interface for you know smart contract interactions. So you can basically set up accounts or re they're called relayers and they can maybe have different addresses different permissions different you can load them up with different balances etc. And. So from there you can kind of make permissioned or spec particularly granted access for part particular tasks you know. And so there's a lot you can do with it. I think a lot of the people have used them for like gasless transactions. You can send an API request asking to do something. The relayer will take care of it. And then you know on your actual user interface app you never had to have a user pay for gas or things like, that. But yeah, it can really build a lot of, that. And I think there's also. When you use them with monitors, that's the other half of the equation there. monitors allow you to listen to smart contract events or functions or anything happening. You they're very flexible and the really

[14:00] power comes in is like you can monitor one thing on your contract. And then as a reaction use something on your relayer. you know, so, that could be something like,. If somebody withdraws way too much out of a contract or is an alarming amount of money, you can maybe pause the contract or you can stop certain things, you can react to things. It's kind of built as both a security setup as well as, you know, just a ease of life setup to, you know, for building apps and stuff. Okay, great. It doesn't seem like we have any more questions. So, I would just thank you for the demo It was super interesting to see how easy it is to set up a front end and create front-end components for a smart contract. I It's kind of tooling where it's making life a lot easier. You get something up and running quicker. And one of the things, that I always love about using tooling like this is, that it's gone through a lot of testing. It's gone typically it's gone

[15:00] through some auditing as well. So. So you get a really solid starting point for your project instead of trying to build everything yourself. So, thank you so much and yeah, we'll be back next week with another great demo. And just a reminder for everyone joining here at 1:30 p.m. Pacific, we have a protocol meeting on Discord. So, see you all there and thank you again, Steve. Thank you, Kristen. Yeah, it's great to be here. See you. Bye.

</details>

## Transaction Fees, Resource Limits, and ZK-Friendly Hashing {#part-2}

<YouTube ID="rWWB7-8A-g8" />

This segment continues ongoing work around transaction fees, resource limits, and developer-facing protocol ergonomics. The conversation builds on prior proposals aimed at making smart contract execution more predictable and sustainable, while preserving flexibility for more advanced applications.

The discussion then turns to support for zero-knowledge–friendly hashing primitives, motivated by the growing interest in Merkle trees and proof-based applications on Soroban. Rather than introducing full hash functions at the protocol level, the proposed approach exposes low-level permutation primitives that allow developers and SDKs to construct ZK-compatible hash schemes while keeping the host interface simple, stateless, and adaptable to evolving cryptographic parameters.

### Key Topics

- Continued discussion and sample implementations related to `CAP-0066` and `CAP-0067`
- `CAP-75`: Poseidon / Poseidon2 support for Soroban via permutation primitives
  - Motivation: ZK-friendly hashes dramatically reduce circuit constraints vs `sha256`-style hashes
  - Need for on-chain hashing to match offchain proof systems when maintaining structures like Merkle trees
  - Design choice: expose internal permutation functions (rather than full sponge/hash APIs) for:
    - simpler, stateless host integration
    - better maintainability and flexibility across different parameter sets
    - enabling SDKs/contracts to implement common hash modes (e.g., arity-2 Merkle node hashing) on top
  - Parameters discussed: field selection (BLS vs BN), state width `t`, rounds (`rf`, `rp`), exponent degree `d`, MDS/round constants
  - Implementation/testing notes:
    - Plan to ship SDK presets (e.g., common parameter sets used by proving libraries)
    - Provide a “hazmat” interface for advanced users to supply custom parameters

### Resources

- [CAP-0066: Soroban In-memory Read Resource](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0066.md)
- [CAP-0067: Unified Asset Events](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0067.md)
- [CAP-0074: Host functions for BN254](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0074.md)
- [CAP-0075: Poseidon Hash Primitives](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0075.md)

<details>
  <summary>Video Transcript</summary>

[00:00] Okay, I'll get started. hi everyone. Today, we are going to be talking about [CAP-75](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0075.md), which is a proposal to add two new host functions to support Poseidon and Poseidon 2 head functions. So the CAP itself is fairly straightforward. two new host functions. It it's pretty standalone doesn't involve any of the previous protocols mostly except using the BLS and BN field. But I want to spend a little bit time on the approaches, that we decided on and the rationale behind this approach. So first of all just a quick introduction on the motivation why do we want the Poseidon and Poseidon 2 hatches. So. So

[01:00] the Poseidon and Poseidon 2 they are I'll call them Poseidon family. So they are family of hashes basically it accept a range of parameters. And then you can configure it to compute output. So what it is it's a sponge based hash function, which means it consists of a sponge, that absorbs input and fit output, which is a variable length input various variable length output function and internally there's a permutation, which is fixed input fixed output and the reason, that u it is useful along with Other catches of similar design is, that it directly operate natively on the prime field. And as you can as you know most of the zero

[02:00] knowledge applications are built off of the prime field such as BRS or BM254, which makes Poseidon natively work with this field and they are ideal in DK application. Just to give a rough idea, it the amount of constraints to generate using a regular hash like a SH 256 versus Poseidon is two order of magnitude difference. So it's a lot of proof side less proof side complexity and time to use Poseidon. So for contrast. So proof allocation typically don't involve rehashing or anything. But for contract implementing logic such as a mer tree, that you want to generate proof of you want to have the same hash implementation between your contract and what you use. When you generate the proof for, that

[03:00] mole tree. I think, that's quite obvious. And to have the Prooseidon implemented on the gas side or contrast side is quite expensive. Even with the functions, that we already provide for BLS field arithmetics, there's still a lot of round trips between converting a few element to bytes and things like, that. So, that's why we want to support Prooseidon as native host functions. So just a recap of where we were last time. Last time we proposed a few three possible approaches to this. First is just to provide the hash functions plain and simple. You know for different field you know for different field combination of B and BLS combination of PID and PIN 2 and a combination of number of hash

[04:00] input. So this gives us what like eight different type of host functions, that will cover a lot of use cases. But this approach isn't good. Because we've from the feedback and from the evidence, that a lot of these hashes they require particular parameters these parameters are not set in stone. So different implementations could choose them differently. So even. If we specify them in the host for example someone else might need a different way to provide a parameter. So this way isn't just provide a hash function isn't the most maintainable way and what about providing more host functions for those field arithmetics and also it wouldn't solve the problem. Because even. If we provide things like matrix multiplication the pose hashing involves a lot of rounds of permutation each

[05:00] round is doing this multip multiplication. So we still end up with a lot of these cause and a all of these round trips. So one of the proposals ended up last time was can we provide a more generic interface for the sponge hash namely the to absorb some input doing permutations and spit out the output. And then be and let it be parameterized. So yeah so, that's what we settled on last time and yeah. So now to transition to this CAP. So this CAP proposes a slightly different approach, which I call approach four, that from the discussion thread for anyone who's following. So approach four is instead of providing the launch interface we provide the internal permutation functions, that the launch

[06:00] hash uses. So why is, that? So. So the sponge is a it's sort of its own animal. It's a different animal than the permutation. sponge design had many different considerations for different applications. For example, not only for hatching. But also for like generating like a random stream of bytes or for MAC method message authentication code or for random like for receable random value generator like these applications are all u designed scope of a sponge. So the sponge needs to be more flexible. It needs to maintain a state. It needs to in some cases it requires switching between absorbing and squeezing. And then

[07:00] switching back. So the sponge interface itself isn't it isn't a single definition, that we can just take. Because and itself is also has some complexity in it. However the internally all the sponge function they call the same permutation function. So after. So in both stun absorb and squeeze the input and output before it was the input is passed. And then the permutation is applied and the output is squeezed. So. So at the center of it is just this permutation function, that takes a fixed length input and a fixed length output. So this is much more maintainable and it's much more easy to support in solarong without ramifications. Because

[08:00] it's just a simple cryptographic building block and the sorbound host doesn't need to maintain any state. So there's no like state related issues for like what. If you make a subcontract call do they you know reinitialize a sponge and how to do, that. So. So by supporting Prooseidon permutation instead of the full Prooseidon hash it gives us a lot of flexibility maintaining sort of host and also sponge itself for a h for a simple hash algorithm, that's like a binary hashing of a Merkel node for example isn't, that complicated. Is just basically it's just a single round of taking the input and applying the permutation and spitting out the output. I've written down a little pseudo code, that basically is what it is in the CAP. So. So just to

[09:00] recap, the sponge interface is complicated. It the sponge is designed for many different use cases, not just hash. Even, though for hash the sponge is really simple we don't want to just baking a simple sponge implementation inside host. While this is much easier to do it in the contract or in the SDK. But it is makes much more sense to support the primitive, that's mostly the most expensive operations happen, which is the permutation function inside the sort of host So, that's the high level motivation, and now I can go through the actual two functions being proposed. One is a Prooseidon permutation and second one is Prooseidon 2 permutation. The two

[10:00] look fairly similar. So. So just a bit of background Prooseidon is the original version developed in 20 2019. Poseidon 2 is a improved version of, that developed in 2023. Internally they work slightly different. Poseidon 2 has u improved the internal matrix shapes. And then add pre relication add a single layer of pre-apply. But overall it works fairly similar. So I'll just cover the Poseidon one. So the process permutation takes the input, which is a vector object, that is your vector of field element. And then the second thing is the field type. So I think it probably makes sense to have field type as a symbol. But in the CAP I'm putting U32 should be

[11:00] equivalent. But yeah field basically is a enum, that specify, which field you want your permutation function to be defined on and of course your input will be passed in the same field as the permutation matrix and all, that. and the rest of it is just internal parameters for the hat functions. so, that's pretty much it. But I'll just spend maybe a few a couple minutes just explaining what these fields are. t is the capacity parameter. So it's the capacity the internal sorry not the capacity. But the internal state side much must match the input and also must match the size of internal matrix. It is decomposed of the rate, which is number of you can think of as number of input

[12:00] you need to hatch at once plus some capacity, which gives you additional security parameters. D is the degree of the fbark, which is the internal one of the internal step in the permutation before applying the matrix multiplication. So for bn and bs both fields d is equal to five. So we may just only accept the equals 5 u. But of course for other field in the future could be different. The round f round t these are the internal partial round and the for round these are the number of round the matrix multiplication happens. So the yeah. So the there's also a linear layer, which is u sorry the linear layer is a run the mod matrix multiplication

[13:00] but the nonlinearity is provided by the run constants, which is also matrix. But specified for each run. So the. So the MD MDS matrix for hash two function is 3x3 run constant is a is another matrix with dimension n by m where n is the number of run and m is three. So, that's a high level run through of the different parameters. The second one is fairly similar. The only difference is, that the internal MDS matrix in the second version is a diagonal matrix. Because of the precision 2 improvement in terms of cost type. So we. So we manage I think we can manage to ship this as a native solar bond library, which means, that all of the operations they are already existing and were defined. These include the

[14:00] field arithmetic for adding and the multiplication and things like, that. So there's no particular peridon specific metering parameters we need to support. But we do have to add these ban 254 field u arithmetic cost types, which is a very opportune timing. Because we have the [CAP-74](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0074.md), which has b24 scala field and pairing. So I went through the parameters metering rationale. Yes. So, that the rationale why hash function why we don't provide a hash function out of box rather than providing the permutation primitive. It is explained and yeah just to also mention these parameters they are

[15:00] so. So yeah. So so some of them they are kind of defined based on the application like. If you have a curve of. If you want to do hashing with BN25 254. Then the degree is five you can change, that. And then the sum of them is depend on the actual application, which is how many inputs you want to hash at once. And then based on the size of the input these parameters like t. And then the number of runs they need to be adjusted the original procidum paper provides scripts and guidelines for how to generate these parameters in general I think most applications have their own they have they use a set of generated parameters like CIRCOM does and Noel does and to provide the maximum

[16:00] like safetiness we would have these as part of preset in the SDK. So like the SDK interface will look exactly just like a hash two, that takes two input. And then internally you may be able to specify the set of parameter like a circum parameter or neural parameter things like, that. And then we also possibly expose these Poseidon permutation as a more like a hazmat interface something, that advanced users, that know what they're doing can call with their own parameters. But we will make them the distinction more clear. Yeah. In terms of testing there's a reference implementation for Prooseidon. And so Horizon lab has a reference

[17:00] imitation for Poseidon 2 and in the same repo has Poseidon one. That's the one we likely going to adopt. And it also provides test vectors for both one and two in different fields and parameter. And. Then there's also the original Prooseidon paper, that come with a sage script implementation with some reference vectors, which we will also match our implementation with in our tests. Tests. There's a draft implementation and I think, that's it. Now four is open for questions.

[18:00] Okay.

[19:00] Yeah. So I did a very rough well I wouldn't say too rough. But like the implementation is fairly mostly good. And then the field for BRS is already there. So I did a number on the reference test cases for BLS the 3x3 matrix case, which is the hash two operation, that's about half a million CPU instruction. So it's a lot better than what I projected last time. And. Then the 5x5 matrix case I believe, that's like cache three input, that's around 1 million CPU. So yeah, that's well below our target ceiling, which we want to support around 20 hash cores in a single contract.

[20:00] questions. Okay. Back to you, C. Oh, okay. You want me to close it? Okay. Bye, everyone.

</details>

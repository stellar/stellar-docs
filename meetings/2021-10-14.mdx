---
title: "Open Protocol Discussion"
authors:
  - david-mazieres
  - eric-saunders
  - karen-chang
  - leigh-mcculloch
  - nicolas-barry
  - jed-mccaleb
  - jonathan-jove
  - orbitlens
  - siddharth-suresh
  - tomer-weller
  - justin-rice
tags: [legacy]
---

import YouTube from "@site/src/components/YouTube";

<YouTube ID="wcjzKdo0xS8" />

- foreign welcome to the stellar open protocol discussion uh in these meetings we discuss core advancement proposals aka caps these are technical specs that suggest changes to the stellar protocol necessary to allow that protocol to continue to evolve to meet ecosystem needs we live stream these meetings so that anyone who is interested can follow along i do want to note it's a technical discussion so if you're watching you should take a look at the cap we're planning to discuss which is linked to in the show description it's cap 38.
- also we do keep an eye on the discussion box and your comments there they do help inform our decisions um that said today's discussion focuses on reviewing final changes to a cap that's already been approved and our goal is to acknowledge and validate those exchanges so you know we'll again pay attention to that discussion box and if relevant questions come in we may try to incorporate them but we do have this very specific goal as i said today's discussion focuses on a single cap cap 38 and this meeting is basically the end of its life cycle that life cycle started with the discussion on the stellar dev mailing list and there's a link to that mailing list in the event description for anyone interested in joining and participating in future discussions um after that discussion the cap was drafted and then iterated on based on feedback and suggestions that came in and once it's settled it was approved by the cap committee entered into a one-week final comment period and then it got through that period it was implemented in a major stellar core release it is now officially part of protocol 18.

With Protocol 18 ready for a validator vote, this call reviewed the final tweaks to CAP-0038 (the AMM proposal that ultimately shipped). The team revisited every outstanding change request—authority revocation, limit enforcement, result codes, and rounding behavior—to make sure the merged implementation behaved just like offers on the orderbook.

Key discussion threads:

- Aligning pool operations with offer semantics: liquidity providers must always be able to withdraw shares, even if their trustline becomes unauthorized, and deposits/withdrawals now emit clearer result codes when slippage or limits are hit.
- Guardrails for issuer actions: when assets are revoked, pool positions unwind predictably and cannot get stuck in “unwithdrawable” states, even if a price swings violently between the deposit and redemption.
- Pre-flight reminders for builders: install Protocol-18-compatible releases of Stellar Core, Horizon, and the SDKs before the November 3 validator vote, because the AMM functionality includes breaking changes across the stack.

<details>
  <summary>Video Transcript</summary>

[00:00] Foreign. Welcome to the Stellar Open Protocol Discussion. In these meetings we discuss Core Advancement Proposal, aka CAPs. These are technical specs that suggest changes to the Stellar protocol necessary to allow that protocol to continue to evolve to meet ecosystem needs. We live stream these meetings so that anyone who is interested can follow along. I do want to note it's a technical discussion. So if you're watching you should take a look at the CAP we're planning to discuss which is linked to in the show description. It's CAP 38. Also, we do keep an eye on the discussion box and your comments there. They do help inform our decisions. That said, today's discussion focuses on reviewing

[01:00] Final changes to a CAP that's already been approved and our goal is to acknowledge and validate those exchanges. So you know we'll again pay attention to that discussion box and if relevant questions come in we may try to incorporate them. But we do have this very specific goal. As I said, today's discussion focuses on a single CAP 38 and this meeting is basically the end of its life cycle. That life cycle started with the discussion on the Stellar dev mailing list and there's a link to that mailing list in the event description for anyone interested in joining and participating in future discussions. After that discussion the CAP was drafted and then iterated on based on feedback and suggestions that came in and once it's settled it was approved by the CAP committee, entered into a one week Final Comment Period and then it got through that period. It was implemented in a major Stellar core release. It is now officially part of Protocol 18. Now there's still a final step before that protocol hits the network, which is that validators have to vote to upgrade the network to Protocol 18, and that vote is currently scheduled for November 3rd. Before that day, anyone and everyone who

[02:00] Builds on Stellar needs to install new versions of any Stellar related software they rely on, including Stellar core Horizon, also including all the Stellar SDKs. There are breaking changes in Protocol 18. If you aren't running up-to-date software with the network upgrades, you will run into trouble. So if you're watching this, you haven't already. Please make sure to update all your Stellar related software content. Okay, enough preamble. Today we're returning to CAP 38: automated market makers. It introduces a powerful new feature that has the potential to really transform the network, which is the ability to create automated market makers, or AMMs. Amms allow users to create deposits into liquidity pools. They also allow buyers and sellers to trade against those pools. They use in the underlying formula to value two assets relative to one another. When trades execute and change the amount of each asset in the pool, the relative prices shift based on a formula. It all happens automatically. So in the case of CAP 38, trading against a liquidity goal is done using existing

[03:00] Path payment operations, which is pretty neat because it automatically gives applications built on Stellar access to this new source of liquidity. It also means that liquidity pools benefit from real world cross border payments and Stellar is the first layer one blockchain to incorporate a m functionality at the protocol level and the first to combine it in this way with cross border payments obviously we're super excited to see what this feature can do to boost overall network liquidity that said back to the technical discussion as I mentioned at this point CAP 38 has already been approved and implemented but during implementation there's always a bit of tweaking that needs to happen and the goal today is to take a look at the tweets that happen during CAP 38's implementation and verify that the final adjustments are safe and sound that they make sense so this is the post implementation validation phase and hopefully the final phase for CAP 38 and so what we're going to do is we're going to look through the changes that have happened in this post implementation

[04:00] Review so before we do that I I'm just gonna walk through them one by one but before we do that does anyone have any questions we're good so here we go the agenda is to walk through the xtr changes and we're going to do it in approximate chronological order so the first change removed liquidity pool ID from union in liquidity pool entry and so I guess my question is does anyone have any questions about this does this change make sense are there any concerns so when we did this I think Siddharth might have made this change yes Siddharth made this change but sir do you want to talk about or do you want me to yeah I can talk about it so the reasoning for this is that the

[05:00] In the original capital liquidity pool ID was under a union but the liquidity the electric key didn't have the liquidity pool ID under a union so you know which means that every type of liquidity pool entry would need that ID that ID so you might as well just take it to the level above that instead of specifying it for each new union we specify in the future so that was the reason for this and the general assumption here is like probably we're going to keep referencing things by hash anyway there's no reason to think that we would change the liquidity pool ID so we might change our hash function right if we decide to move to ketchup from like shot 256 or something yeah does this make that harder or is it just going to be a pain anyway I think it would be pain no matter what because we do a lot of hashing in a lot of places probably it would be sufficiently disruptive that we would end up introducing new ledger keys anyway for that so

[06:00] That's my intuition at least I see Nico nodding so I think he probably agrees with that okay I think we're fine then if nobody objects I mean I don't expect any of these changes to be really objectionable I just think this is kind of one of those better safe than sorry type of things that makes sense okay second change use clean adam and manage offer success results this one was a change that I made the main gap here was that like when I originally drew up the CAP I had kind of assumed like oh we should make the minimum changes that we would have to make to do this it would be less annoying for downstream systems and stuff like that but then there were two realizations the first realization was well then downstream systems need to know how to handle both kinds of claim atoms independently

[07:00] Anyway so they will end up with code duplication and they'll need to know which ones to expect in different scenarios and we'll have to maintain both in Stellar core so it's like all the bad and none of the good the only catch was that it was like slightly breaking for people who actually parse XDR results so my so when I that's a good question Justin when I wrote this I thought the answer was like approximately no one I thought that it was basically just like Horizon and a few other like very specifically written downstream tools like StellarExpert that were doing things like that but it actually turns out that a lot of the SDKs actually had this kind of like result parsing code for trading operations rolled into them I don't interact with the SDKs that much so I wasn't aware of that perhaps I would have changed the calculus a little bit on this but having

[08:00] Already done the work I think it doesn't but at this point I'd my expectation is basically anybody who's using one of those SDKs and interacts with like trading operations probably needs to update prior to the release or prior to the vote excuse me it needs so the SDK itself can handle the XDR person and those people will need to upgrade their SDK exactly and that will generally solve the problem for people that don't have some custom XDR parser which it seems like it's not a ton of downstream systems since most people rely on SDKs this sounds like a good precedent to set that like if you're parsing XDR keep up with protocol and the whole point of xcr is it's not hard to do the upgrade but yeah just need to update your xcr files I like that precedent it's official it's the official press don't know

[09:00] Okay any other questions about that change looks like the next two are added new results to revoke sponsorship mail forms and changed validation results for revoke sponsorship to all be malformed you understand or should I you made one of the changes I made the other you can go ahead okay so basically this change is a bit of a throwback actually to I guess that was Protocol 15 or 14 when there was a side issue with the release and we had to make some retroactive changes and that became Protocol 15 and when we did that we didn't want to change the XDR because that would have required us to basically force everybody to update even more than they had to like all their clients and

[10:00] Everything like that we elected not to do that and so basically there were validation results for revoked sponsorship that didn't return malformed which is like a violation of our convention even though it doesn't matter in the grand scheme of things so these two changes one adds the malformed thing that was missing and the second one just retroactively applies it to all things that were not correct as a Protocol 15 should have zero impact basically okay any anyone have any thoughts questions all right the next one is changed to m32t in liquidity pool use count

[11:00] Yeah I can take this is following our convention of using signed ins and the XDR and we like this number will never get close to you when like even in 32 max so like this just made sense David you're muted if you're trying to talk why it's not inconceivable to have two billion trust lines and so it makes me pretty nervous that you changed signed unsigned but none of the like none of the actual range checks seem to have changed so the reason this is so an account can have a trust line right but when it wants to deposit into a pool it has to create you know a pool share trust line so you can't have more than I don't know I'm not sure what the exact

[12:00] Number is but you can't have more than a couple hundred full share trust lines right why not you can have just do it you can subscribe if you have a billion accounts that are or if you have three billion accounts that all own shares in the same pool wouldn't you that will have its own trust lines right this is on the trust lines like the pool share trust lines not on the pool itself so it's like a per account counter yeah sorry okay maybe say what this what is a count what is the use of a truss line what does this thing actually count so this is making so we have this requirement where you can't delete what is an asset trust line until the pool share trust line is deleted right and this enforces that sorry totally makes sense yes this change is innocuous

[13:00] Yeah completely misunderstood sorry about that no problem I feel like that's what we're here for it's just like make sure that these things are clear and that there's not some something that we're overlooking okay the next one is added new liquidity pool deposit result which is the result is line full this was just a small bug in the XDR the pseudo code already considered the case where you could get line full upon deposit which let me just look at this for one second to make sure I'm about to say the right thing oh sorry this is yes mindful it was already possible that you would have like the maximum number of pool shares that you could hold relative to your limit and then when you deposit you wait let me read this for once yes this is

[14:00] Deposit sorry about that little confusion yes you already have the maximum number of pool shares that you're willing to hold you deposit you can't hold the pool shares that you would have received until you get mine full it was already handled in the pseudocode missing from the XDR so just a correction again that just seems to implement expected behavior as far as I can tell is there I mean well I think this is a more general question I feel like at some point we may want to revise what the use of the limit is on trust lines let's not go down that rabbit hole I totally agree with you on both sentiments that we probably need to talk about that and also that we probably don't want to talk about it right now Nico and I have been talking about it a bit actually and it turns out that there's some tricky details when you try to change how this works

[15:00] Plus line limits we'll get back to that next make liquidity pool deposit and withdraw semantic match the semantics match offers yeah this was a this was just like a so just a design flaw in the original thing you know our goal has been to make you know liquidity pools work exactly analogous to offers in as many ways as possible and this was just a gap there where basically like we were ignoring the fact that there's asymmetry and awe semantics for offers where you can delete even if you're not fully authorized but you can't create when you are fully when you're not fully authorized

[16:00] But for liquidity pools we were just saying like if you're not fully authorized you can't do anything and that doesn't quite make sense so yeah so I believe that the so one like the I think the biggest change that you can withdraw if you're in the authorized to maintain liability state right so you can it's the same thing as pulling offers right and if I'm not sure if this is specified here but if you're in the unauthorized state your pool shares are redeemed automatically right so you can't be in a unauthorized state with pool shares and you're allowed to pull pool shares if you're in the off maintained liability state and you can't but you can't deposit which is I think was the old behavior as well you can't deposit if you're not

[17:00] Authorized so just to check my understanding this means that for example if I am an issuer of an author required asset and I don't want there to be an asset between like my mark my market between my asset and say asset x I could basically revoke authorization from everyone who's contributed to the liquidity pool and that would just automatically kill the liquidity pool is that right okay yeah and that's the intention that's the intended behavior great next is added new results to allow trust and set trustline flags which is low reserve and clarify what happens with zero amount

[18:00] Yeah one sec let's see sorry I need to take a look at this change so I believe that this change is specifying so originally in the original invitation we assumed that the revoke was guaranteed to work for well when you were like the redeemed from the pollution trust line is guaranteed to work when you revoke off but there are some cases where this isn't true specifically if the account that needs to sponsor the claimable balance is in itself being is this in itself is in a sponsorship sandwich we can't guarantee the state of the sponsor so it's possible to hit the low reserve or too many sponsoring error codes so we this is adding that and is there might be a second change here yeah and the other change is that

[19:00] It's you you're not always it's always guaranteed that a claimable bouncer will be created on revoke for example if the claimant will be the issuer or if the amount being withdrawn is zero for that asset so this just specifies those cases I'm actually confused I didn't understand what this does how do claimable balances come into play here so when you revoke on a trust line and that trust line had deposited into a liquidity pool right the way this works is those pool shares will be withdrawn it will be redeemed automatically and then it's but we can't just we

[20:00] Can't guarantee like originally we wanted to send it back to the trust line right but we can't always do that because you know the trust line might be full so the solution here is just create a claimable balance for that asset and then the owner of that trust line can come in and claim it whenever they want to and the reserve for the claimable balance comes from the previous trust line for the pool shares exactly yeah but so yeah it seems like a little bit of a foot gun though because now this is like a case that's like not going to happen very often and when it does happen like probably a lot of wallets and other software is like not going to do the right thing or it's just you're not going to notice it are you talking about like managing claimable balances well sorry this is a situation where usually you just get the funds back and like you know in weird edge cases you get a claimable balance instead

[21:00] Sorry I wasn't clear we create camel bounce every time we don't even attempt to send it back oh I see okay yeah that was the game okay so that's actually good so it's uniform behavior it's a little bit more complicated than just refunding it but it at least it doesn't have this edge case yeah and we acknowledge that this is like really quirky like Siddharth and I spent many hours on the phone trying to figure out if there was a way to not do this and it turns out that basically the crux of the issue here is like you can do you can avoid this issue when you have offers involved because offers have fixed liabilities and they never grow or they only grow upon like a manage offer operation that you can control but here like imagine I deposit into a liquidity pool somebody immediately trades it into some crazy price and now you can't withdraw so it's very easy to get into like a unwithdrawable state so it would have been great if we knew how to avoid this

[22:00] But it is all we could do is this gonna be mysterious to developers that they're getting these claimable balances instead of direct transfers of funds I would think it will be kind of mysterious I think there could be I mean if we were starting from scratch I feel like a better design would be to say you can't have more than like you know two to the 63 of any asset and there's no there's the limits are either there's only a trust line or like we get rid of limits on trust lines and whatever but I mean like given where we're starting like maybe this is reasonable probably the least bad like situation a lot of weird quirky things it turns out could have been avoided with asset issuance limits like David was saying it could have helped in a whole bunch of different avenues actually but that's not the world we reside in but maybe in the future it will be

[23:00] So and by the way I just did a looked at the ledger I think yesterday and it was like thousands of accounts at this point have some whether you have like more than in 64 max it's actually a thing that people do now it was in the tens the last time I checked which I think was in March or April when we were issuing accounts tons of assets basically and now it's thousands you're saying yeah hug maybe we should say that there's there should be a flag on the asset saying whether you can flag an asset saying you can't create more than two to the 63 of them and then you get access to all these good features only when that flag is set or something but anyway we are where we are so I'm just wondering if there's this when I look at this I'm like oh shoot is there some education does this imply

[24:00] That there's some sort of education clarification outreach that needs to happen so that people understand this quirk I mean one thing we could do is we like this is not really a protocol discussion but I agree that like education is a part of what we do and so it's not necessarily something we should ignore it would not be unreasonable to create like a tiny javascript program or python program or whatever uses one of the SDKs and basically what it does is it goes it connects to the test net you set you pointed at a wallet and basically it like goes through the steps of making this happen and basically we can give it to wallet developers as a tool it's like hey like this is we want to make sure you handle this is something that can happen like run this program if your wallet works you're good to go if it doesn't you have a bug the other thing I'll say is that like this like the claimable balances you receive will look exactly like claimable balances you would receive in any other setting so wallets that handle that will probably do the right thing even if they might not reveal it to users in the

[25:00] Most like sensible way yeah I guess like the question here is more like yeah what's the level of support of for claimable balances in the ecosystem today I think it's much better than like even like two months ago but I don't know where we are yeah I feel like a few months ago there was zero support and now there's increasing support because people understand what claimable balances are I mean unlike this time right where we're spending time with an adoption plan that was no we didn't really have a clear sort of and this is not related to this discussion earlier to this group but I was just saying like we didn't have a clear adoption plan for claimable balances so it took a little longer for people to catch on but you know maybe now claimable balance support gets folded into the education about liquidity pools given that this is a fact

[26:00] Okay well that's very helpful for me I know it's not strictly protocol discussion but thank you and I believe we're at we are where we landed at this is what it is this is the world we live in this is okay all right then next added missing validation conditions for liquidity pool deposit this was a another bug fix but a pretty bad bug fix or pretty bad bug basically would have been possible to do things like I mean submit very nonsensical I guess very nonsensical operations where you could just say like hey like you know my min price is bigger than my max price so it's impossible to

[27:00] Succeed but you would still actually go through you'd make it through validation you'd actually get to a bot time you'd actually do some of the apply stuff only to find out quite through the way of the work that you would fail unconditionally so just a bug fix that just makes things sane great fixed incorrect error specification for path payments oh yeah I remember this one probably though I would not be surprised if people have things to say about this one just because it is it was very hard to express what actually happens the original draft of this that we accepted on like June 23rd or something like that

[28:00] Basically what it said is like if you make a path payment and it fails because of stuff happening in the liquidity pools you would get the exact same result as if the liquidity pools had never existed at all but this is like it doesn't take a lot of thinking to think like this is actually probably not possible because for example like what if like imagine you know the original like the original draft of the original language I should say it's like in the first hop you know you're going from a to b and you have both a liquidity pool and an orderbook and you can do it through either path but then on the second half it fails because of something to do with the liquidity pools and then it's like well actually if I in the first path if I had actually take or sorry in the first hop if I had taken the path to the liquidity pool I'm not necessarily going to end up in the same state as if I had taken the path to the other side and then I'm not necessarily going to get the same error code regardless so things get pretty got pretty hairy

[29:00] And it was all about just like designing or not even designing defining a set of rules that we could actually follow to make it predictable what kind of error codes you would get I don't know if we need to get into the details of like how it actually does that because like from any user's perspective they're just error codes but it was all about making a specification that we could actually follow and check that we did correctly when implementing starcore we learned a lot while dealing with this problem though actually that was in that sense it was really enlightening to try to understand this and try to figure out how to write the right stuff but I don't know if it's very enlightening to get into the weeds about how it works I'm just curious can you give an example how is it that a liquidity pool can make a path payment fail or you're saying like it would have failed without the liquidity pool it also fails with the liquidity pool but therefore give the same error

[30:00] Message if you didn't have liquidity pool or just an example would help here yes so there is an example here but I can definitely give you an example that might be more pertinent you could well actually you know what I'm gonna mess it up if I try and do it I'm gonna mess it up if I try and do it off the top of my head let me look at the example that I wrote here and just walk through that unfortunately it doesn't give the example of the weird thing happening so you've put me on the spot but I'm gonna try to produce an example for you okay here's an example you have no orderbook at all in this case it's a single hop but you do have a liquidity pool the liquidity pool

[31:00] Has some liquidity in it but not enough to give you a good enough price when you say no order so the path payment meaning is from a to b there's two assets involved and there's currently no offer no traditional offers exactly there is a liquidity it's very small and so there's a ton of slippage when you trade against it and as a consequence you like you can do the conversion you want to do but you don't get a good price and so in the old world like you know if you only went through the path payment like if you only went through the traditional orderbook you would have gotten too few offers but now you go through the liquidity pool side you actually can do the conversion so too few offers is not a factor but then you get to the end and you don't satisfy the constru the price constraints on the path payment and so the original language said like well I should have returned to the too few offers but that's obviously not something that I could even like if in a long multi hop payment it might

[32:00] Not even be possible for me to figure out what I should have returned without having to go and rerun it all in the absence of liquidity pools which is obviously super inefficient for no gains so yeah okay and so to be totally clear there's no such thing as a path payment that would have succeeded except for the liquidity pool there's no way the liquidity pool could make something fail it would otherwise have succeeded right I think that is correct yes okay because you always get better prices yeah with the liquidity so it's another option so it's not okay I do believe that is correct yeah I think the first time I said it I said something that would have implied that wasn't true but that's right I think that's where I was getting confused so basically now you won't get too few offers because that's doesn't make sense because it's a liquidity pool not an orderbook right you got some other error it is still possible to get too few offers actually even in the case

[33:00] Of the liquidity pool like if the look this can only I don't remember for which this can only happen for path payment strict receive imagine that you have a liquidity pool that has a hundred dollars in it and 115 euros in it that's not like exactly the exchange rate but it's pretty close so let's pretend and then I sent a pass payment strict receive where the destination receives two hundred dollars and I'm trying to send euros this is obviously impossible in the liquidity pool there aren't two hundred dollars to come out so the trade can't be done if there was no traditional orderbook you still end up getting too few offers because when we can't do the trade in the liquidity pool like on a given step we will use the result from the orderbook side that sounds a little weird but basically like the logic here is like try to do the trade on the liquidity pool

[34:00] If you get a good result good to go if you get an error just like throw the error out who cares then go to the orderbook try to do the trade there if you get a better price and you got the liquidity pool was possible do the orderbook if you get a worse price but the liquidity pool was possible due to the liquidity pool and if they were both errors return the error from the orderbook yeah this makes sense it's weird it's not like weird to think about but it was hard to express all of this but we're hitting the exact examples that we walked through when we were working this out but it's just like a reasoned decision about where the errors come from and what the order is okay exactly just need to do something consistent and predictable basically

[35:00] Yeah I can take this so this is I mentioned this earlier but we in a previous line that we just reviewed we added a low reserve error which is like on revoke if the account that is going to sponsor the cranial bounds is already isn't a sponsorship sandwich this is essentially adding at the another error code where it's possible to get too many sponsoring as well if that account if this account sponsoring is has is already sponsoring too many entries so yeah that's it so we have a counter that says like how many entries you are currently sponsoring and that has a limit I believe it's

[36:00] And that has a limit I believe it's in 32 max or you and 32 max most importantly it's limited by your lumen balance isn't it yeah all right but you can theoretically get to that amount I see if you have a lot of that yeah the limit if I should be a little more accurate the limit is actually too many sponsoring plus nub sub entries which is a detail that allows this allows the revoked to be guarant the revoke to work like guaranteed if you're not in a sponsorship sandwich but that which is a detail in the CAP but if obviously we don't like in this case it's a little different which is why we need to check for that error code the reality is exactly what you say David though like the only limit that we ever expect anybody to hit is the sub entry limit all the other limits they exist purely because like we have to do something that has to be well defined but like the circumstances under which you would

[37:00] Have to be and to hit those limits are like so unusual you have to have like three billion base reserves or something exactly one and a half billion lumens like well like it's possible but like why would you be in that situation why would you be why would you be sponsoring so much stuff like it's just weird so and then we interview the person who got to that state well there's a you know most like 20 people or something who can do that right if there's 50 billion lumens available so all right the final change removed new claimable balance ID type yeah so I can take this as well so in the original CAP invitation we added a new claimable balance ID type and also the balance ID is hashed off of a

[38:00] Different objects essentially or a different union in a struct and this is actually unnecessary because we're already like the hash already is that has a different type in it so why were we at the higher level also include a different kind of bounce ID type when it's not necessary so we just remove the new claimable balance ID type yes because we still have the new type and the object that we had the passion yeah I think originally we thought that maybe by having this extra type we could basically derive the reason on where the where this came from but then we realized well actually you already have to go to the transaction that created the claimable balance anyways so

[39:00] This was actually kind of useless I mean like for existing playmobil balances you already have to go through this process so there was like it was a shortcut that was not actually doing anything useful well that's all the changes that happen between acceptance and now and I feel like you know I definitely learned something about some of the choices that we made and implications that they have really outside of the protocol mainly in terms of what we can be telling people but basically it doesn't seem like there's any work that needs to be done to revise or undo any of those changes does that seem correct yeah I have

[40:00] I mean maybe it's just too late for this but like the one thing that would be nice like it doesn't say anything about what happened suppose like 0 3 turns out to be like the wrong number or something like it would be nice to say somewhere to just in terms of setting expectations like that future protocols are allowed to like completely cancel your liquidity pool shares or refund them to you or something like give people like basically like I want to avoid like the next time we revise this being in a situation where like because people are using the previous AMM and we didn't give them enough warning like we're like reluctant to make changes so I'm wondering if we could just add like one sentence to the future work section like it like that like you can't count on your shares continuing to trade in perpetuity if like we upgrade the protocol or something that's a good point because that's also like the kind of the

[41:00] Like the kind of kind of we have a similar expectation with the other book today that it can basically like disappear any day so people should not rely on that in smart contracts or things like that right and we did do that with the orderbook once and it was fine and I could imagine needing to do the same thing in this context I think that's a really good insight David so they take so somebody just writes essentially a sentence that explains this too the liquidity of poor shares can you may get cancelled then you may have to like claim you claim the claimable balances and like reissue if you know if we upgrade the AMM algorithms or parameters that are in use got it which again just for anyone listening would require valid would require a protocol upgrade that would require the consent of validators yes it's not a decision well that would be a CAP actually it's a new CAP too

[42:00] Yeah and a new cab right so there would be a whole process that would lead to that it would be out in the open and it would be this like development life cycle so I guess that then there is an additive request which makes sense and someone's going to take that but other than that we feel that these changes these changes I mean am I okay voting for this but authorizing like one sentence to be inserted before it's you know finalized like I don't want to drag this into another protocol meeting it's like a very minor thing that doesn't matter for today so and if we didn't do this I would still be okay with this I just think it would be nice to do yeah it sounds like everyone agrees right I'm gonna go and do it when we get off the phone probably so or get off the phone so old school thank you John okay cool is there anything else that is pressing that anyone wants to bring up if not I think we're done

[43:00] To bring up if not I think we're done for today there were any questions in the chat before we hang out I don't know everything was so congratulations great we did it let's everybody this is a big deal yeah and so there we go has reached the end of its development life cycle and now it is ready to go out into the world I mean it's already on the test net in Protocol 18 and soon it will be voted on by public network validators which is pretty exciting so great work everybody I'll see you all soon thanks everyone thank you thanks

</details>

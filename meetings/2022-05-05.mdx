---
title: "Classic Asset Wrapper Versus Adapter Models"
description: "This discussion continues the Jump Cannon design work by comparing two competing approaches for smart contract asset interoperability on Stellar, weighing ease of use, security, issuer controls, and ERC-20 compatibility."
authors:
  - david-mazieres
  - jonathan-jove
  - justin-rice
  - leigh-mcculloch
  - siddharth-suresh
  - tomer-weller
tags:
  - legacy
  - CAP-46-1
  - CAP-46-2
  - CAP-48
  - CAP-49
  - SEP-8
---

import YouTube from "@site/src/components/YouTube";

<YouTube ID="oGoqR05-RP0" />

This session dives deeper into Project Jump Cannon by focusing on how existing “classic” Stellar assets should interoperate with smart contracts. The core of the conversation contrasts two proposed models—CAP-48 and CAP-49—and evaluates how each balances backward compatibility, developer ergonomics, security guarantees, and long-term ecosystem evolution.

Participants explore the trade-offs between frictionless integration of existing assets versus a cleaner separation that more closely mirrors ERC-20 semantics. The discussion also broadens into related topics such as issuer compliance controls, wallet and Horizon implications, and how asset design choices may shape adoption, scalability, and user experience across both classic Stellar and Soroban.

### Key Topics

- Comparison of asset interoperability approaches:
  - CAP-48’s adapter-style model that directly operates on classic trustlines.
  - CAP-49’s wrap/unwrap model that escrows classic balances and mints ERC-20-like tokens for smart contract use.
- Design goals for interoperability: immediate usability of existing assets, minimal issuer effort, performance, and safety.
- ERC-20 compatibility concerns, including `balanceOf`, `totalSupply`, allowances, and predictable transfer semantics.
- How wrap/unwrap boundaries isolate classic mechanics while enabling cleaner smart-contract abstractions.
- Preservation of issuer controls such as authorization, revocation, and clawback when assets move into smart contracts.
- Security considerations around signing authority and preventing smart contracts from over-spending user balances.
- UX and infrastructure implications for wallets, Horizon, and future data access layers when assets exist in both classic and smart contexts.
- Issuer decision-making trade-offs between classic assets (scale, cost, exchange compatibility) and smart-native assets (flexibility, programmability).
- Related CAP discussions:
  - CAP-47 (now CAP-46-2) on smart contract lifecycle and mutability.
  - Questions around contract versioning, auditability, and how downstream systems track contract code over time.

### Resources

- [Project Jump Cannon: Choosing WASM](https://stellar.org/blog/developers/project-jump-cannon-choosing-wasm)
- [CAP-0046-01: WebAssembly Smart Contract Runtime Environment](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0046-01.md)
- [CAP-0046-02: Smart Contract Life Cycle](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0046-02.md)
- [CAP-0048: Smart Contract Asset Interoperability](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0048.md)
- [CAP-0049: Classic Asset Wrapper Model](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md)
- [SEP-0008: Regulated Assets](https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0008.md)

<details>
  <summary>Video Transcript</summary>

[00:00] Hello everyone and welcome to the Open Protocol Meeting obviously it is the first time we're doing it in this Discord channel. But most the conversation around Stellar development has moved to Discord. And so it makes sense to kind of put it all in one place most of the Jump Cannon work in fact all of it is really being done in the open here on the Jump Cannon channel and on the Jump Cannon dev channel. So anyone who's interested in seeing us work to bring smart contracts to Stellar can you know join in, that discussion. So today the these meetings these protocol meetings are here to discuss and plan for actual changes to the Stellar protocol and we are focused on Project Jump Cannon at this point and on, which will bring smart contracts to Stellar and we're talking here about the protocol changes, that are necessary in order to accommodate it to tackle Jump Cannon we actually decided to break up the suggested protocol changes into a suite of Core Advancement Proposal and at this point

[01:00] they're actually four different CAPs, that are linked to three of, which are linked to in the media invite one, that just came in under the wire. But it's [CAP-49](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md). So those CAPs are [CAP-46](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0046-01.md) the webassembly smart contract runtime environment, which is what we discussed last meeting and it's basically a building block, that establishes a vocabulary, that we can use to talk about wasm-based smart contract environments 47 the smart contract life cycle defines the structure of smart contracts on Stellar and specifies how users can create update and remove them. Then [CAP-48](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0048.md) and [CAP-49](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md) I think our two approaches to deal with smart contract asset interoperability. And so this meeting is being is like anyone can sort of watch it. Now now I believe David has a SDF role. So but we are also archiving this and posting it on youtube so, that people who can't be in the Discord channel who want to watch the protocol meeting can watch

[02:00] it later. So with, that said you know we're talking about smart contracts I believe, that the first place the first set of issues, that is probably worth talking about relate to your CAPs John [CAP-48](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0048.md) and [CAP-49](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md) deal with interoperability. So I feel like there are some questions, that are open, that we might want to it's probably useful to talk about. Now but John do you want to sort of give an overview of where we are with those two CAPs. And then we can take it from there sorry first time first I'm doing like a video call on discard I'm still getting a little oriented let me pull up the relevant documents give me one moment. And then I will give a little intro okay I'm ready sorry about, that

[03:00] so basically these two proposals they relate to just one very simple question or simple sounding question, which is yes exactly. But some error cuts on, that which is we have some classic assets some of, which have like you know substantial value sitting beneath them and we'd like to be able to use those immediately as soon as you know we deploy jump can and smart contracts on the public network without and the kind of framework here is like well ideally we can use them without anybody doing anything they just kind of work like magic. So there's a couple of things, that go into, that one thing we'd like is for them to be pretty fast tokens are kind of like the framework on, which blockchain lives. So so, that to be really efficient in order to make the whole thing efficient the second thing is like there's no reason to think, that anchors

[04:00] are going to instantly deploy new software to support interoperability between their existing assets like classic assets and smart contracts. And so ideally it just kind of we do it for them in some sense they everybody just gets it for free basically and there's one other requirement, which I'm. Now not remembering oh yeah and the third one is a security kind of situation, which is, that like. When I sign for a Stellar account at medium threshold I have like complete control over all of, that accounts balances meaning like I might be saying, that i'd like to make a five dollar payment but. If I have a million dollars in my account and I signed for a smart contract to control my account at medium threshold it could just make it a million dollar payment ideally we should make it so, that situation is completely impossible you can't just sign for the account to make payments basically. And so these two CAPs 48 and 49 are two different perspectives on this

[05:00] problem [CAP-48](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0048.md) is kind of like what. If I did the thing, that was the most frictionless possible but. If you do, that you inherit a bunch of weird stuff left over from like the fact, that Stellar assets are not really quite exactly like your z20 assets or whatever other Ethereum standard you'd like I'm really focused on erc20 just. Because I'm familiar with it and it's classic and old. But like there are other standards, that could be relevant here. But I'm gonna keep saying here c20 and you should just interpret, that to be whatever standard you like [CAP-49](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md) on the other hand is more like what. If we introduce a little bit of friction. But we make it so, that these things really look like erc20 assets and avoid any of these like weird questions like oh like what who did, that do there's no more ambiguity so, that's kind of my pitch for these two proposals

[06:00] ultimately is it about choosing one path or the other is this like a choice between 48 and 49, that is something, that we need to contemplate and make or are they work together or you know given John given, that [CAP-49](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md) was just like dumped this morning on the repo maybe you can give us like a high level overview and like what are the differences between [CAP-49](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md) [CAP-48](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0048.md) yes and to answer Justin's question it is an either or. But not like an either or and no other options exist it's like a these are two good options and there could be other good options I haven't thought of. But I have thought of a lot of options and these two definitely stand out as like probably the best given our requirements. So it's like either 48 or 49 or something, that none of us have thought of yet to go over what Tomer was talking about in terms of 49. Because I did kind of

[07:00] just drop it on you guys at like 11 o'clock this 11 o'clock in my time this morning basically I went over the issues in [CAP-48](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0048.md), which are listed in the design rationale there's four slash five of them depending on how you think of it and I went through and kind of designed a system, that solves them. So what is the functionality of before I go over how the issues are different or work out differently. So in [CAP-48](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0048.md) basically the machinery is like the like asset adapter or contract, that like everybody gets for free actually goes around and controls the Stellar trust line. So you know like. When you use the erc20 function transfer it actually goes and uses the payment operation to send a payment from this trust line to, that trust line or from this account to, that account. If it's needed whereas in [CAP-49](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md), that never happens

[08:00] the only thing, that the only time the contract will ever use your trust line is. When you call these two functions wrap and unwrap or like. If you're used to we would call them as deposit withdraw. But this was confusing to Niko. So I'm sticking with rap and unwrap and we can change choose whatever names we like later. But I think nobody will be confused by the terms wrap and unwrap and basically like what the wrap function does is it effectively takes some stuff from your trust line puts it in some new type of ledger entry for the smart contract, which I'm going to call a wrapable balance name stinks whatever we can change it. And then it basically mints the corresponding erc20. And then all the other erc20 transactions operate on this you know erc20 type balance, that's just like a new thing completely and the opposite thing unwrap just does all of, that in reverse. And so like the erc20 stuff is like completely working on new ledger entries it doesn't

[09:00] use any of the old machinery at all only the wrap and unwrap functions actually interop with the old machinery. And then to make all this stuff work you. Now have to add a few compliance functions like you have to add auth and clawback to the erc20 side of it but, that's like super simple machinery, that like I mean it's super easy to build I looked at how people have implemented it like I looked at I was actually looking at the USDC contracts to see how they implemented the auth and it's like exactly as simple as I was thinking we would do so, that was kind of a perfect fit in, that sense in terms of how this solves the problems. But actually before I continue anybody want to stop me and ask some questions otherwise i'll just go over how to solve the issues, that I see just for me to understand the there's still this like canonical one-to-one mapping between an asset and a wrapped asset yeah okay it's like a native implementation you do the same kind of thing where you

[10:00] like say like hey like give me the contract ID for this asset and this contract ID is some kind of like native thing there's no wildling behind it just runs it has some interface, that we prescribe and there's exactly one of them for every asset, that you could ever make, that's it and they can store data and I'm not really talking about how the data is being stored in the CAP. Because we don't know what the fee model is yet. So like there will be some fee model I don't know who's paying for it I don't particularly care at this time and whatever we decide later should just retrofit onto, that's, that's, that basically any other questions before I go on okay. So why do I like the 49 version better than the 48 version. So I'm just going to go like over these the issues I noticed. So the first thing is like it's not

[11:00] labeled as an issue in [CAP-48](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0048.md). But it is one, which is like ideally you should be able to use a Stellar erc20 like a wrap an erc20 wrapping a Stellar classic asset however, that interface works ideally you should be able to use it exactly the same way you would use an erc20, that's not even possible in [CAP-48](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0048.md) even ignoring some of the other weird quirks, that like we have to agree on some design, that makes sense Because just. When you initialize a contract like let's say you have a liquidity pool contract and you have like a factory for it, that takes two assets, which are going to be the two assets, that you have reserves for well you'd have to actually check like hey is one of these assets and like a Stellar classic asset even. If it has an erc20 interface. Because you would still need to create the trust lines for it, that's a bummer. But at least it only happens one time in initialization, that doesn't happen [CAP-49](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md) you don't

[12:00] need to create the trust signs the contractor does all the magic and we don't need to be backwards compatible. Because it's all new machinery. However the fee model works I don't know. Then then the next thing is like what is the issue of balance like. If I take the [CAP-48](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0048.md) version and I ask the concept like hey like balance of the asset issuer what should I return. If I return 0 should I return in 60 formats should I return you at 256 max I mean like I have no idea what number to return there is no sensible answer the balance of the issuer is infinite and also zero sorry I think zero is a good answer for, that question. But like you can make a payment from the issuer in account. So surely the balance isn't zero sure it can mint right. But it does it like the it's the balance of like the currently minted you know the current circulating supply

[13:00] I don't know man it's not compelling to me at all. Because like in this context like the function transfer for what like the function transfer. When called on the issuer actually has to me, which is not how an erc20 normally works and since it like. If I can call transfer I should have enough balance to make, that transfer you see. If the function transfer 100 would succeed. Then I must have a balance of greater than 100. I mean should we be rethinking how trust lines work in the legacy model like I think it might have been a design mistake, that like payment is how you create assets like I know like obviously a lot of people expect, that. Now but like maybe, that's something, that we should reconsider, that like actually an issuer can have a balance I totally agree, that I would love to

[14:00] change, that. But it would be a lot of work, that I don't want to do in this context time wise. When like we could just fix the interface on the erc20 side of it so, that this doesn't happen anymore and, that's, that. If you want the same behavior use smart contracts, that's what [CAP-49](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md) proposes this problem doesn't exist in cat49 the reason it doesn't exist in [CAP-49](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md) is. Because the issuer. Now can't hold a real balance and transfer doesn't mint anymore. Because it's all operating on these wrapped up tokens Tomer's making a lot of faces. So I feel like he's doubtful about my argument here no I'm not awful about your argument I understand why like I think there's an elegance to [CAP-49](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md), which is like better separation between classic and smart. But we are putting a lot of burden on you know downstream systems in the user to actually like to wrap and unwrap tokens and like

[15:00] present some sort of like a unified view of the universe, that like across the across these boundaries I agree about the unified view of the universe I don't really agree about the burden of wrapping and unwrapping there's a section about, that. But obviously I dropped this on you guys like two hours ago. So I don't assume you've all read it. But basically my argument is like well hey you have to go and work through this whole allowances thing anyway and. If you have to go and do, that you can wrap up your assets. When you're doing, that at the same time there's nothing stopping you from doing them at the exact same time. So like since your wallet is gonna guide you through the allowances anyway it might as well guide you through the wrapping, that's kind of my argument, that might not apply in the context of like the eip 20 2612 is, that the one where you have the permit function I have to go and look at how, that would work. But I assume we can do a similar thing for the wrapping anyway. So probably it would still be fine

[16:00] okay any questions before I do another one am I actually being helpful here should I stop you're being very helpful John i'd love to hear Nico's take I know he's been having some technical challenges can anybody here okay John can you talk a bit about the various authorization models author required author revocable. While backable and how they would relate to the to both [CAP-48](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0048.md) and [CAP-49](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md) yeah definitely. So in [CAP-48](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0048.md) everything kind of just works the way it used to

[17:00] there's no magic to it at all the only catch is, that like you can't do the auth stuff from smart we could make it said you could. But there's like a wide variety of reasons why you should not be able to and, that might be a problem. But the in [CAP-49](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md) the auth stuff works a little differently. But they it works differently in a like favorably good way everything is simpler and we can actually fix some things, that were broken or not broken perhaps. But less than ideal in CAP in classic. So the first thing, that's better is like in classic there are three authorization states you can be unauthorized authorized to maintain liabilities or authorized in [CAP-49](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md) all of, that still exists in classic. But in smart there's only check you're either authorized you're an officer. Because there are no liabilities. So authorized to maintain liability is the same as unauthorized. So we don't even need to represent it at all glorious

[18:00] glorious the next thing is like we had to do this like off clock sorry trustline clawback trustline flag fallback enabled something like, that I can't remember the name of it anymore to preserve backwards compatibility with trust lines, that like you didn't believe, that they would ever be clawbackable. But since clawback already exists before smart everybody anything, that anybody ever builds on smart should be aware of the fact, that clawback is possible. So we don't need, that flag either sweet. So now we solve two problems already. And so now basically the way, that auth works is it's just like a single bit on your account not on your account on your like stored in the contract data I guess stored in this like wrapable balance entry type of thing and all it does is it says whether you're allowed to use the contract or not and it's more I'm like representing it more in the like completely not allowed to use the contract sense

[19:00] than just what like Stellar classic would allow for example. If your account is not authorized on the contract. Then you can't even use transfer from to transfer from two other people you can't even be you can never be the sender basically on this account and, that I didn't think of, that originally but, that is what is implemented in, that USDC contract, that I was looking at and, that approach makes a lot of sense to me. If I'm not authorized to use it for my own balances I probably shouldn't be authorized to use it for anybody else's balances either sounds dangerous. So so, that's the only real difference. But basically like author revocable clawback all of, that stuff, that can happen on the contract side of it's just determined by whatever the issuer flags. If the issue of flags are currently revocable irrevocable. If it's currently clawbackable you're applaud backable, that's it no other magic to it. So it's a much simpler implementation than exists on classic basically

[20:00] does, that kind of answer your question oh I definitely have some other questions obviously wrapping you can only do from like a classic Stellar asset to a smart asset you won't be able to go the other way around right. So we're essentially saying, that like there will be like a new universe of like payments for example only for smart contract assets, that are completely in jump can like you won't be able to interoperate from the likes of the classic protocol I want to make sure I understand exactly what you're asking me

[21:00] are you saying, that there will be an like are you saying, that basically like. When somebody wants to use a classic asset it ends up being only usable and smart until they send it back or you're saying, that this is kind of a model where people will be using like erc20 type assets on smart I'm saying let's say I'm issuing a new asset on the jump can inside doesn't relate at all to these wrapped assets or to any adapter whatsoever it's just like my own you know Tomer coin tomercoin will not be accessible from the classic protocol in any way like I wouldn't be able to use like a classic payment operation on this coin I mean we should obviously we can't prevent, that. But we should discourage it right like it would be a bummer. If if you know at some point we want to have like really cheap payments and trades

[22:00] right. And so to the greatest extent possibly want to encourage people to use assets, that can participate in you know things like speed x right I mean I suppose in this context like. If you wanted something, that was you know, that could be converted to a classic asset what you would probably just do is actually make it a classic asset and use the wrapper right, that's what I'm saying, that basically like it will be of course it's true you know we will people can implement their own assets. But to the greatest extent possible we hope, that our classic assets will actually serve the needs of kind of ninety percent of the kinds of assets people

[23:00] want to issue. But one would hope right otherwise yes no but. If I want to coin to have features, that are missing from the current seller protocol. Then I have no other choice right. So so I think regardless of what we do we need to acknowledge, that we're basically going into a world in, which there are two classes of assets, that are interoperable between these two runtimes and assets, that are only in Jump Cannon and like do not inter operate and it sounds like we're also saying, that classic assets, that already exist we wouldn't be able to add in like. If you any of those features tomorrow, that you want to add to tomocoin. If USDC wanted to add it had those same features they wouldn't be able to do, that. Because they're it's a classic asset is, that right you might migrate back into the native Protocol

[24:00] I wouldn't actually rely on us building any new features on the old protocol I think, that's yeah John is smiling, that's all I needed. If that's the case. Then like we're actually by doing this we're not really planning a way to bring new features to existing classic assets. So is there going to be this slow overtime movement of assets, that just stop using classic. And then we lose the ability to have assets to speed x and things like, that to be honest I think, that somewhere coin is a bit of a of an edge case like. If we look at like it's not like assets on Stellar actually have very true real features missing from them like it look like we do have a good coverage of like asset features. So I'm not offended by the idea of like issuing them still on the classic side and wrapping them

[25:00] I i'd like to find a way from the user experience to make it the wrapping parts less visible and not have like multiple balances for like the same hassle. But we can figure, that out later. Because the you know the ewe experience is not you know. When you're crypto native it makes sense. When you're like you know just you know arando trying to make their first steps in defa it's not like the best experience yeah I totally acknowledge, that one thing, that is kind of missing from the wrapped contract proposal, that I wrote, which I did think about this morning was whether there should be mint and burn operations on the smart side. If there were mint and burn operations on the smart side it would be possible to effectively issue a classic asset. And then always work on the smart side

[26:00] and. So like your users could unwrap them. And then use them on classic and re-wrap them. If we wanted to preserve, that interoperability. But like in practice everything would happen on smart and people would never really be doing the wrapping and unwrapping unless they want to go back to classic and so, that in, that world you avoid the rap step like imagine. If like you have an anchor flow, that instead of issuing you the classic acid. Then you have to wrap it up and send it smart you just like they ask you like hey like do you want this to be smart or classic and. If you want it to be smarter they just issue it on the smart side. And then you don't have to do the wrapping or we could even do, that by make, that the default at some point, that might make the ux better for some cases, which maybe would be a lot of cases actually I don't know what do you think about, that summer slash lee it's yeah like it complicates things for the issue, and now they need to decide, which side belongs on ideally there would be like one

[27:00] especially with like these Stellar assets, that we expect to be the majority we want to have like a very straightforward best practice and I think we might be just confusing the issue with adding, that functionality on the smart contract I also think we're asking the issuer to make a decision really on versus between scale and flexibility. So we want to be able to. If we want like what David said an issuer wants an asset to be used on things like speed x or on cheap payment operations they're going to be tempted to go, that scale route. But then, that might be conflicting with flexibility like. If they want to have I don't know some sort of SEP 8 like functionality, that allows, that's on chain, that you know maybe says you can use my asset. If you have already been authorized to use some other asset you know as a sort of like a kyc interface or something like, that

[28:00] like. If they want to add something like, that later on or I don't know like they have to decide at the point of issuing am I going to be a smart asset or a an asset they can scale maybe, that well i'd have to think about whether there's a workaround for, that there might be one I'm not really sure. So I don't know I can't i'd have to think about, that more to answer what I think just to clarify. Because I was going to ask this question I think you just answered it with, that lee like I'm an issuer and I'm ch and I'm and there's a choice I can choose to issue a classic or I can choose to issue on smart advantage for issuing on classic is, that

[29:00] has better scalability maybe true I'm just thinking like. If new issuers come to me the other advantages are choose to issue unclassic sorry can you say, that one more time Justin I couldn't hear the whole thing oh this well basically. When new issuers joined the network why would they choose to issue one classic well presumably the idea of classic rate is, that your asset is very well defined right there's just like you know four bits or whatever, that like tell everybody exactly what to expect of your asset and so, that lets you know the fact, that it's you know it's such a well-known quantity also unless it be like you know allows us to implement things more scalably

[30:00] scalably and let's you know sort of guarantee like things like auth immutable right like guarantee, that there won't be weird surprises I think the big thing is, that classic will be cheaper and have more capacity, that's the main reason to do, that on classic. But like for example do we expect exchanges to offer both classic and smart assets or just classic assets like well you know. When when you're getting USDC or whatever will it be a smart USDC or will just be like classic USDC it'll be classic everything, that exchanges do exchanges move slow they move very slow and they're very resistant to introducing changes so. If you ever hope for you listed on you know kraken or wherever

[31:00] like you'll want to make it classic, that's a good point yes yeah generally speaking I think, that except for like extreme use cases for with smart contracts, that have sophisticated non-trivial logic I definitely think we need to push everyone to issue on classic and use this whatever interoperability scheme we decide on. Then I think it becomes pretty important to make it as easy as possible to do this like those mint and burn operations I was talking about they sound important. Now now. Because like. If we want people to get like a unified smart user experience. But still have an underlying classic asset, that you can like actually unwrap, that would be the easiest way to get, that. So so we probably should do, that

[32:00] yeah we're about to make Horizon's life a bit hellish with like figuring out these things and how to convey them to the wallets wait. But isn't the whole point of. If you issue your asset as a classic asset. Then Horizon should just work right, that's another yes yeah. But the question is like. If a user wants to do something on the smart side you know let's say I did something on the smart side, and now I have like part of my USDC balance is on classic part of the USDC thing is on Jump Cannon. Now Horizon needs to give you know give wallet some like unified view. But then why should Horizon even touch the smart side of things

[33:00] I agree george can you expand on why you agree I would also love to hear more I was also like it just doesn't seem like Horizons place to make those kinds of to coalesce those separate things like. If you're making them separate. Then they should stay separate. Because we just give an accurate reflection of the core's state of the world and so. If you have them in two places. Then we reflect them in two places right well a wallet uses Horizon as it's kind of like you know just beta access layer into this into the Stellar universe right now. If a wallet classic wallet well no a wallet not just a classic wallet like I don't have any smart wallets

[34:00] but I would imagine smart wallets maybe wouldn't well like Stellar wallets would want to add smart functionality right it's not going to be like two universes, that's the whole thing right you know. If I have a Stellar wallet and I want to be able to participate in a DeFi application and I need to have access to all those information and we need to find a way to present, that information you're going to need a level of extensibility, that Horizon just like it's not it's just not the Horizon way of doing things like maybe I have some asset and it like keeps its own ledger and like some weird you know compressed state or something right. So like I'm actually there's actually going to need to be like kind of server-side logic for decoding, that right and, that's not we don't want to be like loading, that stuff into Horizon right we want Horizon to be stable and predictable

[35:00] predictable let me rephrase maybe Horizon is a bit of a loaded term. But we need to provide a data access layer to Stellar, that allows wallets to reason about what's going on the dumb side sorry classic side and to interoperate with these like wrap-on wrap functions. So this might not be Horizon this might be you know Horizon ng or whatever. But something needs to provide, that functionality and, that's something is you know like we're making its life a bit difficult well I mean I would argue, that something is going to need to be much more sort of modular and extensible than Horizon right it's just going to be a totally different architecture in fact you might have many instances of this and you have would have some Horizon ngs, that support some assets. But not other

[36:00] assets right and I mean it would just be it's just going to be a much more heterogeneous ecosystem right assuming, that people are taking advantage of the smart contracts all right camera can I try to get some clarity on what you're actually saying here are you saying, that you want this thing I'm going to use the word Horizon and we're all just going to pretend we're talking about the same thing even, though we're not. But you want Horizon this data access layer to be able to talk about both the wrapped balances and the unwrapped classic balances like the trust line balances or are you saying, that you want it to be more generically useful for exploring the state of the smart contract universe outside of these asset adapter rapper things I think you're saying the first one. But I think David thinks you're saying the second one and maybe you're not saying either of them

[37:00] stuff right. Now like I'm trying to think of by the way can you guys hear me I don't know how long you were talking. But I wasn't able to hear you for a. While at least okay can you guys hear me. Now yes okay awesome. So I'm talking about the wrapped assets specifically like the this kind of like dance between wrapped assets and regular assets and I'm thinking about. If I'm trying to you know just like top down design from a user perspective like the wallet experience all the experience they very they have like this universal view in, which a user doesn't have to think about you know, which side an asset is on right. So so either the wallet needs to have these like multiple services, that it interacts with or it has or needs to have like this unified you know service, that it interacts with, that provides it with like a unified view of the world

[38:00] so I think, that regardless of this is something, that needs to happen and it doesn't necessarily actually yeah I think [CAP-48](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0048.md) might be more friendly for downstream. So I mean maybe the problem here is I didn't read these CAPs. Because I didn't hear about them in time. So to the extent, that the I guess, that there's a choice between explicitly wrapping and unwrapping versus like always having assets be sort of both classic and smart at the same time I would you know strongly favor the unified one. But again I haven't read the rationales and stuff you know assuming, that we do, that right. Then we're gonna have sort of classic assets, which are also accessible in smart contracts and we're gonna have like smart contract only assets. So the for the classic assets

[39:00] Horizon should be sufficient right. Because you can access those to the classic interface for the new smart assets every asset is going to need its own Horizon modification potentially or like a lot of assets are. If they're. If they're doing interesting things. And so we're going to need a kind of modularity on the server side we're like I might issue a new kind of asset with like new properties I'm going to need to like also present kind of like Horizon side logic to do, that and I just to me it feels like danger like Horizon doesn't feel like it has the kind of modularity and extensibility, that we would want for, that we should think about a more like plug-in friendly architecture there's another angle to this too and, that is a Horizon like right. Now mostly Horizon just provides access to data and. If we just make sure, that. If we make it such, that Horizon has access to contract data technically

[40:00] clients could still use, that contract data to display things like the balances or whatever you know they can look up in the contract data the same way the contract does there's some downsides to doing, that but, that's one way for us to sort I guess kick, that can down the road a little bit you know we can. But they can potentially be services, that show some specific balance format for specific types of assets it doesn't have to be a Horizon, though clients could just use Horizon to get like the raw contract data actually I think, that's, that's sort of like the model, that of the first demo, that paul had posted into the jump canon channel he posted a demo where you could use this Horizon like service to just get the raw contract data. And then the client can interpret it. However it wants

[41:00] John is the main difference in terms of the interface between [CAP-48](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0048.md) and [CAP-49](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md) like ignoring the wrapped asset part. But the other main difference just being supporting having, that total supply, that's the other interface difference. And then there's a couple other like ambiguity improvements like it's very clear what the answer of balance of is in all cases even outside of just the issuer case in [CAP-49](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md) like is the balance the available balance or the raw balance this is one of the things, that I like kept coming back to. When I was writing [CAP-48](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0048.md) and I don't think I was consistent everywhere. But in [CAP-49](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md) like there is no notion of the available balance from the context perspective it's just the balance. So like there's like some

[42:00] interface improvements in, that like you get the total supply and [CAP-49](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md) you don't get in 48. But like the interface is also just more logical in [CAP-49](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md) like I don't there's only one right answer basically in [CAP-49](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0049.md) for every function it just does the thing, that you expect it to do. Because there's no other thing, that it could possibly do we have to keep to the erc20 interface exactly, though like I could see it being. If we can solve the other problems so. If we found a solution to total supply for [CAP-48](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0048.md) we could say okay there's actually two balance functions there's you know the balance of and available our balance of in the Stellar ecosystem is, that fair and we definitely could do, that. And then we could basically say like hey like you know. When you implement a token on Stellar what you should do is implement both of these functions and probably there you want them to be the same function they just have the same implementation we definitely could go and do everything in reverse

[43:00] so. So yeah a little bit ah it sucks okay maybe I need to shout or something it's good enough okay. Now I was going to say like the reason we have this on the classic side is. Because of liabilities right and actually liabilities we could have implemented, that differently like in smart the way you would do it is actually you would move the actual liquidity outside of the account right. So I think like you know like an offer basically would be you would actually move whatever you want to sell in the offer like, that's not the way we did it whatever but, that's right to me I don't know. If we need to expose those two concepts like balance wise like the available I mean the usable balance is the thing you want to expose like you know the fact, that we, that whatever is locked in our office i

[44:00] mean this is not interesting I think from a smart contract point of view it's not a it's not usable like it's not available right I mean the main downside of, that though is like things, that should be true cease to be true like you should expect, that the total supply is equal to the sum of all the balances, that just won't be true this feels like a minor detail to me like the distinction about how we would expose these two values. Because we could just choose one or we could just expose both and doing either doesn't really break I don't think doing either would break a contract's ability to replicate what you know what's happening on other chains is, that not true I don't know. If it's true. But like. If your goal is to make it. So

[45:00] that these tokens interoperate perfectly with what people are accustomed to using, which is my goal here like. If I could I would just like take the stuff, that people have been building on for five years and just like build exactly, that stuff on seller. Because that's how we're gonna get the fastest adoption and any place where it's not exactly obvious how it works exactly the same, that's friction, that's going to start with a slow adoption and. If it doesn't work exactly the same. Then it's really going to slow adoption. So like the first step is like is it obvious, that it works exactly the same. If the answer is no you probably have a problem and then. If it doesn't work exactly the same you have a second problem so, that's how I feel about this it's like anything we can do to make those answers like this is. So obvious, that you don't need to think about it and it does exactly what you're used to, that should be our goal I don't know. If people disagree with, that goal. But I think it's a really good goal like my goal would be to make this. So stupidly easy for people to use

[46:00] because they're. So familiar with it, that they want to build right. Now immediately you know and unless there are things about the way, that systems currently work, that people hate there are and, that eip 2612 thing, that I mentioned was something, that Tomer pointed out, that some people found a big improvement about something, that people hate from erc20. So like it can be better. But but all of these things work better than classic Stellar assets I think at least for like the needs of smart contracts. So I mean I guess we have about 12 minutes left in this meeting do we want to keep like I know, that there's a

[47:00] few other sort of questions, that came up outside the interoperability questions do we want to take this time to discuss those or should we stick with interoperability there's contract management questions, that I know there's [CAP-47](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0046-02.md) talks about instance stuff, that we want to cover especially. Because the [CAP-48](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0048.md) 49 discussion for. Now I feel like there's a lot to think about and discuss it does feel like we got to a natural lull do you want to talk about the CAP, that you've been working on yeah I can start with the [CAP-47](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0046-02.md). So all right cat47 just specifies how contract management would work

[48:00] actually creating update and removing contracts. So it's know relatively simple compared to [CAP-46](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0046-01.md) and 48.49 48.49 lee had some questions related to this I think the most interesting one was we allow mutable contracts and the CAP doesn't specify any versioning right. Now so one of his questions was, that. If you allow immutable contracts how would you identify, which contract version was used for a specific invocation currently there's nothing in there, that you would have to you know replay history and go look at, which contract entry was used as specific invocation. So yeah. So the least question was around you know auditing, which contract was used I'm not sure. If this is something we should add lee do you want to talk about this

[49:00] yeah I mean you basically set up like I just I think there's two components to it identification. And then referencing. So there should be some way I think for someone to speak concretely around about a specific version of a contract like you should be out there are going to be apis, that expose information about this is the transaction, that executed this is what it executed on there should it makes a lot of sense I think for those apis to be able to point exactly to the exact code and maybe, that's just a hash of the code and. If if so, that's, that's great we just need to include, that in the CAP maybe it doesn't even need to be stored on the ledger I'm not sure. If that's important it could just be a hash, that's not actually stored and you have to calculate it. If you want to calculate it there just needs to be yeah and I i

[50:00] guess in terms of storing in the ledger like the question I had was like you know do we need to install, that in the transaction results or meta or something like, that so, that there is something more concrete or do you just have to know this transaction executed on ledger five and. If you go and look at ledger five at the state of the ledger you can see, that this is the contract, that was there yeah and like. If we have to do, that just feels a bit ambiguous okay. But I think Nico may have mentioned something around you know there's a cost obviously to storing 32 byte hashes for everything. And so maybe this is actually not realistic to store like, that everywhere a contract gets used or something. So Nico I don't know. If you want to expand on, that

[51:00] seems to be having on and off issues connecting to this yeah I can hear you right. Now tomorrow you have been cutting in and out a bit, though from time to time yeah is this something, that downstream systems can do you know. When they index changes they can also index what version of the contract caused these changes I think. So or at least maybe george might be able to shed some light on this I think one thing we have had some issues with like

[52:00] backfilling some of this data in the past. So I think one example would be you know claimable balances don't track who created them and it would actually seem simple for us to say oh yeah downstream systems should be able to just figure, that out. But it was actually really challenging I'm actually not sure. If we actually found a solution for, that maybe there's going to be an ask to the Horizon team who are sort of experts in this field yeah I would say it's pretty hard to say right. Now especially for me I mostly joined as a listener. So I'm not super familiar with how these CAPs are suggested to be implemented right. Now but I do know, that like we have the key value data access model, that paul is working on, which provides access I guess to contracts. But maybe not. So much how

[53:00] those contracts have been interacted with so, that's definitely tbd from the Horizon side I will say, that I felt a little bad in retrospect about the not putting who created a claimable balance on it earlier drafts of the proposal had, that feature and we convinced ourselves, that it was a waste to do it, which was basically just saying like yo Horizon y'all figure it out, which like maybe wasn't super nice in retrospect. But I understand why we did it at the time and I don't know. If I would like even knowing what I know. Now I'm not sure we would have done something differently for, that particular case. But there definitely is some like potential risk for like caveat in the future like I could imagine people wanting to know exactly what happened even on chain like hey like this contract had a bug in it like let me write a contract, that goes

[54:00] and identifies all the bugged out data like I could imagine doing, that or maybe you do it often I don't know I'm not sure. But I don't think we should just assume, that the only obvious thing is to push the problem down downstream yeah I think, that's fair and specifically. Because in this case the identifier or the reference whatever call it could be derived from the data itself. So I think like the claim balance created creator example is more challenging. Because it wasn't actually derivable from the immediate data from the claimable balance itself whereas in this case it is like. If you have the wasn't code you could hash it

[55:00] and. If we say the ID is the hash. Then it might not be the button one thing I was talking to slightly different topic. But still related to like code versioning stuff, that I was talking to darth about yesterday afternoon was about like maybe the state of like and like start had some reasons, that this is like maybe not a brilliant idea and I don't claim it is. But like basically like the idea, that I kind of had, which was weird was, that all contract code is mutable there are no immutability flags or anything for it. But it's only mutable from within, that own smart contract. So basically. If you want to be able to redeploy your smart contract you need to write a function

[56:00] that can redeploy your smart contract. If it is missing your contract is immutable. If it is there. Then you can redeploy your smart contract using whatever scheme you want for signatures and stuff. So the main advantage I see to this is like you get immutability for free and you get mutability for free but. If you want me ability you just have to build whatever readability scheme you want. But the cash, that's pointed out, that made me think, that maybe this is not. So smart is he said, that. If you accidentally bork your contract and forget to deploy your redeploy function you're dead you're just straight dead. So so yeah, that's, that's your risk basically yeah like we I think we concluded with the idea, that maybe it might be a good idea to allow both you know you can update the contract with update manager or update contract app or you can allow the contract code itself

[57:00] up to upgrade the contract let me obviously have to think about this a bit more but, that might be a good idea. If you update. If you deploy your contract. When is the new contract available like the current ledger no it'd probably be the next led you're right yeah it'd be the next ledger it would I guess the operation would basically be like hey at the end of this ledger write the new code kind of like the same thing as like. When we were working on speed x it's like a speed x create offer operation means like hey. When you go into the speed x phase make this offer and try to trade it. So so there's some interesting applications of, that you know you could write a contract, that actually contains multiple versions

[58:00] of itself and it could change, which version of itself is currently going to be deployed based off some other inputs yeah, that's it's intriguing it's funny you say, that. Because I was thinking about things like, that too I was thinking about deploying a client, that can write itself back to the chain, which I thought was just like intriguingly weird. But there's some examples of like twines, that can write themselves back even under this case of corruption. So like you could imagine a contract, that could have its data corrupted. And then write itself back to the contract anyway, which is pretty neat I have no idea how, that could possibly be useful. But like there probably are useful versions of these kinds of machinery it feels like a good thought to end on since especially since we're out of time. So we are going to be having these meetings weekly I don't know. If we're having well we'll sort of deal with scheduling in the background. But so for anyone who's watching you can find

[59:00] them in this channel we're also going to be discussing this stuff asynchronously in the jump canon and jump canon dev channels here on Discord thanks everybody I will talk to you all soon you

</details>

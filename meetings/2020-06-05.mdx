---
title: "ZkVM: About the Motorcrab"
description: "An overview of Project Slingshot and zkVM, covering confidential transactions, programmable predicates, and a modular zero-knowledge architecture designed to support scalable, multi-asset smart contracts."
authors: [oleg-andreev]
tags: [spotlight]
---

import YouTube from "@site/src/components/YouTube";

<YouTube ID="1i-EJykVzag" />

This talk introduces Project Slingshot, an experimental zero-knowledge blockchain architecture centered around zkVM—a programmable transaction format designed to combine confidentiality, composability, and scalability. Rather than starting from protocol mechanics, the session frames the core problem: how to build a public, auditable ledger that still supports private balances, private transfers, and customizable financial logic without constantly upgrading the network.

At the heart of the design is zkVM’s execution model. Transactions are treated as small, self-contained programs that run inside an ephemeral virtual machine. As the VM executes, it builds a constraint system and verifies it using zero-knowledge proofs (Bulletproofs), ensuring assets are conserved and rules are followed without revealing sensitive data. All state changes are expressed as inputs and outputs, allowing transactions to be validated independently and in parallel, while higher-level features like accounts, order books, and payment channels live outside consensus-critical code.

### Key Topics

- Motivation for Slingshot and zkVM: encrypted assets by default, public verifiability, and extensibility without frequent network-wide upgrades.
- Modular architecture: cryptographic libraries, VM, networking stack, and blockchain state machine designed to be deployed as a sidechain, private ledger, or embedded node.
- zkVM execution model: transactions as “PDF-like” programs, stack-based execution, constraint-system generation, and zero-knowledge verification.
- Contracts and predicates: locking assets behind public keys or programmable conditions, including taproot-style branching.
- Confidential value flow: linear asset types, mixing (cloak), and protection against duplication or unintended asset creation.
- Example applications: confidential payments, programmable order books, collateralized loans, and two-party payment channels.
- Design comparisons: contrasts with Stellar’s built-in operations, Ethereum’s global state machine, and Zcash’s fixed circuits.
- Roadmap and integration questions: running zkVM alongside Stellar as a sidechain, bridging Stellar assets, and packaging networking and tooling for broader experimentation.

### Resources

- [Demo site](https://idioms-demo.stellar.org)
- [Project Slingshot GitHub repo](https://github.com/stellar/slingshot)

<details>
  <summary>Video Transcript</summary>

[01:00] Hi. So hello everyone. Today we're going to talk about project slingshot and ZJ diem. My name is Alejandra and I work at Stellar on this project for the some time already, so I'd like to give you an overview why we do that, how we're going to use it and why is it interesting so let's do the time check all right. So the problem that we have is: we know about the ball change. So how do we do the blockchain that protects the private information while being in the public? Right, it's a public system that's fully auditable and transparent, but yet we do the private transaction in it so effectively. We want something like ledger with TOS. So there are two major components to it. One is the confidentiality part, so for

[02:00] These we need some sort of encryption for our balances and accounts and amounts that we transfer. And since it's a public system, we need a public verification mechanism for proving that the encrypted, the Hylian transfers, are actually correct and respects the balancing equation. But people, when they transaction, they don't create the money out of nowhere. So we need some sort of zero knowledge proof in our technology, static. And the third important component is that: some customization mechanism. Why is that? The blockchains are especially consensus systems. They the work best when they're mostly decentralized, deployed widely and as many applications. The users run them and execute the rules

[03:00] And check the transactions, and this means that it's very hard to upgrade the system with new features or improvements. So we need to, on one hand, to make it as simple and focused as possible so it's not buggy, but at the same time we want to build some interesting features around the system, like from smart contracts to whatever you know- decentralized applications to improve the security of people transacting in this new environment. And one way is to just roll out network wide upgrades, which is as hard as it is decentralized, or, on the other hand, foresee some customization points so people can build things on top of it without changing the underlying rules. So this is where the VM part comes in. We

[04:00] Need some sort of program ability for our system and if it's programmable, it means that there are programs and it means that there is some sort of virtual machine that is going to execute those programs. So this is where the DM part comes in. Now, what is slingshot and how does it relate to the akkadian? So slingshot is an umbrella term for the entire suite of libraries and protocol implementations that include not only the can- a more interesting part- the transaction format, the zero knowledge proof sand, the programmable conditions, which is the kvam, but also all the exhibitory cryptographic libraries, such as signature schemes, Multi signature things, the multiple tree implementations, all the way to the entire ball chain system, where the blockchain state machine is a

[05:00] Separate protocol implementation, and the peer to peer networking stack and higher order application protocols, such as the mechanism behind accounts, the protocols for synchronizing- well, that's doing payment channel sorter books and all these kind of things that could be built on top of the core blockchain system. So this whole thing is called slingshot and it's all exists in a single GitHub repo where the development happens. Now, what's interesting about the TVM and the slingshot is that as a filing modular design. Why is it important? This is not a single application that has a specific way of using it. It's more like a collection of libraries that we can flexibly figure out how to deploy and

[06:00] Roll out in the best manner. So we can build a sidechaining. Or we can use it as a private ledger, or we can use it as both. The cryptographic pieces are composable, so we can attach the off-chain proofs to our transactions. So, for instance, we can offload some computational cost from the network by building some intra party proofs about payments, for instance some notarization or zero knowledge other schemes completely outside of the blockchain. So we don't have to load the Internet work. With this computationally heavy problem, we can use the full node as a library embedded in the greater application. That for instance, does some interesting indexing of the transactions and we can decide how big the now it should be, how much data

[07:00] Should store. For instance, the uijik, so state compression scheme allows us to have very little minimal state at the cost of a little bit more bandwidth overhead and you can decide whether you just have this very compact- who know them better than your wallet? Or you have way even lighter wallet, or you build it completely standalone applications and running on a cluster, for instance, with as much data storage as you possibly can, because you want to provide as much service to the very light applications, and this is why the default project is designed to be modular from the beginning. Now, specifically, the key VM is a transaction format that sits on top of the networking part and the consensus mechanism and on top of the KVM then you can build your custom application protocols. So what does it mean to say

[08:00] That the helium is a transaction format? So, in other words, the key VM is a fancy parser. If you think about bitcoin or Stellar or Z cash, the transaction format and those protocols are is more like XML. So this is some kind of hierarchical structure with lists of things that contain other things that describe declaratively the flow of assets. In contrast, theorem is much more programmable, but the transaction format is more like a remote procedure call, where the transaction just sends a message to network and then you have the global state with some programs loaded into that state that can be invoked and do some operations, do some mutation into the state, and that was actually simply signed message into this global computer and the key mam is neither of those two things. It's more like a PDF, so it's sort of a declarative format, but at the same

[09:00] Time it's an executable, a little language that you run through the VM. That is sort of like a parser that exist, the kids, the commands, does some local operations to determine what changes to the state should be made. So you can explain this better. This is the quick overview of the data model indicating. So you have transactions and transactions are objects. These little files transfer assets from inputs and APIs and they can also issue arbitrary assets because it's the multi asset environment, right, just like Stellar. So this is how the esse flows: from inputs to outputs and the outputs are actually the objects that we call contracts. They have a predicate that can all locks some content inside the contract and provides

[10:00] Conditions to unlock the contents, and the contents are called the PD load and it's actually a list of things, and those things could be either values that are local, linear types, the things that you can move around but cannot duplicate, which are the assets themselves, or some data parameters. So your contract is this collection of values and data that can be locked into this container by a predicate, and the simplest way to think about the predicate is the public key, right? So you say whoever owns the corresponding private key can unlock the values and then decide what to do with them. And your unlock by showing the signature on a transaction. So you have a transaction that says I want to spend this value and such way. You have to provide a signature that authorizes you to unlock that contract. Or the predicate could be a little sub program. So you have to run the program,

[11:00] Meaning that the VM will run the program and check additional conditions that are described by the program before deciding to unlock the values. And you can combine both of them with the scheme called a taproot. It's a like Merkle tree of programs and public key is. So you have the flexibility to decide things like. You can either have multiple parties signed together the contract or they could choose individually whatever branch they want to execute. So this gives you a lot of flexibility in terms of pre programming different conditions, that unlock stadium and the mining. And it's a little bit even more flexible because you can not only pre program some conditions or provide a signature, which was action, but you can also provide a signature over in new conditions so you can decide some

[12:00] Program later and then sign it and then that program will be executed. So this gives you infinite ability to do some interesting multi state schemes while having pretty simple design. So how does this all work? Inside the VM? Again, transaction is just a program, like I said, like a PDF file. So in our case it's has a little- just a little bit- of metadata. It's a program that also has a zero knowledge proof and we will show in a second how this proof applies. So what happens? When you want to verify a transaction, you instantiate a VM, and by you I mean the Danelle that verifies the transaction. It instant Chase the VM. That is completely ephemeral. It means that it's not some sort of globally running VM like a dr container, a kind of thing. It's like an instance of a

[13:00] Parser for this specific transaction, so it's very lightweight. You create it just for a single transaction. You load the transaction into this VM and it works as a simple stack machine. So it has a simple stack. It's not your incomplete, so it has a predictable performance and the goal of the VM is not only to provide you with ability to customize a conditions, but it also enforces the network rules. So the operations that excuse they are also checking that you don't duplicate money, that you respect the rules of the network and don't break that. So what the in des? It runs the program and the n as the program is running it's compiling on the fly thing that we call a constraint system, which will be used for the zero knowledge proof. So the constraint system is effectively just a list of linear and multiplicative equations that check that, for instance, the sum amount should, because some other

[14:00] Amount or should, be subject to certain formula. But the cool part is that this constraint system works in zero knowledge, meaning that those numbers in the formulas that you are manipulating- they are all- can be encrypted, and so your program can manipulate this encrypted values and require that they conform to certain formula. And, as a result of execution of the program, you will have this sort of a matrix of constraints that builds this constraint system and, after the program finished executing, then the verifier runs the serial logical flow, VM checks. The proof is correct for this constraint system, which proves that whoever knew this secret keys that encrypted those amounts correctly combined them. So if there was a smart contract saying that a couple of values must correspond to a certain

[15:00] Formula, then this- these values being secret, they're still correctly constrained by the formula. So this is the job of the zero knowledge proof and the VM does that in the end of the program execution. And finally, all the facts in the VM are fully local there, don't affect the global state. So it allows you to evaluate all the transactions independently from each other and verify in parallel. So how do we even do the effects? So all these inputs and outputs are actually recorded in the transaction log, which is simply a list of effects that should be applied to the blockchain state, and once we've run the program and verified this, your knowledge constraints- then we simply take this log, this list of effects that are effectively saying that you have to erase certain inputs and create certain outputs and then we apply them to the bot fisty. And this is very

[16:00] Lightweight operation that can not only fail if you're trying to double span: the same output twice and two different transactions and if it happens that the second transaction tries to suspend the same input, then it will fail in the very end at that application stage. But this is the only stateful operation and the system. Now, how do you instructions look like? Think of this as a Stellar operations. In Stellar transactions you have realities of operations that you could do, but they are more like a list of things that are not really working with each other. They just enumerate what you want to do in a transaction, for instance, to send money from here to there or open offer or create an account, things like that. So in a similar Berean, the key VM has instructions that are high level, well liked constellar. They did their high level operations. They don't. They are not like assembly, one

[17:00] Assembler language: low level operations that just manipulate bits, they manipulate values, they manipulate contracts, the high level concepts, but they are all composable with each other. So, for instance, you can instantiate a contract and then open it up and then take the values out of it, move them around, maybe mix and merge them together there and then lock them in a new contract. And this sequence of operations will be not just the list of them but actually manipulating those values on the stack behind the scenes. So here's an example: let's say you want to make a custom constraint, to do something about it. So you start with pushing some numerical value on the stack, instantiate a variable out of it that creates the variable inside the constraint system. Then you combine different arithmetic operations on it that, as a side effect,

[18:00] Create those constraints and without actually computing, because the value could be encrypted. And you finished those constraints by saying verify, meaning that you can pull the whole constraint it. You want to record it into the constraint system so it will be checked later. Then you can. So it looks something like this: so you have a formula and you do this kind of stack machine as syntax for multiplying, adding, checking, equality and verifying, and then, once you have this variable all verified, you can create overboard value and output in a certain place. So you say, okay, this value is correct, so I am making a payment with it. And boiler instruction is kind of cool because it's a zero interest rates boring just within the life of the VM. It gives you to balance the negative and positive. 1 and negative has to be mixed it with the proper payment coming from somewhere else, using this zero knowledge mix

[19:00] Instruction that we call cloak. It's implements, it's a whole clock protocol that allows you to mix M inputs into n outputs, preserving the assets but in complete zero knowledge. So you don't know where the asset flows within the boundaries of transaction. So these instructions gonna show you how you can combine the value of flow with custom conditions. And the important part is that this is all imperative, meaning that all the contracts they do not have kind of declarative conditions but they incredibly do things that they want to be done with linear types that cannot be simply dropped or created out of nowhere or duplicated. So entire clasts of security vulnerabilities are eliminated versus the access control lists always have this problem where you have hard time combining the different clock rolls

[20:00] Together. Here it's very imperative, and Lear types help greatly by just literally moving the valley where it needs to be moved and then make sure that you don't break the rules along the way. So this is very powerful but at the same time, very safe system. So I'll say a couple of words about cryptography so can make it all work. It's important to have, on one hand, fancy cryptography but at the same time, pretty conservative one. So we have this stack of the high performance curve to 5519 implementation, on top of which we have the safe cryptographic group, the, which would build a bulletproof system, and that allows us to do this custom constraints. And we use the blue person two ways. In one way it's a cloud product call that enforces the network rules that mean that you cannot duplicate money and at the same time it allows you

[21:00] To do on the fly custom constraints. And this is cool because many other 0no systems, like Z cash, they, do not allow you to do on the fly conditions. Instead, they use a very complicated trusted setup where several priorities must decide the rules and compute some crunch numbers in order to compose a single solid constraint system that will be used for all the purposes of the network for one time. And bulletproof allows us to avoid this trusted set up and instead build the constraints on the fly every time the transaction is running, because this is so fast and lightweight. And finally, if you provide the interface to all of that, we have these easy KVM instructions, and then, on top with you, using these instructions, this is where you build your applications, and this whole stack that we have is written in POS. So everything is very neatly compiled and one, first of all, hassles in an API, is in

[22:00] Between two layers, and then it's compiled without any overhead in a while. Finally, efficient binary, just like you would have with C++, for instance. So another cool thing is that the DMA operations in the KDM are designed to be either cheap or expensive, which is funny, but the point here is that the chip operations are very cheap- it's really like a parser- and all expensive operations are completely uniform- a scalar point, multiplications in this cryptographic group, and this means that they can all be deferred and done in a batch, which makes them much faster. So, effectively, what you have is you have a very quick run of the program, then you have a bunch of things to compute in a cryptographic group that you can batch together and do very efficiently. Later you can even imagine doing that. And in GPU, if you have to verify a lot of

[23:00] Transactions and then you have an answer where the transaction is valid enough. So this gives us very low educational agency. For the features that we have. It's less than one millisecond per output, so effectively, like lesson no, second for payment, or more like Costas begins, maybe like two milliseconds per payment, because payment Nelson always have them change out but, and we use all opportunities to prove performance that we can. So if you have multiple signatures they all can be aggregated and then batch verified and transaction size is pretty distant, so it's like one 1 2 to 2 kilobytes and this growth slow very quickly. So if multiple parties join together they greatly optimize the total cost of the network. And so a couple of examples to how you can build something with this. So one is the basic payments. So the cool part is things like accounts and balances. They are all off

[24:00] Chain concepts. As to the basic network on the season, it's an APIs and all the interesting kind of data wrangling. It happens I've seen that provide security for the people involved in, for the party stress of acting and greatly improved performance because there is a lot of can, a complicated decision making is completely taken out of the consensus critter parts and placed inside their application. This also allows you to innovate faster because you can do different protocols and try different versions of like payment channels or be famous protocols completely outside of the can a consensus critical part. So you don't you have to only upgrade the knows that care about this feature and not the entire network. So the orderbook is an interesting example of smart contract. So

[25:00] It's simply a contract that allows you to unlock the value being offered for a price. So this is where you use the predicate. I can pack several conditions inside the predicate and the cool thing about the zero knowledge is that you can do this both and public. So it's like Stellar, like completely public offer and there's no nothing secret going on, but you can still do this kind of semi public. So if you have a pool that wants to be kind, forced on the network and be auditable by authorized parties, but you don't want to do publicize exact prices and exact assets that are being offered, then you can also do that as well, because all these formulas work on the encrypted values as well and you can notice that this contract allows you to do imperative description of the conditions that you want to do. So you check that certain quantity and the

[26:00] Price is moved to certain address and then you unlock the asset that you have. You never I have to do this in a passive- checks that whatever is provided or whatever like feature on that transaction object is set or some flag the set versus. In Bitcoin there is very complicated kind of hashing flags, so there's none of those things. You can empirically just do the things that I have to happen and then if there are some kind of negative amounts left on the stack in DBM, then the user has to provide appropriate amount of payment to cover them. And finally, payment channels is a nice example that shows you how to do complicated state machines. In this model where you don't have global programmable states, like in Assyrian supima channel, natural is a state machine between two parties that can do payments without settling them on the network and the only thing that network sees is that the initially deposit some

[27:00] Money, in that they closed the channel at some point later, but all the intermediate movements of the money are not visible, but still they have to provide some assurances to the parties involved. So how does it work? If the one party becomes unresponsive, then the latest signed agreement could be used as a way to exit the channel and settle by another party unilaterally. So this state machine is implemented on top of transactions, so the states are embedded in those contracts and transitions are the transaction objects in themselves, which is pretty natural. It's just the intermediate assigned transactions. They are not published until you want to exit the channel. So this is how it looks in this model of inputs and outputs and transactions. Finally, to kind of wrap it up a little compressor with all the designs and then we can proceed to the questions. So it's

[28:00] Kind of like a setting for discussion leader. So if you compare the design of the KTM, it's always very different but is founded on similar principles. So it's multi asset environment for modern financial protocols and the specific difference is that the data and asset values are confidential, encrypted, by default. You can, of course, make them public if you want to do any sort of conditional or conditional disclosure schemes, if you need some audit. The concept of accounts is completely off-chain and the verification of transaction is largely stateless and your mechanism for customization is this: composable instructions instead of just enumeration of kind of thicker, higher level operations. And another important

[29:00] Difference is that the orderbook logic installer is built in and has some kind of stateful conditions that will allow were more interesting kind of multi party map price assurances. In the KVM there is no such. Build the open concept, you can build all sorts of orderbooks on top of the system yourself, depending on like how complicated he wanted to do to be. Compared to the Syrian atrium is also a design for the customization and smart con metrics, but the model is quite different. The etherium is sort of like a global state machine with a lot of code and like libraries of code that can call each other and do a lot of stateful changes. In the KVM all the changes are isolated and limited to this creation and deletion of the outputs. And another important part is that the KVM is not cheering complete by design. So it really

[30:00] Acts more like a parser and allows just as little composition between the instructions in data as necessary to create ease for financial operations, but not to just program whatever. And the assets are first class types that you can move directly around instead of being some entries and a miniature bank that you have to program inside your program, inside the serial. So this makes the whole design much more easy to reason about because you don't have to win vent a little ledger inside the ledger every time you want to create a new asset. And finally, education Manero. They they're heavily focused on the privacy and they provide some cool non interactive obfuscation of the transaction graph, which the key DM does not provide, but you can still do this with teams like pointer, and so when multiple people join multiple inputs to one transaction, then they can sort of

[31:00] Mix them. But Cillian provides you with the ability to have customization in contracts where easy cash, Tamara doesn't have any, and still even have the confidential computation within those contracts and finally, the occasional manera, have single assets and to kvms design for multiple asses. So, as a summary, what we're having here is this experiment in combining customization, confidentiality and scalability features in a single project and using two to the optimal degree: all the latest inventions in the blockchain space, where we have reasonably innovative cryptography and but still trying to be on a conservative side and trying to make things very scalable and high performance and, you

[32:00] Know, obviously pushing as much as possible to the kind of chain application to design so we can innovate faster and have the core consensus critical parts as simple as possible. So that's all I got for my talk today, and then we can transition to questions. You can check out the demo at the idioms: demo Dostal org and there is a star slash slingshot repository on GitHub where all the discussion and design work is happening daily. Thank you,

[33:00] Oh yeah, so we received some questions. So the first question is: can the gibeom law to be applied to the Stellar blockchain or is it a separate sidechain? The deviant watching is entirely separate system that can work as a side chain, or it can work complementary, like it can work as a side chain. Complementary reaches dollars, so you could have a set of validators overlapping both systems and using the same Stellar consensus protocol. So we can operate in parallel and we have some thoughts on how to do the import export mechanism for their Stellar asses from the main chain into the GK VM side chain at the same time, and the similar mechanism can be used for the Zika VM in private setting. Let's say, you have a organization where you need a robust

[34:00] Internal ledger that is cryptographic, assured and limits the information exposure, and you would like to use it internally but also interoperate with Stellar. So that's also a good idea, because then you can protect your internal data from your own system administrators and your IT department. So you can more precisely specify who sees what information if you run their thus giving and blocking, just as your internal private letter. The question is: a Kinney build an automated node for collateralized loan. How would you invoke locking for deposits, and is there an up code, or do you require an operator in between? So this is a cool question because collateralized loan is one of those things that teaching naturally build

[35:00] With the KVM instruction set so you could make an agreement that the person who receives the creditor receives the money if they lock some digital asset as collateral and this lock will have a custom predicate that allows you to take it out of, allows that, sorry, I lost the creditor to take out the loan after some time out, and also allows the person who takes it takes the loan to unlock the collateral, provided they make a payment and the contract, the predicate of the contract, will have a provision area formula to check that the payment was done, including whatever required interest rate before the tenant. So this scheme requires you to build a

[36:00] Little bit of this kind of smart contractor program to embed in a transaction and build some infrastructure around to kind of support it and the Wallis to use this feature, but then it provides both parties good security against each other. They can simply unlock the de collateral with mutual agreement, but if they disagree or don't cooperate, then each party has the clause that protects them from another. So the creditor is assured that after a timeout they can simply take the collateral salt in the market and the debtor is assured that they don't need to cooperate with a creditor. They can simply take back the lawn to take back the cloud or, provided the payout alone, to pre predefined address, and so that's a perfect example for the use of the KVM and you don't need any third party to intermediate. Ease these

[37:00] Elections was fully like just to parties and without any trusted third party. To your medium, I was able to provide a timeline for when he expects to get him to be fully complete and live on Stellar. So that's a trick question because, like the GBM itself was pretty complete. What's required, which is a canal, like annoying engineering problem, is to build this kind of blockchain, kinda networking infrastructure around it so you could integrate it just with the kind of networking nodes which is an ongoing problem right now with. We have the blockchain state machine, we have the peer to peer network components, but there is also, you know, also kind of wearing the right packaging. You have a node with the UI stuff and things like that, but also there is the integration

[38:00] With the installer consensus protocol and integration with the Stellar assets. There are two separate problems so far. I would like to have an assistant as possible, but we're kind of getting out of the stage where we have to build something within this gonna slingshot project and now it's, you know, in the last, in the ongoing wakes, we're going to really face the problem of integrating where the Stellar consensus protocol and with a Horizon and with like input of the assets. So we're working on the roadmap for this right now. So this require not just kind of work on the project itself, but more like an integration work and working with more or engineers on the store in a broader,

[39:00] Taller side. So the roadmap isn't being in development right now. We have any more questions? Well, thanks everyone for joining us today. We're glad you've watched this livestream and if you would like to participate in a project and I have questions, would like to integrate things with your applications, then please find the GitHub repository, which is a Stellar slash slingshot, and I would

[40:00] Be glad to see your issues or pull requests. Thank you so much.

</details>

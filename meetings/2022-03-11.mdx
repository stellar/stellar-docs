---
title: "Create Innovative NFTs on Stellar with JavaScript"
description: "Hands-on workshop covering how to design, mint, and trade innovative NFTs on Stellar using JavaScript, with a focus on composable NFTs, royalty enforcement, and Stellar-native primitives."
authors: [anke-liu, kalepail]
tags: [community]
---

import YouTube from "@site/src/components/YouTube";

<YouTube ID="v576JFBuwFU" />

This developer workshop walks through how NFTs can be built on Stellar using JavaScript, focusing on practical architecture rather than hype. Speakers explain how Stellar’s account model, authorization controls, and transaction composition enable programmable NFT experiences such as enforced royalties and conditional transfers.

The session combines conceptual grounding (what NFTs are, how they differ from fungible assets, and why smart contracts matter) with a detailed, end-to-end technical demo. Developers are shown how to mint NFTs, attach IPFS metadata, control asset behavior via authorization servers, and implement royalty payments that persist across secondary sales.

### Key Topics

- Overview of NFTs as programmable, non-fungible assets and how smart contracts drive on-chain experiences
- Why Stellar is well-suited for NFTs (low fees, fast settlement, accessibility, and built-in DEX)
- Stellar-specific primitives: accounts, trustlines, Horizon API, asset authorization, and sponsorship
- Anatomy of a Stellar NFT: issuing account, IPFS-hosted metadata, and transfer controls
- Building “innovative NFTs” by combining NFTs with custom transaction logic
- Live walkthrough of a JavaScript project that:
  - Mints NFTs on Stellar testnet
  - Stores metadata via IPFS
  - Enforces royalty payments on every resale
  - Uses an authorization server to control asset behavior
- Practical discussion of decentralization trade-offs and future paths (Turrets, upcoming on-chain smart contracts)

### Resources

- [Stellar NFT Hackathon on Devpost](https://stellarnft.devpost.com)
- [Stellar Horizon API Documentation](/docs/data/apis)
- [Stellar JavaScript SDK](/docs/tools/sdks)
- [Lightmint NFT Marketplace on Stellar](https://lightmint.io)
- [InterPlanetary File System (IPFS)](https://ipfs.tech)

<details>
  <summary>Video Transcript</summary>

[01:00] All right, let me know when those streams live. All right, hello all. Thank you so much for coming and also thank you for bearing with us. We had a few technical difficulties, but we're able to get it started shortly, you know. Welcome everyone to the workshop. My name is Anke Liu, I'm a program manager at the Stellar Development Foundation and I'll kick off today's workshop and this weekend's hackathon. You must know me from the many emails I've sent you over the past few days with the result of you either being here in person or watching virtually

[02:00] And like. So, again, thanks all for coming, and let's start off a little bit about SDF. So the Stellar Development Foundation, or SDF for short, is a non-profit organization founded in 2014 to support the development and growth of the open source Stellar network and, with seller, stf seeks to unlock the world's economic potential by making money more fluid, markets more open and people more empowered. The foundation helps Stellar maintain Stellar's code base, supports the technical and business communities around Stellar and provides thought leadership to regulators and other stakeholders. So what is this network that we're looking to support? Stellar is an open source blockchain network with the goal to provide financial infrastructure that's fast, cost effective, resilient and, most importantly, available and accessible to anyone,

[03:00] Regardless of where they live, and this is really important. Individual payment schemes are currently not interoperable in the traditional financial system and this leads to high fees and delays, especially when transferring value, and it's also inequitable, as it excludes billions of people who currently do not have access to traditional financial services. Blockchain technology is challenging us to think about money and value in a new way, presenting the opportunity to make it better, more effective and more efficient. Its use cases go far beyond just investing in cryptocurrencies and, in much the same way that the internet democratized access to information, Stellar uses blockchain to democratize access to the financial system and it can make sending value around the world as easy as sending an email. Stellar was founded in 2014 after bitcoin. Stellar

[04:00] Was founded in 2014 after bitcoin and Ethereum- oh sorry, I think my mic had some of my hair- and handles millions of transactions each day submitted by businesses, banks, governments and developers like yourselves, all over the world to build innovative financial products and services. To date, there are over 90 2000 unique assets issued on Stellar and there are over 6 million accounts in existence and in 2021 alone, the network processed over two billion operations, from which 155 million are payments, and this shows really that the network is built to scale and is actively used. And a Stellar is an energy efficient syncing mechanism specifically designed for remittances and payments. Transactions are processed within seconds and cost way less than a penny. So what can you actually do with Stellar? On

[05:00] Stellar, you can issue your own assets as tokens on the network- think stablecoins like uscc, cryptocurrencies, real estate and, of course, nfds- practically anything. Then you can also trade these tokens peer to peer using a built in decentralized exchange or the recently added automatic market maker functionality. You can also transform currency as you send it, which is a powerful feature for cross border payments. But let's get back to why you're all here today: the Stellar NFT hackathon. As the main sponsors of this year's south by southwest financial 3 0 summit, the Stellar Development Foundation is sponsoring a 48 hour hybrid hackathon starting right now that challenges the experience and newcomers alike to build a project on Stellar that incorporates the use of NFTs. So we have ten thousand dollars worth in prizes,

[06:00] Worth of excellent prizes, excellent Stellar's native currency, and these prizes will be awarded to the best implementations of the following challenges that combine the best of art and technology. So let's start with the artist challenge. So first up, we have the Stellar NFT artist challenge, where you will create art based on a prompt and mint it as an NFT enlightenment, which is an NFT marketplace on Stellar. And so the art prompt that we'll use for this challenge will embody the spirit of the metaverse. So there is a very different, many interpretations to what the metaverse actually looks like. So we encourage you to explore your inner artists and create an image, video or audio file that reflect your version of the metaphors, in whatever form it takes. Awards for the most stunning NFTs will be willow win awards totaling fifteen hundred dollars worth of XLM allocated by the Stellar dev and NFT community, and

[07:00] To participate in this particular challenge you can scan the qr code or enter bit li Stellar NFT artist and register. But, more relevant to this workshop, we have the Stellar NFT wizard challenge, where you will build innovative NFT experiences on Stellar, go beyond just buying and selling and explore how these composable NFTs open up opportunities for you as a developer. Prices totaling 8500 worth dollars worth of XLM will be awarded to the most interesting implementations. So to all of you watching right now, head over to stellarnft devpost com and make sure to register today. The deadline for both of these challenges is sunday, March 13th, at 2: 30 p m central time. So go out there and build something awesome. And all communications will be in the Stellar developer Discord, including the live chat for today's workshop. So definitely

[08:00] I recommend, if you want to, definitely any questions, please scan the link or head over to the steli developer Discord and ask your questions in the workshop live chat. And all of the virtual identities and in personalities should have received an email with that link as well. So if you're not able to scan it, please look it up in your email. And now I leave this up for a bit while- I give the word to Tyler to actually start our NFT workshop. All

[09:00] Right, I will add my welcome. Thank you all so much for attending. Thanks for your patience while we got ourselves settled. We're here to talk about. NFTs are an incredible economic innovation being developed on the blockchain, but, as with any innovation, there's a lot of funk mixed in with the fresh. It's my aim today to focus on some of the interesting use cases for NFTs made possible by the incredible technical functionality of the blockchain they're built on, specifically the Stellar blockchain. But who am I? My name is Tyler van der Hoeven and I lead ecosystem engineering at the Stellar Development Foundation. I've been at the SDF for just over two years, but have been building on the Stellar stack for almost six years now.

[10:00] I've built many various production and experimental products on Stellar, everything from games and developer tooling to educational resources and funding programs. Stellar is a vibrant and expressive tech stack able to handle an incredibly diverse scope of financial use cases. Before we get into the meat of the talk, I'm going to quickly call out our Stellar developer Discord server as well and ensure that everyone has a chance to join that. Myself and the rest of the DevRel team will be hanging out there this weekend to answer questions and help you as you continue your exciting journey into Stellar. And once you join that Discord, the server you're going to want to look for is the workshop live channel for entering your qa. We're going to have a couple of sessions for Q&A today. So if you're in that Discord server, if you have, as you have, questions, enter those into that Discord server so we can get to those questions later on

[11:00] During our Q&A. All right, let's talk road map. Where are we headed today? What will we be covering? Our talk is going to be divided into three main sections. We're going to talk about kind of the theory and background, NFT's explained, talk about NFTs more specifically on the Stellar blockchain, and then finally we'll have a break in there and then finally we'll come back to actually create an innovative Stellar NFT. So we'll get into the codes. So firstly we'll dive into NFTs- explain more generally. So we'll define some terminology. Then we'll cover some basic technical underpinnings of NFTs with a specific aim of ensuring that we lead with the tech of NFTs and not the hype. This is a cart and horse scenario- and we must ensure the order is correct- or will end up in the funk arena of NFTs, and that is not where you want to be. Finally, we'll spend a little time covering a specific use case involving creator economies. This

[12:00] Is an area I believe is ripe for. This and upset. So, as you're thinking through in your heads, what might I build with NFTs, or what should I produce for this hackathon or even looking beyond, this is an area that I'm particularly interested in. The goal here simply to properly orient our basic understanding of NFTs as technology, first before use case, and then to hopefully ignite some excitement for what the proper orientation will then allow us to build. Next, in section two of our talk, we'll pivot our attention to observing NFTs on the Stellar blockchain. We'll cover some basic Stellar terminology to ensure we don't get too lost in the woods of mumbo jumbo. From there we'll take a closer look more specifically at the Stellar chain itself and its unique benefits as the host chain for your NFT initiatives. Next we'll, finally, we'll spend some time dissecting an actual NFT: live on the Stellar blockchain, observe its anatomy, it's technical composition. Finally, we'll end this section,

[13:00] The second section here- actually playing around with the project that we're going to be building later on, after the break. The goal here to make a convincing argument for Stellar is your chain of choice for your next NFT project, and to crack the door on what they might actually look like in practice. After this, we'll have some time for some questions and then we'll move into a bit of a break. Finally, we'll come back for section three. After the break. We'll come back, start working on our project. For the afternoon we'll actually dive into the code covering the layout and design constraints, criteria of our project, to ensure that we're all on the same page for what we'll actually be building. Then we'll dive right into the code as I'll walk us through the repo that I've constructed for this project. It'll be a guided tour, if you will, through the wonderful world of innovative NFTs on Stellar. Finally, of course, we'll end with a with that repo and a website where you can all clone that and play around yourselves in the hopes that project will serve

[14:00] As a good launch pad for your own innovative NFT projects. All right, NFTs explained, let's cover some terminology. There's really only three main terms that I feel like we really need to define at the outset, terms that, regardless of whether or not you agree with me or not, are fundamental to our understanding of the construction and utility of NFTs, and these terms are fungible, non fungible and smart contracts. We won't spend a lot of time believering these terms. I'm just going to define them for the context of this talk and then move on. So first, fungible: fungibility is the defining characteristic of an asset able to be divided and interchanged indistinguishably from other units of that same asset. So you can think about it like drinking from a glass of water. You can sip more or less water, but it's all just water. Each drop is indistinguishable, identical, equal to every other drop in the glass. This

[15:00] Is traditional. This is like traditional currency. So dollars, dimes, pennies, it's just money: divisible, exchangeable and identical in value. Its utility is to be an avenue of exchange for something else. It is not itself the commodity. Alternatively, you've got non fungible so non fungibility is aiming to be a commodity or a collectible- remember, NFT stands for non fungible token- so an asset intended to be held and enjoyed or at least to be a direct vehicle for those types of experiences. Non fungible assets achieve this in their nature as indivisible assets, where each one is a whole on its own, distinguishable and unique. Where fungible assets behave like water, non fungible assets behave more like tickets, both opening access to experiences and each one being unique at some level. Even as there may be tickets to the same experience, each one may be for like a different seat. Finally,

[16:00] That brings us to smart contracts, the final essential term in the, this sort of trifecta of NFTs more generally, and this I define as a decentralized computer function controlling cryptographic accounts. This is the experience engine of our NFT. NFTs are the ticket unlocking the experiences as defined by these smart contracts. This is where all of the innovation lies in our work on NFTs. This is where we begin to do things others could only dream and hope for in previous generations. What blockchain gives us is decentralized cryptographic computer functions. Is this ability to unlock an entirely new way to interact and transact within our communities? Let's dive into that a little more. So NFTs: let's talk about NFTs explained. We start at the fundamental, foundational layer. This is the programmable,

[17:00] Contractible, decentralized ticket concept. We can move safely and powerful, into a new realm of behaviors, so asking questions which must always return consistent results. These aren't necessarily new questions, but they've never been decentralized and assured to be consistent. Before, there was always some third party entity in the middle able to alter state, change the narrative, disrupt the experience. What NFTs give us is a tech stack on which to build consistent, programmable experiences without disinterested or potentially or eventually, nefarious middlemen, and this is a revolutionary concept and I really want to. I really want it to sink in. And it's tough, because nowhere else in our world do we operate like this. Absolutely every internet interaction that we have today operates on fluid fundamentals. Prices change, fees change, morals change, availability changes, culture and ease of access change. Nothing

[18:00] Is consistent, but math is. Computer. Programs are smart contracts on chain are. Tie that to internet experiences and you've just changed for the better. Every online interaction for everyone, everywhere, instantly. No, if you're not getting it yet, let's look into an example: modern creator economies. So consider all the big social media platforms of our day: instagram, facebook, tick tock, youtube, etsy, spotify, twitch, the app stores- these are all the way that we entertain ourselves today. These are the platforms where creators get paid. It's where audiences pay to enjoy the art and creativity of their fellow humans. It's a wonderful thing that these platforms exist, but there's one singular, fundamental flaw: the platforms are fluid. There's no consistency or guarantee. The only thing that you can be sure of as a creator and consumer, is that middlemen will squeeze out

[19:00] Maximum profit margins between your money in and the creator's paycheck out. It's unfortunate, but now, thanks to blockchain and NFTs, it's unnecessary. The programming, the contracts that run these platforms could and should be run on chain. Wherever the transfer of value is involved, consistency can and should be added to ensure the link between creators and fans is as close to peer as possible and then all decentralized, and all of it decentralized such that no single third party can alter the fees, shut down the content and suck as much life out of the experience as possible. So alternatively to that, what we have today, let's consider enlightenment, a decentralized NFT marketplace. On Stellar, which we'll observe in use in a bit, the essential monetary transaction programming is all running directly on chain enlightenment, the visual interface has been disassociated from the monetary compensation model. Artists and fans can connect

[20:00] Directly via on chain NFT data. There's a world of work to be done beyond just marketplaces, though. We really need to move away from just curation and discovery to deeper connections and interactions with those we already enjoy and appreciate. So I really consider this to be a greenfield space for innovation and an entirely new way of looking at creator economies. It's really a creator micro economy where interactions and experiences are much smaller and more catered directly between artists and fans- living room jam sessions kind of- versus just another picture and an endless feed of content. NFTs allow for this. We just need to build for it. So this brings us to our second section, where we move away from NFTs more generally and begin to look specifically at Stellar. So, just like NFTs more generally, there are some terminologies, some terms that we should be familiar with before jumping into to Stellar more deeply. First is core

[21:00] Is the fundamental software Stellar validators used to run the Stellar blockchain. All the features and functions describing what Stellar can and cannot do live here in the core program that is Stellar. Next Horizon, the api access point unpacking core data into a collection of usable json endpoints for clients to connect with, both on the browser and on the server for the applications we'll build on Stellar. Most of your interactions when you're building Stellar applications will be interacting with Horizon at some level. Another one that you'll see pop up a lot- we talked about just a moment ago- is lightmint. This is our premier nfc marketplace, which is pioneering NFT best practices for the Stellar ecosystem. Another one is ipfs interplanetary file system. It's the de facto decentralized NFT metadata database. So it's not a Stellar technology, but it is one that we can easily integrate

[22:00] With when constructing our Stellar NFTs. That's one you're going to see popping up a lot. Finally, trust lines: this is a Stellar specific technology. These are assets. So trust lines are assets on Stellar. They exist as trust lines. For an asset to exist, a holder must first opt in by creating a trust line to the assets issuing account. This is accomplished via a change trust operation, which we'll observe later on when we dive into our project. So these are terminologies you're going to see popping up a lot in different documentation, and we'll cover some of these in more detail later on. Next, why build on Stellar? There are many reasons you might choose to build on Stellar, not least of which are things like Stellar being fast, accessible, affordable, lean, secure, scalable, compliance, friendly and reliable. However, of all these significant benefits, there's one often unsung hero in this entourage of excellence that I would

[23:00] Really like to highlight, and that is that Stellar is equitable. Stellar is a purpose built blockchain on a mission to become the global payment standard, and at the floor of this objective is the fundamental technical requirement that Stellar maintain accessibility. The only way to become a global payment standard is if everyone in the world is able to access and benefit from the chain. From this foundation of accessibility comes reliability, but I don't really mean- or I don't just mean- that the network stays up. I more primarily mean the reliability that comes from the actual governance structure of the Stellar chain. Blockchains are expensive and validators shoulder that cost- the node's running the core software and actually providing the decentralization of our network. In most other chains, the compensation for this service is provided in the form of transaction fees, where validators are paid by the network for running the network.

[24:00] It's a reasonable model, but it has one glaring flaw in that now validators are directly incentivized to ensure the network is maximizing their profit returns for running the network versus using the network. So in this world, high fees and inefficiencies are a good thing for validators. On Stellar, this struggle is nowhere to be seen because the network validators have the same incentives as the users they derive profit from their own projects using Stellar, versus those validators actually running Stellar. Validators are not paid by Stellar. They are paid same as you to build profitable businesses on the network. This fosters a network of low fees and innovation for improving network efficiencies. When we all make money the same way, we're all aligned on the same mission. We have a recipe for consistent, reliable and an accessible network, for building long term legitimate, profitable businesses. Finally,

[25:00] Let's move away from theory to some practice. What does an NFT on instiller actually look like. What are the components necessary to pull one off? There are three primary components: an NFT issuing account, the NFT metadata or the link to the asset. And then there are there's NFT issuing criteria or the smart contract, things like timed auctions. The royalty payments will be building today. Also things like holder restrictions if you have different controls on your asset. I'm going to walk through the anatomy of an NFT on Stellar quickly, so we're going to jump off of our slides for a moment. So this is over. On lightmint, this is one of my NFT projects that I built way back when I was getting started. It's just a very simple algorithmic created

[26:00] Pixel glyph. There's some neural network that's running. You can see, did a little phrase and it'll build you an interesting NFT. So it exists as an image, a title description. It's got some tags and stuff. If we scroll down here to our details, you can see the ipfs hash right here which would hold. If we were to click on that. it would pull up an actual json file. This is a kind of standard way of describing an NFT from an ipfs hash. So it's got that title description, an image link. If we were to actually open up that image link, you can see the picture here on ipfs, if we open up the actual asset on Stellar- so I'm going to open up StellarExpert, which is a blockchain explorer for Stellar- you can see the asset right here. We've got our issuing accounts kind of hidden behind this, our issuing account. Right here you can see that ipfs hash that's been associated

[27:00] With our issuing account. So a Stellar account issues the NFT. Other users can then open up a trust line for that asset, at which point the NFT can move to that account whenever it's sold. There's a couple other pieces of information here. If you scroll down you can see some of the history of the NFT, some different operations for when it was bought and sold. We've already mentioned the ipfs hash. There you've got that asset code but all kind of going back to that original issuing account and then when you're on lightmint, it's just providing this visual interface to something that exists on chain. So if lightman were to go down. You could very easily spin up some other interface and begin using Horizon to pull in that information, to pull in that data and show the NFT again. So

[28:00] That particular NFT is really primarily it just deals in those first two elements: an NFT issuing account and the metadata. The issuing criteria or smart contract ability of the NFT when interacting directly on the sterile will be somewhat limiting in that particular scenario. You have the native Stellar DEX for buying and selling NFTs, but that's about it. If you want to add more conditions to the experience of your NFT, you'll need to look beyond these vanilla NFTs and move into the realm of what I'm calling innovative NFTs, where you combine arbitrary smart contract logic with this basic issuing account and stored metadata. For that we turn to a project that I launched in fall last year. So NFT klpl com I've got a couple of innovative

[29:00] Smart NFTs that I've built. We'll go ahead and take a look at that. I'm going to switch over here again. So I've got a few of them. I became interested in NFTs background August of last year and began just kind of poking around at what they were, what you could do with them, quickly kind of got bored of just making art and putting it on chain and wanted to do something a little different, more interesting, more programmed, and that's where smart nfcs came from. The one that we're going to look at today is called the dig. I've only done three of these, but they're all quite different. So I leave it to you to explore the rest of those. But if we look at the dig, this is a, an NFT experience. So it's like a social experiment experience. NFT. It's this singular NFT. That's this pixel grid, 40 by 40 pixels, and the way that you interact with it is actually by purchasing individual pixels off

[30:00] Of the grid, so users will come in off pick, they kind of use the interface to poke a couple of pixels, the ones that they want to buy, and then, as this pic, as this NFT kind of, becomes minted as it gets, as a as these plot tokens is what they're called- get purchased, you get closer and closer to the final NFT. You can see right here we've actually got a few left, so the final NFT hasn't actually minted yet does look like they've kind of uncovered the wizard in the middle. So the secret's been revealed, I guess, if I were to log in with my albedo account, which is one of our- if you've ever used metamask, this is kind of similar- you can see my plot token that I purchased somewhere down in here. So there's a couple of different things going on in this particular smart NFT or innovative NFT, and

[31:00] That is that there is an NFT that, and be minted, but only after certain conditions have been met, and in this case there are two. First, all of the pixels have to be minted for this final NFT to be minted, and then, second, if you actually want to get this final NFT, you have to hold one of these plot tokens. So only plot token holders, only people who participated in the dig, will actually be eligible to hold or claim this final NFT. And so you kind of set up this arbitrary logic within your smart contract which create this interesting experience for an NFT. If you go and read our drop document here you can see I've outlined all of the different criteria. You know what's going on for this NFT, the different operations within the command. If you go and look at, there's a guest that has the actual code for the smart contract. There's actually three different commands in this single smart contract: one

[32:00] For digging up plot tokens, one for minting, which you can't actually run yet because the NFT hasn't been fully dug, and then there'll be another one that'll open up as well once the mint command has been run, where you can issue yourself for free, essentially, that final NFT. If you hold a plot token, so you can go through these different functions here that actually provide the criteria under which those individual commands can actually be run. So, again, I've done a couple of these. They've all been a lot of fun. To really start to explore what can we do beyond just putting art on chain. You can build these little microcosmic experiences, these little games where, yes, it might be pretty focused, there may not be millions of people that interact with this, but you don't need that if you can build something interesting and something focused, you can get your small community, your people,

[33:00] To get engaged with the content that you're generating without having to go through any specific third party next. So that's the kalepail collection. It's quite fancy, but it's a little bit too deep for our first stab at an innovative NFT for our time here this afternoon. For that. We're finally going to turn to the afternoon's task at hand, and that's the project that we'll be covering today: an innovative royalty payments NFT project. So I'm going to walk through this real quick before we have some questions again. If you've got questions, make sure you're in that Discord, pop those into the chat. We'll answer those in just a moment, but I'm going to walk through the project that we're actually going to be building today. So this is a royalty payments NFT project. So

[34:00] I've got an account over in our gorgeous interface. I've got a user account that I've generated. So this is going to be the original minting account for the NFT or the NFTs that this account mints. If you remember, each NFT has its own issuing account. So we're going to go ahead and generate a brand new issuing account which will be the host of our new NFT that we're about to mint. The next thing we're going to need is an ipfs hash, and I'm using NFT storage to host my NFTs, the images, and I've gone ahead and uploaded one here. I'm gonna grab that. We've got our new issuing account right here funded. We'll put in this ipfs hash and then we'll click mint and when we do that ipfs hash will be attached to the issuing account that we just generated up above, kind of bundling it all together and then issuing my user account this

[35:00] Brand new NFT. So we'll go ahead and do that and this is actually happening right now on chain. All of these NFTs are actually going on to. It's right now the Stellar test net, but we've actually literally gone and minted a brand new NFT on the Stellar test net. So there it is. That's my NFT. I'm going to go ahead and sell this. I'm going to sell it for 100 XLM. You'll remember that we're actually adding a 10 royalty. So what's 10 of 100? It's 10. So this NFT will actually be being sold for 110 XLM. If we go and open up an alternative browser here, I'm going to pull this over. I'm also going to open up browsers

[36:00] To work with. Let's go ahead and refresh this. We should see that NFT available for sale right there. We can see those NFTs available to purchase. I'm going to go ahead and buy this one. So this is: we will go down 110 here and we should go up 110 for the account that actually owns it. So we'll make that purchase over on this page. We're able to sell it now because we're the owner. If we refresh this browser over here- and I'm actually just going to shrink this down for a moment- we can see that now has 110. If we sell this, let's say we'll do 50. They're going to sell their XLM at a loss bummer, and then we'll refresh this page. We'll should see 55, because it's the 50 plus the five for the 10 royalty. And

[37:00] If we buy this, what should happen? This account should receive 50 and this account should actually receive five, because the royalty payment is going from the purchase here, where five goes over to the original minter as a royalty payment and then 50 goes to the user who's actually selling. So we should see this go up by 50 and this one should go to 10: 1: 5. And that's exactly what happened. So our contract is working. The NFT is actually being able to, it's being sold between these two accounts, interacting directly with each other, not involving the minting account at all, and yet this account is consistently receiving its royalty payments as the NFT is sold by other users. So this is what we're going to be building today, after a little bit of Q&A. So if you're interested, excited, intrigued, I know I am, I

[38:00] Know I am, but before we go to that, we're gonna. We've kind of gotten a taste, we've gotten a nice overlook of NFTs in general, NFTs on Stellar. We'll take a quick moment for some Q&A off of our Discord server. We'll take a break for about 15 minutes or so and then we'll come back for our afternoon of actually looking at, the programming, looking at the code. All right, do we have questions off of Discord? Are we good? Let's go ahead and start? Oops, let's start with some Discord ones. Nope, no, in fact, the application we'll be building will not be fully decentralized, for

[39:00] Sake of making it a lot simpler to, for initiate. But adding decentralization isn't super difficult. So it's, but it's not required for the hackathon. Yeah, sorry. The question is: does the go? Let's go back just real quick to the first question so that I can read that off again. No, just ask me the first question again, just so I can get it for the folks on online. Does it need to be fully decentralized? So the question was: does the application, does the hackathon app, need to be fully decentralized for it to be valid? And no, it does not. It's fine if it's running centralized, so long as it's actually on Stellar. And then the second question was: do

[40:00] They need to have like a user interface for interact? There needs to be something that we can actually test and use, and building a gui is probably a really good way to do that. If you've got like api docs, that might be sufficient. But there has to be something for us to actually test and play around with. So I would say a soft yes, there needs to be something to play with. Good question, anything else? All right. Do we have any questions from the audience? Anybody have anything pressing on their mind before we move to a break? All right, perfect, we will move to a break and then come back in about 15 minutes or so and start diving into our actual project. All

[01:04:00] Right, we're gonna jump back to our seats, or you can stand, you know, if you want, all right. So who's ready to start getting into some code? Before we do, though? I've got two slides left that I want to cover about both the technical blueprint for a project, along with the relationship between how our seller NFT exists, and it's like the relationship between our seller NFT and what I'm calling the NFT auth server. So first, the design of

[01:05:00] Our NFT. So what we're going to build is an application that configures an issuing account, attaches metadata to it, issues that NFT and then finally, obviously, it will require that all sales of the NFT sends back a 10 royalty payment to the original minting account whenever the NFT is sold. Next, how we're going to build it. There's going to be a client interface. So this is the website or marketplace for our royalty payment NFT, and we're also going to build an authorization server. So that'll be that the authorization server, auth server- is a Stellar transaction builder that opens and closes authorization for our innovative NFT, ensuring that royalty payments are in fact being issued whenever the NFT is sold. So, finally, tying this all together, let's talk a little bit more about our

[01:06:00] Auth server as it relates to asset authorization controls. So there was a question about decentralization, so let's talk about that just a little bit. Seller's design includes account and trustline controls. There are a few different types of controls that assets can have, but in our case we're going to configure full control. Where an asset exists as an entirely permissioned asset, its movement, then its ability to be bought, sold and even held, is entirely under the control of the issuing account. This will allow us to insert our royalty payment logic in between some authorization operations when building Stellar transactions. So the transaction building will be taking place on our auth server. Right now, this auth server will be hosted by us, not very decentralized, but, for those taking notes, this liability can be removed right now via an ecosystem initiative called Stellar Turrets,

[01:07:00] Which takes the auth server smart contracts that we'll be building and executes them on a decentralized network of servers. Alternatively, the seller development foundation, SDF, has recently announced an exciting new initiative code named jump can it project jump canon, which will bring this auth server functionality straight to layer one. So in a word, smart contracts directly on Stellar. With our NFT design understood and the foundations of asset authorization laid, we can finally turn to our code editor to begin walking through the repo containing our innovative royalty payments project. So I'm going to switch real quick to mirror my displays so that I can code here, so

[01:08:00] Inside our project, and I'll give you the repo if you haven't already found it yet. Some of you aggressive personalities probably already found my repo. But I'm going to be walking through the repo. I'll share it with you afterwards, but try and follow with me as we walk through the project that we have. And then when you get your own version of the repo, you can kind of dive through what we've got. So we've got two different directories here. One is our client and one is our server, the client obviously

[01:09:00] Being the front end of the application and the server being the back end auth server for our application. Let's go ahead and start on the client side, so this would be the website when we load in something like our application. Not sure why, that's there we go, and so let's walk through that. I've put some comments in the most used parts of the application, so I'm not going to talk about css or html much today, so we'll go ahead and close those ones up. What I want to walk through more particularly, are the actual methods that we're using to mint an NFT and then offer or trade the NFT. so those are the two primary functions happening in our frontend

[01:10:00] Application right, where you can mint a brand new NFT and then you can offer it for sale, you can buy it. So there's really just two interactions. But the first thing, before we can even get to that minting of an NFT, is when we actually click generate for creating a new public key. So inside of methods, I've got three javascript files that I want to walk through, the first one being creating an account. So this is triggered by the buttons that you click when you generate or regenerate, kind of create a new user account, and that lives inside of this method right here. So let's walk through it. And a lot of this is like once we've covered one of these. The way that you build Stellar transactions is kind of always the same, so it'll start to feel a little bit repetitive, but that's a good thing. When we initially create an account, what we need to do is generate a brand new key pair. So 910. Here we generate a new public private key pair for Stellar and

[01:11:00] Since we're on test net, we can use- and to go ahead and create that account so that it exists on changes. Because you have a valid public private key. Fair doesn't mean that it automatically exists on chain. You need to fund it. You need to get it into a state where it exists on chain, it can begin to receive or be the issuing account for an NFT or hold NFTs. So we're using friendbot here to do that. Where we actually get some free- it's kind of like a faucet if you've ever used those before- get some free test net lumens. So we call that. Then we're going to load up the account to get its status as on chain. So after we've created it, we can then call it to load up its current state on chain. If we're clicking the button where it's just generating a new user account, we go ahead and exit out of the then statement and we just say, super duper, thanks for the new account and I'll assign it to my user. That's what happens when you click on this

[01:12:00] Generator regenerate button right here. If, however, you are actually creating a new issuing account, we need to do a little bit more. What we need to do is create the account and then we actually need to associate a brand new signer to that account. So Stellar has a multi sig built right in at layer one where you can attach multiple signers. When you initially create a public private key pair, the secret key you create for the public key- those two things are connected. When you go and fund it, that private key is what gives you access to do anything with the public key: make payments, send operations, etc. But you can also associate other private keys, other keys, to that account, where they also will have control over that account. And in our case that's what we need to do. Remember, every NFT has its own issuing account. So in your NFT project scenario you've got dozens, hundreds of individual

[01:13:00] NFTs, but each one of those needs to be controlled by this authorization server where it's kind of inserting itself in the middle saying like, oh, before you do anything, we need to make sure that if the sale is happening, that an NFT, a royalty payment, is going back to the original mentor. You can't just do whatever you want with this NFT. There's an authorization server sitting in the middle that's ensuring royalty payments go out whenever it's appropriate. And so for that check to happen, you need a signer. But rather than storing hundreds and hundreds of secret seeds in your database, we're going to attach one to every single issuing account. So every single new NFT that we mint, we're going to add this same authorization server signer that will now act as the intermediary, sort of saying: okay, I have permission to sign for this NFT anytime you're trying to do something with

[01:14:00] It. And so before that can happen, we need to add this signer to each of these new issuing accounts, and so that's what we're doing. Right here, on line 28 through 33, we're adding this new set operations operation. So right here in this block, in this if block, we're building a new transaction for the new account that we just created. We're on testnet. Here you can read a little bit more information about fees or network passphrases, and then on this transaction we're adding a single operation, and this is the set options operation, where this signer is added. This signer comes from an environment variable on the client side, which is the public key for the auth servers signer, that auth server signer again being that single signing key that will be attached to every single new NFT that's minted. So now the auth server has control over every single NFT that's being issued. Hopefully this is sending off some red flags in your mind. This is where the decentralization

[01:15:00] Piece will come in right. You don't want one account controlling every single NFT on your platform. So in the Stellar Turrets model which I mentioned before, you actually add lots of different signing keys, each holding a different weight of the threshold, right? So if the account has, let's say, a weight of 10 and each of these signers has a threshold of one. You would need 10 to agree before anything could happen with that NFT. In the on chain smart contract model, the actual account itself would be controlled by the code. There wouldn't necessarily be some signer, it would be the contract itself which would control the account. The contract would act as a signer, and so this right here. Super useful, really interesting. But this is where the decentralization piece becomes really important. If you were to try and ship this more widely, moving on, after we build our transaction, we can then get it signed and

[01:16:00] Then submit it to the network where this issuing account now has the signing key for the authorization server. At that point our account is fully ready to have NFT data associated to it and that's where api mint command comes in. So we move. After we create our account, we go to api mint. This is what comes in. Whenever you have your ipfs hash input, there will be a button for minting that will pop up. We don't want to mint until we actually have an ipfs hash. So if we actually were to click this, I don't think abc is probably a valid ipfs hash, but my check is not particularly intelligent. There's something here, and so then the mint button becomes available. That button fires off this api mint function. Inside. Here we're actually all we're doing

[01:17:00] Is calling our authorization server because we need to set up this new issuing account with the ipfs hash that we want to attach, which becomes the representation of what our nrft actually behaves as. So this we're going to look at this on the server. But this is a fetch command that's made to our auth server. We're going to pass it- the user account, the issuer account, that ipfs hash that we input, and then it's going to go to the auth server is going to make server. check, make sure everything looks fine. It's going to the out server is actually going to build the transaction. So we don't build the transaction on the client side. We want to really be sure that the transaction that's being built is exactly what we want. It's kind of the building a smart contract on the fly, if you will. So the request goes to the server will build this XDR will build this transaction, the Stellar transaction, according to whatever your smart contract logic is, and then send that

[01:18:00] Transaction back to the client for any final signatures that might be needed for that transaction to be valid. In our case, the user needs to sign it, and we'll look at why that's the case in a moment when we go to the server to see what transaction is actually being built. Finally, then, just like before, once it's signed, we can submit it to the network. At this point, I think it's probably worth actually going to the server and looking at what's going on here. There's not a lot that's going on inside of our server. We have some environment variables which actually denote those signer secrets. There's also a sponsor secret, which we'll look at in a minute, but this is the signer secret. This is the actual signing key. That will be the authority for all of the NFTs that are issued from our project. This is the signing key that will be added to any XDR in each Stellar transaction, XDR, seller transaction- same thing that will be generated from the back end of our application,

[01:19:00] From our auth server. We've got an index here, which is our router, just a very simple collection of some routes. You can see contract right here and then, based off of the command of mint or offer, it'll go here, and then there's a little switch statement: if it's a mint, it runs the mint function. If it's an offer, it runs the offer function. And those exist inside of the contracts directory. And so let's go ahead and look at our mint function here on the server, and so this is going to look kind of familiar. Remember that the Stellar SDK that we're using, this Stellar base in this case, works on both the client and the server side. So what you will build when you build transactions on the client, it'll be very similar to how you build it on a server. We go ahead and instantiate the function. Here, this mint function, we can gather our arguments. You'll notice these look very similar

[01:20:00] To what we passed in on the client side. We gather those, put them into some consts. We instantiate NFT as our asset. This is going to be the NFT asset that we're actually going to issue, that this issuing account is going to send out. It's going to be called NFT. That'll be the code for it. And then we go and make a quick fetch on Horizon itself looking up this account got to make sure that it actually exists. And then, once we pull in that information, we can begin to use that account's information so that the user account- they're going to behave as the source for any fees that are incurred when we actually submit the transaction to the network. And then, once we have that, it's time to actually begin building out our transaction. So Stellar transactions exist, kind of these envelopes that you put operations into. Transactions on Stellar are atomic, which means you can put lots of different operations into a Stellar transaction, this

[01:21:00] Kind of chain of events- and either all succeeds or it all fails together. You don't kind of have a partially successful Stellar transaction. The whole thing succeeds or fails together and this allows you to build some really complex and relational logic in your transaction you can build. You can include up to a hundred operations, so that's a lot of logic that you can include into a seller transaction and again it will all succeed or fail together. You kind of. You don't have to do this like oops, it failed. At this point now we need to like reverse, go back up the chain and undo whatever we did before. And this becomes really important when we start getting into the offer contract. Right here we've got a collection of these different operations inside of our mint contract and the first one you'll notice is set options, where we are setting flags, an inflation destination and then the source, the flags here. This is where we're actually locking down the issuing account. We're saying this asset is an authorized asset, it's a controlled asset. No one's allowed to do anything

[01:22:00] With this asset unless the issuing account permits it, unless we say so. You can look. There's a couple of different flags that you can set inside of the set options. You can look those up later. But 15- that's kind of our max. Right now we're I'm allowed to do anything. Is the issuing account I have full control over this asset. The inflation destination: Stellar used to have an inflation mechanic that was retired by the ecosystem, decided that it wasn't all that helpful. But there's still a field that exists on Stellar accounts that you I'm kind of now sub opting I'm taking it over and I'm using it to store the address for the original mentor so that when we come back in the future and we're trying to make offers, I know who am I supposed to send the royalty payment to. This is where I'm going to store that. So I'm going- I'm gonna go ahead and include it right here. The user account, the original minter. Next up we've got a manage data operation where that ipfs hash is being stored.

[01:23:00] Nothing fancy going on there. You've got a name and a value, so ipfs hash. So we know what it, what key to look for, and then the value of that. We're going to change trust. If you remember trust lines. This is where this is going to come into play. You've got, we're going to put this on the user account. Now is opening up trust for the NFT right? So the issuing account in this minting transaction is going to, the NFT is going to exist, but a user still needs to trust it. The user doesn't hold the NFT yet. The issuing account needs to send it, but it can't send it unless the user trusts it first. So that's what we're doing here in change trust. We're opening up a trust line for the NFT. Next there are trustline flags. This is where this is kind of the magic part of an authorized asset- anything that exists between the set trustline flags- authorized true and authorized false. This is kind of the. What do I want to allow that I couldn't, if this asset were not authorized. So because

[01:24:00] This is an authorized asset now, I'm allowed to insert arbitrary logic in between. In our case it's a royalty payment, so I'm trusting the user account to hold this asset. Yes, they're allowed to, and inside of this authorization I'm making a payment. I'm going to send to the NFT. now that it's trusted, I'm going to send the NFT back to the user for one NFT that they're going to hold and then I'm going to lock that asset back down immediately so they can hold the asset exists in the user account, but they're not allowed to do anything with it. They can't sell it. The only way they're going to be allowed to do anything else with this NFT is to go back to the issuing account and get some authorization to do something with it. So at this point again, because it's atomic, you kind of have this chain of logic that's going down of these different operations that are happening. We open up the trust line, we authorize it, we send the payment and then we de authorize it. So the user now has it once

[01:25:00] This transaction executes, but they can't do anything with it. Finally, then we've kind of bundle up this whole transaction into the XDR that we send back to the client. So this is where we take that transaction, we convert it. XDR is kind of like json, it's a little bit more compact, but same sort of thing where you're just taking some instructions and encoding it into a nice little package that you can send back to the client- in this case. So that is our mint method, and so at this point, once we've minted an NFT, the user holds that NFT, they can't. The original minter holds that NFT, they can't do anything with it except whatever the authorization server allows for. And the only thing in this case, in our case, that the authorization server allows for, is this api offer function. And this is where you can start to get really creative, like minting. The process

[01:26:00] That I've used for minting will kind of be the same. You need to have an authorized asset that you can now control what it's allowed to do, so that people can't just bypass your royalty payments or whatever other logic you have. But after it's been authorized, after you know that you have an asset that is off, controlled, now you can insert whatever kind of logic you want. In our case, we're going to do royalty payments. But you've seen, previously I had a whole bunch of random, arbitrary logic inserted between authorizing open and closed in different transactions. So this is where you're really going to start to look at what kind of creative, interesting things do I want to do? In my case it's royalty payments. So let's look at that when you actually go to on the client side. So we're back inside the client application. We've got this api offer method, so let's just walk through it briefly. You've

[01:27:00] Got a sell side or a buy side. So you've two things that are going to happen when you have an NFT. Either you're going to be selling it Those are the only going to be buying it. Those are the only two things you can do, and if you're, the only way you can buy it is if somebody else is selling it, and so we're going to assume that if you don't have it, that you're. If you do have it, that you're selling it, and if you don't have it, you're buying it right. So there's, it's a one of one NFT and so if it does exist out there as an offer, you're going to be trying to buy it. Otherwise, if you have it, you're going to be trying to sell it. And so here, if you're selling it, you can enter the sale price for it. I don't actually have any NFTs at the moment. I think if I go to one of my, I think this one holds it at the moment, so I can go and sell, that little modal pops up. We'll put in that hundred and then this one will be for sale and we can move into

[01:28:00] Seeing that on this page here, where we have the option to buy it. So when we sold that right, then this is the modal that popped up. We're on the buy. We were on the sell side, we configure our price, we make sure that the price is actually something valid. We need to go and find the issuing account, because that's the account that's going to hold information about who the royalty payment should be going to. It's also going to include what NFT are you selling and do you actually own it? Do you have the right to sell it? Next up, we actually call the auth server contract offers. We have mint and we also had offer. This one is offer. We've got a couple of different arguments here. You got your user account, issuer account, the offer ID. You can delete open offers, otherwise you'll be creating a brand new one. The price that you're inputting- in our case that was 100- and

[01:29:00] Then, depending on whether or not it's a buy or a sell, you're either going to be buying an NFT or you're going to be buying- I guess XLM right. So it's always going to be putting out this offer of: I want to give an NFT and receive XLM, or I want to get an NFT and give XLM. These are some of these. Things are hard coded if you wanted to get more complex and do other assets, you absolutely could. It doesn't have to be done in XLM. You can use other assets. There's loads and loads of them, as you saw previously in our example. To keep things simple, we are doing XLM for NFTs, but just be aware that it's not that difficult actually to open up access for assets other than just native XLM. Then, just like before, we're going to make that call to the auth server, everything's going to. We're going to check everything, make sure it's all legitimate. Then that auth server is going to build a transaction and send that XDR back to the client, will then sign that transaction

[01:30:00] And submit it, to sign that transaction and submit it to the network. So this point, we should actually look at that particular contract over on our server. So this is the this one. Right, here is the offer. So there's a little bit more going on here, but it's not still not that complex. Essentially, we're trying to achieve the same thing. We're trying to build an XDR which is either going to sell an NFT or buy an NFT, depending on this, the state and the requester, the actual user account that's coming in and the whether or not the that user holds or is looking to hold the NFT. So we set up some very basic checks. We get the parameters from the request, maybe some of those comments, and then what we do here- very similar to what we did before we go to the Horizon, we load up

[01:31:00] The account. The user account is going to be the source of this transaction, so they will consume any fees again for this transaction. Then we're going to look up the NFT balance for the user account. Again, this is going to be this toggle that, if you hold the NFT, you're going to be a seller. If you don't have the NFT, you're going to be a buyer. We need to make sure that the user, regardless of whether or not they're buying or selling, like you, can't do anything with an NFT if you don't hold it. Remember we need that trust line opened to be able to do anything with this NFT. So the very first thing we're going to do is check. If you don't have an NFT balance, we definitely need to open up a trust line for that. So we do that first. The next thing, again: regardless of whether you're buying or you're selling, you need permission from the auth server to do anything with this asset. And so we're going to open up that trustline flag again and say: as long as this trustline flag is open, so long as you have permission, you're authorized.

[01:32:00] Anything that comes next you're allowed to do. And then we'll lock it back down again at the end. And so we open up that kind of regardless of whether you're buying or selling, you're going to need permission. So we're going to open up that authorization and then we do the toggle of whether or not you're buying or you're selling. If you have an NFT balance and that balance is greater than zero- if you hold the NFT, then you are going to be trying to sell it- we're going to grab- and we're going to begin so- the sponsor account. We'll get to this in just a minute. This is actually something very helpful when we're starting to deal with Horizon and showcasing data, so we'll skip that for just a moment and come back to it. But if you're a seller of the NFT, the thing that you, that we really need to be doing, is manage a sell offer. So there's a Stellar operation called manage sell offer, where you take a selling

[01:33:00] Asset and a buying asset, an amount that you're trying to sell and the price that you're trying to sell it at, and then the offer ID, in our case, is going to be zero. If it's not zero, you're going to be deleting the offer. But if you're creating a brand new offer, then that will be zero. So, essentially, you'll be selling the NFT, buying XLM, you'll be selling one whole NFT for whatever price you set on the client side, and then we're going to close that sponsorship again. We'll come back to that in just a bit- and so that would be the if statement. If you are selling an entity, the only thing that you need to do if you're selling the NFT is get the NFT up on the Stellar DEX to actually put it up for sale so that other people can see it for sale and then offer to buy it. And so if we skip this other else statement, the only thing, the only other thing that exists in that transaction is to close the trustline flags that

[01:34:00] We opened up at the very beginning. We closed that. So anything that happens in between, in this case the only thing that's happening is the offer to open up that offer. We lock that down. Now the offer exists on the DEX but you can't do anything else with it. You've been given permission by the auth server to put that NFT up for sale, but now you can't do anything else with it, and so that XDR, that transaction goes back to the client and then it can be signed and submitted. So if we were actually that's what we did over here when we created the offer you can see delete offer- that would obviously go take the offer ID, send it back up. Hey, we're going to delete that offer. It's removed. If we go back and we refresh, we'll see that there are no NFTs available to purchase at the moment. So let's go ahead and put that back up. So now we've got the ability to sell and delete offers as an owner of an NFT. But what if we want to buy an NFT? So we've got? Either we don't have a trustline open yet for this NFT, or we do, but it's zero.

[01:35:00] We don't actually hold the zero, yet. In that case, we're inside of our else statement, right? So we've got. Either we've got no NFT balance or the balance is zero, less than zero. That's when this else statement will fire off. And so in this case, what do we need to do? This is where things get a little bit interesting with our inflation destination. When you hold the NFT and you're offering it for sale, there's no royalty payments involved, right? I don't want to make a royalty payment if the NFT is not actually changing hands, if nobody's actually purchased it, if it hasn't swapped, so in that case no royalty payment is being made. The only time we actually want the royalty payment to be made is when a payment is being made, when the NFT is changing hands, and in that case we need to look up the inflation destination. That comes again from our issuing account. It's stored inside of the inflation destination from when

[01:36:00] We were originally minting, and so we grabbed that inflation destination. That's what's going to be used in our royalty payment here. As the second op, but the first stop, we're actually using a path payment strict receive. You might wonder why we're not using just a counter offer, and that's because we have to be absolutely sure in this case, that and that the NFT is actually changing hands, right? Can you imagine if we actually made a royalty payment using an offer, but the offer wasn't actually taken, but the royalty payment was, so you would lose your money from your royalty payment but you didn't actually get an NFT. Offers don't have to be taken necessarily, especially if, like, the offer maybe existed but they deleted it right as soon as you were trying to take it. So your offer went up to buy an NFT, but there now is no NFT to take. But the royalty payment would still go through if we were just making an offer and now there's an offer to sell the NFT, but nobody's at that point in time selling the NFT but your royalty payment got

[01:37:00] Taken. That would be unfortunate. So to cover that case, we're actually doing a path payment, strict receive, and this consumes an offer. It is guaranteed to consume an offer for whatever criteria you put inside, and if there, if it doesn't succeed, if you don't meet the criteria of the path payment, the actual transaction will fail, and so this is a really useful way to ensure that the NFT has actually changed hands before the royalty payment is consumed. So in this case, what's our send asset? We are sending XLM and we're sending up to the price for whatever the NFT exists, as in our case it's a 55 lumens, I think at this point actually it might be 110. But regardless, that's the max we're willing to send. The destination is our user account The user is actually doing like a self pay. If you ever done a market order on coinbase or something, this is kind of what we're doing. We're essentially doing this like auto swap of an asset. We're making

[01:38:00] A payment to ourself where an XLM goes out and an NFT comes back, the destination asset. So what do we want to send XLM and then to receive. We want to send XLM and then have magically come back on NFT and we have to receive. We required, we are required to receive one NFT, so the whole NFT. And if we don't, then this operation will fail. The whole thing will fail. Nobody will receive royalty payments and maybe we'll try again, maybe the seller of the NFT is pulled back. They're not actually selling the NFT anymore and the whole thing fails. If we do not receive this one NFT, then nothing else will succeed. The path payments can be used for other things where you can have like multiple paths, multiple hops to go through. In our case we're just doing XLM to NFT, so we don't need any paths and then finally that source again we're kind of paying ourselves using XLM and receiving an NFT. This is a way to consume an open offer, but guarantee that we consume that open offer, otherwise the

[01:39:00] Whole thing fails and we don't accidentally make a royalty payment without receiving our NFT. Once we're guaranteed that we now have this one NFT, it's safe for us then to make a royalty payment again, because this is all atomic. This whole thing succeeds or fails together. You can't sort of time, it or interes, intercept this transaction and say like, oh, I got my NFT, I'm going to kill this transaction and not make the royalty payment. The whole thing succeeds or fails together and so at this point we have our NFT in this transaction. At this point it's safe for us now to make the royalty payment. We're going to make that royalty payment to the influence inflation destination for the selling asset. In this case it's enforced to be XLM and what's the amount going to be? whatever the sale price was times 10. So if we're selling for 100, it's going to be 10 XLM. Once that payment is made, we can then carry on with that logic of closing down the trustline flags. The

[01:40:00] User now holds that NFT but they are not allowed to do anything with it. So we're kind of back where we started, where some cool arbitrary logic has happened. In our case, royalty payments has been enforced, but now we've locked down the asset. Nothing else can happen until the user then comes back and calls the offer api endpoint again and we offer it for sale again and then someone else can buy it again, but the inflation destination being that thing that's always going back, that royalty payment, always going back to that original inflation destination. And so at this point when we come back into our api offer again, they get that XDR back. The user will sign it. The user needs to sign it because they're making a payment and we need their permission to make that payment so that user will sign with their key pair. If you're using something like albedo or one of those delegated signing services like metamask, this is where that modal might pop up and

[01:41:00] They confirm that they actually want to sell this. I'm encoding, putting those secret seeds in local storage just to make things a little bit easier for the user. But if you want to have confirm logic, kind of like that web 3 stuff, you can use those different delegated signing services where that secret account is a, c, that secrecy is managed by the user. All right, so at this point we kind of have really all of the logic through just those two functions and that original minting where we assign the signer to the auth signer to the new issuing account. There's not a lot of logic here. It's actually quite simple. You might, you'll probably want to do more interesting things in your project, but a lot of times- and this is actually true in most smart contract programming- there really isn't a whole lot of fancy stuff going on. There might be some complex math for some of these bigger DeFi projects, but a lot of this isn't very complex. You've got

[01:42:00] A client service, a user interface and some really basic logic. The thing that's really innovative, is when you add decentralization, when you have multiple machines running these lot, running this logic, to where you can't just shut this down. And now, anytime this auth server is called, if it's being run by five different machines, one decides I don't want to run this anymore. The four others can continue to run it. Or in the case of a decentralized, on chain smart contract, there's thousands of machines that are running this and you can't shut it down. The account is actually controlled by the machine, not by a single third party. So it's not that the functionality, the contract logic, is that complex, it's that it's decentralized. There's lots of people that are like okaying this, that are putting their sign, their signature stamp on this, saying yes, we approve of this transfer of this asset. I mean most of these are less than 100 lines of code and you can get away with some really cool stuff, in this case, enforced royalty

[01:43:00] Payments for an NFT. That can just exist. It's out there, it's on chain. Any interface that wants to show it and sell it can use the same logic to accomplish that. It's quite fantastic and, again, not that complex. There is one more thing, though, that I would like to cover, and that's that it's true in any sort of defy application development, where you're kind of it's not a fight, but sometimes it'll feel like a fight- between the data that's on chain and how you actually build an interface around that data. So you've got all this stuff happening on chain, usually in a very efficient manner. That can sometimes make it really hard to showcase that in an interface. So in our case, we have a bit of a challenge that I haven't discussed, and that is actually showing NFT, NFTs on the interface. So when you have this UI, how am I supposed to show? How

[01:44:00] Am I supposed to show just the offers for my NFT project, just the offers that are for royalty payments. Why aren't all of the NFTs on Stellar showing up in this interface? How have we gotten it to where it's only showing ones that are involved in my project? Well, the way we do that, if we look at app view again, there's a method here called update offers and this is going to- you guessed it- update offers, that array of different NFTs and this is an actual Horizon api call. That's getting offers from the Stellar blockchain. So if we were to go to laboratory- Stellar laboratory- really quickly on test net and explore the endpoints here, we can actually look at what this api endpoint that it's calling this one right here. All offers, now, obviously all the offers, is not what we want. We don't want all of the offers, because that's going to be literally all of the offers on sellers. These are not just the ones

[01:45:00] That are involved in my NFT project. So how am I going to filter all of the offers on Stellar to only show just the ones that are involving my project? We might think you could filter by, like, some sort of NFT code or something and that's actually a. It's a good assumption, so it's not a bad one. You could maybe use like NFT code or some special code. The problem is now you're open to an attack vector, right? So if you used the NFT code where you just said, like NFT, any asset that uses a code NFT is going to be part of this project, or you could, you know, use your name NFT. The problem is there's an attack vector now that anybody else like, if they want to like, insert them their NFT into your project. They just need to name their NFT after the naming convention that you've used. So somehow you need to use something that's like official, that's secure, that only your project knows, as a filter mechanic so that nobody else can insert themselves and say

[01:46:00] Like I'm going to issue an NFT, that's actually a scam- and get my way into your project. This is a real legitimate concern. When you're building projects in open on a decentralized network, it becomes kind of tricky because everybody knows what your project looks like, everybody knows what your asset codes are, and so you have to use cryptography. You need to use something that's like signed, something that only you have permission to do to be able to build out filter mechanics for your UI. So in our case what we're doing is using. Sponsorship is something that exists on Stellar where a sponsor will say: whatever the fee is to put this on chain right, so you have to stake a certain amount of lumens to hold things on chain. So an account is one lumen, trust lines and offers are half of a lumen to actually have them exist on chain on Stellar. And so a nice mechanic to offload that from your users is to use sponsorship where your service account can

[01:47:00] Say like, hey, I'm gonna, I'll take the can for you, I'll sponsor those things for your user account. So your users kind of insulated from those fees. But another nice feature of this is that sponsorship can only happen if it's signed for. You can't just add a say like, hey, you sponsor my account, please, it has to be signed for. I need to give permission for your account to be signed for so we can actually use this functionality to sponsor the offers for these NFTs. Now they're signed for, so that when we go to Horizon we say I would like to get all the offers, I only want the offers that are sponsored by a specific account. And that specific account is something that I, the auth, the authorized account controls, and so that authorized server controls the sponsorship for each of these offers. And now, when we filter, we only get the offers that are sponsored by our account. And so if we go back to our code here inside

[01:48:00] Of our offer logic, that's what this begin and end. Sponsoring future reserves operations are where we're sponsoring the user account with our sponsor account, and this is coming from an environment variable, very similar to the actual signing secret, the signing server that was controlling the NFT. This is a sponsor signer that's going to sponsor the offers for these NFTs and so by wrapping this managed sell offer inside of this open and close sponsorship, we now have a mechanic, a secure mechanic by which we can filter our front end to only show offers that have been issued or that have been sponsored by this particular sponsoring account. And you're going to see, like there, there's only so many. There's a lot of these like little tips and tricks that can really help building out your front ends. But you're going to find that

[01:49:00] If you're not careful, building in public like this, building on a decentralized chain like this, there's a lot of little gotchas. And this is really true on like fully on chain platforms where it's I mean, there's just so many little hacks that people can use when you don't control, when it's not a centralized authority, that you have complete control over everything. You're going to have a lot of these little foot guns. But by doing things like this, where you're sponsoring offers and having kind of these little nuggets of control, you now can have the interface, the user interface, that you exactly specifically want. So there's a couple of those. Sponsorship is a really good one. You'll find a couple others if you go through the drop docs on my smart NFT, so kalepale com you go through the drop docs, you'll find a few more. That will really help as you build out and kind of find yourself fighting a little bit between server and client and things might work great. But if you're not careful, somebody else could say like ha, I've found a vulnerability, I found ha,

[01:50:00] I've found a vulnerability. I found a way to insert my NFTs into your project if it's not fully signed for and secured. So that's just a nice little feature here. You'll find a few more, but that's a really nice one. So with that, there are other pieces here, but they're all commented pretty well. Again, the application's not super complex. You've got a client and server. There's instructions for how to run those. I'm going to move now back to the slide deck. I think this is a qr code for our dev Discord. We're actually moving into the hackathon part now, so hopefully you'll be able to build some innovative NFTs and actually get rolling on some of these interesting and innovative projects. As promised, there is a GitHub repo. If you go to NFT steller buzz there's a link down at the

[01:51:00] Bottom where you can actually grab the repo for this and clone it and begin poking around, get comfortable with the code, feel free to clone this and use this as the base for your hackathon projects. If you want to again, if you go to those parts where the your opening and closing authorization, that's where you may start to choose to insert your own arbitrary, interesting, innovative logic. With that we will move to any qa that folks have around, anything that we've discussed today, any questions. So

[01:52:00] The question: is there any mechanic natively on chain that allows you to ensure that you can't issue any more of an NFT without locking the account? So by locking the account, you essentially remove signers from the issuing account such that you can't do anything else with the issuing account in. So if you've issued, if you've said to the world like hey, it's a one of one NFT, but you've left yourself as a signer, you could go actually in the future and issue more NFTs. I don't think so right now on Stellar, without actually locking the account. There are some things you can do with signers that would disable you from submitting specific operations like payment operations, where you would send more NFT so you could lock yourself out of those specific operations through the signing thresholds. But yeah, until we get on chain smart contracts or you use Turrets and give control of the account over to the Turrets network. I

[01:53:00] Don't think so. It cannot. The question was: can the inflation destination be an array of strings for multiple accounts? It cannot. But you don't have to use the inflation destination to store your royalty payment addresses. You could use so, if you remember, back in the manage data operation. Managed data allows you to assign arbitrary key value pairs inside of an account and we saw we stored ipfshash in the ipfs hash for the metadata for NFT as a key value pair in the metadata. You've got up to 1 000 key value pairs per account so you could store your

[01:54:00] Royalty payment addresses inside of the set options or inside of the managed data operations for that account and just put a bunch of your royalty payment addresses inside of the managed data operations instead of using the inflation destination. Yes, the question was: can you submit a pre authorized transaction? So now we're getting into the weeds. So there are different types of signers that you can add to a Stellar account- the most obvious one is just other Stellar accounts- but you can actually also add preimages for sha 256 hashes and you can add transactions, so actual transaction hashes. So whenever you build a transaction XDR, a sha 256 hash is generated and you can store that hash inside of the signer array of your account.

[01:55:00] Sort of saying I give my account. authorization that if you can ever find this transaction again, I give my permission to sign off on it. And so what you could do in this particular scenario is build a transaction that re enables your account, that re adds master signers, that reconfigures the signing thresholds to your account at some point in the future. That would then put your account back into a state where it could issue more NFTs, which could be a kind of interesting scenario, because you could actually flip the script on that a little bit and say I'm not going to lock my account, but I'm creating a pre authorized transaction to guarantee that at this point in the future I will lock my account. So give me six months to figure this out and then at that point I'm guaranteeing to lock my account with this pre authorized transaction that I've like pushed to the public. Everybody can see it and in some, at six months in the future, we will be able to submit this transaction and it will lock the account. Or you can, yes, do the inverse of that and unlock your account with that pre authorized transaction. It's pretty cool feature but definitely an advanced one.

[01:56:00] Good question, good, any audience questions, feel free. If you have questions for projects you're working on. We're kind of moving into our Q&A building session. There are no dumb questions. Just you know people that didn't ask questions when they should have. Oh,

[01:57:00] Let me read that one, let me read that one off offline. That one sounds interesting. We'll go ahead and wrap up. We have a happy hour coming up. We're gonna. I mean, the hackathon has already started. So get hacking, keep building, make sure you join our developer Discord. If you haven't, we'll be around all weekend to answer questions. I'll be milling about for quite a while to answer questions, excited to see what you guys are building. Thanks so much for giving me your time. Super bullish, excited about NFTs. Hope you are as well. Thank you so much. Applause

</details>

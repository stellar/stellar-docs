---
title: "Intro to the KaleFail project by Elliot Voris"
authors: [carsten-jacobsen, elliotfriend]
tags: [developer]
---

import YouTube from "@site/src/components/YouTube";

## Part 1

<YouTube ID="2XVt87tG5LI" />

SDF Developer Advocate Elliot Voris gives an introduction to the KaleFail project, and cover how it was built, the purpose and future features. KaleFail is building on top of Kalepailâ€™s KALE project and both serve as fully fledged demo applications, showcasing key Stellar/Soroban features.

Links:

- [KaleFail](https://kalefail.elliotfriend.com)

- [Source Code](https://github.com/elliotfriend/project-kalefail)

- [KALE](https://kalepail.com/kale)

<details>
  <summary>Video Transcript</summary>

[00:00] Hello and welcome to this me this week's Stellar Developer Meeting today I have a guest and the guest is actually from my own team it's Elliot and ell is going to talk about a project, that he's been working on and it's a fun project in our team and the deal team we talked about it should be fun to learn to to build on on Stellar fun to learn to build on Stellar and one of the ways can do, that is to play around ourself and and build some cool stuff we can play around with and hopefully you find fun too. And then of course there's a lot of learning involved in, that. So I'm very very excited to to introduce you to very excited to introduce you to to Eliot and and his pet project kale fil. So maybe you can just give a little introduction to how how did this little introduction to how did this all get started I think has something to do with kale yeah. So like Carson mentioned my my name is Elliot I am a

[01:00] mentioned my name is Elliot I am a developer Advocate also here at SDF I get to be at jack of all trades in a lot of ways and I love I've Loved for a long long time just messing around with Stellar having fun and just breaking stuff as you said Matias go I was reminiscing with Tyler earlier today about all the ways, that we used to kind of like Jerry rig this chain of operations into creating some smart contract esque kind of thing. But Soroban is one-year-old today and we have actual official real life smart contracts on Stellar and it's an amazing time to be developing in the community and it's an amazing time to be here having fun I think a lot of the time we get kind of like caught up in the seriousness of what we are doing here at Stellar and the the real life

[02:00] here at Stellar and the real life implications of what we're building and sometimes there's just room for like something on the lighter side you know. And so Tyler started, that in, that vein recently with kale I think it was back in November he kind of launched this. And so I'll share my screen. Now and yes perfect. And so kale. If you aren't aware is sort of like this I'm going to m coins kind of asset built on Stellar, that Tyler AKA kalepail introduced originally Enrique kind of created this SCM or fcm contract, that initiated this sort of like mining competitive sort of asset concept and Tyler took, that and kind of went in a more teamwork oriented kind of

[03:00] Direction with it so. If you aren't already I highly suggest you start mining some kale it's a lot of fun I'll demonstrate it's real easy real simple. If you're not already logged in you can create a new account I'm actually going to cancel, that. Because I already have one. But I'm gonna log in and I'm presented with this oh, that was the wrong one no it wasn't I'm presented with this this prompt, that presented with this prompt, that I can plant something and I'm GNA sign, that with my pass key this is a smart wallet, that I've been given to to plant and sort of get this opportunity to mine some kale and everybody is kind of in this together we're like communally Community Community Driven mining. So to speak sort of like a pool. If you've ever tried actually mining ether or Bitcoin or whatever

[04:00] whatever and all of the people for about five minutes or. So pull their efforts to kind of hash and create this like this hash, that has a certain amount of zeros there's a lot of math. If you click on Tyler's project repository here it'll take you to his GitHub where there's all kinds of stuff about how the math works and as a group of people it all yeah it all all gets matched together and. When you work. And then eventually Harvest after a block has been successfully planted and revealed I don't know. If that's the right word. Then everybody can Harvest and you get your kale back to you you get kale minted to you back to automate it with his website and you don't have to use this website to do

[05:00] it. But it's a lot of fun and it's honestly the easiest way to do it you C we've got a leaderboard here and you can see, that Bri right here with her 3,000 or. So is in the top 10 congratulations and yeah it's a lot of community is of fun a lot of community is kind of built up around this and it's a really good time to check it out and to get involved the thing, that everybody's been asking, though is like I've got this kale I've got in this wallet one and a half or. So oh I get to harvest one and a half or. So kale, that I've mined what do I do with it and up to. Now it's kind of been like not, that much like there's not really a market for it you're not really like selling it and, that's kind of by Design. So what I created I'm

[06:00] affectionately calling kale fail and Tyler really loves, that name he's super excited about it and it's just sort of a riff a spin. If you will on this this kale asset, that Tyler's put together. And so right. Now it is essentially a trading contract and this contract makes it possible for you to send kale just like his farming site you can sign up here with a smart wallet it'll give you a smart wallet and you can put some kale into, that contract into your smart wallet. And then you can trade it for right. Now we've got broccoli we've got cabbage we've got kabi. If you don't know the farming lingo those are all different cultivars of the same species of plant as kale it's like really they're all the same thing, which is why it's always tradable one to one. And so I'm going to send like a 100 kale let's get some

[07:00] broccoli back make the Trade sign with your smart wallet. And then it thinks for a second longer and it thinks for one more second and 105 kale I mean broccoli. Now in my wallet let's do the same thing with with cabbage and it's essentially just the smart contract is holding on to the kale in the reserves and you can see this update date as the transactions go through it's holding it in reserve and it's minting new vegetables to me let's do Co Robbie as well I'm going to make a trade sign in and I'm going to get as many vegetables as I dang well please. Because I need the fiber or something I don't really know what vegetables are good for. But now I'm sitting here I've got 100 each is of bro Oli cabbage col

[08:00] Robie and the way I designed this contract is, that it's kind of extensible. If that's the right word I'm not entirely sure to allow you to allow the owner of the Trading Post to update their stock or add new vegetables take them away and kind of expand and grow as as the expand and grow as the arises. So what I'm going to do here I'm going to copy paste this link into the chat as well. And then I'm G to try my best to share a different window what. If I do, that and present and we can do this one does, that work does everybody see, that that cool NOP, that's the wrong I don't want

[09:00] that okay. So the contract works it's pretty simple as far it's split into like owner customer kind of interfaces and really there's one function for the customer it's trade right you have an address for your customer what vegetable you want to trade how much of it and whether or not you're buying kale whether you're getting kale out of the exchange or. If you are getting broccoli or whatever the case may be and it does it just makes sure, that it's an actual vegetable, that we have in stock it sets up a couple of clients depending on. If you're buying kale or selling kale. And then it it. If it's selling kale. And then it. If it's kale, that you're buying, that means kale is going to be transferred from The Trading Post contract into your own wallet it's going to burn the broccoli or cabbage or whatever you're Trading and it's going to transfer from The

[10:00] Trading Post contract into your customer wallet otherwise it's going to receive as the kale receive the kale into the Trading Post contract transfer. And then it's going to Mint the vegetable into your smart wallet. But I also have this owner interface, that allows me to add vegetables. When I see fit so. If you'll all bear with me I'm going to try this without having done this before we're going to try this real real live I'm going to add brussels sprouts Raph has been asking for brussels sprouts since the day I launched this. So I figure it's probably time to give him what he wants. So we're going to Stellar contract asset deploy deploy source is going to be kale Bale, that's what I call it

[11:00] network is main net and the asset is going to be this thing, that I'm copy pasting right. Now so what you don't know is, that Russell's Sprouts is far more than 12 characters, which is the maximum amount, that can be, an asset name. So I had a real hard time landing on a proper abbreviation for what Brussels' Sprouts should be okay. So the asset is deployed. So we will Stellar contract invoke source is kale fail no yes kale fail network is main net ID is going to be whatever whatever this asset contract was and we're going going to invoke the

[12:00] was and we're going to invoke the set admin function new admin is going to be the Trading Post contract address and the transaction is signing and submitting. And then we get transaction successful where where is it true cool I always look for, that. Now we get to add it to our Trading Post F contract invoke Source kale fail network main net ID is the Trading Post contract and we're going to invoke the add add vegetables function new NOP it's called veg doubles

[13:00] to add. Because I am real creative mattius and we're going to make an array of or vector rather of addresses. If we wanted to do more than one. And then we invoke simulation's okay submission looks like it's okay let's go back to I know I'm giving you guys Whiplash with all of these window switches okay. Now we go back to kale fail and. If we're lucky yes the vegetables available are. Now including brussels

[14:00] sprouts. So I'm going to snatch up some of of, that BR Sprouts is about the closest thing it was my wife's idea she actually enjoys Brussels sprouts, which is sin basically. But now I am the first one with my very own Russell Sprouts be sure to grab some on your own I've got a couple things up next for kale fail number one is, that it's a pain in the butt to sign up for kale fail for kale mine some kale and get some stuff there. And then also have to sign up for kale fail transfer the tokens do all, that before you can actually do anything. So I'm going to set up an ad signer kind of functionality where you can log in to kale fail with your existing kale wallet I'm excited for, that should be really soon able to do, that next thing after

[15:00] that is this kitchen, that Tyler and jrome have been itching to get a hold of soon we'll have a salad like NFT basically just kind of a pretty simple like let's trade your Co tokens burn the vegetables and and give you a really pretty picture of a salad or something else I'm not sure what other produce related things might be in store. But soon after, that got in mind for like more fancier NFTs. If any of you have been around for like four or. So years and remember the smart NFTs, that Tyler put together some maybe interesting Concepts similar to, that. But actually on soron and even maybe like Community submitted recipes or other kinds of NFT goodness fun things, that can be voted on maybe and approved and all, that kind of stuff I'm super open to any

[16:00] ideas you guys have or anything, that people kind of generally want to see or what do you want to do with your kale maybe we can make it happen. But yeah, that is kale fail in a nutshell everybody go have some fun enjoy the AI art, that I stole from Tyler's site to begin with and read all of the Fantastic lore, that Bri has put together like it is phenomenal all of the like five whole chapters like it's a freaking novel go enjoy it great great thank you for for the it great thank you for the presentation and and and actually this is a fun game it's fun I is a this got a little bit addicted to farming kale and and it's it's to farming kale and it's really fun but. When you think about it what what. If we take kale and kale fail it it's actually a DeFi application. Because it has the elements of a DeFi

[17:00] application it's just gamified a little bit and instead of using real token names or real coin names real asset names we're using are you using kale and broccoli and Brussels sprouts. But this is actually a DeFi application and and and as you are switching between. When you're trading kale for for broccoli I trading kale for broccoli I hope hope a lot of people noticed, that you're just using pass keys there there was no using pass keys there was no complicated wallet access or anything like, that just use just Ed the a pass key. So so this is actually it's a good example. If if. If developers want to play around and see what what can you play around and see what can you build on on Stellar and with soran and and how is this build and with soran and how is this build. Because underneath all the the fun stuff it is actually a DeFi application and there's there's a lot of there's a and there's a lot of sorant features like like pass

[18:00] lot of sorant features like pass Keys, that's included in this. So there's a lot of learning, that goes into understanding how this works and lot of inspiration and and it's a good sample project. If if you want to learn more about this. So yeah any any other Tech, that I left out, that I didn't fun that that you can learn from looking at the the source code here yeah the source code is definitely here like available on the kale fail site like easy to get to it's a spelt kit application. If you're like into front-end libraries and Frameworks and stuff, that's just kind of how my brain works to build in, that. But to your point, that everything is Pass Key powered like this contract this smart wallet, that I have CB WN whatever whatever doesn't have to hold like this space reserve of lumens there's no lumens, that it holds s in oh it's

[19:00] $163 sweet it doesn't have to hold any XLM to operate on the network everything is done through launch tube. So it's like this pay Master service, that really abstracts the gas fees sequence numbers transaction envelopes all the like difficult things about building on Stellar sometimes is like just taken care of. And so like no fees come out of my smart wallet wallet same is true for. When you're mining kale it's all done through launch tube and it's just this incredible opportunity to use these smart wallets to like just have a wallet, that you can like hand to somebody you don't have to tell them like okay. Now buy lumens from coinbase and do this to get your wallet set up it's just ready for users to actually use. So yeah you you just mentioned use. So yeah you just mentioned launch tube and maybe. If everyone is not familiar with what launch tube is

[20:00] can you maybe go into yeah little bit of details how you're using launch tube and what role it plays in this yeah. So launch tube is a service, that we're kind of pioneering to make it easier for applications and developers to build applications, that use Stellar like. When you are trying to build a transaction you need a sequence number you need an account to pay, that sequence number you need a balance to pay those fees you need a Base reserve held in the wallet like one Lumen minimum to like make sure, that your account is active like a minimum balance requirement at some banks and all, that can kind of be a pain for a developer. If you're trying to get users set up on their wallet so, that they can actually interact with the blockchain. So you got to either sponsor or give them one Lumen to satisfy, That

[21:00] Base reserve you have to pay whatever fees for those transactions to actually hit the network launch tube, though is in you get assigned transaction from the user using my pass key wallet for these examples. And then you send, that transaction to launch tube and launch tube will take care of the sequence number the fee paid all like the developer has to worry about is getting a like a token with valid launch tube credits on it and, that's super easy barely an inconvenience. If you go to test net. Launch tube. XYZ genen it'll give you one for free. If you want a a real life mainnet one jump into the launch Tu channel in our Discord or reach out to myself for Tyler or Carsten Chris any of the

[22:00] developer Advocates would be more than happy to provide you with launch tube credentials so, that you can start building in this same like super easy super streamlined way I feel like I didn't fully answer, that that sorry, that's great. So yeah I can only encourage everyone to go play farm some kale do some trading get your broccoli other vegetables and and then go look at the source code. Because this this is in this is a really cool application it it really shows a lot of different features of of Stellar and different features of Stellar and soran. So go have fun with it and go look at the source code and learn how Elliot built this. So I think this was all we have time for today unless we have a couple of questions I don't think we have one. But you there still a for the quick there is an opportunity to ask a question

[23:00] anybody sweet doesn't look like it. But thank you so much for joining Elliot it was fun to see kale Phil and yeah hope everyone is having fun with it thank you have a great day bye

</details>

## Part 2

<YouTube ID="hDIP22z6nq4" />

In this protocol meeting, a Core Advancement Proposals is discussed - Siddharth Suresh will will be presenting the memo related updates to CAP-0067.

Here are some resources to read up on:

- [CAP-0067](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0067.md)

- [Discussion](https://github.com/stellar/stellar-protocol/discussions/1553)

<details>
  <summary>Video Transcript</summary>

[00:00] All right I'll get started well welcome everyone today I'll be speaking about an update to CAP 67, which is the unified events CAP. So so a recent change was made where with the goal of reaching feature parody with regards to Memos in seller classic and more specifically you know batch payments within a transaction with different mxed operation Source accounts are possible in classic and this is a way you can make batch payments to an exchange. So we wanted to make similar functionality possible in in sorun. So the the proposed solution is to add an extension function called transfer with memo to the Token standard. If if you want to support memos. So the function takes an optional optional memos for both the from and two addresses and will emit transfer event with a new topic, that is a vector of memos this this format does need to be discussed, though there's

[01:00] there's been a lot of discussion on this recently so. If we don't expect, that the memos to be filtered on. Then it should actually be in the data field. But putting putting this into the data field will be a breaking change, which is why I didn't initially update the proposal for, that. Because the data field is currently an integer instead of a map. But one of the options is is making, that breaking change and updating, that and the the other option is to split the. If you want do want the top memos to be filtered on is to split, that Vector two separate memo fields in the topic. So we leave the the memos in the topics and allow them to be filtered on there and instead of. So those are updates to the transfer event the other alternative is instead of emitting the transfer event we ALS we emit a we still we emit the transfer event as it exists today. And then we emit an additional transfer with memo

[02:00] event with the memo information so. If you care about the memo you consume, that event as well and there's also an alternative proposal in the thread I just linked from Dima to First Class the MOX count type, which is a a different proposal from the transfer with memo a methodology, that that the CAP defines. So yeah there I know there's a lot of opinions on what we should do here I don't know. If anyone wants to chime in maybe Lee or dimma yeah I guess I could quickly present my option option and recap some points I've made in the discussion Regarding why do I think, that my proposal might be a better option than an explicit operation code transfer with memo and the gist of The Proposal is, that

[03:00] we make it. So from the client standpoint the mark addresses do not look like do not require any special treatment meaning, that you can create an st Val, that represents for example Max classic account and pass it as out to the contract and and changes are only necessary on the contract side similar to to the transfer memo option right the changes are necessary on the contract side to support this. Because if you're are talking about the approach or we literally have a transfer with memo function we are kind of reinforcing the memo concept, that is really problematic. Because like we have two different identifiers

[04:00] identifiers, that the users need to care about and we put it deeper into the protocol into the token standards. And then we just expect down Downstream systems to handle it in a special way to and. If represented this singular address I am not sure. If this is going to apply like. If if this has worked for example I don't see why wouldn't like changes to the trade they constantly get issues with memers they could in theory build an M address and it back into memo and g account, that doesn't happen. Because that's very cumbersome and, that Reise on a lot of parties to do the right thing at the same time whereas in my proposal the only thing, that a v would need to do is well convert a Spring key into an address, which is like

[05:00] call library function. So there is no need to somehow specially handle this and we are kind of reinforcing a good pattern of using Max accounts and the the main benefit of Max accounts is, that they have a canonical single address representation and in general the user doesn't need to worry about what exactly it is only s it's they need to worry about is, that this is their address of their exchange account quote unquote and they need to deposit money to this account and this is the only thing, that they we need to worry about. So it's kind of the gist of the proposals there are definitely information details, that could be discussed. But I guess there was lot of position on the whole idea of doing doing this, which honestly I'm still not

[06:00] sure sure I understand the reasons behind. Because again again like the transfer M proposal is like doubling down on the memo hack, that has been existent in the protocol for a. While so yeah, that's kind of my side process here with your propos proposal to you you have a transfer function, that would take two different types right it would either it could either take the address object is exists today or among yeah address object Bally I'd say the main requirement is, that on the client side Al XDR should deal with SC addresses, that represent maxed accounts can introduce a concept of Max contracts as well, that's the main requirement. Then

[07:00] everything else is going into the realm of the implementation details and things may be adjusted for quity. If I think, that's needed like. But yeah in my original proposals area was, that since the contract types are they by the nature of our San design they're polymorphic right or they variant types basically right. So you can pass a general Val, that represents one of the about of types to the contract, which means, that the layer of the contract interfaces there shouldn't be an issue for a contract to be able to accept not only add dress object in a function. But either an address object or maxed address object. So is one way this can

[08:00] be implemented U on like the level of the Cross contract interraction there is of course definitely some stuff, that needs to be figured out how how exactly do this DEC how do we represent this interface at all. But I don't think it's impossible to achieve especially given, that it's kind of a narrow use case I think it could be a separate interface, that you implement. If you want to support MOS and this interface will be compatible with the interface of the Regional token contract. Because again protocol itself does not enforce any type restrictions Ty restrictions happen at the contract implementation layer. So I think yeah can do, that and the same goes for the event trade like we can do different things

[09:00] about the events like we can a transfer event we can like ex option and kind of in favor of, which is another benefit of this approach is, that since we have Max accounts in the protocol what we could do is we could have a an additional field in the event structure itself for through this mares I don't know. If it is too wasteful or not. But at least this is an option, that we have, that does not require imited additional EV and also does not mess up index and for those who don't care about M. So you could have a set Vector of the multiplex Tes addresses in the event, which would generate automatically. So yeah, that's kind kind of one of the options, that this opens up as well. So the the vent point you mentioned like, that's a, that's be done with either approach right where we

[10:00] separate the max ID well it depends on versus goes like in the transfer memo option it has to go through the normal EV data structure. So it will either belong to data or topics with a protocol based approach we have an option of putting it into a sort field, that is not data and not a topic Oh you mean the XDR yeah in the XDR yes so. If you don't care about this you will not see it at all and this event will quite a normal transfer event you interesting okay so, that that would require some Downstream like some work in RPC to expose, that additional information right. Because I don't think RPC currently exposes of course everything course I mean sure any option requires like some sort of additional work somewhere yeah and

[11:00] yeah it's not an argument Pro con it's not a pro con of any approach yeah sorry I Wasing wanted to say something yeah. So I think like we're discussing a few different small features, that all come together into sort of these two different ways, that we could implement this. And so I think the the four different features we're talking about is you know should the should it be an M address or should it be a g address plus a memo in the input. And then the same thing for the output the event. And then we're talking about should we reuse the transfer function the existing transfer function or should we separate the this use of M memers into a separate

[12:00] function. And then should we reuse the transfer event or should we separate them into the transfer with memo event like each of these these things are like separate decisions, that we can make I think some of what you've alluded to De about you know the SDK and you know what would this look like in the S Cas. So I understand I think. When we look at from the the host interface yes all values, that come into a contract are a Val. So it's a little bit like. If you're a Java programmer and you're familiar with like object you know you can make your parameter coming into a function as object or you can make it some type and map to different types. So you know we could add nstk type, that is I'm not sure what we' call it any address I'm just going to use the term any address right. Now and address could be this MX

[13:00] address or it could be the address we have today. So the MX address is an M address and the address we have today is a g or a c. And so we we could do, that. But we're sort of adding a lot more, that I think every token developer is going to be exposed to and going to have to learn about and, that's like, that's a barrier to entry, that's a a potential point of confusion. So why I think, that every token developer will be exposed to this is. Because we can't change we can't have, that token interface be something, that's extendable. So like right. Now the SDK has. If the function name is the same. So right. Now there's this token interface in the S an SDK and there's tooling built around, that by folks like. If you go and have a look at like the OpenZeppelin contracts and stuff. So there's like tooling being both buil bu up around

[14:00] being compatible with it and we can't have like another trait, that provides a different type of transfer function, that has the same name and has a different type as the input so, that means, that somebody, that goes and implements you know one of those traits their code might not be compatible with someon the other type of the trait. If we have two complete different traits there sort of like it's very difficult it's not really simple in Rust to you know rust doesn't have this concept of like overloading functions. So it's it's just yeah it's a little bit difficult to figure out how do we actually make, that work. So I think like the develop like a narrative around like what a developer experiences. So like on the surface I think like yeah this you know trying to build everything into one function overloading the type these are all nice engineering these all seem like nice engineering decisions. But the narrative, that actually results in for the

[15:00] user of the SDK is is reasonably complicated like they need to learn about more things whereas most custom token developers probably don't need to know about MX addresses they probably don't need to know about memos like a lot of what we're adding for like Marx address and memos is for yeah I guess some specific UK US cases where the token Developers for those specific U cases would need to be aware of them yeah I'm yeah I I've made a lot of like I've answered a lot of these questions in the discussion. But yeah I can answer again and I'd really like to challenge a lot of your points. Because well first thing is the developer complexity I think, that transfer memo option introduces developer complexity

[16:00] arguably more developer complexity just in different place and this place is St like wets or block explorers and I would argue, that complexity in these places is much worse. Because instead of you know doing this once or a few times in places like OpenZeppelin implementations for example right you actually ask every developer to to either resort to just present in this transfer with memo operation literally transfer with memo and you know we we kind of just repeat the mistake of building them into protocol and we'll have funds lost. Because people just forget to paste memo in the operation or you have a requirement for the downstream developers to have the same level of knowledge of what M must do. But the work around again. If we like in case of the SDK. If there is at least some

[17:00] possible way of building a samean solution for the developers, which we can discuss this rain firms options for the downstream it's basically up to them for the interpretation and I don't see a sane way of standardizing this and making sure, that you know every time address is an address but. If you encounter transfer res memo somewhere. Then this is not an address this is Max address and then. If you encounter an M address and user tries to make a transfer you actually need to resort to this different function and you need to break it down I think it's more complicated than messing a bit with r traes and the solutions, that are proc involve like what. If token interface accepted just a valve for examp example, which is

[18:00] that's type safe. But you know token implementation just makes a check. If it is address in one case Max address in the other case. Then like we don't even need separate traes or it just move the check out of SDK autom magical type conversion into into the contract project there just one option we we can think about more my point is, that like I feel like fundamentally this is just a better place to put complexity. Because it's higher upstream and ultimately not many people need to deal with it especially like you know. If it's always once and something like opens up implementations. But but also sorry one last thing I wanted wait like one last point I wanted to make I don't agree, that most of the token developers should not care about memos I think they do. Because because like they probably would hope their

[19:00] tokens being listed on the exchanges at some point sooner or later. So I think in either option they will kind of need to worry about this in one way or another either by implementing transfer B memo or Max Account Support. So yeah again I'm not sure. If we are saving something here specifically yeah yeah. So I think one thing I think was interesting you you talked about the you this this idea, that like we want to be able to encourage madress use and we we we don't want to go down, that past where you know the two were separated. Because that was you know a mistake it was easy to forget them I think we're conflating some of the layers here so. When esses were added there were actually two problems to solve. So the first problem was people not forgetting the the the memo and

[20:00] displaying, that information. So displaying, that combined information in just a single identify, that they could just copy and paste the wallet. Now the second problem, that had to be solved was how do we get, that information into the existing transaction XDR the way, that we settled on solving, that second piece is actually largely an implementation decision so, that first piece is like the actual problem the problem we were trying to solve the user problem the second piece was the implementation is just implementation details and the way we tried to solve, that at the time, which was largely led by just the existing structure of the XDR was was to put, that memo ID next to the account inside this moxed account structure. Because we could actually do, that in a way, that didn't break a lot of the existing XDR. But the goal was really just to get the memo alongside each of these places where where where we needed to basically you know attach to a destination or attach it to the source. So I think like, that

[21:00] last part is largely an implementation decision the Sol the problem, that was originally solved with MOX accounts is, that first part you user copy and pasting a single ID into their wallet and I don't like both of the solutions we're discussing here they both satisfy, that first problem, which I think is like you know. If we're going to continue to support MOX accounts, that's like, that's sort of the thing we have to make sure, that continues to get solved and otherwise like a lot of the those details about you know does the wallet split apart the M address wallets already need to know about M addresses. So like, that's not a big deal does the or you know they could potentially we could make the SDK easier at you know doing, that for them but, that's largely an implementation detail detail. So I guess I'm not really seeing like the connect with like how adding continuing to propagate passing

[22:00] those. Because I mean in the XTR like to be really clear like in the XTR an M address is still two parts the Melo is still separated from the you know the public here sure totally. But the thing is, that again this transfer with memo we have like two separate contract call arguments and yeah of course it is an implementation detail. But this is a detail, that will cause a lot of bad decisions Downstream wait again one decision can we talk specifically about what decisions are. Because because something I just want to highlight is, that Downstream systems will want to filter these events by the G address not by the no no I'm not talking about the events I'm talking about the C and again to make me Point Clear like I I'm not even insisting on any specific solution to the events I'm talking specific about how is this function

[23:00] being called I'm arguing, that transfer mem is harmful. Because well you have a functions, that has four arguments and downstream. When you're building this call and trying to get user input for it you basically have two options one option is do what you do every other time for every other function, which is like have a strict matin of a cous to input function arguments what we are proposing here with transfer memos is, that well in this particular case they will need to somehow somehow either take M address as user input and split it into two parts or I don't know I'm not sure how this is supposed to look like and then. When we are talking about R, which again kind of us with a function arguments we're in exactly the same position where we kind

[24:00] of need to in this particular case we need to do something about like this mapin of arguments, that is normally one to one and you know your code would be hey. If I say C address a render is a string key. But here is say no no no like you you cannot render this as a string key you actually need to render first and second argument as this m spring key. So you know I doubt this will work and this is honestly like how again I made this point before like we can say, that transaction memo is an implementation detail just renders destination as an M address of memo plus was a destination account like, that that works on paper. If you have a single payment. But we will don't do, that. Because it's like very unintuitive and error prone for

[25:00] were you there yep just I don't know. If George would like to George is typing some things in here it sounds like he has some perspective to share don't know. If he wants to join the stage

[26:00] sure yeah I mean I can just reiterate what I put in the chat, which is pretty similar to Demus points I think, which is, that having separate functions for this and separate parameters for this just reintroduces the problem at the user layer, that you mentioned Lee, which is, that people forget their memos right. So by by separating it out you're just reintroducing, that possible confusion it seems to me, that. If we want first class support for custodial wallets, which is like the main user of M addresses. Then you would want first class support and transfers right and you would want, that to also be present in custom tokens. If if a token doesn't support M addresses right. Then you can't use it in the exchanges, which you know might be fine and might be a decision, that the token makes. But I feel like we would want to encourage, that rather than make it this very distinct opt in thing, that you have to

[27:00] have a separate function to handle you mentioned, that people will forget the memo but. If an exchange is still displaying in M address and the wallet is receiving, that M address I mean. If the wallet doesn't know what to do with an M address it's going to failed there's going to be some sort of error but. If a wet knows what to do with an M address it's going to unpack it. So I'm I'm I'm trying to figure out where is the forgetting the memo paste coming in you're suggesting we would continue to use the M string key. But not actually propagate, that at anything. But the UI layer layer correct, that's the layer, that's like the input into creating a transaction, that's the layer where this the M address came about to solve the problem I see. And so the application developer would be responsible for

[28:00] dissecting the M address rather than just passing it along along yep now, that's, that's not without a cost I acknowledge. But I think the cost like this is we're discussing tradeoffs yeah and the cost in the solution I'm proposing is just using new version of spring key library. Because again it just Maps into address. But arguably things are a bit more complex on the con side, which yeah yeah I'm not sure. If it's necessarily significantly more complex could you elaborate on what you mean by an M address maps to C address SC address sorry SC. So so basically. When because like what I'm proposing like I

[29:00] want V to just wait do what they are likely doing. Now right it would paste the destination as a string key and you can just take this string key convert it into address SC well pass it to the co and this is like like this is what you have to do. Now to support sound transfers right and the only you will need to do to support Max transfers as well updates the libraries things will magically work it is a lot less work and a l a lot less chances of just doing something weird yeah what what typically happens in I think most SDKs George you can probably correct me. If I'm wrong about this or. If it's not most. But I think what most stks do is you give them a string. So you give them the M address or the G address. And then the SDK is the

[30:00] one, that builds the MOX account on the classic side yeah whatever the XDR types are. So most applications don't build the XDR types themselves. But right, that's the point right. But say like do we make contract codes with just like strings and even Z like you still know need to know, which contract code to make right. Because your safe default should probably be transfer. But then or maybe the saet default should be transferred with memo but, that's not always going to succeed. So there is definitely some L of projects, that needs to happen even like ticated build calls just from the strings. But I'm not even sure. If that's the case right. Because conversion and building actual call is different and here like we are mixing the conversion and building the call. Because

[31:00] currently again for each and every contract call the conversion is one to one you have like two string keys and an amount and this is argument to the transfer and here is say well here is like three two string keys and amount. But you need to M this to four arguments and sure, which where it should happen this is like how capsulated in it decay or V care about it or whatever client. So I don't know maybe there is some good Solutions there. But but I feel like it's kind of hacky and error prone. And then again as I pointed in the discussion like BL explorers may displays is differently as well so. If you were to check your transactions there you would be confused confused yeah. So I think we're I think like where these different ideas were optimizing for different things. So I think the proposal for transfer with

[32:00] memo is like very simple to add to the SDK and the experience or the knowledge about what you or what you need to know about, that extension of a token is really isolated. And so I think like there are benefits to developer onboarding for contract development in the Stellar e system. Because of, that. And then I think the the idea, that you're presenting is optimizing for there being one interface a single interface people need to learn with. So people need to know about this stuff. So there's more for them to maybe know up front as a contract developer. But once they know, that information it's a single interface. And then an added benefit of this is, that in things like stks or at, that client level you do still get like, that single view of the M address whereas with the First with the the first proposal we don't you don't get like the single view. Because clients

[33:00] need to unpack things. So I think like these two different approaches are optimizing for different things trading off different things I think something, that you mentioned before deer is like we don't we haven't really figured out exactly what the SDK would look like and what the experience would be there maybe we need you know assuming, that we have all the time in the world Maybe we need to actually do a spike there to make sure, that we don't have any unknowns and, that we have a Clear Vision for like what the contract developer experience is going to be yeah sure I agree, that prototype wouldn't hurt. Because yeah I want to make make sure this makes sense aswi

[34:00] I think maybe we could discuss the event portion of this. So like I earlier I listed out like there were like four micro decisions we sort of need to make within these decisions and one of those decisions or two of those decisions is around the event. So I think we've talked quite a lot about like the input the trans the transfer function versus the transfer M function. And then you know should it be G memo and M on the inputs for the outputs I don't think I saw in your proposal, that they would be an M address. So so is are both proposals consistent, that whatever the event is it would both the event would contain a g. And then a separate memo yeah say don't have a strong opinion we have options and the tradeoffs are are like much less clear to me. Because well we could easily

[35:00] put M addresses right there in the event and look the same. But the concern is, that it will confuse consumers, that don't care about htic rate, which is why we could do either separate field, that is protocal defined for this MOS, which has again a down set of B it's a protocal change and also it adds with four bites to the all the events events just kind of bad. But of course you can just do whatever you would do with transfer this memo by just you know providing ways of getting the mar from and. And then you can do basically anything you want to structure and I think U you know there is no difference between transfer this memo and my proposal the scenar we. If the all resarch to split Max address into two

[36:00] parts. Then they very can cze whatever events we think are the best trade of yeah the only distinctive thing about my proposal, that we had this yet another option of having M thiz as a parallel field to topics and data. But other than, that I don't have to strong opinion on what the event should look like yeah to's not here today. But I did run this by him yesterday like what u based off what he knows from a product perspective would it make more sense for exchangers to you know filter on or exchangers or anchors to filter on, that m versus a jress his opinion was a Gess I think we haven't I don't think we have like like a survey of how people typically filter

[37:00] but existing exchanges would be given, that historically there were just a separate G and a memo are probably filtering on G address oh yeah totally I kind of like we know status quo, that most exchanges use G+ memo MH. But they also don't use the events, which is what we're discussing here. So there may be honestly an opportunity here like to kind of. If people need to migrate anyway you can kind of try to promote well something maybe a bit. But I think for non- exchangers memos maybe kind of know to deal this. So right. But exchanges would be using Horizon and Horizon typically uhit imits in air quotes Things based on account. So I think, that's where like the the

[38:00] idea, that okay like exchangers they currently collect these events affects payments VI account. So we should probably just keep doing the same thing in a mid Advance buy account, which I think makes sense. Because like these topics are intended to be things, that you could filter on and so. If I'm running a system, that's catering for n number of events coming in to one g. But you know across like all those n number of moed IDs like it from a scaling perspective it's difficult how would you use an RPC to filter on all of those things you wouldn't you'd be just You' just have your system ingesting everything relating to the geod. And then splitting them out oh I see Nico he's on yes. So yeah I guess you guys were talking yeah there's the you know number

[39:00] two right, that is the do you want to expose the G Plus memo or the m in the output right as an event I think maybe we should maybe talk first about number four in your list right, that is is it a single transer event or is it multiple events. Because I think you know like they are like implications in this context like the the way I'm thinking about this is, that the tradeoff is, that so. If we have separate events the nice thing about it is, that we keep the transfer events for the standard token contract as a you know fairly clean like it's the same thing we don't you know mess with it the problem with, that approach where you have two events is, that you need to do some sort of

[40:00] reconciliation from The Exchange side. If people send. So assuming, that like the The Exchange requires memo. But for some reason somebody sends money and forgets to specify the memo they actually need to reconcile the those two event streams in some way basically to find the U the transfers, that happened, that don't have a you know transfer with memo equivalent and, that sounds a bit complicated to do I mean it's doable it's just like you have to to kind of you do this kind of reconciliation on a per transaction basis basis. So yeah. So like I don't know what you guys think about about this one. Because yeah. If if we can get one event, that's the the other ation I starting a discussion right, that was I think the

[41:00] the type of problem we we have in, that context is how does extensions to a standard on as an event right like how do they look look like right. Now like we're saying maybe we keep adding topics to the the event the problem I see with doing, that. If we're not like super careful on on on, that is you know as you add more extensions to like how does, that work like you you know to keep you know they are basically Index right in the in some arrays arrays so. If you only implementing one of those extension you know extension number 20 does, that mean you have to put a bunch of voids you know like in the you know up to 20 basically, that's, that the type of things, that happens in, that World and yeah who manages the the namespace I mean the name spacing

[42:00] here being you know just a number. But there's a bit of, that question, that kind of pops up in this case it probably makes sense I think you mentioned this it it would make sense for the topics to be in the data field not the topics and you would you. If you turn the data into a map. Then you only look look for what you care about I age extending topics definely the extensions would have their own name of sort like maybe here would say memos or something and then, that's a string and then, that's how you can. Then have a custom data attached to it yeah, that's the cleanest option Le is, that what you were is, that what you were thinking too yeah my point was just to move them out of the topics in general I mean I think in general the memo probably don't belong there like

[43:00] filtering on the memo IDs is is getting a little too granular like we these topics are meant to be like things, that you could filter on, that you know most people are going to want to filter on. Because I think maybe George you can confirm this like I think the RPC or different systems have to index these topics. So like we've already got four topics like once you start adding more topics it's like PE yeah yeah I agree I don't think the memo needs to be a topic. But the and for the the same reasons, that you know Nik is mentioning too like having to add in all these voids like. Now we got six topics. And then like you get to like 20 topics eventually. When there's even more extensions this doesn't really it doesn't create an interface, that's intuitive at all I think. But I think this is like one of the nice things about the separate event the transfer of memo event is it's it's

[44:00] very very explicit like you know. If you want to ingest. If you're looking at an operation and there's a transfer and a transfer of memo and you care about me. If you don't care about memos for starters you just don't care about, that other event and. If you do care about memos. Then you can adjust, that one instead for, that operation. But like I was saying, though Exchange is care about both. Because they need to to basically ingest those transfer with no MOS. Because that's basically how they can you know through tech support or whatever they can return the money to the the sender yeah. So for them like there is this other issue, that's I feel like this has come up like. So many times, that there's this other issue, that okay. Now we have two events. So then they have to figure out not double processing them and I think we shouldn't not do this for, that

[45:00] reason. Because we should solve, that problem or we should have a story for, that for how to solve, that problem it doesn't necessarily have to be solved today. But it's something we should solve whether, that be through like I think you know we've talked about ideas like an invocation ID. So then you just say like okay like this this memo and this other transfer they're in the same invocations I don't double count the other one or something like, that yeah unfortunately I feel like invocation w't help here like there was an unrated discussion, which is unrated. Now about like what. If a token wants to charge s during a transfer for example and you'll have an for example to transfer events, that are actually separate transfer events in

[46:00] general I feel like. If we were to come up with a good event linking mechanism it would be almost exactly the same thing as converting data into map like almost. Because what I think we could do is say like for the event we can say what is some special link in a and you know you can think of every event with assembly in caned is a part of the same event. But at this point honestly like why don't just make data map. Because I think, that's the only way really to prevent double counter is like you have unambiguous way to say like you know these two events are actually describing the same things, that has happened. So maybe map is really it's right way to go

[47:00] sure so, that's what it's I guess we can maybe discuss it offline we have maybe 10 minutes left. But the one of the questions to answer is do we either use a new event or make a breaking change to the data field and make it a map is, that right does, that sound good I guess have a question I don't know how like consumers of those things you know what they do. But like. If if it was an extra field at the end of the event, that is added would, that really like like be a much of a breaking in change basically like like people are just using the index zero whatever like

[48:00] you know the I mean it's already an array right. So like at theend you talk about the topic or the data data the data isn't an array right. Now it's a an integer, that's the breaking change like making yeah, that's a pretty big breaking change yeah I thought it was like we had a vector already originally it was a map. And then I think it got changed to a vector. And then I think got changed to an integer okay. So yeah we have, that question to answer and for the the transer memo prop like function

[49:00] versus Deus proposal I think the yeah, that what we want to do is prototype what, that looks like in the SDK to see what it looks like so, that that's the I'm guessing I think, that's the status of, that question, that is number three right go ahead, that's, that's a suggestion yeah I mean, that that's I think it's a good idea my suggestion is. If we're leaning towards, that approach we absolutely should spike out what the develop contract developer experiences. Because I don't think for something, that I suspect will be as intrusive to the developer experience on the contract developer side I don't think we should trade, that off for the benefit of clients not having to unpack an M address. Because I think both of these things obviously have a cost there's a cost saying to wallet clients you have to unpack an M address to put it into the to the SDK. But

[50:00] but, that's yeah I think I would prefer, that cost cost over over MX addresses and and Mos sort of intrusive intrusively entering every to implementation. But this is why to SP it I think just you know to see how bad, that that is and to see what surprises there are I think you know one thing, that came up in the the chat was in the past we've been concerned about M addresses accidentally being having balances stor against them and, that's one reason why we wouldn't want to add the M address to the main address type it it just be. So easy for a developer just to store balances against the M. But then, that that's not accessible to to use by the G address requiring or or something okay the I noticed, that even with this

[51:00] proposal, that problem could still occur. If I'm understanding correctly like this m address will be convertible with Val so, that it can be used as an input. And so in theory you'd be able to store it as well oh I mean same can be said about transfer like you can do whatever sorts of stupid things in your contract like nothing PR you from storing some inders in storage for no reason yeah. But there's like. If something's going to become a thing, that people shouldn't do we shouldn't set them up to fail. But but also yeah, that's what I wanted to say like. If you're concerned about this like you can just make it impossible to make this keep prevent people doing themselves you know I'm not sure we can with the existing the way the rust type system is. So I mean obviously

[52:00] we can do anything we want. If we Val implementation no no we can do this as the host level yeah I'm not saying it's SDK level can just make it it fail. But these types are just a contract type right is is MX address cont it is a c Val like we can say like. If your leer key SC contains a maxed address you just will not trate it right totally totally do we could do, that. If it's anywhere in the anywhere like. If it's inside a VC or. If it's inside like a nested type or something like, that is, that what I'm saying yeah yes we we have similar checks to what like we make sure, that you you know cannot create AAL or C out of non-representable types and stuff like this. So defin have validations like, that not in the St specifically. But you know they pretty

[53:00] flexible in host in terms of like restriction types. So really I was thinking about this as well like. If you're concerned, which is a valid concern like you know to not shoot yourself in a EG like you still will be able to probably extract an integer and. If you really want to you will be able to store like this for for some reason. But the same can be said about transfer Le you need to be very intentional about doing something bad and we can prevent the most obvious mistake, which is we just write in Mar address window storage this is preventable okay. So we, that that's question number, that's, that was the decision number three we still have to figure, that out

[54:00] like a lot of complexity it feels like we're discussing a lot of complexity just yeah yeah just to improve, that one little thing at the CL okay. Then for decision two I think we agreed, that we should, that the output should have G Plus memo right instead of just the mend mend and I guess one is tied to three right like the G Plus versus M for input. So I guess, that's something we still need to answer it are there any we're running out of time are there any other open questions sounds like we still have some stuff to discuss

[55:00] yes I guess the question on the yeah single event or not right, that's number four by going back to this right like this one is it could be a I mean it's a breaking change potentially right. If it's a for like the downstream you know like like like systems right, that are ingesting I don't necessarily think, that it's U like as a breaking change like, that it's not necessarily like insurmountable right like it's a basically it's like kind of like the type of thing you do in you know in in many situations we can allow like we have to allow in the token standard, that it's either a single amount or a or or some or something something else right. And then you have to dynamically Downstream. Then U do something different

[56:00] based on either the type or or or. If it's you know I guess it's the type yeah, that that tries this yeah you're talking about making the data field a map right. If it was a map or or a vector yeah yeah I yeah we we've discussed this a bit internally there doesn't seem it is a breaking change. But there doesn't seem to be much opposition to this we can bring this back up. If if it helps in this case yeah I think to like the way we would do this. If if this memo thing is a separate Set and an extension we'd make a change to set 41 as well as the extension. So like SE 40 ideally we'd change set 41 so, that it says, that the field could be an amount or or a map, that contains an amount yeah so, that. If folks are developing they they're not they don't feel like they need to use just the

[57:00] amount. If the for non-mo transfers yeah mount as an integer fi definitely has to be a part of the standard like we cannot decate it. Because the historical events have it already already yeah would remove it we just say, that both all right. Now we're out of time. So this there's are there any other questions or concerns right. Now continue adding them to the chat and we can address them and we'll continue continue any any open questions in the GitHub discussions all right thank you

</details>

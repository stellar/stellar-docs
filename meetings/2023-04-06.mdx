---
title: "Transient Storage and Upgradable Contracts"
description: "Design discussion covering a proposed transient (ephemeral) storage feature and a v1 contract upgrade mechanism, weighing developer UX complexity vs. benefits, and outlining a protocol-level approach to make upgrades observable and secure-by-convention."
authors:
  - dmytro-kozhevin
  - graydon-hoare
  - leigh-mcculloch
  - paul-bellamy
  - siddharth-suresh
  - tomer-weller
tags: [soroban, CAP-46-2]
---

import YouTube from "@site/src/components/YouTube";

<YouTube ID="aDWTaMNhKes" />

This session focuses on two contract-platform capabilities: a lightweight transient storage concept for “only-needed-during-execution” state, and a v1-ready upgrade path for deployed contracts. The group explores where each feature helps, what it costs in complexity, and how developers and tooling would reason about it.

The discussion leans toward minimalism and clear observability: avoiding extra storage modes unless they unlock compelling real-world use cases, while prioritizing a protocol-level upgrade mechanism so contracts shipped in v1 aren’t permanently frozen without an upgrade path.

### Key Topics

- Transient storage proposal: ephemeral state that avoids ledger writes and footprint inclusion, aimed at lowering transaction cost/size and ledger growth
- Primary motivating example: temporary allowances/approvals during multi-step cross-contract flows (e.g., distribute funds across receivers) without persisting allowance state
- Concern: limited concrete use cases today, and adding another storage mechanic may confuse developers (especially alongside state expiration and other storage behaviors)
- Token interface impact: desire to avoid “multiple allowance types” and extra surface area if persistent approvals remain the standard
- Related ecosystem context: similar ideas in Ethereum (transient storage opcodes) and its relevance there for re-entrancy patterns; noted as less motivating here given current execution model
- Conclusion on transient storage: consensus to remove/de-scope due to narrow benefit vs added conceptual overhead, unless strong use cases emerge
- Upgradeability motivation: without a built-in mechanism in v1, contracts deployed in v1 that don’t include self-upgrade hooks could remain unupgradeable forever
- Upgrade approaches compared:
  - Storage delegation/proxy-style patterns (powerful but more manual machinery and tricky ergonomics/performance in a VM-heavy environment)
  - Protocol-level “update contract executable” approach (contract updates its associated WASM hash via a host function; auth logic stays with the contract)
  - Optional extension: allow executable indirection to another contract (cheap proxy-style “shared implementation” pattern for fleets of instances)
- Observability argument: protocol-level upgrades are easier for explorers/tooling to detect than bespoke proxy patterns, making behavior changes more auditable and less “hidden”
- UX/security tradeoff: discussion of including the WASM hash in signed payloads to invalidate old signatures after upgrades (extra safety vs potential user friction)
- Practical note: footprint/preflight behavior already makes some “stale view” failures likely, reducing the incremental benefit of hash-in-signature in many cases

### Resources

- [EIP-1153: Transient Storage Opcodes](https://eips.ethereum.org/EIPS/eip-1153)
- [CAP-0046-02: Smart Contract Lifecycle](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0046-02.md)

<details>
  <summary>Video Transcript</summary>

[00:00] Okay let's get this party started hey everyone welcome to storybond design discussions today we're gonna talk about two topics transient storage and upgradable contracts I'm going to take over Justin and I apologize in advance for my nasal sound I'm a bit congested is Dima here yes Dima do you wanna take us through transient storage yeah sure. So is this really a pretty small feature and I don't really want to spend too much time on it like. If you think we don't need it let's just drop it. But basically the idea he said it's also next the cross contract interactions are much more capable than without it for example. If a contract wants to do some temporary allowance

[01:00] to distribute funds between multiple receivers or something like, that it could create cause increase allowance function and do as a corresponding expert transfer phone call right and the thing is, that allowance in this case is not needed to be persisted and my initial intention here why I came up with this ready in the first place is, that I didn't want the token to have any persisted allowances. But but yeah this was a topic we have discussed last week and it doesn't seem like the general consensus is, that the time being on the persistent allowances to still remain in the token yeah. But original this idea was. If you want to create something, that is needed only for the duration of the

[02:00] time you could use this ephemeral storage or whatever his name is and basically its benefits were, that it doesn't need to be included in the footprint and it doesn't need to be written to The Ledger, which is beneficial both from the like transaction size standpoint transaction costs 10 point and it's beneficial for The Ledger as well and the other thing is, that from the interface 10 point it probably would be pretty simply to use from the SDK perspective. Because we can abstract it away. If needed and meaning some generic interprets or maybe you can switch your plug or something. So I wouldn't be too concerned about SDK side. But I guess the main concern is

[03:00] that valves running too many use cases for, that at least yet and I kind of agree especially. If he just don't want to go with temporary allowances and we go with persistent allowances yeah I think I don't actually want to upload the token interface with like multiple allowance types or something like, that. So you know you can drop it all we can view it. But not use it in token I don't have a really strong opinion like there are definitely some interested cases one can come up with you know one contract calls another contract multiple times. And then as a contract made want to maintain some state. But but yeah maybe this cases are too narrow to worry about them. Now I guess, that's I have to sleep. Now got it. So it is worth mentioning, that this thing has been discussed a lot in the Ethereum ecosystem and I think

[04:00] they're getting pretty close to actually putting something like this, that's the AP 1153 transient storage op codes and in the Ethereum ecosystem it's also something, that's been considered in the context of re-entrancy attacks. Because it allows you to basically kind of like a contract instead of flag, that it's like being processed right. Now and then. If there's like a re-entrance. Then the contract can check, that flag I think for us it's less relevant right now. Because there's no re-engency possibility at all and I think, that. If we're gonna add re-entrancy possibility there's probably going to be a flag in the call function, that allows you to set like whether or not you accept, that. So I think, that's less of a motivation for Soroban my question to you do you mind I think I asked this in the past aside from the allowances use case is there are there any other examples, that you can point out too

[05:00] so actually speaking of reinsurance I think. If we do it in whatever ways it might be actually useful and I just forgot to talk about this I don't know. If I don't think there are planning arrangements for everyone maybe eventually I feel like it will be beneficial to be able to write some Perfection bits even. If it is controllable on the individual contract overall. But otherwise I don't think I have a super good concrete example I've been thinking generally about you know us tickets for approvals it's just a case of, that. But you know in general you can imagine something like a custom accounts a smartphone creating some authorization tickets, that might be used during the

[06:00] execution time for multiple calls. But you know I guess the main issue here is, that since this thing like this does not exist for example in a cage yet right I guess run many users of, that. Because well there's no such feature. So yeah. But I cannot come up with like I'm very convincing case right. Now like I have just some fake ideas I don't know obviously it can be implemented efficiently in azervation maybe they can yeah. But the important part is, that well yeah like I understand, that use cases are probably not, that obvious. But also the maintenance cost is pretty low as well. So it's not like a huge shade of it's not very good you know complicated subsystem we need to maintain as well. So yeah, that's something big got it. So I think, that given, that last

[07:00] week we decided to keep long lasting approval or persistent approvals and given, that you know simple authorizations are handled by off next without actually requiring allowances at all I would say, that this is a pretty narrow use case and we'll clutter the asset interface. So I definitely agree with the sentiment, that we shouldn't include it and I wonder. If anyone else on this call has a different thinking about, that. So you're saying not only remove it or like don't make any changes the token contract. But also remove it from and the SDK right. Because it's been, that

[08:00] like the tooling for this has already been implemented right yeah my vote would be to remove it especially given, that it's such a narrow use case and also you know with State expiration we have a lot of different storage mechanics in the end and I think, that adding another storage mechanic can just add to the product confusion for Developers yeah I agree. If we're not going to use it. Then and we don't have any other good use cases I'm fine with removing it yeah at 10 degrees well it does sound like a very cool feature. But it also to a large degree it's an optimization and yeah there definitely is like a complexity cost to developers needing to be aware of this thing. So you know knowing, that it should or shouldn't be in a

[09:00] footprint, which I guess is largely taken to get you know care of by the fact, that we generate the footprints for people. But but may have developers needing to make a choice about what they use it just seems like one more thing, that people need to know and learn about or make a decision about, that for the most part it sounds like we would be telling people don't use this isn't something, that you would use except for you know these educations, that is a very strong opinion I can imagine finding use cases for it but. If we're aiming for minimalism. Then I guess we remove it I don't really care is it in the current release the release has just gone in. Now okay it sounds like we're pretty

[10:00] in agreement right. Now on removing this. So so I will we'll go to the next topic, which is upgradable content yeah one small thing on this like since it is in the current release someone comes up is a good idea for use case please let me know. Because you know. If there is something legitimate, that people can use right. Now and they can play with it. So you know we. If it is. If it seems useful like we can reconsider this trade. Because it's not really correct oh it is not no right oh okay, that's a bit unfortunate oh okay I guess you still can write. If you have some ideas yeah and once it's asking. If it was it wouldn't be a complicated to include Post Main net it will be somewhat complicated in a sense, that it will

[11:00] require a protocol release. But yeah it just will be one not complicated okay next topic is upgradable contract. So Dima you distributed a doc a couple weeks ago, that outlines three different proposals and you've implemented one of them can you give us a brief overview on the different on the problem and the different solutions and focus on the one, that you're proposing yeah sure basically I essentially want some contract upgrade mechanism to be shipped in V1 just. Because if there is no such mechanisms and contracts written in V1 will stay unupgradeable forever. Because no matter what mechanic we come up with it will need to be controlled by the contract itself and you know. If contract

[12:00] doesn't have an updating kindness there is no way it can upgrade itself. So it is of course possible with the current tool set to build something like a proxy. But the issue is, that the state will need to like the state of the proxy contract has to belonged as a top level contract 80 and currently it's not possible to achieve it. So we need something to address this issue, which is why I had things a proposal an assumption line were said okay we could add some sort of storage delegation mechanism, which I think someone quoted existed in Solana maybe some other chain I believe it was one. But it could be wrong here. But basically it's just one of the approaches, that is possible or you say hey I allow or not yeah I

[13:00] allows, that contract I'm calling to actually be using my storage it's not super straightforward to implement I guess and also it is going to be relatively manual in terms of like besides the storage delegation mechanism you still need to write all the focusing machine Machinery, which might be an overkill for some cases. So second option insert option. But basically three depends options three develop since option two and yeah for the option two what we do is we just allows the contracts to update their conflict executable entry as we call it. Now or basically contract says this is a reference to my implementation versus references hash of the Horizon web installed engine. So

[14:00] this is Proposal with Zipcar is already deserve it just to allow contracts to call host function and update the hash of this wasn't blob to be some other value performs an updates. So basically the update logic and authorization logic is on the contract developer, which makes sense a he wants to have different authorization approaches to this. But the main point is, that it is. Now possible to just upgrade the button, that has been used as an addendum to, that is. If you folks suggested. Then the I have this implemented as well we will and wasn't hash to their standardized signature payload for sales just so, that you know

[15:00] will basically get a some feedback. If something has been updated once they were sending the transaction, which I guess might make sense. If something has been signed a. While ago well yeah, that's kind of safety measure, that's comes with this obviously there are some security concerns. But my guess is, that this is not significantly more different contract uality based sequels it can be strong funds from it or something like, that there are some angles to attack service contracts. And so on. And so forth. So basically it's ultimately on the

[16:00] contract developers and the good thing about this approach is, that it is very easy to tell, that the contract is upgradable like it cannot be obfuscated as far as I understand. Because you need to follow the host function and kind of obfuscate the plus function calls. But should be visible even from the Vasan blobs, that the contract is subgradable yeah and also as a benefit compared to the first option where we just automate in the storage access this approach allows to easily extends the interface. So for example say you have some NFT contract. And then after a year NFT standard has been ironed out and some new functions have been added to it you may just update implementation of your NFT and provide some new functions, that's maybe a bad example I don't know. If that happens or not. But you get the idea right, that it's possible to extend the interface without any special

[17:00] machinery and it's compatible with them and host environment and option three is just another feature on top of, that where we allow besides a point generator wasn't hash be allowed to point it a different contract and use these different contracts wasn't hash as implementation and once this gives us basically a like very cheap proxy pattern or it is possible to do centralized upgrades of the implementation on a bunch of contracts this is how I have noticed some bigger contracts work like uni swap I believe where they have some implementation contract and you know it can be updated in various ways for example there could be some voting or something like this. So

[18:00] again authorization is kind of on the contract Traders and it can be as complex as needed. And then soon as the implementation is updated every instance of the contract gets update immediately, which is close fast and cheap and it is of course more narrow use case than just upgrading a single contract instance. But arguably it is pretty important as well. Because well it affects maybe a smaller fraction of the contractors are likely the most meaningful contracts like uni swap. So basically this will probably concern anyway token mm implementations and stuff like, that. Because this tend to have many instances and say probably should be controlled by a single entity a lot of the time

[19:00] so yeah this is options option two is, that is yeah all the parses there. So it's only a matter of review and it's very easy extending it is not hard as well. So I don't see a very good reason to not do, that besides maybe some additional ux complexity. But I saw some folks had some I won't say, that. So and, that's. So I do feel like there's one possible solution, that is not mentioned here and it may be. Because it's like really bad from a performance perspective. But you could always create like a simple kind of like contract, that's, that just like stores things. So like a storage access contract. And then the

[20:00] proxy can like you know can pass, that as an argument to whatever implementation contract it uses right. Now right and, that's something, that's pretty much doable. Now yeah I guess, that's an option, that kind of yes of house supports for option one it is still like still wouldn't tell for the interface updates as I mentioned and of course this is really slow and I think it's all enough to the point of being as well as your attaching the storage wasn't like a couple of times okay separate to the performance issue I am curious on how authentication auth would work in, that flow like with the auth be between the two contracts or

[21:00] like how would you like the nice thing about auth for users or with the contractors you're sort of like scoping their users access potentially. But would we be able to do the same thing for a contract, that's deeper I guess we can with auth next sorry I like, which approach are you referring to I'm just talking about what time it is the idea time it was sharing where data is I guess it doesn't really matter you just like your storage interface instead of like calling storage through then. If you would call storages and as a contract and another contract would rely on the invoker being the admin something exists. So basically it is definitely doable other or not it's a good idea isn't

[22:00] probably it's not the best CD. But I mean yeah it kind of works and presumably it's a bad idea. Because we were talking about what I described as like three separate wasn't environments in it right yeah it's a ton of the Cross VM calls and I mean every storage Bridge would be another VM read the right would be a VM code and VM codes are really expensive, that's the most expensive thing you can do, which is why kind of in favor of built-in mechanisms. Because besides providing some unique features they are also much more efficient Point like additional VM instantiations, which are expensive right but. If we go in the path of introducing protocol changes for this you can imagine, that like this and again

[23:00] I'm not attached to this idea in any way. But you can imagine a world in, which we take this you know simple contract like simple storage contract and nativize, that so, that it's native code I'm not sure how would we negative is it won't be possible oh yeah well. So is, that worth doing like I'm curious why the like this, that approach is more beneficial than the solution too like just using the host function, that's, that's a good question. So I think solution to is possible my knee-jerk reaction the solution too is, that the fact, that a contract implementation can change is not trivial like it's you know especially. If you look at other

[24:00] smart contract platforms out there right. Now now I feel like, that is going to be something, that is a bit more difficult for people to wrap their heads around I'm not sure how is it different from the processor implementation change is exactly what happens it says, that instead of changing the contract, that is serving as implementation you are changing the implementation itself, which is actually easier to trace a generic fashion. Because it's independent of any contracts yes from a user perspective I agree with you but. If you look at the USDC contract, which is a proxy contract right. Now this you know it never changes right it's always still the proxy contract and the state changes and there's like a different address, that it forwards to. But the contract itself

[25:00] didn't change right it's like an observer perspective like a block Observer perspective well is it actually a good thing I don't think I think, that's a good thing. Because I think the fact, that the actual code, that runs like the fact, that the actual contract code and this is semantics. So just there's a thing right it's a contract Behavior may change and it is actually hard to notice, that it has changed pressing the second solution emit an event probably and it will be very clear, that the implementation has changed I think it is it actually makes things more observable safer right. Because well you can argue yeah it is just a proxy right. But it may point it at a different implementation and. If block Explorer actually cared about, that it would be pretty tricky for

[26:00] break it would need to know how exactly this proxy reference is being stored or you know introduce and standard based events or something. So I don't quite agree, that it's necessarily a better thing. Because it creates a false Impressions, that the contract doesn't change or it actually like its Behavior actually does change in fact. But it's just sophisticated yeah I think there's basically no way for us to I agree with Gemma here I think there's no way for us to prevent contract behavior from changing contracts can just change Behavior, that's, that's, that's their nature they don't always. If they did one thing yesterday they don't necessarily do the same thing today. Because they might have code in them, that says you know. If it's Wednesday do something different right there's always the possibility for contract changing what you're getting out of something being built into the protocol is a standard way of expressing a pattern of contract change. And so block

[27:00] explorers or anyone else can actually observe, that particular type of change, which is upgrades and upgrades are you know the least pathological and most expected type of contract change, which is, that someone just pushes an update to their contract. Because like life goes on and they've added teachers or they fix bugs, that's, that's something everyone does in software. And so I think expressing it in protocol is actually a good idea I'm in favor I think two or even three I think three can be layered on top of two like it can be done as a future extension so. If it's going like MVP like we could just do number two initially. And then have you know an additional flag on the thing called indirect reference rather than direct reference and, that's not the end of the world. But I think building another product I mean this is like I'm a broken record I always want to build stuff into the protocol. So this is no surprise coming from me. But I'm definitely on the do it in a protocol level it's 100 of contracts are going to want to upgrade themselves at some point. So it feels like supporting, that is quite natural

[28:00] yeah I think, that was a really good explanation from D mind grade I'm I've changed my mind also one more Point like you have mentioned native as in the contract I don't think you have a good user story for, that. But I think actually this functionality probably can be leveraged. Because I'm not 100 sure. If it will be ever able to kind of make current contract implementations native without a lot of fun guns especially like alternative implementations of the same interface, that are slightly different, which means, that you know in the future you could say update current contract not tourism. But to any different implementation so, that's another consideration and another benefit of having this in protocol versus just something, that Hulk

[29:00] builds with contracts foreign there's one aspect of the way this we're implementing this, that I saw getting discussed in Discord there was conversation about changing how Earth worked with updating so, that signatures froth included the wasn't hash itself so, that. If an update occurs everyone's signatures get invalidated I'm curious I guess like what the motivation for, that is yeah I'm to be clear I am kind of neutral to, that idea I think you can either do it or not do it there's a motivation was mostly about culture and security implications like it adds

[30:00] some degree of additional confidence right in what you're signing coming back to the most example of Hayes is the same contract well it kind of can be sure and I think this makes the most sense. When when probably more concerned not about the implementation changing to something, that is clearly malicious say you know there was a token balance and sensor it's an update and admin. Now can transfer your whole token balance elsewhere oh they probably can do this anyway. But I got the point right. So like we are not talking about malicious upgrades here. But let's say you just want contracts to be audited. If they are updated like you do not trust contracts by default would say we have some database of trusted contracts right and. If the contract is getting

[31:00] updated chances are it won't immediately get to this database for example you know we can connect your wallet to it or something like this, which kind of makes it reasonable to just sign for a certain implementation and you know. If it has changed. Then it will basically get to learn it about this or something like, that. So basically your wallet will be more aware about what you are signing and there is more possibilities for the audit let's get inside of course this is all just Theory I don't know this will happen in reality. But this is something, that we enable. If we add implementation to the US payload. So let's say it again yeah. Because it sounds like I wasn't sure. If this was like part

[32:00] of the core idea what, which I think it sounds like it's something we're just sort of considering on the side. Then yeah I think my concern about it is, that it's more of like an advanced user it sounds like more of something, that like an advanced user would care about I'm not the general user and to enforce something like, that on the general user I think would actually create problems you know in the moment, that a contract upgrades anybody who's currently submitting your transaction is going to fail the vast majority of those users probably don't care and they probably just want to go and gonna have to go resign something, that they would have been happy to go through anyway and I think I like we always have the weak link, that a contract developer could just implement the proxy button sorry, that you know the thing, that you're signing doesn't change. But the thing with the logic actually is will yeah sure it's I guess as I said it's

[33:00] more about the question of Trust basically let's say you have some swap contract, that doesn't actually hold any balances. So it doesn't really care about you know. If someone can suddenly drain funds from it. But you do care about its implementation and again this kind of needs some mechanisms for accessing some audited implementations results, that of course it makes zero sense with, that it makes some sense for the cases. When you have some contracts, that per C doesn't matter much. Because yes country proxy pattern could be implemented right. But then you know like would you trust this contract in the first place right yeah talking about this use case for you know you worry about the contracts being audited and

[34:00] right, that's something I don't really know for. Now how, that would work right. Because in general having some trusted contracts contract implementation databases is something, that seems like a good idea. But for those days will need to be built by community and I don't know to each degree only to cover all the cases. So yeah as I said I'm kind of partial in the city as well I understand some arguments for it and interest against it you know for some it will be just an annoyance thing not sure maybe we should ask for Timbers and thinkers opinions. Because saber advocating for I didn't maybe they have more arguments as well right yeah. So I'm I don't disagree, that this probably has some utility. But but I feel like there's an opportunity here

[35:00] for us to implement this in such a way, that it's not required you know it's not part of the like you know. If we make it part of the signature. Then in theory everybody has to buy us into this model this very over cautious I'm only going to use something, that's yeah like basically buying into, that whereas. If we find a different way to implement, that requirement such, that it's not actually part of the signature. But maybe it's part of the you know like we have the footprint for example maybe we have something like the footprint, that lists out the wasm hashes of the contracts, that you're invoking and the protocol just checks, that. So it's actually part of the signature for the actual invocation. But it's part of the signature for the transaction maybe I don't know yeah actually, that's a great point now, that I think about it you kind of oh it's not you it's a transaction Source who is signing the footprint

[36:00] but, that's an interesting point. If the contract updates, that transactions will anyway fail. Because they are accessing a different wage or entry it just kind of interesting right like of course it needs to happen in the short time window between like pre-flight snapshot getting updated and the contribution update is in this window and the transactions will still fail. So yeah I don't know. If it would necessarily be part of the footprint. But maybe something like the footprint. If it can't be part of the same thing yeah just where you could list out you know these are the contracts, that I'm willing to be executed in this oh right yeah. But but truly thinking about it seems like the window where you would sign something basically you could just do this soft chain right maybe you shouldn't really worry about plotting the transactions with this. Because like. If you really

[37:00] care about, that and your wallet has some logic, that can, that has some base of trust and implementations right it just can be maintained by doing some redundantly requests to the lecture snapshots, that are presumably fresh and probably from the security system point it's going to be really, that much different from signing the version hash. Because because the time window for the contract has been updated. But the snapshot of The Ledger hasn't been updated kind of coincides with the pre-flight call anyway. So your transaction will still probably fail. Because it has invalid footprint maybe signature shouldn't be even concerned about, that like first really need to align for you to basically sign a call without knowing, that the contract has been updated and actually relating it as I'm not sure

[38:00] possible. So yeah I think, that's maybe a good point and we shouldn't worry about it's too much and it seems like the just the forward side implementation is reasonably safe. If you really concerned about what contracts you're calling are there any other open questions Dima about the implementation of proposal number two, that you want to consult with a group actually I think it's super straightforward yeah I think it's pretty easy to use and doesn't introduce too much percent unless as well. So yeah

[39:00] okay are there any other questions from anyone else on stage or in the audience okay this has been very productive thank you all and we can keep chatting on the on Discord. If you have any further questions have a great day y'all

</details>

---
title: "Stellar Next-Gen – Technical Deep Dive into Stellar"
description: "A technical walkthrough of Stellar’s architecture, covering how the network works end to end—from nodes, ledgers, and transactions to consensus, governance via CAPs and SEPs, and hands-on development using Horizon, SDKs, and Stellar Laboratory."
authors: [justin-rice, marta-lokhova]
tags: [community, CAP-38, SEP-31]
---

import YouTube from "@site/src/components/YouTube";

<YouTube ID="umyvd60fV9g" />

This session delivered a deep, system-level explanation of how Stellar operates under the hood. The discussion started with the fundamentals—nodes, accounts, ledgers, and transactions—and gradually built up to how those pieces fit together to enable fast, low-cost, and final payments on a global network.

From there, the speakers explored Stellar’s unique approach to consensus and governance, comparing it to proof-of-work blockchains and explaining why safety, determinism, and low latency are core design goals. The session concluded with a practical developer walkthrough, showing how builders interact with Stellar using Horizon, SDKs, and Stellar Laboratory to issue assets and submit transactions.

### Key Topics

- Stellar network fundamentals
  - Nodes running Stellar Core maintain a shared, immutable ledger
  - Accounts, balances, and operations as the core ledger primitives
  - Transactions composed of up to 100 ordered operations
- Ledger updates and transaction flow
  - Transactions submitted by users and applications worldwide
  - Validators agree on transaction sets every few seconds
  - Once applied, ledger changes are final and transparent
- Consensus and security model
  - Stellar Consensus Protocol (federated Byzantine agreement)
  - Quorum slices, quorums, and open participation
  - Preference for safety over liveness to avoid forks and reversals
  - Comparison with Bitcoin and Ethereum consensus approaches
- Performance and sustainability
  - Fast finality with single-confirmation settlement
  - Very low transaction fees compared to proof-of-work systems
  - Energy-efficient consensus without mining or heavy computation
- Open-source governance
  - CAPs define protocol-level changes to Stellar Core
  - SEPs define standards for building interoperable applications
  - Network validators vote on protocol upgrades
- Developer stack and tooling
  - Stellar Core, Horizon API, and language SDKs
  - Using Stellar Laboratory to build, sign, and submit transactions
  - Live demo of issuing assets and querying ledger state
- Getting started as a builder
  - Testnet usage for safe experimentation
  - Learning paths via documentation and Stellar Quest
  - Community-driven development and contribution

### Resources

- [CAP-0038: Automated Market Makers](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0038.md)
- [SEP-31: Cross-Border Payments API](https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0031.md)
- [Stellar Laboratory](https://laboratory.stellar.org)
- [Stellar Quest](https://quest.stellar.org)

<details>
  <summary>Video Transcript</summary>

[00:00] Justin Rice. I'm the VP of the ecosystem at the Stellar Development Foundation, where I work with people to understand, how to use the network, developers and enterprises- and at the SDF. Our goal is to support the open source, open participation Stellar network, of which you will hear a lot about in a minute- in order to increase equitable access to the world's financial infrastructure. Marta hello, and yeah, I'm Martha Lakova. I'm a software engineer on the Stellar Core team at cell development foundation, and so I work on the actual implementation of a distributed ledger, which is what powers the Stellar network. So really excited to be here with you. We ready, all right, we are going to dive in. This is going to be a fairly in depth explanation of Stellar and of the blockchain technology that powers it. We're going to talk for a while, hand it to Marta, and then we'll probably pause about halfway through for questions and then we'll sort of dig, roll up our sleeves and sort of do a little bit of

[01:00] Playing around with the actual network. So, technical, deep dive, interstellar quick agenda. I'll explain how the Stellar network works. I guess I just sort of went through this. Give it to Marta to talk about how it compares to other blockchains, and then we will talk about sort of open source and an open source project, and then we'll use the Stellar laboratory and leave some time for Q&A. Okay, the Stellar network is made up of nodes. What are nodes are computers that connect and communicate with one another to keep a common accounting ledger and to approve and ratify changes to it. So on the image on the right, all those dots, those are nodes. Stellar's open participation, so anyone can spin up one of these nodes and they run this thing called Stellar Core that Marta helps build. It's decentralized because these nodes are run by independent individuals and organizations all over the globe. So each of those dots is a computer running style according to community,

[02:00] The common ledger that nodes work together to keep it's stable. Physics major in the college, nice, and you guys are all students. Can you please mute your microphones? Thank you, I thought that was like a like, just like coming in hot with a question at the top and I would. I approved that level of verve and engagement. Okay, ledger, understanding the ledger. So I said that knowns work to keep a common ledger. It's stable, it's secure, it's transparent. Stable because the network is spread over a bunch of servers and computers all over the world, so you can't turn it off. There's not a central server. It's secure because the ledger entries are immutable, right once a transaction has been processed. No one can change the data or manipulate the numbers to their liking. And it's transparent because, like many blockchains, like all black public blockchains, everyone can see the ledger and trust that the information is correct. That's the ledger. So nodes keep the ledger. And what's on the ledger? Well,

[03:00] Accounts are the essential data structure in Stellar. They are saved on this global ledger. They hold balances, they sign transactions, they also issue assets and account access is controlled by public, private key cryptography. So every Stellar account has a public key. Usually they start with g and every account also has a secret key, which always starts with an s. The public key is safe to share, right? That's how people identify your account so they verify you, authorize the transaction. It's kind of like your email address: people need to know it to send you an email. That reference feels probably dated to many of you. Your secret key, however, is private information that proves that you own your account. It's like your password can't share with anybody. You use your secret key to sign transactions, which essentially call functions that change the state of the ledger. So transactions, that's the next word. Transactions on Stellar are made up of. operations, which are the actual

[04:00] Functions that change the ledger. So a payment, that's an operation offered to buy an asset, that is an operation. Now, this is Stellar vernacular. Here it's a little confusing because operations- honestly, that's what most people think of when they think of transactions. But on Stellar you can actually bundle 100 operations into a single transaction. You can put them in a specific order. They execute in that order. You can use that to do some interesting things. We won't get into it right now, but when I say operations you can kind. of think transactions. Most transactions in fact consist of a single operation. Each of the entries that you see in this example ledger, that's a single operation transaction. So Lisa sends me fifty dollars. Thank you, Lisa. Transactions are time stamped and they contain unique identifying information and every three to five seconds- those nodes that we talked about earlier- they bundle all the transactions together into a set. They apply that set to change the state of the ledger. Let us

[05:00] Walk through that process. So it all starts with a ledger, which is, again, is essentially a list of accounts and balances. It's like a giant spreadsheet and a sql database. Users, wherever they are in the world, they submit transactions to send and exchange assets on the network. Some of these are individual users with Stellar wallets. Some of these are businesses using making b2b payments and using Stellar, they can move funds anywhere in the world. They can convert currency along the way thanks to a built in system of exchange that includes orderbooks and automated market makers, which we will talk about later. These transactions are essentially bundled into sets, they're confirmed by validating nodes, they are applied to the ledger, at which point they're final and create an immutable record, and then the whole process starts over. So why is a blockchain ledger immutable? Why can't someone change the previous entries on the ledger? How do these transaction sets come together and get finalized anyway? To answer those questions, I'm going to pass the mic to Marta, who's going to dig in and explain how blockchain protocols work generally

[06:00] And also how the Stellar consensus protocol works specifically. Marta hello, Justin, thank you. Always great to hear you talk about these things. So yeah, so let's dive a bit deeper into technical aspects of the Stellar network and the Stellar consensus protocol in particular. So to do this, we're going to put things into perspective. We're going to compare Stellar to two biggest blockchains out there: bitcoin and Ethereum. So let's start with the intended function of these three blockchains. So bitcoin was the first blockchain to show a decentralized, completely native store of value, excuse me. So we think of it as the first internet native money. Recently, more and more people have been referring to bitcoin as digital gold, due to its scarcity and potentially a way to beat inflation. But in this talk, which is going to focus on, kind of, the initial goal of bitcoin as outlined in the bitcoin paper, which is digital money.

[07:00] On the other hand, Ethereum acts as a general purpose decentralized computer. So what I mean here is that it provides infrastructure for developers to write programs or smart contracts that can really execute anything. So this allows a variety of different applications on the Ethereum network, so things like NFTs or borrowing, lending applications, asset issuance and so forth. And so, finally, Stellar focuses on payments. So Stellar is really good for fast and cheap payments, as well as issuing digital assets on the network. For example, on Stellar you can issue stablecoins such as USDC. So next let's compare consensus mechanisms for each of these blockchains. So bitcoin and Ethereum both use proof of work which we're going to discuss in a lot more detail in the next slide, but for now, I also wanted to know that Ethereum. is actually in the process of a major upgrade, as they're moving away from proof of work towards proof of stake. So, while the intended

[08:00] Proof of stake model actually has some better properties when it comes to securities and scalability. In this talk we'll mostly focus on the current state of Ethereum and then so for seller. It actually used a completely different approach to consensus. Specifically, it uses federated byzantine agreement, which is implemented via the Stellar consensus protocol, to achieve consensus. So let's actually dive a little deeper and try to understand what different differentiates all these consensus mechanisms. So first I just want to kind of step back and emphasize that a consensus mechanism is vital for the security of the blockchain. It is essentially what allows all the nodes on the blockchain to agree on something in a safe way. If nodes don't agree on transaction in a safe way, it opens up a possibility for double spend attack. So a double spend attack is essentially spending the same money twice. A quick example here: imagine paying five dollars for parking but then spending the same

[09:00] Five dollars to buy an ice cream. So you received the goods for a total of value of ten dollars, meaning that you got the parking space time and you got an ice cream, yet you only paid five dollars for everything. So consensus mechanisms want to ensure that such a scenario can happen. So now let's dive a little deeper into what a proof of work system is. So to reach consensus, nodes need to agree on transactions to confirm in the next block. In proof of work systems, each validator solves a very difficult math problem that requires a lot of computational resources. It is also proven that there's no shortcuts to the solution. So the only way to get to the right answer, is to actually perform the computation, I e show the proof of work. So validators- the first validator that solves that problem- essentially gets to create the next block. And then validators that create creates that block, they broadcast it to everyone else on a network.

[10:00] So as other nodes on the network discover the new block, they basically accept it, since it's essentially a longer chain, and then, once they accept it, they can start working on the next block on top of that newly created block. So here again I want to kind of emphasize that validators on the network accept the longest chain. So if the validator is first to mine the block, it basically creates that longer chain that is later discovered and accepted by others. So another thing about proof of work is that validators are incentivized to participate in the block creation that we just discussed, because they receive monetary rewards in the form of coins for producing these new blocks. And you might have heard about this process is called mining and it's very popular. So now let's shift gears a little bit and talk about how Stellar approaches consensus. It's actually a completely different consensus mechanism because there are no computationally heavy tasks.

[11:00] So instead nodes select other nodes on a network that they trust and they exchange messages with those nodes to agree on a set of transactions to confirm in a particular block, and we call these sets of trusted nodes quorum slices. So let's unpack what quorum slices actually mean. So to understand how consensus is reached on Stellar, let's first look at the examples of these quantum slices that we just discussed. So recall that a quorum slice is a set of nodes that a validator chooses to trust. On the right we have a network of four nodes: a, b, c and d, and we express trust relationship between these nodes with arrows. So, for example, a has b and c in its quorum slice and another example is node b: it has a, c and d in its quorum slice. So now that we know what quorum slices are, let's define quorum.

[12:00] So quorum is a non empty set of nodes that contains a slice for each member. So, for example, a, b and c is not a quorum? Why? Well, because it actually does not contain a slice full slice for b and c. If you look at the diagram, so you see that d is in the quorum slice for both b and c, so it must be in the form. On the other hand, a, b, c and d is a quorum because it hand a, b, c and d is a quorum because it includes a slice for each member. So now that we know what quorum slices and forms are, the key detail of consensus on Stellar is that network. The network only confirms a block if a quorum agrees on that block, so it needs the agreement of a whole quorum to confirm the transactions. Great. So now that we've talked a little bit about consensus, let's switch to open participation. So what does it mean to have open participation? It means that there's no central

[13:00] Authority allowing or preventing you from participating on the network, meaning that anyone can join and start validating transactions and participating in consensus. And we wanted to include this feature because it's just so vital for decentralization. As and as you can see, all three networks have that, but we thought it was important to include this feature as well. All right, cool. So next we have some key security properties to go over. So, as you can see, bitcoin and Ethereum prefer liveness and Stellar prefers safety, and you're probably very confused because I haven't defined either liveness or safety. So we're going to unpack this, so we're not going to spend too much time on the actual computer science theory here. But the most important point that I want to convey is that there are three desired properties that consensus mechanisms always want to have. So those are safety, liveness and full tolerance. What do they mean? So? Safety is a guarantee that all nodes produce the same block, the same valid

[14:00] Block, meaning that nodes can't produce contradicting block blocks. Aliveness guarantees that nodes will eventually produce a new block and won't just hold and you know be not being unresponsive. And then, finally, fault tolerance ensures that the network can tolerate node failure. So either nodes going down or actually becoming malicious and sending like conflicting messages to other nodes. So in distributed systems it is proven that you can only have two out of three of these properties. And typically consensus protocols always want to guarantee fault tolerance. And because consensus protocols select fault tolerance, they're left with deciding between safety and lightness. So what exactly happens when either safety or liveness are selected? So if we choose safety, which guarantees that all nodes will produce the same block, nodes will get stuck until they can. They

[15:00] Nodes will get stuck until they can all produce the same block. Remember, Safety means that nodes can't produce differing blocks. On the other hand, if we choose liveness, nodes choose to produce a blog, any blog, meaning that they choose to stay alive, but they may produce a block that will later be overridden by a different block as network advances in consensus. So this potentially invalid block is actually what can open up a possibility for a double spend attack, and we'll look into example of this a little bit closer in the next slide as well, yeah. So let's see a visual example of how liveness is picked over safety. So here, yeah, each clipboard icon basically represents a block, and so as new blocks are propagated on the network, nodes can learn about it at different speeds. So it's actually possible for two blocks on the network to have a different view of the blockchain. So remember how nodes choose to follow

[16:00] The longest chain in proof of work systems. But what if some nodes haven't learned about the longer chain yet? So they continue to follow the chain that they currently consider the longest, and this is how you can end up with a different view of the blockchain, as we try to show in this example. So, on the other hand, let's look at the network that prefers safety over liveness, which is what Stellar consensus protocol does. So the important thing to realize here is that a split that we had in proof of work systems can actually never happen because Stellar consensus protocol prefers, or chooses safety over liveness. So instead, nodes hold if they can't agree on the same block. So if there is no quorum that agrees on a particular block, nodes just hold and stop processing transactions. So we just covered some important security properties. Let's actually see how long it takes to

[17:00] Confirm a transaction on these blockchains. So every bitcoin block takes about 10 minutes, while Ethereum blocks block is about 13 seconds. Note that we also included the number of confirmations needed to consider the transaction final. And this data is from coinbase. So remember that in proof of work systems, nodes continue producing blocks and as they discover newer blocks on the network, they might switch to a longer chain, potentially abandoning the previous chain they considered longest. So because of this, we typically want to wait for the network to confirm several blocks after your transaction made it into a block. So- and this is needed to reduce the chances of the network switching to another longer chain, and so on coinbase, as you see in it in a table, users wait for three confirmations for a bitcoin transactions and on

[18:00] Ethereum it's a 35 confirmations. So this is completely different. On Stellar, there's actually no need to wait because, exactly because of the feature that we just described in the previous slide, where Stellar prefers safety over liveness, so because the agreement of the whole quorum is needed in order to produce a block. Once a block is produced, operators can be sure that the block won't later be revoked. So once it's confirmed, it's confirmed, and on Stellar, a block is produced every five seconds and only one confirmation is needed to deem the transaction final, exactly for the reasons that we just described. Okay, so now let's also look at the average transaction cost. So again, we averaged the data over the past 12 months. As you can see, it's quite different acro across these networks, and I just also wanted to kind of point out that

[19:00] This fees fluctuate is they depend a lot on how much competition there is for a particular transaction to be included in the block. But kind of the most important point that I want to make, here, is that is the order of magnitude difference between Stellar and these other networks, despite the fact that these fees fluctuate. All right. So now let's talk about sustainability. So, as you can see, proof of work systems require high energy consumption, and energy consumption on Stellar is quite low. And why is that so? Remember how we said that in proof of work systems, nodes try to solve a heavy computational task as fast as they can. So this is directly related to energy impact. So heavy computational tasks require a lot of cpu, which in turn requires a lot of power, and in proof of work systems, validators are essentially incentivized

[20:00] To have high quality hardware that uses a lot of power in order to increase their chances of producing the next block. This is different on Stellar. So because Stellar does not require computationally intensive operations to reach consensus, and instead it has nodes establish trust, relationship with each other and just exchange messages to reach consensus, this can actually be done on the very modest hardware and it does not require a lot of power. All right, so we just talked a lot about a lot of things, and the final feature that I want to talk about is resistance. to 51 attacks. So what are these attacks? So again, remember that proof of work systems nodes that solve a computationally heavy task, they get to produce the next block. So this is also directly related to how much computational power a validator has. a lot of computational power, it is more likely to

[21:00] Win the block race and have the network accept that block. This means that if validators with over 50 percent of the computing power become malicious, they have the ability to take over the network and dictate every subsequent block. So, as an example, if a top few miners in a bitcoin network colluded, or, for example, a large government felt threatened by bitcoin and invested a lot of resources into mining rigs, the network could be taken over. So on Stellar, such an attack is not possible because computing power is not a feature of consensus. On Stellar, nodes choose other nodes that they trust to decide which transactions to confirm. In the blog. Nodes do not accept the block based on computational power. So this means that even if an attacker adds a million nodes to the network, this will not impact consensus as long as nodes in network do

[22:00] Not add those malicious nodes to the quorum slices. And so usually nodes on Stellar add organizations that they trust to the aquarium slices. So this means an attacker will need to convince other nodes to you know on the network to add attackers nodes to the quorum sizes, which can be difficult. All right, great. So to summarize: the Stellar consensus protocol is a federated byzantine agreement which allows for open membership to support growing decentralization. It has low latency, which allows fast transaction times. It is resistant to malicious actors and 51 attacks and it prefers safety over liveness to prevent forks. And I know I just said a bunch of things. I'm going to stop here and see if there are any questions. Before giving back to Justin

[23:00] Any takers any questions about consensus protocols, about the Stellar consensus protocol, I'm always thinking that I trip over federated byzantine, agreement system sometime and I'm like, oh, we should. I want to call proof of vote or something. That's not a question. Shy students, if you have questions, sometimes they put them in the chat too. Marta, oh, yeah, right, we can do chat as well. Oh, somebody, really encourage you guys to ask questions. Yes, yeah, hi, I was wondering if so. If, when you're talking about security or safety versus liveness, like how does seller have low, isn't that what's the benefit of live, of like liveliness, if the speed for transactions is still faster on like Stellar, like why would anyone choose to value liveliness? I think it's just that those. consensus protocols are like completely different, like so on Stellar, for

[24:00] Example, yeah, you prefer safety, but then you have to also select your quorum set correctly and make sure that it's actually configured correctly, which can be sometimes like difficult. And so, like you know, on this proof of work systems, I think that's just like a feature of consensus. Yeah, because you know this, you can basically have like multiple chains at the same time, and because it's a distributed system and you know these computers need to learn about these different chains. On the proof of work system, then they can have like a partial view of the network at the time. So I, I'm not sure that. Well, you know, one thing I sometimes think about with Stellar is like the validators on the network are known entities, so, as smart to point it out, like they have to trust one another. They have to opt into adding entities to their quorum set. They know who those people are. And so when you value safe, safety right if the network

[25:00] Halts, what that means is that, remember, it's a decentralized network. Nobody has the ability to turn it off. No one can just turn it back on either. Right, like you actually have to coordinate validators if a network holds, and so I almost also think that like one feature, one necessity for, like a network that does value safety over liveness is that validators have to be able to find one another right to restart the network if something goes wrong. And I think on a lot of like in networks that are proof of work, where miners are basically like anonymous- I don't even know if that would be possible. Yeah, and I think, like because Stellar was designed for payments, like it was really important, then if you know, if something happens, like some kind of split on the network, like everybody just stops, you know there's no kind of forking and continuing to different views of the world. If nobody can agree on one view of the world, everybody just holds. So it's kind

[26:00] Of like a important feature, given how the network is used, you know, like for payments, for cross border payments and like assets. Thank you, Marta, that was awesome. All right, I'm going. Okay, I'm picking it up and I'm talking about open source contribution. So all of that martin talked about is super awesome. That is, there is a code base, that sort of all these nodes run that allow them to run to sort of talk to one another to vote, to come to consensus to ratify transactions. And a fundamental ethos behind the development of that code base- and it's part of what makes me love SDF- is that it's open source, right. Anyone can review the code, anyone can contribute to the code. No one owes the owns the code right, it's open, it's free, it's participatory. You, listening, can join the good fight.

[27:00] Today you can work on the code, all you. need is a GitHub account. There's a wide world of innovative Stellar developers, and while many of them are focused on building their own apps and services that make use of the network, which we'll talk about in a second- the sort of application layer- many are also contributing to helping evolve the software that powers the network itself and that software that powers the network. It never sits still. It's constantly being iterated, improved on, worked on in order to fulfill the needs of the ecosystem, including all the projects that are built to the application level. So here's a question: if you have this code base and it's evolving and no one owns it well, how does it evolve? And I'm going to talk about that quickly. Two main ways: Core Advancement Proposal and Stellar Ecosystem Proposal. Bear with me here. Court advancement proposals, CAPs. This is a method that we sort of came up with the foundation. Actually I don't even know who started it. But at this point it is a codified process to allow contribution to come in and amend and update the code that runs. Stellar Core

[28:00] That martin talked about. So coordinates my proposals. They're suggested changes to the protocol of Stellar. They have a direct effect on how the network operates. They're about 40 plus of them. Each one outlines a specific change and they're used to add new features to the network itself. So a recent example is one called feedback transactions, which allows fees to be paid by any account on the network and it enables an application to cover its users transaction fees. Now network fees are handled at the protocol level. So this new feature, it required a new operation to be built into the protocol and that's why it had to be implemented in Stellar Core and that's why it was a CAP according proposal had to be done that one. Incidentally, we just added automated market making functionality to Stellar Core, CAP 38. I'm not gonna get into it right now, but it was super cool two weeks ago. So CAPs, they have a life cycle, right, it's a multi SEP process to ensure it's high quality and backwards

[29:00] Compatible. For CAP to be qualified, classified as final and go live on the network, it has to go through all these stages, has to be implemented in the code but then, fundamentally, before it actually hits the network, it has to be accepted by a majority of the network. Validators. Vote on the protocol number. The network runs using the same Stellar consensus protocol they use to ratify transactions. So, governance wise, anyone can contribute to code, can be implemented, but before it is, actually adopted the network has to give it the thumbs up. Now that's different. That count process is different than the other kinds of standards that live outside of the Stellar code, Stellar eco system proposals, SEPs for short. These deal with changes to the standards and methods used to build on top of the network. Again, there are 40 plus of these for various purposes. They're labeled by numbers. These don't alter the Stellar code, but they are technical blueprints that allow developers to agree on how services using the network should be implemented to allow for maximum interoperability. So basically, a lot of the times these

[30:00] Say: here's how to set up an extra network api. There they detail, like sort of two sides of an interaction: server side, how to create the api, the client side, how to consume the api. Again, they also follow a life cycle from draft to final. I'm going to give you an example. so this is less abstract. SEP 31 is a standard that allows businesses to make compliant cross border payments on behalf of two users. So imagine a user wants to make a traditional remittance payment, right, they log into admittance providers website, they provide funds and they enter information about the recipient and they want to have the money just show up in the recipients account. They don't even know they're using Stellar, but they're working with companies that have integrated Stellar on the back end. So to complete the, transaction and comply with regulations, the remittance provider, they actually need to know the recipient's bank account and routing number and they need to collect KYC information about the recipient and to do all that they're receiving and they need to share it with the receiving party. Right, so

[31:00] There isn't a direct path between two yet user Stellar account on network and so instead the anchors will create, use a SEP to create these extra network apis that allow them to share KYC information. Okay, that was sort of a lot. Again, that was the code. Marta talked about, the actual consensus protocol. Those two things- SEPs and CAPs- were the ways that the code evolves. But in truth, interacting with Stellar is actually quite simple and because we're actually going to move way up the stack now. So most developers who are building on Stellar, they aren't necessarily working CAPs or SEPs, they aren't necessarily thinking about the protocol level or interacting with Stellar Core in the raw. Every day they're using an SDK, a software development kit, in their preferred language, and those SDKs are interacting with a network api called Horizon. So this three tiered stack of responsibilities, it sort of divides things so that each piece of software

[32:00] Can focus on its specific purpose right. Stellar Core concentrates on transaction submission and consensus. Horizon provides an ergonomic interface to allow people to submit, to actually interact with the network, and SDKs kind of abstract away the complexity in a variety of different languages. So when you're developing on Stellar you can for the most part kind of not think about what's going on in the hood- at least not all the time- and you can just use an intuitive rest api to submit transactions, query network data. It's actually pretty cool, but again that feels a bit abstract. So let's make it concrete. We actually have a thing called the Stellar laboratory. This is a handy tool that you can use to build, sign and submit transactions to the network and you can use it to query all the api endpoints and to understand what that means and how to use it. We're going to do something quickly right now. I hope this. works. We're going to issue an asset, so we're going to do it on the test net, which is the development sandbox for Stellar. It's just like the main public network, but it's not connected to

[33:00] Real world money. So this is the process for issuing an asset on the test net. It would be the same for the real network. Quick overview: okay, and issuing an asset requires a number of SEPs and the basic way to do this, which is covered in the developer docs- the easiest way to do this is to create two accounts: one is an issuing account and one is a distribution account, because in order to issue an asset on Stellar, one account has to trust the other to give it the asset and then that account has to make the payment. This might seem weird, but you'll see what it looks like in action, and so I'm going to now open Stellar laboratory. Let's see, are you seeing Stellar laboratory? Okay, this is Stellar laboratory and, as you can see, it's on the test network. I first want to create two. new Stellar accounts, so this is what we will call the issuing account.

[34:00] It's really crazy. And then, because in real life you would need to actually fund this, every Stellar account requires a minimum balance of lumens in order to exist on the ledger. To prevent spam. In real life, you'd have to fund it with real lumens. But again, we're on the test network, so I can just get test network lumens. Now this account has its minimum balance. That is my issuing account. I'm generating a second account. This would be the distribution account. Okay, saving these on a handy spreadsheet. In reality, you would be very careful with these keys. And again, I've generated that key pair that I need to fund it. And so, again, this is Stellar laboratory and what I've just done is created two new accounts. But, as you can see up here at the top, there's all these different tabs that you can use to actually understand what's going on the seller network you can actually build, sign, submit transaction and explore endpoints. So, to start with, we're just going to

[35:00] Build a couple of transactions and what we're essentially doing is we're taking that second account that we created, which is the distribution account. I'm adding it here. I say: fetch the next sequence number. I set the fee I'm not going to worry about time balance, but this is me constructing a transaction and the operation type is going to be change trust. So to change trust, I'm going to basically believe in an asset that exists, called you shy, that is actually issued by the issuing account. So again, what I'm doing here is, with the distribution account, I'm trusting the issuer account for an asset called you shy. I'm basically going to see that I have generated the, right transaction envelope and I'm going to sign this in the transaction signer. Let's hope this works. So I need for that I need the secret key, if you recall. I need the secret key of the account

[36:00] And then I can submit the transaction in the transactions. This is a three to five seconds, as you can see. I submitted the transaction and the transaction is complete. Again, this interface you can use to sort of create any kind of transaction. I'm going to do one more transaction really quickly, which is basically with the issuing account. I'm going to make a payment, so I'm putting in the issuing account. Now I'm fetching the next sequence number, I'm going to create a payment operation- this always makes me nervous- and I'm going to send it to that distribution account. Here is a distribution account.

[37:00] I'm going to send I don't know 13, 13. Not many. Again, I can sign. this with the public key for the issuing account. So again, this all feels a bit strange, but I'm going to wrap it all together so nicely in the end and once I sign it I can submit the transaction. Let's hope it works. Transaction submitted, okay. So what I just did was that I basically created two accounts. One is a issuing account that actually creates and sends the asset in a distribution account. The distribution account essentially linked to the issuing account and said I trust you to send me an asset and the issuing account made a payment to the distribution account and now that account will hold a balance of the asset. And that was basically. We just issued an asset on seller. You can issue any asset that represents anything with any asset

[38:00] Code, and it's just as simple as that. Just a few things that you can do in this interface: or you can do it with an SDK- now one. Final thing, as I mentioned, Horizon is an endpoint. I mean, is that api that has different? endpoints? And this interface, the Stellar laboratory, will actually show you how to construct various queries to the Horizon endpoints. So right now, if I go to Horizon and I sort of query the distribution account, what it should have is a balance of this asset that we just created, oops. So I'm going to put it here and you will see that, in fact, if I scroll down to the json response, that it does have a balance of this huge, shy asset. So what I essentially did was issue into. this account a new asset that never existed before on the ledger. Now, part of what's cool is that this actually happened on a test network that replicates the real network, and all of

[39:00] That payment, all that issuance was actually done on multiple nodes. And now I'm going to open just like a totally different thing. This StellarExpert is a block explorer for the Stellar network. It's not something that we built, it's not something we maintain. It's actually maintained by a company in ukraine, right, and this is basically a way to view actions on the Stellar network, and I can. It's set up to view the test network, so I can actually go to a totally different third party interface. I can look up the key right, and I can see that, oh, look, there is the public key, there's the asset that it issued, there's its balance. Here are the transaction history. Here's what we just did and like this is sort of the way that it fundamentally works, is that, using this api, you can create payments, make payments, issue assets, and all of that activity is actually done on this sort of like common blockchain that you can view from almost any other source,

[40:00] And so that is asset issuance on. Now I accidentally stopped sharing my presentation, sorry, okay, is there more to do here? And so there you go: those features right: the ability to issue assets that allow you to build an interoperable world, because all kinds of companies or single devs can sort of build, issue assets, build interfaces that connect to the blockchain, and it is very easy to get started right. Stellar, again, supports common development languages: javascript and python. There's extensive documentation, developers can build and operate on the network with very few resources, and there is this test network and we have great documentation which you can find at developers steller org

[41:00] So for anyone who is sort of here and wants to build on Stellar, you can get started immediately. I guess the final thing that I do want to say: oh no, there's way more. The next thing that I want to say is that, also, if you're interested in learning more about Stellar and doing some hands on stuff with that laboratory, I would suggest that you go to `quest.stellar.org` and, after signing up, with Discord and your albedo wallet, you can basically compete in quests to win an NFT badge several times a year. There are live series where you can compete. This is basically a gamified intro, Stellar- that lets you learn if you're going to do it. I'd recommend starting with the practice. Quests start with quest one and you'll need to create an account, like I just did, and then it will sort of walk you through processes that you need to the resources that you need to complete the quest and you'll get a set of keys and once you submit the right transactions and you can use that Stellar laboratory interface, you can basically verify your solution, claim an NFT. It's super fun, even if you don't know how to code, because you can use that interface and if you run into issues, you

[42:00] Can always ask questions. In our vibrant community, we have a Discord server of Stellar clusters and actually that was it. So if you want to find out more about Stellar, go to `stellar.org` again, I recommend using Stellar quest to keep learning, and that was a fairly deep dive. so again it was. We looked at the Stellar stack, we looked at basically the interface and how you can issue an asset. And then, finally, Stellar quest, the gamified way to learn more about Stellar, and now we will open it up for questions.

</details>

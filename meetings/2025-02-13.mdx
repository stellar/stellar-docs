---
title: "OrbitLens showcases StellarBroker and StellarExpert"
authors: [carsten-jacobsen, orbitlens]
tags: [developer]
---

import YouTube from "@site/src/components/YouTube";

## Part 1

<YouTube ID="8UGDT1pGZYU" />

OrbitLens will showcase StellarBroker and StellarExpert services. StellarBroker is a multi-source liquidity swap router that aggregates liquidity from Soroban AMMs, Classic AMMs, and Classic orderbooks. The second part of the presentation will focus on Stellar smart contracts insights and on-chain transaction analytics using StellarExpert blockchain explorer.

Links:

- [StellarBroker](https://stellar.broker)

- [StellarExpert](https://stellar.expert)

<details>
  <summary>Video Transcript</summary>

[00:00] Hello everyone and welcome to this week's Stellar developer me. If you were joining us last week you would have seen OrbitLens I invited him back again. Because we had. So much to cover last time, that we didn't go through everything we we wanted. And so obit Lance has actually built quite a few projects on on Stellar and and one of them I'm sure you're very familiar with is is still our expert. So we're going to cover, that a little bit today. But first we will hear more about sell broker. So yeah

[01:00] just please just introduce yourself again I know introduced you last week. But for new people on here please go ahead and introduce yourself yeah sure hello everyone everybody knows me as OrbitLens I'm the lead of StellarExpert team we're building different infrastructure services on Stellar network and basically today I'd like to talk about two of them Stellar broker yeah. So Stellar broker is a multisource liquidity swap tool and swap rotor for Stellar currently star star has several issues

[02:00] with fragmented liquidity basically it leads to worse price for end users complexity using varas protocols and as a result it's quite difficult to find the best price between all of them. Because some assets are located mainly on classic Stellar DEX and others on new protocol imms. But someone executes like large trade. If someone trades a scale usually such large volume trades are vulnerable to front running and front running actually leads to profit loss on multiart trades. Because splitting each trade into several

[03:00] smaller trades results in a situation. When somebody can front run your Swap and try to be faster and extract The Profit and of course there is simply the question of liquidity. Because I do remember there was a situation where people couldn't simply swap on chain and execute the settlement for about 100,000 USDC in one trade with with one pass payment trate, which is also not the best user experience. So we've been working on the project called U Stellar broker with with the with a team from Ultra Stellar

[04:00] so our original idea was to implement the solution, that will cover everything in one One Stop. When you, that will allow you to swap anything and execute your transactions on chain classic and San it provides a lot of benefits for and users providing better exchange rates front running protection and on large trades it will lead to the minimal price impact non-custodial swaps allow us to avoid centralization issues and and also there is no need to

[05:00] retry failed transactions. Because everything will be retried automatically and even. If the swap fails for some reasons for example liquidity isn't there there anymore. Then the system will propose a new like a new trade opportunity, which will be automatically executed for applications, that want to integrate our service we can offer revenue from user swaps reliable execution flow seamless API integration, which means, that you just connected to your existing wallet and it will work just fine and of course it's a fling the complexity of building for two different networks like classic andoran

[06:00] which is a bit separated despite, that it's under the same Stellar network grof and like managing multiple connections to various swap protocols. So partner, which connects to the system can view the Revenue and receive payouts for the swaps executed by the users this kind of monetizations benefits and users and developers alike. Because users still get better rates and developers can receive like micro bonuses from these transactions from their user base the integration will be pretty is straightforward we already published

[07:00] the SDK for it and everything you will need you'll just need to insert AP from the website and from this point will work will just work and as a hood it's much more complex than than it looks. Because it works with varas liquidity pools on the San. So currently we have Aquarius and S SW pools connected at our production website and we also have two more pools in the pipeline, which expected to come next week it will be forx Hub

[08:00] and it will be comment pool. So our execution engine like finds the best opportunities and first of all analyzes how the trade can be split into many multiple trades. Because executing several different trades instead of one large transaction means, that there are chances to to get front run or to just end up with a failed transaction. Because the market is always a dynamic scene it's moving a lot and it's virtually impossible to guess, which liquidity will be there like in the next Ledger. So our engine fls all the complexity here. Because it

[09:00] provides tracking of submitted transactions it automatically connects to Stellar core fetching all the required information from there and we basically can basically have the entire graph of all available DEX orders there in memory and of course graph for soran soran tools this is everything is located in the same place and provides you a very convenient interface on top of web soet API, which is pretty fast we made some measurements and like average quart response time is less than 300 milliseconds, which is very fast and usually like our

[10:00] nod receives updates and send it to user like more than two seconds faster than Horizon. Because we connect directly to Stellar core to receive all the trade information as as fast as possible and we can execute like multiple trade simulation per seconds it's tens of thousands it scales well well with paralyzation of CPU threats. So it means, that getting more simulations results in better price quotes for end users so, that's basically pretty much all of it I just wanted to say, that is it is already connected

[11:00] to albida wallet and we're working to connected to Stellar and other Ultra Stellar applications. If you are interested interested to try it to play around just let us know and let's talk any wallet or like application, that works with user trades U can benefit from this optimized transaction execution flow. So just let us know probably. If if we have any questions in the chat I'll be happy to answer yeah let's let's see. If there's any any questions in the

[12:00] chat there was one about public facing docks I think I've shared a link to to GitHub is there anything else people can go look at yeah it's basically the J Hub link and currently it's the npm package, which shows the example of connection to the system so, that's basically everything you need to integrate great I think it's super interesting also and not not just. Because of the the the ease of use. But also the speed and and and the fact, that you can bring bring bring the swap in on on your own application and and and decide what what fee you're going to charge for for for doing the the swap. So super interesting. If we don't have any other questions

[13:00] we can also see. If we have some time at the end of it. But we can move to StellarExpert and, that should be a tool, that is known by most Stellar developers it was probably the first tool I started using trying to verify, that my transactions were going through and just playing around with with different different Quest and onboarding games. So so yeah it's I think it's familiar to most. So be interesting to hear from the creator of it yeah happy to hear, that and, that's the tool, that been around for years and I'd like to thank you for all the users, that keep up with us and despite sometimes U arise in small bugs problems with it we're trying to keep it

[14:00] as as functional as it could be and today I'd like to talk a bit about smart contract stats and analyzes of smart contract transactions. Because we've been receiving some questions by email and other communication channels on how it works and I think it might be interes in not only for newcomers. But also for season developers still. So first of all how can you get to the transaction and how can you find something you just need to copy paste like account address contract address or proit name into the search box on the website and will lead you directly to the the account or

[15:00] contract history where you can see this list of transactions here you can see operation type and like execution date to check a particular operation you just need to click this small small arrow and it will present you the expanded view I know it's a bit scary. But no need to panic it's only from the first glance we'll go through it and it will be quite there is nothing too complex about it first of all it shows the C tree of the top level contract invocations. So we have this level contract, that can invoke some other contracts and

[16:00] provide provide additional functionality through this. When you click this info icon you can see the expanded view of the contract function itself it automatically shows you parameters of the function return return value value like version of the runtime and SDK and. If developers left Commander. Then you will also see this R commands in this section debit and credit records show the amount of token, which have been

[17:00] transferred like spent received in the trans during the transaction execution. So we can see here for example, that this amount of tokens has been debited from this account and credited to another account contracts can save the data on The Ledger with different storage retention options. So like in data is basically the data, that is inside the contract itself and every time time like the environment loads the instance of the contract it also loads all the data attached to it resistent entries stored separately and temporary items can be used to store some cheap temporary

[18:00] information, that can be easily evicted evicted additionally some contracts may emit events, which is U this mechanism is intended for publishing data for indexers the event consist of the header of the event and some arbitrary contract contract data. So these events can be further analyzed by indexers by rpcs or some other applications and at the bottom of the invocation you can see what happens on the system level. So like input output memory usage Ledger entries written and U read and

[19:00] many other very low level statistics and additional of course here you can see also fees charged for these particular particular transactions, which can be analyzed further now. If we scale up a bit we have a contract view. If you just click the address of any contract you will end up here at the contract View and it will display like the general summary of the contract and current contract balances this is I think is is a liquidity pool contract, that holds XLM and you DC

[20:00] assets we have here the information who created the contract and there was some hash of the contract also it was pretty active contract, that made a lot of transfers data storage here shows the number of entries, that have been been written and stored on chain below it you can see the detailed breakdown of all the ocation stats here you can play around with functions selecting some spe specific function you want to to analyze choose the period for starts and and analyze some specific statistics. So for example. If you want to know why

[21:00] these grew up after the recent deployment you can see it here you can see how this value change over time and how to analyze them history tab we already talked about iter and the interface tab contains the list of public experts from the contract it's like functions all the structures enams everything, that is declared in the contract and publicly available all the contract interfaces here and it's quite handy tool. If you want to build a transaction using CLI or any other Tool or you just maybe want to play around Vis it and check

[22:00] what's inside the contract here is also the link for downloading the contract contract was and here is the next interface, which shows the the list of stor data entries for some particular contract here we can see the, that the entry is persistent or not it's TTL value. So time to leave. When the last it was updated and balances attached to these values values and one more thing, that I'd like to cover probably not everybody knows about this functionality. But we have protocol versions history in the interface it's under the main menu

[23:00] section and in the protocols history you can see changes, that were applied to the to The Ledger during prodal upgrades and of also during suran runtime F changes updates it's the lowlevel view of what happens. When validators vote for increas in limits and basically here you can easily check and say what are our current limits and what was the last update and what changed during I have a lot of more to cover. But let's wrap at it. Because I think, that we have already few minutes left so. If you have any question questions let

[24:00] let St yeah thank you for for the run through I definitely have learned a little bit I'm I'm still a pretty basic user. But but I think it's it's it's a very it's it's very practical to to be able to see something like the the protocol upgrades I think there's a lot of good features for for debuging and for for evaluating your your contracts do we have any questions from from the comments I don't see, that I don't think. So but yeah let's see there's one here something about combining plastic and soron is this in the context of StellarExpert yes. So we already show

[25:00] the transaction history and trades and everything for classic operations. But trades history and some specific for example liquidity pool stats or for example blend pool stats they are still unavailable. Because like right. Now we still have the process of standardization in progress. So right. Now the committee is talking about moving to some more more obvious standards for publishing for example events what will be the format of these events and how they can be further analyzed by Downstream systems to produce all the DAT it it should be available soon in

[26:00] Star expert all the price history all the stats from surban Contrition okay great I think, that's all we have time for today thank you for for joining again thank you for inviting this was really interesting I love to see some of the community build tools it's it's a it was a pleasure to to chat to you again and yeah. If anyone else has some some questions I'm sure they can reach out to you on on Discord. But yeah definitely for joining and thank you all this thank you okay thank you bye bye

</details>

## Part 2

<YouTube ID="u204TwiHJpE" />

This protocol meeting we discuss two Core Advancement Proposals - Dima is presenting CAP-0068 and CAP-0069, both of which add new host functions.

Here are some resources to read up on:

- [CAP-0068](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0068.md)

- [CAP-0068 Discussion](https://github.com/stellar/stellar-protocol/discussions/1626)

- [CAP-0069](https://github.com/stellar/stellar-protocol/blob/master/core/cap-0069.md)

- [CAP-0069 Discussion](https://github.com/stellar/stellar-protocol/discussions/1633)

<details>
  <summary>Video Transcript</summary>

[00:00] I see some folks have come to the meeting already and we probably can get started first and pleas meain chat like. If you can hear me. Now okay great thank you right. So today we have two rather small CS to go through both cups are about adding some new host functions for turbon and both pretty simple. So

[01:00] just hopefully shouldn't take too long to to discuss the first okay maybe maybe let's wait for like 30 seconds more I see folks keep coming right hey can see no one has t some last even okay. So let's get started right we have tab 68 first and tab 68 proposes to add a new host function will be used to get at an

[02:00] executive for an address and depending on what the address is the EXA the executable value will be different depending on what the addresses more specifically. When the address corresponds to the classic account with technically no contract and executable for it, which is why we'll return Special Value Value, that that this is a classic account now. When the dra corresponds to a contract there are also two different cases one case is. When the contract is a to asset contract, which is our buildin contract and in, that case again you will get the flag, that says, that this is a tered contract and. When you're doing with a CL

[03:00] with a regular vasm contract we'll tell this vasm contract and provide the respective has this is actually both specification of the CAP and quick description of the CAP there isn't much to talk about here. But I guess there is quite a few things to tell about motivation for why would someone actually want this super Po and why this hasn't hasn't implemented initially in the protocol. So in general addresses are kind of abstract right You can for example call require o for any address and in the background we will figure out what exactly to call for it or you can save the address in the storage for example and you don't care exactly what B is suggest. But there are some more

[04:00] narrow use cases, which kind of came up during the time of Tran's existence and they're kind of different in their ways. But the common topic as well some information about the address is necessary to be retried specifically one of the cases, which has been brought up is about distinguishing the custom tokens and S asset contract tokens and the way this function will help is, that it will be actually able to tell on chain. If a given contract is a store asset contract. And then for example you can look up the contract name and see, which classic asset it corresponds to and you actually don't need to worry about like. If you know the executable is a s contract and you know

[05:00] that its name is for example native right. Then you actually are 100% sure on chain, that the contract you dealing this is actually xrm contract, which has the name native and executable ised contract and same goes basically for any asset and this use case has come up in the context of the AEL breaks, that does some FR chain token Ren and basically you know to deploy a token on a different chain they need to understand like. If it is a classic tokens they doing with and th they can create appropriate metadata for this event and there is no need to hurt code for example ID for all the contracts and I think the question of what is the address of the XLM contract or how how they figure out. If something is XLM has come up quite a bit before, and now we provide a way, that doesn't actually involve for in the hardcoded

[06:00] XLM value, which may be valuable in some cases another re case, that has come up here. But basically. When deing with a custom accounts there are maybe several actually quite different cases for why you would want to know specifically what is a hash of a particular wasm contract what is a wasm hash hash and this may come up both in the implementation of the custom account itself itself say I you want your customer account to only authorize token operations on some tracted token implementation right again for example to asset contract trusted custom token implementation or maybe in general you want to be able to verify the source of certain contracts you

[07:00] want to in right it is more of a customization SC and in another case, that T has brought up specifically is, that. If you wanted to build some modelized account, that have several contracts Implement in several different authorization policies, which kind of makes sense for the general customer account custom custom customization customization you basically may have some contracts, that would do us for you and you actually want to be confident, that this contracts will not be updated. So for example you trust certain contracts to do something on your behalf and you trust its current implementation. But you do not want this implementation to be ever seen and. If you know

[08:00] what is the current casat you can actually enforce, that and for the hasn't make sure, that the hash hasn't seen in the future location. So all and allers are like pretty narrow cases it probably doesn't come up for each and every contract. But I think they are interesting enough and in general functionality exist makes sense to provide it like other part of the deployer function right you you can deploy something. But you cannot know what exactly has been deployed. Now we kind of boot in another end of this and I think beyond what I've been talking about there are some other things, that people may come up to with this functioning bits it is not something you need to store for example example right I can try to speak louder is it better

[09:00] okay okay yeah I should have P me sooner yeah. So what I've been saying is, that the use case presented inen discussions are some this. Because it motivated this happen the first place. But I'm sure there are more things, that people may come up with and this functionality is not unique to s s. But for example EV EVM has functions for retrieving the actually they even have functions to retrieve the entire code, which I don't think is relevant to soran. But also like to retrieve the hash of the contract code, which is more or less what we are doing here. So I think all know it's pretty sensible idea

[10:00] to have and seemly some use cases where this is helpful. So this is pretty much it on the C presentation and I don't know. If there are any questions. But there was a a discussion in GitHub regarding the data structure to be used here. Because the initial CAP has n data structure structure proposed and Lee has suggested to use a flat data structure and I think I haven't replied on the discussion. But after looking at this again before this m I think it seems like a sensible suggestion. So I'll probably update the CAP and makes it ANM structure flat yeah. So it's like guess small implementation detail. But I

[11:00] think it probably makes sense to do, that yeah so, that's pretty much it on CAP 68 are there any questions e

[12:00] yeah regarding the fony yeah I agree, that even, though we kind of going to have two very similar data types I think it makes sense conceptually to have this FL I guess it's not too much of Maintenance Maintenance burden yeah not for performance reasons. But mostly for quity all right anyways. If anyone has any more questions please pause them in the discussion thread other, that that's pretty much it for CAP 68, and now CAP 69 it's an even simpler CAP and it simply adds two conversion functions one to com

[13:00] convert string object into bite object and another to convert bite object back into string object and the reason for this is basically, that spring object well well first thing is, that strings and byes and thran are exactly the same thing. So kind of makes sense for them to be convertible to each other. But the main reason for why this has actually come up is, that due to I guess bit of an oversight in in the design string has very restricted set of the host functions, that can do anything about it specifically you can get only stream lens today and copy it into memory. So people were trying to get

[14:00] for example a character of a string object and, that's not possible without actually copying the whole string back into guest memory and. If you don't know the lens of your string. Then you need to link aloc or do some weird ha where you would only Lo some swice or something. So basically it's all kind of hey and just adding the conversion functions is a very quick fix for, that. So you can convert string into bites on the host side perform any of the operations, that are already available for bites. And then maybe either converted back or I don't depending on your logic. So yeah I think it was mostly design I don't think say great reason to not have it

[15:00] and also this has come up actually about a year ago for the at least once before like recently and again people are just confused why there is no conversion between bites and strings and well you can just add it it's a very simple change. So I guess, that's all I have to say for this CAP yeah so. If there are any questions again please let me know or please pause them in the respective GitHub discussion right so, that's it for me I don't know

[16:00] if someone wants to use this time for CAP 67 or not I don't know. But yeah, that's pretty much it for for me and. If no one else has any to about. Then you can call it Med e

[17:00] e

[18:00] e e

[19:00] okay it seems like no moment discussion for today and I guess, that's it for this meeting thank you everyone for attention

</details>
